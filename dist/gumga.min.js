
angular.module('gumga.core',
	['gumga.services',
	'gumga.controllers',
	'gumga.directives']);

(function(){
	'use strict';

	angular.module('gumga.controllers',[]);

})();

(function(){
	'use strict';

	angular.module('gumga.directives',
		[
		'gumga.directives.address',
		'gumga.directives.queries',
		'gumga.directives.alert',
		'gumga.directives.breadcrumb',
		'gumga.directives.counter',
		'gumga.directives.formbuttons',
		'gumga.directives.manytomany',
		'gumga.directives.manytoone',
		'gumga.directives.menu',
		'gumga.directives.nav',
		'gumga.directives.onetomany',
		'gumga.directives.search',
		'gumga.directives.table',
		'gumga.directives.upload',
		'gumga.directives.form',
		'gumga.directives.mask',
		'gumga.directives.list',
		'gumga.directives.translate'
		]);

})();

(function(){
	'use strict';

	angular.module('gumga.services',[
		'gumga.services.address',
		'gumga.services.keyboard',
		'gumga.services.base',
		'gumga.services.utils',
		'gumga.services.alert',
		'gumga.services.translate',
		'gumga.services.webstorage',
		'gumga.services.populate',
		'gumga.services.rest',
		'gumga.services.notification'
		]);
})();

(function(){
	'use strict';
	/**
	 * @ngdoc directive
	 * @name gumga.core:gumgaAddress
	 * @restrict E
	 * @description O componente GumgaAddress recebe um objeto que será preenchido com o endereço, que pode ser pesquisado através do CEP (Utilizando um WebService GUMGA),
	 * ou preenchido manualmente pelo usuário. Este objeto de entrada pode ser vazio ou preferivelmente no formato do objeto GUMGA.
       * ## Exemplo
       * Veja um exemplo em funcionamento [aqui](http://embed.plnkr.co/7t9mZtLl9bPuVhmig0oI/).
	 * @param {Object} value Atributo obrigatório que irá conter o nome do objeto no $scope no qual os valores do Endereço serão colocados.
	 * @param {String} name Atributo obrigatório e único que irá conter um nome de identificador para a directive.
	 * @param {String} title Atributo opcional que irá conter o título para o panel da directive.
	 * @param {Function} onSearchCepStart Atributo opcional que irá conter o nome de uma função que será executada quando a busca pelo CEP começar.
	 * @param {Function} onSearchCepSuccess Atributo opcional que irá conter o nome de uma função que será executada quando a busca pelo CEP retornar sucesso.
       *  Pode ser chamada com um atributo com os valores `on-search-cep-success="doSomething($value)"`
	 * @param {Function} onSearchCepError Atributo opcional que irá conter o nome de uma função que será executada quando a busca pelo CEP retornar erro.
       *  Pode ser chamada com um atributo com os valores `on-search-cep-error="doSomething($value)"`
      */
	AddressDirective.$inject = ["GumgaAddressService", "$http"];
      function AddressDirective(GumgaAddressService,$http){
      	var template = [
      	'<div class="address" style="padding-left: 0">',
      	'    <div class="col-md-8 col-sm-12 col-xs-12" style="padding-left: 0">',
      	'          <accordion>',
      	'                <accordion-group style="margin-top: 1%" is-open="true" heading="{{::title}}">',
      	'                      <div class="col-md-12">',
      	'                            <label for="input{{::id}}">CEP</label>',
      	'                            <div class="input-group">',
      	'                                  <input type="text" class="form-control" ng-model="value.zipCode" id="input{{::id}}" ng-keypress="custom($event,value.zipCode)">',
      	'                                  <span class="input-group-btn">',
      	'                                        <button class="btn btn-primary" type="button" ng-click="searchCep(value.zipCode)" ng-disabled="loader{{::id}}" id="buttonSearch{{::id}}">Search <i class="glyphicon glyphicon-search"></i></button>',
      	'                                  </span>',
      	'                            </div>',
      	'                      </div>',
      	'                      <div class="col-md-4">',
      	'                            <label for="tipoLogradouro"><small>Tipo Logradouro</small></label>',
      	'                            <select type="text" ng-model="value.premisseType" class="form-control" ng-options="log for log in factoryData.logs"></select>',
      	'                      </div>',
      	'                      <div class="col-md-5" style="padding-left: 0; padding-right: 0">',
      	'                            <label for="Logradouro"><small>Logradouro</small></label>',
      	'                            <input type="text" ng-model="value.premisse" class="form-control id="oi"/>',
      	'                      </div>',
      	'                      <div class="col-md-3">',
      	'                            <label for="Número"><small> Número </small></label>',
      	'                            <input type="text" ng-model="value.number" class="form-control" id="numberInput{{::id}}"/>',
      	'                      </div>',
      	'                      <div class="col-md-12">',
      	'                            <label for="Complemento"><small>Complemento</small></label>',
      	'                            <input type="text" ng-model="value.information" class="form-control"/>',
      	'                      </div>',
      	'                      <div class="col-md-7">',
      	'                            <label for="Bairro"><small> Bairro </small></label>',
      	'                            <input type="text" ng-model="value.neighbourhood" class="form-control"/>',
      	'                      </div>',
      	'                      <div class="col-md-5">',
      	'                            <label for="Localidade"><small> Localidade </small></label>',
      	'                            <input type="text" ng-model="value.localization" class="form-control"/>',
      	'                      </div>',
      	'                      <div class="col-md-4">',
      	'                            <label for="UF"><small> UF </small></label>',
      	'                            <select ng-model="value.state" class="form-control" ng-options="uf for uf in factoryData.ufs"></select>',
      	'                      </div>',
      	'                      <div class="col-md-4">',
      	'                            <label for="País"><small> País </small></label>',
      	'                            <select ng-model="value.country" class="form-control" ng-options="pais for pais in factoryData.availableCountries"></select>',
      	'                      </div>',
      	'                      <div class="col-md-4" style="padding-top: 2%">',
      	'                            <a class="btn btn-default pull-right" ng-href="{{returnLink(value)}}" target="_blank">Maps <i class="glyphicon glyphicon-globe"></i></a>',
      	'                      </div>',
      	'                </accordion-group>',
      	'          </accordion>',
      	'    </div>',
      	'</div>'];
      	return {
      		restrict: 'E',
      		scope: {
      			value: '=',
      			onSearchCepStart: '&?',
      			onSearchCepSuccess: '&?',
      			onSearchCepError: '&?'
      		},
      		template: template.join('\n'),
      		link: function (scope, elm, attrs, ctrl) {
						function isEmpty(obj){
    					for(var key in obj) if(obj.hasOwnProperty(key)){
        				return false;
    					}
    					return true;
						}
	          if(isEmpty(scope.value)) scope.value = GumgaAddressService.returnFormattedObject();
	          if(!attrs.name) throw "É necessário passar um parâmetro 'name' como identificador para GumgaAddress";
      			scope.title = attrs.title || 'Endereço';
      			scope.id = attrs.name;
      			scope['loader' + scope.id] = false;
            scope.factoryData = {
                ufs: GumgaAddressService.everyUf,
                logs: GumgaAddressService.everyLogradouro,
                availableCountries: GumgaAddressService.availableCountries
            };
            var eventHandler = {
                  searchCepStart: (attrs.onSearchCepStart ? scope.onSearchCepStart : angular.noop),
                  searchCepSuccess: (attrs.onSearchCepSuccess ? scope.onSearchCepSuccess : angular.noop),
                  searchCepError: (attrs.onSearchCepError ? scope.onSearchCepError: angular.noop)
            };
      			scope.custom = function ($event, cep) {
              $event.charCode == 13? scope.searchCep(cep) : angular.noop;
      			};

      			scope.returnLink = function (value) {
      				if (!value.number) {
      					value.number = '';
      				}
      				return 'https://www.google.com.br/maps/place/' + value.premisseType + ' ' + value.premisse + ',' + value.number+ ',' + value.localization;
      			};
      			scope.searchCep = function (cep) {
      				scope['loader' + scope.id] = true;
      				eventHandler.searchCepStart();
      				$http.get('http://www.gumga.com.br/services-api/public/cep/'+cep)
      				.success(function (values) {
      					eventHandler.searchCepSuccess({$value: values});
      					scope['loader' + scope.id] = false;
      					if (parseInt(values.resultado) == 1) {
      						scope.value.premisseType = values.tipo_logradouro;
      						scope.value.premisse = values.logradouro;
      						scope.value.localization = values.cidade;
      						scope.value.neighbourhood = values.bairro;
      						scope.value.state = values.uf;
      						scope.value.country = 'Brasil';
      					}

      				})
      				.error(function(data){
      					eventHandler.searchCepError({$value: data});
      				})
      			};
      			if (scope.value.zipCode) {
      				scope.searchCep(scope.value.zipCode);
      			}
      		}
      	};
      }
      angular.module('gumga.directives.address',['gumga.services.address'])
      .directive('gumgaAddress',AddressDirective);
    })();

(function(){
	'use strict';
	/**
	 * @ngdoc directive
	 * @name gumga.core:gumgaAlert
	 * @restrict EA
	 * @element ANY
	 * @description O componente gumgaAlert serve para criar notificações growl-like e é baseada em eventos.
	 * Para o funcionamento da directive, é necessário incluí-la apenas uma vez no seu código html (de preferência no index.html),
	 * para que os listeners sejam adicionados(Atualmente, na nova versão isto não é mais necessário, ver {@link gumga.core:GumgaAlert}). 
	 *
	 * @example
	 * ## Para que o alerta seja realizado, utilize um dos eventos:
	 * <pre>
	 * 	$scope.$emit('dangerMessage',{title: 'Error' ,message: 'Error 404'});
	 * 	$scope.$emit('successMessage',{title: 'Parabéns!' ,message: 'Sua solicitação foi aceita com sucesso!'});
	 *  $scope.$emit('warningMessage',{title: 'Cuidado!' ,message: 'A área que você está entrando é restrita.'});
   * 	$scope.$emit('infoMessage',{title: 'Salvar' ,message: 'Para salvar, entre em contato com o administrador.'});
	 * </pre>
	 *  Para ver um exemplo em funcionamento, clique [aqui](http://embed.plnkr.co/wdlI7U4nQf9kNhGlyCfU/)
	 */
	Alert.$inject = ["$rootScope"];
	function Alert($rootScope){
		return {
			restrict: 'EA',
			scope: false,
			compile: function(){
				function notify(icon, title, message, type) {
					$.notify({
						icon: icon,
						title: title,
						message: message
					}, {
						type: type,
						offset: 50,
						timer: 100,
						delay: 3500,
						onShow: $rootScope.$broadcast('onNotificationShow'),
						onClose: $rootScope.$broadcast('onNotificationClose'),
						allow_dismiss: true,
						animate: {
							enter: 'animated bounceInRight',
							exit: 'animated bounceOutRight'
						},
						template: '<div data-notify="container" class="col-xs-9 col-sm-3 alert alert-{0}" role="alert">' +
						'<button type="button" aria-hidden="true" class="close" data-notify="dismiss">×</button>' +
						'<span data-notify="icon"></span> ' +
						'<span data-notify="title"><b>{1}</b></span><br> ' +
						'<span data-notify="message">{2}</span>' +
						'</div>'
					});
				}

				$rootScope.$on('dangerMessage', function (ev, data) {
					notify('glyphicon glyphicon-exclamation-sign', data.title, data.message, 'danger');
				});
				$rootScope.$on('successMessage', function (ev, data) {
					notify('glyphicon glyphicon-ok', data.title, data.message, 'success');
				});
				$rootScope.$on('warningMessage', function (ev, data) {
					notify('glyphicon glyphicon-warning-sign', data.title, data.message, 'warning');
				});
				$rootScope.$on('infoMessage', function (ev, data) {
					notify('glyphicon glyphicon-info-sign', data.title, data.message, 'info');
				});
			}
		}
	}
	angular.module('gumga.directives.alert',[])
	.directive('gumgaAlert',Alert);
})();
(function(){
	'use strict';

	Breadcrumb.$inject = ["$rootScope"];
	/**
	 * @ngdoc directive
	 * @name gumga.core:gumgaBreadcrumb
	 * @restrict E
	 * @description O componente GumgaBreadcrumb serve para mostrar ao usuário a lista das páginas visitadas. Este componente atuamente
	 * funciona caso exista dependência do [ui-router](https://github.com/angular-ui/ui-router).
	 * 
	 * O componente GumgaBreadcrumb ouve ao evento `breadChanged`, que recebe os states que estão sendo visitados. Uma das implementações possíveis para esse
	 * evento breadChanged é a seguinte:
	 * <pre>
	 * $rootScope.breadcrumbs = [];
      $rootScope.$on('$stateChangeSuccess', function (event, toState) {
        updateBreadcrumb(toState.name, toState.data.id);
      });
      function updateBreadcrumb(state, id) {
          function get(id) {
              for (var i = 0, len = $rootScope.breadcrumbs.length; i < len; i++) {
                  if ($rootScope.breadcrumbs[i].id === id) {
                      return i;
                  }
              }
          }
          if (id && get(id) >= 0) {
              $rootScope.breadcrumbs.splice(get(id), $rootScope.breadcrumbs.length - get(id), {state: state, id: id});
          } else {
              $rootScope.breadcrumbs.push({state: state, id: id});
          }
          !id ? $rootScope.breadcrumbs = [] : angular.noop;
          $rootScope.$broadcast('breadChanged');
      }
	 * </pre> 
	 * Este código foi colocado dentro do `run` do módulo principal da aplicação.
	 */

	function Breadcrumb($rootScope){
		var template = [
		'<ol class="breadcrumb">',
		'<li ng-repeat="bread in breadcrumbs" ><a ui-sref="{{::bread.state}}">{{::bread.state}}</a></li>',
		'</ol>'
		];
		return {
			restrict: 'E',
			template: template.join('\n'),
			replace: true,
			link: function($scope, $elm, $attrs){
				$scope.$on('breadChanged',function(){
					$scope.breadcrumbs = $rootScope.breadcrumbs.filter(function(e){
						return e.state.split('.').length >=2 ;
					});
				});
			}
		};
	}
	angular.module('gumga.directives.breadcrumb',[])
	.directive('gumgaBreadcrumb',Breadcrumb);
})();
// define = Require.js
(function(){
  'use strict';

    Counter.$inject = ["$compile"];
      /**
       * @ngdoc directive
       * @name gumga.core:gumgaCounter
       * @element input
       * @description O componente gumgaCounter permite escolher um tamanho máximo permitido no campo, também cria um contador de caracteres indicando se os caracteres
       * passaram do limite ou não. 
       * 
       * Caso um valor seja passado para a directive, ela atualizará o contador baseado nesse número. Caso não, ela pegará o valor
       * passado para a directive {@link gumga.core:gumgaMaxLength}
       * 
       * @example
       *  Um exemplo da directive gumgaCounter funcionando pode ser encontrado [aqui](http://embed.plnkr.co/6xJuUuiI456kqbXN3Q6f/).
       * <pre>
       * <input name="example" ng-model="example" gumga-counter="15" />
       * </pre>
      */

      function Counter($compile){
            return{
                restrict: 'A',
                link: function (scope, elem, attrs) {
                    scope._max = parseInt(attrs.gumgaMaxLengthText);
                    if (!isNaN(parseInt(attrs.gumgaCounter))) {
                        scope._max = parseInt(attrs.gumgaCounter);
                    }
                    var template = '<p class="{{_max <= teste.length ? \'text-danger\' : \'text-muted\'}}">{{_max <= '+ attrs.ngModel +'.length ? "Você passou o limite de '+scope._max+' caracteres" : _max - '+ attrs.ngModel +'.length + " caracteres restantes" }}</p>';
                    elem.after($compile(template)(scope));
                }
            };
      }

      angular.module('gumga.directives.counter', [])
        .directive('gumgaCounter', Counter);


})();


(function () {


  angular.module('gumga.directives.form',[
    'gumga.directives.form.form',
    'gumga.directives.form.errors',
    'gumga.directives.form.error',
    'gumga.directives.form.max.date',
    'gumga.directives.form.max.length',
    'gumga.directives.form.max.number',
    'gumga.directives.form.min.date',
    'gumga.directives.form.min.length',
    'gumga.directives.form.min.number',
    'gumga.directives.form.pattern',
    'gumga.directives.form.range.date',
    'gumga.directives.form.range.number',
    'gumga.directives.form.required',
    'gumga.directives.formbuttons'
  ])


})();

(function(){
	'use strict';
    /**
     * @ngdoc directive
     * @name gumga.core:gumgaFormButtons
     * @restrict E
     * @description O componente gumgaFormButtons pode ser utilizado para quando necessite de botões para o formulário,
     * tanto de continuar inserindo, de salvar e retroceder.
     *
     *  @param {Function} submit Parâmetro obrigatório que contém uma função que será executada quando o botão de continuar for clicado.
     *  @param {boolean} valid Parâmetro obrigatório que irá conter um valor booleano para validar caso o formulário é válido para liberar o botão de salvar.
     *  @param {Object} continue Object que deverá conter um atributo booleano chamado `value`, para controlar caso continuará inserindo ou não. Essa 
     *  opção aparecerá apenas quando o objeto $stateParams(pertencente ao ui-router) não possuir um id, ou seja, caso esteja numa tela de inserção.
     *  @param {boolean} confirm-dirty Parâmetro não obrigatório que irá conter um booleano para indicar caso deseje ter uma confirmação de saída do formulário
     *  quando este foi alterado alguma vez.
     */
	FormButtons.$inject = ["$state", "$stateParams", "$modal", "$rootScope"];
    function FormButtons($state, $stateParams,$modal,$rootScope) {
        return {
            restrict: 'E',
            scope: {
                do: '&submit',
                valid: '=',
                continue: '=?',
                confirmDirty: '=?'
            },
            template:
            '<div class="full-width-without-margin">'+
            '   <scope></scope>'+
            '   <div ng-class="getPosition()">' +
            '       <label id="continuarInserindo" ng-if="continue" >'+
            '           <input type="checkbox" name="continuar" ng-model="continue.value"/>' +
            '           <span>Continuar Inserindo</span>'+
            '       </label>' +
            '       <button class="btn btn-warning" style="margin-right: 0.8em" ng-click="back()" type="button"><i class="glyphicon glyphicon-floppy-remove"></i> Back</button>' +
            '       <button class="btn btn-primary" style="margin-right: 0" ng-click="do()" ng-disabled="!valid" type="button"><i class="glyphicon glyphicon-floppy-saved"></i> Save</button>' +
            '   </div>'+
            '<div>',
            require: '^form',
            link: function (scope, elm, attrs, ctrl) {
                if(!attrs.confirDirty) scope.confirmDirty = true;
                if(!$stateParams.id) scope.inNew = true;
                if(!attrs.continue) scope.continue = false;

                scope.getPosition = function () {
                    if (attrs.position == 'left') {
                        return 'pull-left';
                    }
                    return 'pull-right';
                };

                scope.back = function () {
                    if(scope.confirmDirty && ctrl.$dirty){
                        var modal = $modal.open({
                            template:
                            '<div>'+
                            '   <section class="modal-body">' +
                            '       <h4>Deseja sair sem salvar as alterações?</h4>' +
                            '   </section>'+
                            '   <div class="modal-footer">'+
                            '       <button class="btn btn-default" ng-click="handleClose(false)">Não</button>' +
                            '       <button class="btn btn-default" ng-click="handleClose(true)">Sim</button>' +
                            '   </div>'+
                            '</div>',
                            backdrop: false,
                            keyboard: false,
                            size: 'sm',
                            controller: ["$scope", "$modalInstance", "$state", "$rootScope", function($scope,$modalInstance,$state,$rootScope){
                                $scope.handleClose = function(_boolean){
                                    _boolean ? $modalInstance.close(true) : $modalInstance.close(false);
                                };  
                                if($state){
                                    $scope.currentState =$state.current.name;
                                    $rootScope.$on('$stateChangeStart',
                                        function(event, toState, toParams, fromState, fromParams){
                                            $modalInstance.dismiss();
                                        })
                                }
                            }]
                        });
                        modal.result.then(function(shouldIGo){
                            if(shouldIGo){
                                $state.go(attrs.back);
                                return 0;
                            }
                        })
                        } else {
                            $state.go(attrs.back);
                        }
                };

            }
        } 
    }

angular.module('gumga.directives.formbuttons',['ui.bootstrap','ui.router'])
.directive('gumgaFormButtons',FormButtons);

})();
(function () {
  'use strict';

  List.$inject = ["GumgaListHelper", "$compile"];

  function List(GumgaListHelper,$compile){
    /**
    * @ngdoc directive
    * @name gumga.core:gumgaList
    * @restrict E
    * @description
    * 	A directive gumgaList foi desenvolvida para substituir a antiga gumgaTable. Ela é mais configurável que a antiga table, e traz um meio mais fácil de configurar.
    *  	O componente possui dois tipos de configuração: diretamente no html e através de um objeto javascript.
    *
    * 	# Configuração da table através de um Objeto Javascript
    *
    *		Para aplicar a configuração na table, existem os seguintes atributos:
    *
    * | Param | Type  | Default | Details |
    * |-------|-------|---------|----------------|
    * |selection|String| single | Valor que será utilizado para definir como será a seleção da tabela. Possíveis valores: <label class="label type-hint type-hint-string">[multi / single]</label> |
    * |itemsPerPage|Array| [10,20,30,40,50] | Valor que será utilizado para definir o número de registros selecionado pelo usuário. O valor escolhido será exposto no $scope através da variável itemsPerPage |
    * |sortDefault | String | | Valor que será utilizado para definir qual o campo padrão de ordenação. Este valor será o identificador da coluna.
    * |columns |String| | Valor que irá definir quais as colunas e a ordenação delas. O formato deve estar no seguinte padrão: <label class="label type-hint type-hint-string">[column1,column2,...,columnN]</label>
    * |conditional | Function | angular.noop | Valor que será utilizado para fazer a formatação condicional do registro. A função deve retornar um objeto que contém a classe e a comparação utilizada <label class="label type-hint type-hint-string">[function(value){ return {'2px solid red': value.age < 18} }]</label>
    * |columnsConfig |Array |[]| Array que será utilizado para configurar as colunas que foram definidas no atributo columns.
    *
    * # Configuração da coluna através de um Objeto Javascript
    *	Para configurar as colunas, dentro do atributo columnsConfig, são criados objetos que poderão ter as seguintes configurações:
    *
    * | Param | Type  | Default | Details |
    * |-------|-------|---------|----------------|
    * |name | String |  | Valor que será utilizado para identificar a coluna. Este name deve ser o mesmo que está no atributo 'columns',
    * |title|String| NOME_DA_COLUNA.toUpperCase() | Valor que será renderizado no título da coluna.
    * |size|String| 'col-md-3' | Tamanho da coluna baseado nos valores do bootstrap. Exemplo: ** col-md-x **
    * |content |String|{{$value.NOME_DA_COLUNA}} | Valor que será renderizado no conteúdo da coluna.
    * |sortField |String | | String que será  usada para fazer a ordenação, e que irá como parâmetro na função de ordenação..
    * |conditional | Function | angular.noop | Valor que será utilizado para fazer a formatação condicional do registro. A função deve retornar um objeto que contém a classe e a comparação utilizada <label class="label type-hint type-hint-string">[function(value){ return {'2px solid red': value.age < 18} }]</label>
    *
    *
    *	  @param {Function} sort Parâmetro que contém uma função que será chamada para que o desenvolvedor possa fazer a ordenação dos registros.
    *	  @param {String} class Parâmetro para aplicar na table uma classe específica.
    *	  @param {Array} data Parâmetro que irá conter os dados que serão mostrados na tabela.
    *	  @param {Function} onClick Função que será executada quando o usuário clicar em um registro
    *	  @param {Function} onSort Função que será executada quando a ordenação for realizada
    *	  @param {Function} onDoubleClick Função que será executada quando o usuário clicar duas vezes em um registro.
    */


    function ctrl($scope, $element, $attrs, $transclude){
      function verifyEmpty($v,other){return (!$attrs.$v ? other : vm[$v])};
      var vm = this;
      // Valores utilizados pela aplicação
      vm.selectedIndexes = []
      vm.selectedItem;
      vm.selectedItemDir;
      vm.$parent = $scope.$parent;

      // Funções utilizadas
      vm.sortProxy = sortProxy;
      vm.selectRow = selectRow;
      vm.double = double;''
      vm.conditional = cond;
      vm.conditionalTableCell = conditionalTableCell;
      vm.selectAll = selectAll;
      // Valores que serão expostos no $scope
      $scope.$parent.selectedValues = [];
      $scope.$parent.itemsPerPage;
      // Número de itens na página
      vm.page = $scope.$parent.itemsPerPage;

      vm.originalData = vm.data;
      vm.data = angular.copy(vm.data) || [];
      vm.config = vm.config || {}
      vm.data.forEach(function(val){val.__checked = false;});
      vm.config.selection = vm.config.selection || 'single';
      vm.config.sortDefault = vm.config.sortDefault;
      vm.config.itemsPerPage = vm.config.itemsPerPage || [10,20,30,40,50];
      vm.config.columnsConfig = vm.config.columnsConfig || [];
      vm.config.conditional = vm.config.conditional || angular.noop;
      vm.config.sort = verifyEmpty('sort',angular.noop);
      vm.config.class = $attrs.class ? 'table ' + $attrs.class : 'table';
      vm.config.onClick = verifyEmpty('onClick',angular.noop);
      vm.config.onDoubleClick = verifyEmpty('onDoublelick',angular.noop);
      vm.config.onSort = verifyEmpty('onSort',angular.noop);
      if(vm.config.sortDefault)sortProxy(vm.config.sortDefault);
      if (vm.data && vm.data.length > 0){
        vm.config.columns =
        !!vm.config.columns ?
        GumgaListHelper.ensureDefaultValues(vm.config.columns.split(','),vm.config.columnsConfig) : GumgaListHelper.loadDefaultColumns(vm.data[0]);
        vm.config.auxColumnsToSort = vm.config.columns;
      }

      $element.append($compile(GumgaListHelper.mountTable(vm.config))($scope));

      function selectAll(checkboxBoolean){
        cleanArrays();
        vm.data.forEach(function(data,index){
          data.__checked = checkboxBoolean;
          if(checkboxBoolean)pushToArrays(data,index);
        })
      }

      function findInOriginalArray(val){
        var copyWithoutCheckedAttributes = angular.copy(val);
        delete copyWithoutCheckedAttributes.__checked;
        return vm.originalData.filter(function(originalRegistry){
          return angular.equals(originalRegistry,copyWithoutCheckedAttributes);
        })[0];
      }
      function cleanArrays(){
        $scope.$parent.selectedValues = [];
        vm.selectedIndexes = [];
      }
      function pushToArrays(val,index){
        vm.selectedIndexes.push(index);
        $scope.$parent.selectedValues.push(findInOriginalArray(val));
      }
      function setEveryCheckedToBoolean(bool){
        vm.data.forEach(function(elm){
          elm.__checked = bool;
        })
      }
      function cleanValueAndArrays(clause,value){
        if(clause){
          setEveryCheckedToBoolean(false);
          cleanArrays();
        }
        if(value) value = false;
      }


      function selectRow(ngRepeatIndex,ngRepeatValue,$event){
        if($event.target.type == 'button' || $event.target.tagName == 'A'){
          $event.stopPropagation();
          return null;
        }
        var selectedValues = $scope.$parent.selectedValues;
        cleanValueAndArrays(vm.checkAll,vm.checkAll);
        if($attrs.onClick)vm.onClick({value: ngRepeatValue});
        if(vm.config.selection == 'single'){
          if(ngRepeatValue.__checked){
            ngRepeatValue.__checked = false;
            cleanArrays();
          } else {
            cleanValueAndArrays(vm.selectedIndexes.length > 0)
            pushToArrays(ngRepeatValue,ngRepeatIndex);
            ngRepeatValue.__checked = true;
          }
        } else {
          ngRepeatValue.__checked = vm.selectedIndexes.filter(function(val){return val == ngRepeatIndex}).length < 1;
          if((ngRepeatValue.__checked) || vm.selectedIndexes.length == 0 ){
            pushToArrays(ngRepeatValue,ngRepeatIndex);
            return 0;
          }
          var indexOfValueSelected;
          selectedValues.forEach(function(val,indx){
            if(angular.equals(val,ngRepeatValue)) indexOfValueSelected = indx;
          })
          $scope.$parent.selectedValues.splice(indexOfValueSelected, 1);
          vm.selectedIndexes.splice(vm.selectedIndexes.indexOf(ngRepeatIndex),1);
        }
      }

      function sortProxy(field){
        if($attrs.onSort) vm.onSort({field: vm.selectedItem, dir: vm.selectedItemDir});
        if(!$attrs.sort) throw 'You have to pass a sort function to GumgaList [sort="sort(field,dir)"]';
        vm.selectedItem = field;
        vm.selectedItemDir == 'asc' ? vm.selectedItemDir = 'desc' : vm.selectedItemDir = 'asc';
        vm.sort({field: vm.selectedItem, dir: vm.selectedItemDir});
      }

      function double(value){
        if($attrs.onDoubleClick) vm.onDoubleClick({value: value});
      }

      function conditionalTableCell(value,ordering){
        var columnToGetTheConditional = vm.config.columns.filter(function(val){return val.name == ordering});
        if(columnToGetTheConditional[0]){
          var obj = columnToGetTheConditional[0].conditional(value)
          ,   trueValue, falseValue;
          for(var key in obj){
            if(obj[key] === true){
              trueValue = key;
            } else {
              falseValue = key;
            }
          }
          return '\"'.concat(trueValue).concat('\"');
        }
        return '\'\'';
      };

      function cond(value){
        var obj = vm.config.conditional(value),trueValue
        ,   falseValue;
        for(var key in obj){
          obj[key] === true ?trueValue = key : falseValue = key;
        }
        if(trueValue){
          return '\"'.concat(trueValue).concat('\"');
        }
        return '\'\'';
      }
    }
    ctrl.$inject = ["$scope", "$element", "$attrs", "$transclude"];;
    return {
      restrict: 'E',
      scope:{
        'sort': '&?',
        'class': '&?',
        'data': '=',
        'onClick': '&?',
        'onDoubleClick': '&?',
        'onSort': '&?',
        'config': '=configuration'
      },
      controller: ctrl,
      controllerAs: 'vm',
      bindToController: true
    }
  }
  angular.module('gumga.directives.list',['gumga.services.listhelper'])
  .directive('gumgaList',List);
})();

(function(){
	'use strict';

	ManyMany.$inject = ["$modal", "$compile", "$timeout"];
	/**
	 * @ngdoc directive
	 * @name gumga.core:gumgaManyToMany
	 * @restrict E
	 * @description
	 * 	O componente gumgaManyToMany é um componente que é utilizado para mostrar duas listas lado a lado, e permitir que um registro seja trocado de uma lista para outra,
	 * 	assim como também visualizado os seus valores(caso seja um objeto). Um exemplo do componente pode ser encontrado [aqui](http://embed.plnkr.co/gyrqAKQQGuEHwp2npv8G/).
	 *
	 * ---
	 * ## Configuração de como será mostrado o valor na lista
	 *
	 *Para que o programador possa escolher como os valores serão demonstrados, foram desenvolvidas duas tags que devem estar dentro do componente manyToMany.
	 * 		<pre> <left-field>{{$value}}</left-field>
	 * 		<right-field>{{$value}}</right-field></pre>
	 *
	 * @param {Array} left-list Parâmetro obrigatório que irá conter uma variável que possuirá um array, para ser mostrado na lista da esquerda.
	 *  *A lista da esquerda será filtrada e não conterá resultados iguais a da lista da direita.*
	 * @param {Array} right-list Parâmetro obrigatório que irá conter uma variável que possuirá um array, para ser mostrado na lista da direita.
	 * @param {Function} left-search Parâmetro obrigatório que irá conter uma variável que possuirá uma função que irá ser executada toda vez
	 * que o usuário digitar algo no input acima da lista. Essa função terá o valor do input como parâmetro. O parâmetro deverá ser este: `left-search="doSearch(text)"`
	 * @param {Function} right-search Parâmetro obrigatório que irá conter uma variável que possuirá uma função que irá ser executada toda vez
	 * que o usuário digitar algo no input acima da lista. Essa função terá o valor do input como parâmetro. O parâmetro deverá ser este: `right-search="doSearch(text)"`
	 * @param {Function} post-method Parâmetro não obrigatório que irá conter uma variável que possuirá uma função que irá ser executada quando o usuário desejar adicionar um valor
	 * caso sua busca não tenha trazido resultados.
	 * @param {Function} on-list-change Parâmetro não obrigatório que irá conter uma variável que possuirá uma função que irá ser executada quando o usuário tiver clicado em um registro
	 * e o mesmo tiver trocado de lista.
	 * @param {Function} on-value-visualization-opened Parâmetro não obrigatório que irá conter uma variável que possuirá uma função que irá ser executada quando o usuário tiver aberto o modal
	 * para visualização de dados
	 * @param {Function} on-value-visualization-closed Parâmetro não obrigatório que irá conter uma variável que possuirá uma função que irá ser executada quando o usuário tiver fechado o modal
	 * para visualização de dados
	 * @param {Boolean} authorize-add Parâmetro não obrigatório que irá conter uma variável que possuirá um booleano que irá fazer o controle para mostrar o botão de adicionar um registro caso a busca não
	 * tenha retornado nenhum registro
	 * @param {String} left-label Parâmetro não obrigatório que irá conter uma String que irá aparecer acima do input e da lista.
	 * @param {String} right-label Parâmetro não obrigatório que irá conter uma String que irá aparecer acima do input e da lista.
	 *

	 */
	function ManyMany($modal,$compile,$timeout){

		return {
			restrict: 'E',
			scope: {
				left: '=leftList',
				right: '=rightList',
				leftFn: '&leftSearch',
				rightFn: '&rightSearch',
				postMethod: '&',
				onListChange: '&?',
				onNewValueAdded: '&?',
				onValueVisualizationOpened: '&?',
				onValueVisualizationClosed: '&?',
				authorizeAdd: '=?'
			},
			transclude: true,
			link: function (scope, elm, attrs, ctrl, transcludeFn) {
				scope.left = scope.left || [];
				scope.right = scope.right || [];
				if (!attrs.authorizeAdd) scope.authorizeAdd = true;
				var mockObject = {};
				scope.texts = {left: '',right: ''};
				scope.template = '';
				scope.labels = {left: attrs.leftLabel,right: attrs.rightLabel};
				var eventHandler = {
					listChange: (attrs.onListChange? scope.onListChange : angular.noop),
					newValueAdded: (attrs.onNewValueAdded ? scope.onNewValueAdded : angular.noop),
					valueVisualizationOpened: (attrs.onValueVisualizationOpened ? scope.onValueVisualizationOpened :angular.noop),
					valueVisualizationClosed: (attrs.onValueVisualizationClosed ? scope.onValueVisualizationClosed :angular.noop)
				};
				transcludeFn(scope,function(cloneEl){
					angular.forEach(cloneEl,function(cl){
						var element = angular.element(cl)[0];
						switch(element.nodeName){
							case 'LEFT-FIELD':
							scope.texts.left = element.innerHTML;
							break;
							case 'RIGHT-FIELD':
							scope.texts.right = element.innerHTML;
							break;
						}
					});
					checkErrors();
				});
				mountRenderedContent();
				scope.$watch('left',function(){
					checkErrors();
					copyObject(scope.left[0]);
				});
				function copyObject(obj) {
					for (var key in obj) if (obj.hasOwnProperty(key)) {
						mockObject[key] = null;
					}
				}
				function checkErrors(){
					var errorTexts = [];
					if(!scope.texts.left || !scope.texts.right){
						errorTexts.push('You have\'nt provided the content to GumgaManyToMany directive');
					}
					errorTexts.forEach(function(txt){
						throw txt;
					});
					removeDuplicates();
				}
				function removeDuplicates(){
					function filterOnRight(text){
						return scope.right.filter(function($elm){
							return $elm[attrs.filterParameter] == text;
						}).length
					}
					scope.leftAux = scope.left.filter(function(elm){
						if(filterOnRight(elm[attrs.filterParameter]) == 0){
							return elm;
						}
					});
				}
				function mountRenderedContent(){
					var text =
					'<div class="full-width-without-padding">\n'+
					'   <div class="col-md-6" style="padding-left: 0">\n'+
					'       <strong><small>{{::labels.left}}</small></strong>\n' +
					'       <div class="{{showClass()}}">'+
					'           <input type="text" name="manymanyleft" ng-model="leftFilter" novalidate class="form-control"' + doesItHaveFunction('left',0) + ' ng-change="leftFn({param: leftFilter})" ng-model-options="{ updateOn: \'default blur\', debounce: {\'default\': 300, \'blur\': 0} }"/>\n' +
					'           <span class="input-group-addon" ng-show="showPlus(leftFilter)"> ' +
					'               <button type="button" style="border: 0;background-color: #EEE" ng-click="addNew(leftFilter)"><i class="glyphicon glyphicon-plus"></i></button>' +
					'           </span>' +
					'       </div>' +
					'       <ul class="list-group" style="max-height: 200px;overflow: auto;">\n' +
					'           <li class="list-group-item" style="display:flex;padding: 7px 15px;" ng-repeat="$value in leftAux ' + doesItHaveFunction('left',1) + '">' +
					'               <a class="inside-list-anchor" ng-click="removeFromAndAddTo(leftAux,right,$value)">' + scope.texts.left + '</a>' +
					'              <button class="badge" style="background-color: #81AEDA;cursor: pointer;border: 0" ng-click="halp($value)"><i class="glyphicon glyphicon-resize-full"></i></button>' +
					'           </li>\n'+
					'       </ul>'+
					'   </div>\n'+
					'   <div class="col-md-6" style="padding-right: 0">\n'+
					'       <strong><small>{{::labels.right}}</small></strong>\n'+
					'       <input type="text" name="manymanyleft" ng-model="rightFilter" novalidate class="form-control"' + doesItHaveFunction('right',0) + '/>\n'+
					'       <ul class="list-group" style="max-height: 200px;overflow: auto;">\n' +
					'           <li class="list-group-item" style="display:flex;padding: 7px 15px;" ng-repeat="$value in right ' + doesItHaveFunction('right',1) + '">' +
					'               <a class="inside-list-anchor" ng-click="removeFromAndAddTo(right,leftAux,$value)">' + scope.texts.right + '</a>' +
					'              <button class="badge badge-helper" ng-click="halp($value)"><i class="glyphicon glyphicon-resize-full"></i></button>' +
					'           </li>\n'+
					'       </ul>\n'+
					'   </div>\n'+
					'</div>\n';
					elm.append($compile(text)(scope));
				}
				scope.removeFromAndAddTo = function(removeFrom,addTo,value){
					removeFrom.splice(removeFrom.indexOf(value),1);
					eventHandler.listChange({$value:value});
					addTo.push(value);
				};
				scope.addNew = function(text){
					scope.leftFilter = '';
					scope.postMethod({value: text });
					eventHandler.newValueAdded();
				};
				scope.showClass = function(){
					if(scope.showPlus()){
						return 'input-group';
					}
					return '';
				};
				scope.halp = function(obj){
					scope.template =
					'<div class="modal-body">\n';
					for (var key in obj) if (obj.hasOwnProperty(key) && key != '$$hashKey' && key != 'oi' && key != 'version') {
						scope.template += '   <div class="form-group">\n';
						scope.template += '       <label><small>'+ key +'</small></label>\n';
						scope.template += '       <input type="text" ng-model="$value.' + key +'" disabled class="form-control"/>\n';
						scope.template += '   </div>\n';
					}
					scope.template += '   <div class="modal-footer">\n';
					scope.template += '       <button type="button" class="btn btn-warning" ng-click="back()">Back</button>\n';
					scope.template += '   </div>\n';
					scope.template += '</div>\n';
					eventHandler.valueVisualizationOpened();
					var mi = $modal.open({
						template: scope.template,
						size: 'sm',
						controller: ["$scope", "$value", "$modalInstance", function($scope,$value,$modalInstance){
							$scope.$value = $value;
							$scope.back = function(){
								$modalInstance.dismiss();
							}
						}],
						resolve: {
							$value: function(){
								return obj;
							}
						}
					});

					mi.result.then(function(){
						eventHandler.valueVisualizationClosed();
					})
				};
				scope.showPlus = function(){
					function filterLeft(){
						return scope.leftAux.filter(function(el){
							return el[attrs.filterParameter] == scope.leftFilter;
						}).length < 1;
					}
					function filterRight(){
						return scope.right.filter(function(el){
							return el[attrs.filterParameter] == scope.leftFilter;
						}).length < 1;
					}
					if(scope.authorizeAdd == true){
						return filterLeft() && filterRight();
					}
					return false;
				};

				scope.doesItHaveClass = function(){
					if(scope.left.length > 0){
						return '';
					}
					return 'input-group';
				};
				function doesItHaveFunction(field,place){
					if(place == 0){
						if(field == 'left' && attrs.leftFn){
							return  'ng-change= "' + attrs.leftFn  +'({text: leftFilter})" ';
						}
						if(field == 'right' && attrs.rightFn){
							return  'ng-change= "' + attrs.leftFn  +'({text: rightFilter})" ';
						}
						return '';
					} else {
						if(field == 'left' && !attrs.leftFn){
							return ' | filter: leftFilter';
						}
						if(field == 'right' && !attrs.rightFn){
							return ' | filter: rightFilter'
						}
						return '';
					}
				}
			}
		}
	}

		angular.module('gumga.directives.manytomany',['ui.bootstrap'])
		.directive('gumgaManyToMany',ManyMany)
	})();

(function(){
    'use strict';

    ManyToOne.$inject = ["$templateCache", "GumgaKeyboard", "$modal"];
    /**
     * @ngdoc directive
     * @name gumga.core:gumgaManyToOne
     * @restrict E
     * @description
     *  A directive gumgaManyToOne pode ser usada para quando o programador precise de um select que filtre uma lista assíncronamente.
     *  Ela também permite adicionar um registro caso a busca retorne uma lista vazia e permite também visualizar os atributos do registro selecionado.
     *  ---
     *  #Exemplo básico de utilização do GumgaManyToOne
     *  O exemplo desse componente pode ser encontrado [aqui](http://embed.plnkr.co/NYL3gItVsWLFcGxt5itz/).
     *
     * @param {Object} value Parâmetro obrigatório que irá conter uma variável que será o registro escolhido na lista.
     * @param {Array} list Parâmetro obrigatório que irá conter uma lista dos registros que foram buscados.
     * @param {Function} search-method Parâmetro obrigatório que irá conter uma função que fará a busca na lista assíncronamente. `search-method="getSearch(param)"`
     * @param {Function} post-method Parâmetro obrigatório que irá conter uma função que dependendo do parâmetro `async`, chamará a função async com o parâmetro
     * `post-method="post(value)"` e caso o parâmetro async não esteja presente ou seja falso, fará um push na lista.
     * @param {String} field Parâmetro obrigatório que irá conter o atributo do registro que está sendo procurado e o que estará na lista.
     * @param {Boolean} authorize-add Parâmetro não obrigatório que irá conter uma variável que possuirá um booleano que irá fazer o controle para mostrar o botão de adicionar um registro caso a busca não
     * tenha retornado nenhum registro
     * @param {Btava veoolean} async Parâmetro não obrigatório que irá dizer caso componente fará um post chamando a função passada ou um push na lista. Por default, o valor é
     * @param {Function} on-new-value-added Parâmetro não obrigatório que irá conter uma variável que possuirá uma função que irá ser executada quando o usuário adicionar um novo valor.
     * @param {Function} on-value-visualization-opened Parâmetro não obrigatório que irá conter uma variável que possuirá uma função que irá ser executada quando o usuário tiver aberto o modal
     * para visualização de dados
     * @param {Function} on-value-visualization-closed Parâmetro não obrigatório que irá conter uma variável que possuirá uma função que irá ser executada quando o usuário tiver fechado o modal
     * para visualização de dados
     */



    function ManyToOne($templateCache,GumgaKeyboard,$modal){
        $templateCache.put('mtoItem.html',
            '<span bind-html-unsafe="match.label | typeaheadHighlight:query" style="cursor: pointer;"></span>');
        var template ='<div class="full-width-without-padding">';
        template += '   <div class="form-group">';
        template += '       <div ng-class="showFullView() || authorizeAdd ? \'input-group\' : \'\'">';
        template += '           <input class="form-control"  ng-model="model" type="text" typeahead="$value as $value[field] for $value in proxySearchMethod()">';
        template += '           <span class="input-group-addon" style="background-color: transparent; padding: 3px 12px;border-left:0" ng-show="showFullView()"> ';
        template += '               <button class="badge" style="background-color: #6ECFFF;border: 0" ng-click="halp(model)" ><i class="glyphicon glyphicon-resize-full"></i></button>';
        template += '           </span>';
        template += '           <span class="input-group-addon" style="padding: 0 0.25%" ng-show="authorizeAdd"> ';
        template += '               <button type="button" style="border: 0;background-color: transparent" ng-click="addNew(model)" ><i class="glyphicon glyphicon-plus"></i></button>';
        template += '           </span>';
        template += '       </div>';
        template += '   </div>';
        template += '</div>';
        return {
            restrict : 'E',
            template: template,
            require: '^form',
            scope : {
                model:'=value',
                list: '=',
                searchMethod: '&',
                postMethod: '&addMethod',
                field: '@',
                onNewValueAdded: '&?',
                onValueVisualizationOpened: '&?',
                onValueVisualizationClosed: '&?'
            },
            link: function(scope, elm, attrs,ctrl){
                scope.formCtrl = ctrl;
                var ngModelCtrl = elm.find('input').controller('ngModel'),
                eventHandler = {
                    newValueAdded: (attrs.onNewValueAdded ? scope.onNewValueAdded : angular.noop),
                    valueVisualizationOpened: (attrs.onValueVisualizationOpened ? scope.onValueVisualizationOpened :angular.noop),
                    valueVisualizationClosed: (attrs.onValueVisualizationClosed ? scope.onValueVisualizationClosed :angular.noop)
                },
                async;
                !attrs.authorizeAdd ? scope.authorizeAdd = true : scope.authorizeAdd = JSON.parse(attrs.authorizeAdd);
                !attrs.async ? async = true : async = JSON.parse(attrs.async);
                scope.list = scope.list || [];
                function checkIfItIsString(string){
                    return ((typeof string).toUpperCase().trim()) === 'string'.toUpperCase().trim() && string.length > 1;
                }
                scope.$watch('model',function(){
                    checkIfItIsString(scope.model) ?
                    ctrl.$setValidity('GumgaManyToOne',false) : ctrl.$setValidity('GumgaManyToOne',true);
                });
                try {
                    GumgaKeyboard.bindToElement(elm.find('input')[0],'down',function(){ngModelCtrl.$setViewValue(' ')});
                } catch(e){

                }

                scope.showFullView = function(){
                    return ((typeof scope.model).toUpperCase().trim()) === 'object'.toUpperCase().trim() && scope.model != undefined;
                };

                scope.showPlus = function(){
                    return (((typeof scope.model).toUpperCase().trim()) === 'string'.toUpperCase().trim() && scope.authorizeAdd === true) ;
                };

                scope.proxySearchMethod = function(){
                  return scope.searchMethod({param: ngModelCtrl.$viewValue});
                };
                scope.addNew = function(text){
                    if(async) {
                        scope.postMethod({value: text})
                        .then(function(values){
                          scope.model = values;
                        })
                    } else {
                        scope.list.push(text);
                    }
                };
                scope.halp = function(obj){
                    var template = '';
                    template =
                    '<div class="modal-body">\n';
                    for (var key in obj) if (obj.hasOwnProperty(key) && key != '$$hashKey' && key != 'oi' && key != 'version' && key != 'password' && typeof obj[key] != 'object') {
                        template += '   <div class="form-group">\n';
                        template += '       <label><small>'+ key +'</small></label>\n';
                        template += '       <input type="text" ng-model="$value.' + key +'" disabled class="form-control"/>\n';
                        template += '   </div>\n';
                    }
                    template += '   <div class="modal-footer">\n';
                    template += '       <button type="button" class="btn btn-warning" ng-click="back()">Back</button>\n';
                    template += '   </div>\n';
                    template += '</div>\n';
                    eventHandler.valueVisualizationOpened();
                    var mi = $modal.open({
                        template: template,
                        size: 'sm',
                        controller: ["$scope", "$value", "$modalInstance", function($scope,$value,$modalInstance){
                            $scope.$value = $value;
                            $scope.back = function(){
                                $modalInstance.dismiss();
                            }
                        }],
                        resolve: {
                            $value: function(){
                                return obj;
                            }
                        }
                    });
                    mi.result.then(function(){
                        eventHandler.valueVisualizationClosed();
                    })
                };
            }
        }
    }
        angular.module('gumga.directives.manytoone',['ui.bootstrap','gumga.services.keyboard'])
        .directive('gumgaManyToOne',ManyToOne);
    })();

(function(){
  'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaMask
   * @restrict A
   * @description O componente **GumgaMask** serve para adicionar máscaras aos elementos inputs que se fazem necessário, como CPF, CNPJ, telefone e etc.
   *
   * @example
   * Um exemplo da directive gumgaTable funcionando pode ser encontrado [aqui](http://embed.plnkr.co/SALkp5bKRZ1aywsrpmEX).
   *  <pre>
   *  	<form class="" action="index.html" method="post">
   *  		<input type="text" name="name" value="" ng-model="cpf" gumga-mask="999.999.999-99" gumga-mask-options="maskOptions">
   *  	</form>
   *    <script type="text/javascript">
   *    $scope.maskOptions = {
   *    	maskDefinitions: {
   *    		'seuRegex': /[regex]/
   *    	},
   *    	clearOnBlur: false,
   *    	eventsToHandle: ['input', 'keyup', 'click', 'focus']
   *    };
   *    </script>
   *  </pre>
   *
   * @param {String} gumga-mask Por padrão o componente tem 3 tipos de regex aceitas, que são **9** (numéricos), **A** (alfanuméricos) e ** * ** (alfanuméricos)
   * @param {Object} gumga-mask-options Objeto em $scope com regex extras ou sobreescrever configurações default.
   * @param {String} gumga-mask-placeholder Trabalha em conjunto com o placeholder nativo, contudo, o **gumga-mask-placeholder** deve seguir o mesmo padrão
   * de caracteres do informado no **gumga-mask**. Enquanto o nativo fica ativo sem atividade no input, ao disparar o evento focus, o gumga-mask-placeholder
   * ficará ativo.
   */
  Mask.$inject = ["$parse"];

  function Mask($parse) {
    function isFocused (elem) {
      return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
    }

    return {
      priority: 100,
      require: 'ngModel',
      restrict: 'A',
      scope: {
        gumgaMaskOptions: '=gumgaMaskOptions'
      },
      compile: function gumgaMaskCompilingFunction() {
        var options = {
          maskDefinitions: {
            // Numéricos
            '9': /\d/,
            // Alfa
            'A': /[a-zA-Z]/,
            // Alfanuméricos
            '*': /[a-zA-Z0-9]/
          },
          // Se true, limpa o campo caso inválido no evento onBlur
          clearOnBlur: true,
          // Eventos para processamento
          eventsToHandle: ['input', 'keyup', 'click', 'focus']
        };

        return function gumgaMaskLinkingFunction(scope, elm, attrs, ctrl) {
          var maskProcessed = false, eventsBound = false,
          maskCaretMap, maskPatterns, maskPlaceholder, maskComponents,
          minRequiredLength,
          value, valueMasked, isValid,
          originalPlaceholder = attrs.placeholder,
          originalMaxlength = attrs.maxlength,
          // // Variáveis usadas exclusivamente para eventos
          oldValue, oldValueUnmasked, oldCaretPosition, oldSelectionLength;

          function initialize(maskAttr) {
            if (!angular.isDefined(maskAttr)) {
              return uninitialize();
            }
            processRawMask(maskAttr);
            if (!maskProcessed) {
              return uninitialize();
            }
            initializeElement();
            bindEventListeners();
            return true;
          }

          function initPlaceholder(placeholderAttr) {
            if (!placeholderAttr) {
              return;
            }

            maskPlaceholder = placeholderAttr;
            // Atualizamos o valor do input
            if (maskProcessed) {
              elm.val(maskValue(unmaskValue(elm.val())));
            }
          }

          function formatter(fromModelValue) {
            if (!maskProcessed) {
              return fromModelValue;
            }
            value = unmaskValue(fromModelValue || '');
            isValid = validateValue(value);
            ctrl.$setValidity('mask', isValid);
            return isValid && value.length ? maskValue(value) : undefined;
          }

          function parser(fromViewValue) {
            if (!maskProcessed) {
              return fromViewValue;
            }
            value = unmaskValue(fromViewValue || '');
            isValid = validateValue(value);
            ctrl.$viewValue = value.length ? maskValue(value) : '';
            ctrl.$setValidity('mask', isValid);
            if (value === '' && attrs.required) {
              ctrl.$setValidity('required', !ctrl.$error.required);
            }
            return isValid ? value : undefined;
          }

          var linkOptions = options;

          if (scope.gumgaMaskOptions) {
            linkOptions = scope.gumgaMaskOptions;
            if (angular.isObject(linkOptions)) {
              linkOptions = (function(original, current) {
                for (var i in original) {
                  if (Object.prototype.hasOwnProperty.call(original, i)) {
                    if (current[i] === undefined) {
                      current[i] = angular.copy(original[i]);
                    } else {
                      angular.extend(current[i], original[i]);
                    }
                  }
                }
                return current;
              })(options, linkOptions);
            }
          } else {
            linkOptions = options;
          }

          attrs.$observe('gumgaMask', initialize);
          if (angular.isDefined(attrs.gumgaMaskPlaceholder)) {
            attrs.$observe('gumgaMaskPlaceholder', initPlaceholder);
          }
          else {
            attrs.$observe('placeholder', initPlaceholder);
          }
          var modelViewValue = false;
          attrs.$observe('modelViewValue', function(val) {
            if (val === 'true') {
              modelViewValue = true;
            }
          });
          scope.$watch(attrs.ngModel, function(val) {
            if (modelViewValue && val) {
              var model = $parse(attrs.ngModel);
              model.assign(scope, ctrl.$viewValue);
            }
          });
          ctrl.$formatters.push(formatter);
          ctrl.$parsers.push(parser);

          function uninitialize() {
            maskProcessed = false;
            unbindEventListeners();

            if (angular.isDefined(originalPlaceholder)) {
              elm.attr('placeholder', originalPlaceholder);
            } else {
              elm.removeAttr('placeholder');
            }

            if (angular.isDefined(originalMaxlength)) {
              elm.attr('maxlength', originalMaxlength);
            } else {
              elm.removeAttr('maxlength');
            }

            elm.val(ctrl.$modelValue);
            ctrl.$viewValue = ctrl.$modelValue;
            return false;
          }

          function initializeElement() {
            value = oldValueUnmasked = unmaskValue(ctrl.$modelValue || '');
            valueMasked = oldValue = maskValue(value);
            isValid = validateValue(value);
            var viewValue = isValid && value.length ? valueMasked : '';
            if (attrs.maxlength) { // Double maxlength to allow pasting new val at end of mask
              elm.attr('maxlength', maskCaretMap[maskCaretMap.length - 1] * 2);
            }
            if ( ! originalPlaceholder) {
              elm.attr('placeholder', maskPlaceholder);
            }
            elm.val(viewValue);
            ctrl.$viewValue = viewValue;
            ctrl.$setValidity('mask', isValid);
            // Não usando $setViewValue, então não sobreescreve
            // o valor do model sem interação do usuário.
          }

          function bindEventListeners() {
            if (eventsBound) {
              return;
            }
            elm.bind('blur', blurHandler);
            elm.bind('mousedown mouseup', mouseDownUpHandler);
            elm.bind(linkOptions.eventsToHandle.join(' '), eventHandler);
            elm.bind('paste', onPasteHandler);
            eventsBound = true;
          }

          function unbindEventListeners() {
            if (!eventsBound) {
              return;
            }
            elm.unbind('blur', blurHandler);
            elm.unbind('mousedown', mouseDownUpHandler);
            elm.unbind('mouseup', mouseDownUpHandler);
            elm.unbind('input', eventHandler);
            elm.unbind('keyup', eventHandler);
            elm.unbind('click', eventHandler);
            elm.unbind('focus', eventHandler);
            elm.unbind('paste', onPasteHandler);
            eventsBound = false;
          }

          function validateValue(value) {
            // Valida o tamanho mínimo requerido da máscara
            return value.length ? value.length >= minRequiredLength : true;
          }

          // Remove máscara
          function unmaskValue(value) {
            var valueUnmasked = '',
            maskPatternsCopy = maskPatterns.slice();
            // Processo para retirar componentes do valor
            value = value.toString();
            angular.forEach(maskComponents, function(component) {
              value = value.replace(component, '');
            });
            angular.forEach(value.split(''), function(chr) {
              if (maskPatternsCopy.length && maskPatternsCopy[0].test(chr)) {
                valueUnmasked += chr;
                maskPatternsCopy.shift();
              }
            });
            return valueUnmasked;
          }

          // Adiciona máscara
          function maskValue(unmaskedValue) {
            var valueMasked = '',
            maskCaretMapCopy = maskCaretMap.slice();

            angular.forEach(maskPlaceholder.split(''), function(chr, i) {
              if (unmaskedValue.length && i === maskCaretMapCopy[0]) {
                valueMasked += unmaskedValue.charAt(0) || '_';
                unmaskedValue = unmaskedValue.substr(1);
                maskCaretMapCopy.shift();
              }
              else {
                valueMasked += chr;
              }
            });
            return valueMasked;
          }

          // O atributo padrão placeholder funciona normalmente,
          // o atributo gumgaMaskPlaceholder define a máscara com o placeholder
          // e deve atender a quantidade de caracteres da máscara.
          function getPlaceholderChar(i) {
            var placeholder = angular.isDefined(attrs.gumgaMaskPlaceholder) ? attrs.gumgaMaskPlaceholder : attrs.placeholder;

            if (typeof placeholder !== 'undefined' && placeholder[i]) {
              return placeholder[i];
            } else {
              return '_';
            }
          }

          function getMaskComponents() {
            return maskPlaceholder.replace(/[_]+/g, '_').replace(/([^_]+)([a-zA-Z0-9])([^_])/g, '$1$2_$3').split('_');
          }

          function processRawMask(mask) {
            var characterCount = 0;

            maskCaretMap = [];
            maskPatterns = [];
            maskPlaceholder = '';

            if (typeof mask === 'string') {
              minRequiredLength = 0;

              var isOptional = false,
              numberOfOptionalCharacters = 0,
              splitMask = mask.split('');

              angular.forEach(splitMask, function(chr, i) {
                if (linkOptions.maskDefinitions[chr]) {

                  maskCaretMap.push(characterCount);

                  maskPlaceholder += getPlaceholderChar(i - numberOfOptionalCharacters);
                  maskPatterns.push(linkOptions.maskDefinitions[chr]);

                  characterCount++;
                  if (!isOptional) {
                    minRequiredLength++;
                  }
                }
                else if (chr === '?') {
                  isOptional = true;
                  numberOfOptionalCharacters++;
                }
                else {
                  maskPlaceholder += chr;
                  characterCount++;
                }
              });
            }
            // Posição do cursor imediatamente após última posição válida
            maskCaretMap.push(maskCaretMap.slice().pop() + 1);

            maskComponents = getMaskComponents();
            maskProcessed = maskCaretMap.length > 1 ? true : false;
          }

          function blurHandler() {
            // Se clearOnBlur for true em options,
            // limpa o campo caso esteja inválido.
            if (linkOptions.clearOnBlur) {
              oldCaretPosition = 0;
              oldSelectionLength = 0;
              if (!isValid || value.length === 0) {
                valueMasked = '';
                elm.val('');
                scope.$apply(function() {
                  ctrl.$setViewValue('');
                });
              }
            }
          }

          function mouseDownUpHandler(e) {
            if (e.type === 'mousedown') {
              elm.bind('mouseout', mouseoutHandler);
            } else {
              elm.unbind('mouseout', mouseoutHandler);
            }
          }

          elm.bind('mousedown mouseup', mouseDownUpHandler);

          function mouseoutHandler() {
            /*jshint validthis: true */
            oldSelectionLength = getSelectionLength(this);
            elm.unbind('mouseout', mouseoutHandler);
          }

          function onPasteHandler() {
            /*jshint validthis: true */
            setCaretPosition(this, elm.val().length);
          }

          function eventHandler(e) {
            /*jshint validthis: true */
            e = e || {};
            // Permite uma minificação mais eficiente
            var eventWhich = e.which,
            eventType = e.type;

            if (eventWhich === 16 || eventWhich === 91) {
              return;
            }

            var val = elm.val(),
            valOld = oldValue,
            valMasked,
            valUnmasked = unmaskValue(val),
            valUnmaskedOld = oldValueUnmasked,
            caretPos = getCaretPosition(this) || 0,
            caretPosOld = oldCaretPosition || 0,
            caretPosDelta = caretPos - caretPosOld,
            caretPosMin = maskCaretMap[0],
            caretPosMax = maskCaretMap[valUnmasked.length] || maskCaretMap.slice().shift(),
            selectionLenOld = oldSelectionLength || 0,
            isSelected = getSelectionLength(this) > 0,
            wasSelected = selectionLenOld > 0,
            // Case: Digitando um caracter para substituir uma seleção
            isAddition = (val.length > valOld.length) || (selectionLenOld && val.length > valOld.length - selectionLenOld),
            // Case: Delete e backspace se comportam de forma idêntica em uma seleção
            isDeletion = (val.length < valOld.length) || (selectionLenOld && val.length === valOld.length - selectionLenOld),
            isSelection = (eventWhich >= 37 && eventWhich <= 40) && e.shiftKey, // Arrow key codes

            isKeyLeftArrow = eventWhich === 37,
            // Necessária devido ao evento não fornecer um keycode
            isKeyBackspace = eventWhich === 8 || (eventType !== 'keyup' && isDeletion && (caretPosDelta === -1)),
            isKeyDelete = eventWhich === 46 || (eventType !== 'keyup' && isDeletion && (caretPosDelta === 0) && !wasSelected),
            // Lida com casos onde acento circunflexo é movido e colocado na frente da posição maskCaretMap inválido.
            // Logic abaixo assegura que, ao clicar ou posicionamento acento circunflexo para a esquerda, acento
            // circunflexo é movido para a esquerda até à direita directamente de caráter não-máscara.
            // Também aplicado para clicar uma vez que os usuários são (discutivelmente) mais propensos a voltar
            // atrás com um personagem ao clicar dentro de uma entrada cheia.
            caretBumpBack = (isKeyLeftArrow || isKeyBackspace || eventType === 'click') && caretPos > caretPosMin;

            oldSelectionLength = getSelectionLength(this);

            // Eventos que não requerem nenhuma ação
            if (isSelection || (isSelected && (eventType === 'click' || eventType === 'keyup'))) {
              return;
            }

            // Controle de valores
            // ==============

            // User attempted to delete but raw value was unaffected--correct this grievous offense
            // O usuário tentou apagar, mas valor bruto não foi afetado - corrigir este grave ofensa
            if ((eventType === 'input') && isDeletion && !wasSelected && valUnmasked === valUnmaskedOld) {
              while (isKeyBackspace && caretPos > caretPosMin && !isValidCaretPosition(caretPos)) {
                caretPos--;
              }
              while (isKeyDelete && caretPos < caretPosMax && maskCaretMap.indexOf(caretPos) === -1) {
                caretPos++;
              }
              var charIndex = maskCaretMap.indexOf(caretPos);
              // Strip out non-mask character that user would have deleted if mask hadn't been in the way.
              valUnmasked = valUnmasked.substring(0, charIndex) + valUnmasked.substring(charIndex + 1);
            }

            // Atualiza valor
            valMasked = maskValue(valUnmasked);

            oldValue = valMasked;
            oldValueUnmasked = valUnmasked;
            elm.val(valMasked);
            ctrl.$setViewValue(valUnmasked);

            // Posição do cursor
            // ===================

            // Caractere digitado a frente nos casos em que o primeiro caractere de entrada é um char máscara e o cursor
            // for colocado na posição 0.
            if (isAddition && (caretPos <= caretPosMin)) {
              caretPos = caretPosMin + 1;
            }

            if (caretBumpBack) {
              caretPos--;
            }

            caretPos = caretPos > caretPosMax ? caretPosMax : caretPos < caretPosMin ? caretPosMin : caretPos;

            while (!isValidCaretPosition(caretPos) && caretPos > caretPosMin && caretPos < caretPosMax) {
              caretPos += caretBumpBack ? -1 : 1;
            }

            if ((caretBumpBack && caretPos < caretPosMax) || (isAddition && !isValidCaretPosition(caretPosOld))) {
              caretPos++;
            }
            oldCaretPosition = caretPos;
            setCaretPosition(this, caretPos);
          }

          function isValidCaretPosition(pos) {
            return maskCaretMap.indexOf(pos) > -1;
          }

          function getCaretPosition(input) {
            if (!input)
            return 0;
            if (input.selectionStart !== undefined) {
              return input.selectionStart;
            } else if (document.selection) {
              if (isFocused(elm[0])) {
                // Maldito seja o IE
                input.focus();
                var selection = document.selection.createRange();
                selection.moveStart('character', input.value ? -input.value.length : 0);
                return selection.text.length;
              }
            }
            return 0;
          }

          function setCaretPosition(input, pos) {
            if (!input)
            return 0;
            if (input.offsetWidth === 0 || input.offsetHeight === 0) {
              return; // Inputs escondidos
            }
            if (input.setSelectionRange) {
              if (isFocused(elm[0])) {
                input.focus();
                input.setSelectionRange(pos, pos);
              }
            }
            else if (input.createTextRange) {
              // Maldito seja o IE
              var range = input.createTextRange();
              range.collapse(true);
              range.moveEnd('character', pos);
              range.moveStart('character', pos);
              range.select();
            }
          }

          function getSelectionLength(input) {
            if (!input)
            return 0;
            if (input.selectionStart !== undefined) {
              return (input.selectionEnd - input.selectionStart);
            }
            if (document.selection) {
              return (document.selection.createRange().text.length);
            }
            return 0;
          }
        }
      }
    }
  }
  angular.module('gumga.directives.mask', [])
  .directive('gumgaMask', Mask);
})();

(function(){
	'use strict';
	Menu.$inject = ["$http", "$compile"];
	/**
	 * @ngdoc directive
	 * @name  gumga.core:gumgaMenu
	 * @restrict E
	 * @description
	 *  O componente gumgaMenu é uma directive que cria um menu na lateral esquerda da tela para facilitar a navegação do usuário no sistema.
	 *  Seus itens são carregados de forma dinâmica através de um arquivo `json` que é carregado através de uma requisição HTTP. Além disso,
	 *  ele faz um filtro de acordo com as keys passadas para ele também através de um arquivo `json`.
	 *  ## Exemplo
     *  Veja um exemplo em funcionamento [aqui](http://embed.plnkr.co/UcMtAor6sUA6s0oZnJiu/preview).
	 *  @param {String} menu-url Parâmetro obrigatório que irá conter uma variável com o endereço do arquivo `json` para que seja carregada as entradas do menu.
	 *  @param {String} keys-url Parâmetro obrigatório que irá conter uma variável com o endereço do arquivo `json` para que seja carregada as chaves que farão o filtro do menu.
	 *  @param {String} image Parâmetro obrigatório que irá conter uma variável com o endereço da imagem que ficará no menu.
	 *
 	 * ## Example
	 * 	###Exemplo de json para o menu:
	 * <pre>
    [
      {
        "label": "Home",
        "URL": "welcome",
        "key": "CRUD-BASE",
        "icon": "glyphicon glyphicon-home",
        "icon_color": "",
        "imageUrl": "",
        "imageWidth": "",
        "imageHeight": "",
        "filhos": []
      }
    ]
	 * 	</pre>
	 * 	###Exemplo de json para as keys:
	 * 	<pre>
    [
      "CRUD-BASE",
      "CRUD-User"
    ]
	 * 	</pre>
	 *
	 *
	 *  @param {String} menu-url Parâmetro obrigatório que irá conter uma variável com o endereço do arquivo `json` para que seja carregada as entradas do menu.
	 *  @param {String} keys-url Parâmetro obrigatório que irá conter uma variável com o endereço do arquivo `json` para que seja carregada as chaves que farão o filtro do menu.
	 *  @param {String} image Parâmetro obrigatório que irá conter uma variável com o endereço da imagem que ficará no menu.
	 *

	 */
	function Menu($http, $compile) {
		return {
			restrict: 'E',
			replace: true,
			scope: {},
			link: function (scope, el, attrs) {
				scope.v = [];
				var indexs = [];
				var count = 0;

				var menuOpen = false;

				$http.get(attrs.menuUrl).then(function (data) {
					scope.dados = data.data;
				}, function (data) {
					throw 'Erro:' + data;
				});

				$http.get(attrs.keysUrl).then(function (data) {
					scope.keys = data.data;
				}, function (data) {
					throw 'Erro:' + data;
				});

				scope.$watchGroup(['dados', 'keys'], function () {
					if (scope.dados && scope.keys) {
						gerateMenus();
					}
				});

				var gerateMenus = function () {
					var template = ['<div>'];
					template.push('<button id="btn-menu" class="btn btn-link" ng-click="mostrarMenu()"><i class="glyphicon glyphicon-align-justify"></i></button>');
					template.push('<nav id="menu" class="col-sm-3" name="menu">');
					template.push('<ul class="menu-holder">');
					template.push('<img ng-src="' + attrs.image + '" alt="logo" width="40%" class="img-centered">');
					for (var i = 0; i < scope.dados.length; i++) {
						if (keyIsValid(scope.dados[i].key)) {
							template.push(gerarNavPill(scope.dados[i], 'menu', {count: -1, label: null}));
						}
					}
					template.push('</ul>');
					template.push('</nav>');
					template.push('</div>');
					template = template.join('\n');
					el.append($compile(template)(scope));
				};

				var gerarNavPill = function (param, type, parent) {

					scope.v[count] = {
						isActive: false,
						parent: parent.count
					};

					var urlSelected = location.hash;
					var url = angular.copy(param.URL);
					url = '#/'+url.replace('.','/')
					if (urlSelected==url) {
							var template = ['<li class="' + type + '-option" style="background: #4ca089" >'];
					} else {
							var template = ['<li class="' + type + '-option">'];
					}

					if (param.filhos.length > 0 && verificarPermicaoFilho(param.filhos)) {
						template.push('<i  ng-class="v[' + count + '].isActive ? \' glyphicon glyphicon-chevron-down \' : \'glyphicon glyphicon-chevron-right\'" class="fa ' + type + '-color"  ng-click="resetarMenu(' + count + ')"></i>');
					} else {
						if (param.icon) {
							if (param.icon_color) {
								template.push('<i  class=" ' + param.icon + ' " style="color: ' + param.icon_color + '" ng-click="resetarMenu(' + count + ')"></i>');
							} else {
								template.push('<i  class=" ' + param.icon + ' " style="color: #fff" ng-click="resetarMenu(' + count + ')"></i>');
							}
						}
					}

					template.push('<a ui-sref="' + param.URL + '" ng-class="v[' + count + '].isActive ? \'is-active\' : \' \'"');
					if (parent.label === null || param.filhos.length > 0) {
						template.push('gumga-translate-tag="' + param.label.toLowerCase() + '.menuLabel">');
					} else if (param.filhos.length === 0) {
						template.push('gumga-translate-tag="' + parent.label.toLowerCase() + '.' + param.label.toLowerCase() + '">');
					}
					template.push(param.label);
					template.push('</a>');

					if (param.imageUrl) {
						if(param.imageWidth && param.imageHeight){
							template.push('<a ui-sref="' + param.URL + '"><img  src="' + param.imageUrl + '" style="width: '+param.imageWidth+'; height: '+param.imageHeight+';" ng-click="resetarMenu(' + count + ')"></i></a>');
						}else
						template.push('<a ui-sref="' + param.URL + '"><img  src="' + param.imageUrl + '" style="width: 20px; height: 20px;" ng-click="resetarMenu(' + count + ')"></i></a>');
					}

					var aux = count;

					count++;
					if (param.filhos.length > 0) {
						template.push('<ul ng-class="v[' + (count - 1) + '].isActive ? \' submenu-group-ativo\' : \'submenu-group\'" class="menu-holder">');
						for (var i = 0; i < param.filhos.length; i++) {
							if (keyIsValid(param.filhos[i].key)) {
								template.push(gerarNavPill(param.filhos[i], 'submenu', {count: aux, label: param.label}));
							}
						}
						template.push('</ul>');
					}
					template.push('</li>');
					return template.join('\n');
				};


				scope.resetarMenu = function (index) {
					var i;
					if (scope.v[index].isActive) {
						for (i = 0; i < scope.v.length; i++) {
							scope.v[index].isActive = false;
						}
						setarTrue(scope.v[index].parent);

					} else {
						for (i = 0; i < scope.v.length; i++) {
							scope.v[i].isActive = false;
						}
						setarTrue(index);
					}

				};

				var keyIsValid = function (key) {
					return scope.keys.indexOf(key) != -1;
				};

				function setarTrue(index) {
					if (index >= 0) {
						scope.v[index].isActive = true;
						setarTrue(scope.v[index].parent);
					}
				}

				scope.mostrarMenu = function () {
					menuOpen = !menuOpen;

					var elm = el.find('nav');
					if (menuOpen) {
						elm.addClass('open-menu');
					} else {
						elm.removeClass('open-menu');
					}
				};

				function verificarPermicaoFilho(filhos) {
					for (var i = 0; i < filhos.length; i++) {
						for (var j = 0; j < scope.keys.length; j++) {
							if (filhos[i].key == scope.keys[j]) {
								return true;
							}
						}
					}
					return false;
				}

			}
		};
	}

	angular.module('gumga.directives.menu',[])
	.directive('gumgaMenu',Menu);

})();

(function(){

  'use strict';
  Nav.$inject = ["$state", "GumgaWebStorage", "$modal", "$rootScope", "$timeout"];
  /**
  * @ngdoc directive
  * @name  gumga.core:gumgaNav
  * @restrict E
  * @description O componente gumgaNav é uma directive que cria uma barra de navegação superior, para ajudar o usuário. Dentro da barra de navegação,
  *  possuímos uma busca que, quando o botão ENTER é pressionado, ele redireciona para a página de Busca Multi-entidades. Possui também informações sobre o usuário que está logado,
  *  uma opção para fazer o logout e outra para alterar a senha.
  *  ## Exemplo
  *  Veja um exemplo em funcionamento [aqui](http://embed.plnkr.co/PeJHAS6viutuekw614ZL/preview).
  *  @param {String} title Parâmetro não obrigatório que contém uma string que será o título que aparecerá na barra de navegação.
  *  @param {Boolean} multi-entity Parâmetro nao obrigatório que contém um valor booleano para compilar ou não a busca multientidade. Por padrão, o valor é true.
  *  @param {String} put-url Parâmetro não obrigatório que contém uma String ou uma variável que estará no $scope da directive para atribuir uma url para fazer o put do alterar a senha.
  *  @param {String} state Parâmetro obrigatório que contém uma String com o $state para qual será redirecionado quando o usuário clicar em Logout.
  */
  function Nav($state, GumgaWebStorage, $modal, $rootScope, $timeout) {
    var template = [
      '<nav id="navbar">',
      ' <a href="#" class="navbar-logo" style=" float: left;">{{title | uppercase}}</a>',
      ' <span style="color: white; font-size: 1.4em;margin-left: 2%; float: left;"><small>{{info.organization}}</small></span>',
      ' <div class="navbar-form navbar-left" ng-transclude></div>',
      ' <b class="pull-right">',
      '   <img ng-show="info.picture" class="img-circle" style="width: 40px; height: 40px; margin-right:10px;" src="{{info.picture}}" />',
      '   <a href ng-blur="hidePanel()" class="status-navbar" ng-click="showPanelNavBar()">',
      '     <small  style="font-size: 85%;">{{info.name}} &nbsp;&nbsp; <i class="glyphicon glyphicon-triangle-bottom" style="margin-left: 1px"></i> </small>',
      '   </a>',
      ' </b>',
      ' <span ng-if="multientity" ng-click="treatUrl()" class="glyphicon glyphicon-search btn pull-right" style="color:#fff; padding-top: 1%; margin-right: 5%; height: 100%;"></span>',
      ' <input ng-if="multientity" type="text" id="inputSearch" ng-keyup="submitSearch($event)" style="background: none repeat scroll 0 0 rgba(244, 214, 214, 0.15); border: double; font-size: 14px; outline: 0; color: #fff; height: 100%; margin: 0; border-color: rgba(0, 0, 0, 0); z-index: 2000;" ng-model="search" ng-show="inputVisible" class="navbar-input flip-right" placeholder="Search">',
      '</nav>',
      '<div class="nav-panel" ng-show="showPanelNav">',
      ' <div class="panel-body" id="navPanelBody">',
      '   <button ng-repeat="link in navlinks" ng-click="handle(link)" class="btn btn-link" style="display:block;width: 100%;color: black; font-size: 0.9em;"><i class="{{link.glyphicon}}"> </i>{{link.text}} </button>',
      ' </div>',
      '</div>'
    ];

    var modalTemplate = [
      '<div class="modal-header">Change Password</div>',
      '<div class="modal-body">' +
      '   <form name="ModalForm" novalidate>' +
      '   <label> <small>Old Password</small></label>' +
      '   <input type="password" ng-keyup="validPassword(user.newpass, user.oldpass)" ng-focus="oldPasswordInvalid=false" class="form-control" ng-model="user.oldpass" required/>' +
      '   <label class="text-danger" style="width: 100%;"  ng-show="oldPasswordInvalid">Esta não é sua senha antiga</label>' +
      '   <label><small> New Password</small></label>' +
      '   <input type="password" class="form-control" ng-keyup="validPassword(user.newpass, user.oldpass)" ng-model="user.newpass" required/>' +
      '   <label class="text-danger" style="width: 100%;"  ng-show="newPasswordInvalid">Por favor insira uma senha diferente da antiga.</label>' +
      '   <label><small> New Password (again)</small></label>' +
      '   <input type="password" class="form-control" ng-keyup="validPasswordConfirm(user.newpass,user.newpasscheck)" ng-model="user.newpasscheck" required/>' +
      '   <label class="text-danger" style="width: 100%;"  ng-show="newPasswordConfirm">Repita a nova senha corretamente.</label>' +
      '</div>',
      '<div class="modal-footer">' +
      '   <button class="btn btn-primary" ng-click="ok(user)" type="submit" ng-disabled="ModalForm.$invalid || !btnEnabled"> Save</button>' +
      '   <button class="btn btn-warning" ng-click="cancel()" type="button"> Cancel</button>' +
      '</div>' +
      '</form>'];
      return {
        restrict: 'E',
        scope: false,
        transclude: true,
        template: template.join('\n'),
        link: function (scope, el, attrs) {
          var putUrl = attrs.putUrl;
          if(attrs.multiEntity == "true" || !attrs.multiEntity) scope.multientity = true;
          (!scope[attrs.putUrl]) ? putUrl = scope[attrs.putUrl] : angular.noop;
          scope.info = GumgaWebStorage.getSessionStorageItem('user');
          scope.navlinks = [{text: 'Change Password', glyphicon: 'glyphicon glyphicon-user', value: 'pass'}, {text: 'Logout', glyphicon: 'glyphicon glyphicon-log-out', value: 'logout'}];
          scope.inputVisible = false;
          scope.title = attrs.title || '';
          scope.treatUrl = function () {
            scope.inputVisible = !scope.inputVisible;
            $timeout(function () {
              document.getElementById('inputSearch').focus();
            },200);

          };
          scope.$on('close', function () {
            scope.showPanelNav = false;
          });
          scope.showPanelNavBar = function () {
            scope.showPanelNav = !scope.showPanelNav;
          };
          var obj = {};

          scope.submitSearch = function (event) {
            var key_code = event.keyCode;
            if (key_code === 13)
            $state.go('multientity', {'search': scope.search})
          }

          scope.hidePanel = function () {
            $timeout(function () {
              scope.showPanelNav = false;
            }, 200);
          };

          scope.handle = function (link) {
            scope.showPanelNav = !scope.showPanelNav;
            switch (link.value) {
              case 'pass':
              var modalInstance = $modal.open({
                template: modalTemplate.join('\n'),
                size: 'sm',
                controller: ["$scope", "$modalInstance", "$http", "GumgaWebStorage", function ($scope, $modalInstance, $http, GumgaWebStorage) {
                  var userSession = GumgaWebStorage.getSessionStorageItem('user');
                  $scope.btnEnabled = false;
                  $scope.oldPasswordInvalid = false;
                  $scope.newPasswordConfirm = false;
                  $scope.newPasswordInvalid = false;

                  $scope.validPasswordConfirm = function (password, confimPassword){
                    if(password !== confimPassword){
                      $scope.newPasswordConfirm = true;
                    }else{
                      $scope.newPasswordConfirm = false;
                    }
                    $scope.enabledBtn();
                  }

                  $scope.validPassword = function (password, oldPassword){
                    $scope.user.newpasscheck = '';
                    if(password == oldPassword && password){
                      $scope.newPasswordInvalid = true;
                    }else{
                      $scope.newPasswordInvalid = false;
                    }
                    $scope.enabledBtn();
                  }

                  $scope.enabledBtn = function (){
                    if(!$scope.newPasswordConfirm && !$scope.newPasswordInvalid){
                      $scope.btnEnabled = true;
                    }else{
                      $scope.btnEnabled= false;
                    }
                  }

                  $scope.ok = function (user) {
                    $http.put(attrs.putUrl, {
                      user: userSession.user,
                      password: user.oldpass,
                      newPassword: user.newpass})
                      .success(function (data) {
                        if (data.response == 'BAD_PASSWORD') {
                          $scope.oldPasswordInvalid = true;
                        } else if (data.response == 'OK') {
                          $scope.$emit('successMessage', {
                            title: 'Senha alterada',
                            message: 'Sua senha foi alterada com sucesso.'
                          })
                          $modalInstance.close();
                        } else {
                          $modalInstance.close();
                        }
                      });
                    };
                    $scope.cancel = function () {
                      $modalInstance.dismiss();
                    };

                  }],
                  resolve: {}
                });
                modalInstance.result.then(function (selectedItem) {
                  scope.selected = selectedItem;
                });
                break;
                case 'logout':
                $state.go(attrs.state);
                break;
              }
            };
            el.find('input')
            .on('keypress', function (k) {
              if (k.keyCode == 13)
              scope.treatUrl()
            });
          }
        };
      }

      angular.module('gumga.directives.nav',['ui.bootstrap'])
      .directive('gumgaNav',Nav)
    })();

(function(){
	'use strict';

	OneToMany.$inject = ["$modal", "$populate"];
	/**
	 * @ngdoc directive
	 * @name gumga.core:gumgaOneToMany
	 * @restrict E
	 * @description
	 * 	A directive gumgaOneToMany pode ser usada quando é necessária a criação de uma lista de objetos dentro do formulário, especialmente quando esses
	 * 	objetos acessam outros Services. Ela lança um modal para a criação destes objetos, que podem ser recursivos. Além disso, possui suporte a edição e remoção
	 * 	destes registros.
	 * @param {Array} children Parâmetro obrigatório que irá conter um Array que será utilizado para construir a lista.
	 * @param {String} template-url Parâmetro obrigatório que irá conter uma string referenciando a url na qual o template do modal estará.
	 * @param {String} property Parâmetro obrigatório que irá conter uma string com a propriedade do objeto que será mostrada na lista.
	 * @param {String} name *Utilizar modal-title*.
	 * @param {String} modal-title Parâmetro não obrigatório que irá conter uma string com o título que será passado para o controller
	 * @param {String} controller Parâmetro obrigatório que irá conter uma String que referenciará o nome do controller que será atribuido ao modal.
	 * *Este controller necessita injetar além do $scope, as propriedades **entity** e **title** *
	 * @param {Function} on-delete Parâmetro não obrigatório que irá conter uma variável que irá conter uma função que será chamada quando um elemento da lista for deletado.
	 * A função que está no on-delete
   * @param {Function} on-value-visualization-opened Parâmetro não obrigatório que irá conter uma variável que possuirá uma função que irá ser executada quando o usuário tiver aberto o modal
   * para visualização de dados
   * @param {Function} on-value-visualization-closed Parâmetro não obrigatório que irá conter uma variável que possuirá uma função que irá ser executada quando o usuário tiver fechado o modal
   * para visualização de dados
	 *
	 */
	function OneToMany($modal,$populate){
		var template = [
		'<div class="col-md-12" style="padding-left: 0;padding-right: 0">',
		'   <button type="button" class="btn btn-default" ng-click="newModal()">New</button>',
		'   <ul class="list-group">',
		'       <li ng-repeat="child in children" class="list-group-item">',
		'           {{::child[property]}}',
		'           <button type="button" class="btn btn-default pull-right btn-sm" ng-click="newModal(child)"><i class="glyphicon glyphicon-pencil"></i></button>',
		'           <button type="button" class="btn btn-danger pull-right btn-sm" ng-click="removeFromList(child)"><i class="glyphicon glyphicon-remove"></i></button>',
		'       <div class="clearfix"></div></li>',
		'   <ul>',
		'</div>',
		'<div class="clearfix"></div>'
		];

		return {
			restrict: 'E',
			template: template.join('\n'),
			scope: {
				children: '=',
				templateUrl: '@',
				property: '@displayableProperty',
				name: '@',
				controller: '@',
				onDelete: '&?',
				onValueVisualizationOpened: '&?',
				onValueVisualizationClosed: '&?',
				modalTitle: '@'
			},
			link: function (scope,elm,attrs) {
				var eventHandler = {
					valueVisualizationOpened: (attrs.onValueVisualizationOpened ? scope.onValueVisualizationOpened :angular.noop),
					valueVisualizationClosed: (attrs.onValueVisualizationClosed ? scope.onValueVisualizationClosed :angular.noop),
					delete: (attrs.onDelete ? scope.onDelete : angular.noop)
				};
				scope.newModal = newModal;
				scope.removeFromList = removeFromList;
				scope.getFromModal = getFromModal;
				var name = attrs.name || 'New';
				if(!scope.children) throw 'You must provide a list to GumgaOneToMany';
				if(!scope.templateUrl) throw 'You must provide a templateUrl for the modal';
				if(!scope.property) throw 'You must provide a property to display in GumgaOneToMany';
				if(!scope.controller) throw 'You must provide a controller to the modal';
				function getFromModal(selected){
					eventHandler.valueVisualizationClosed();
					if(JSON.stringify(scope.etty) !== '{}'){
						scope.children.splice(scope.children.indexOf(scope.etty),1,selected);
					} else {
						scope.children.push(selected);
					}
				}
				function removeFromList(obj){
					eventHandler.delete({$value: obj});
					scope.children.splice(scope.children.indexOf(obj),1);
				}
				function newModal(obj){
					scope.etty = {};
					if(obj){
						scope.etty= obj;
					}
					eventHandler.valueVisualizationOpened();
					var modalInstance = $modal.open({
						templateUrl: scope.templateUrl,
						controller: scope.controller,
						resolve: {
							entity: function(){
								return scope.etty;
							},
							title: function(){
								return scope.name;
							},
							populateScope: function(){
								return $populate.populateScope;
							}
						}
					});
					modalInstance.result.then(getFromModal);
				}


			}
		};
	}

	angular.module('gumga.directives.onetomany',['gumga.services.populate'])
		.directive('gumgaOneToMany',OneToMany)


})();

(function () {
  'use strict';

  Query.$inject= [];
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaQueries
   * @restrict E
   * @description
   * 	O componente gumgaQueries pode ser utilizado como um complemento para a directive gumgaSearch para quando ela for uma busca avançada. Ele utiliza o array searchQueries que é
   * 	exposto pelo componente de Busca Avançada.
   *
   * @param {Function} save-query Função que será executada quando o botão de salvar a pesquisa for clicado.
   * @param {String} label String que será colocada como título
   * @param {String} placeholder String que será colocada como placeholder o input.
   */
  function Query(){
    var _template =
    '<div class="col-md-12" ng-show="hasQueries && $parent.searchQueries.length > 0">'+
    '   <label><small>{{::label}}</small></label>'+
    '   <div class="col-md-12">'+
    '   <div class="col-md-8"  style="padding-left: 0;padding-right: 0;">'+
    '   <gumga-advanced-label '+
    '         ng-repeat="query in $parent.searchQueries"'+
    '         attr="{{query.attribute.name}}"'+
    '         hql="{{query.hql.label}}"'+
    '         value="query.value"'+
    '         index="$index"'+
    '         disabled="true"'+
    '         style="margin-right: .5%">'+
    '   </gumga-advanced-label>'+
    '</div>'+
    ' <div class="col-md-4" style="padding-left: 0;padding-right: 0;">'+
    ' <div class="input-group input-group-sm" style="">'+
    '   <input type="text" ng-model="name" class="form-control" placeholder="{{placeholder}}" />'+
    '     <span class="input-group-btn">'+
    '       <button ng-disabled="(name.length < 1)" class="btn btn-primary" ng-click="saveQuery({query: $parent.searchQueries,name: name})" >'+
    '         <i class="glyphicon glyphicon-floppy-save"></i>'+
    '       </button>'+
    '     </span>'+
    ' </div>'+
    ' </div>'+
    '</div>';
    return {
      restrict: 'E',
      scope:{
        saveQuery: '&',
        placeholder: '@?'
      },
      template: _template,
      link: function (scope,elm,attrs) {
        scope.label = attrs.label || 'Busca ativa:';
        if(scope.$parent.searchQueries){
          scope.hasQueries = true;
        }
      }
    }
  }

  angular.module('gumga.directives.queries',['gumga.directives.search.advancedlabel'])
  .directive('gumgaQueries',Query);
})();


(function(){
	'use strict';
	/**
	 * @ngdoc directive
	 * @name gumga.core:gumgaSearch
	 * @restrict E
	 * @description A directive gumgaSearch pode ser utilizada para fazer montar queries de busca, sejam essas buscas normais ou avançadas. É possível escolher
	 * quais campos no qual a busca será feita, assim como na busca avançada.
	 * ## Exemplo
     * Veja um exemplo em funcionamento [aqui](http://embed.plnkr.co/ezZITh3ZfmwVao0Xz1w6/preview).    
	 *
	 * O componente utiliza-se de tags que só funcionam dentro das tags do componente, que são as tags `<advanced-field></advanced-field>`. A tag de advanced-field 
	 * 	recebe dois atributos como parâmetro: `name` e `type` que recebem , respectivamente, o nome do atributo a ser pesquisado e qual seu tipo.
	 * 	<pre>
	 *  		<advanced-field name="nome" type="string"></advanced-field>
	 *  		<advanced-field name="idade" type="number"></advanced-field>
	 *  </pre>
	 * 
	 * @param {Function} advanced-method Parâmetro obrigatório que irá conter uma função que será utilizada para fazer a busca avançada.
	 * Para receber a query avançada, basta passar um parâmetro `param` para a função. `advanced-method="function(param)"`
	 * @param {Function} search-method Parâmetro obrigatório que irá conter uma função que será utilizada para fazer a busca simples.
	 * Para receber o campo e a pesquisa que foi feita, basta passar os parâmetros `field` e `param` para a função. `search-method="function(field,param)"`.
	 * @param {String} fields Parâmetro obrigatório que irá conter uma sequência de campos com o qual o componente irá criar a lista de atributos que serão pesquisáveis.
	 * Exemplo: `fields="id,name,company,age"`
	 * @param {Boolean} advanced Parâmetro não obrigatório que irá conter um valor booleano para controlar se o componente irá ou não fazer busca avançada
	 * @param {Function} on-search Parâmetro não obrigatório que irá conter uma função que será chamada quando uma busca simples for feita. 
	 * @param {Function} on-advanced-search Parâmetro não obrigatório que irá conter uma função que será chamada quando uma busca avançada for feita. 
	 *
	 * 
	 */
	angular.module('gumga.directives.search',
		[
		'gumga.directives.search.search',
		'gumga.directives.search.normalsearch',
		'gumga.directives.search.advancedsearch',
		'gumga.directives.search.advancedlabel',
		'gumga.directives.search.searchhelper',
		]);

})();

(function(){
  'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaTable
   * @restrict E
   * @description O componente **GumgaTable** serve para expor dados em forma de tabela.
   * O componente expõe no $scope.selectedEntities um array contendo os objetos das linhas selecionadas para que o desenvolvedor possa usa-los em ações.
   *
   * @example
   * Um exemplo da directive gumgaTable funcionando pode ser encontrado [aqui](http://embed.plnkr.co/SALkp5bKRZ1aywsrpmEX).
   *  <pre>
   *    <gumga-table values="list" columns="name,age"></gumga-table>
   *    <script>
   *    $scope.list = [{name: 'Guilherme', age: 28},{name: 'Igor', age: 19}];
   *    </script>
   *  </pre>
   *
   * @param {String} values Atributo obrigatório. Deve ser o nome do array exposto no $scope para popular a tabela.
   * @param {String} columns Atributo obrigatório. As propriedades do objeto que serão apresentados como colunas na tabela,
   * @param {String} size Possuem 3 opções de tamanhos, **large**, **medium** e **small**, que respectivamente ocupam, todo o espaço da row, dois terços e
   * um terço. O valor padrão é large.
   * @param {String} translate-entity Nome da entidade.
   * @param {Array} pages Deve conter os valores para apresentar opções de registros por página.
   * @param {String} table-class Possuem 3 opções, **bordered**, **striped** e **condensed**, que respectivamente, adiciona bordas a tabela,
   * alterna cores das linhas e diminui o espaçamento interno das linhas e colunas. O valor padrão é bordered.
   * o componente seguirá a ordem de colunas adicionada ao atributo.
   * @param {Boolean} multi-selection É true por padrão, determina a possibilidade da seleção de várias entidades ou apenas
   * uma por vez.
   * @param {Function} sort-function Nome da função atribuida ao $scope para manipular a ordenação, a função recebe dois
   * parâmetros, **field** e **way** que serão, a coluna e a direção da ordenação respectivamente, existem duas direções,
   * **asc** ou **desc**.
   * @param {String} sort-default Deve conter a **coluna** e a **direção** separados por virgula, será a ordenação padrão na primeira exibição da tabela.
   * @param {Expression} row-class Deve conter uma expressão condicional para marcar determinadas linhas correspondentes como
   * verdadeiras perante a expressão.
   * @param {Function} onSelect Nome da função que será executada ao evento click.
   * @param {Function} onSort Nome da função que será executada ao evento de sort.
   */
   Table.$inject = ["GumgaUtils", "$compile", "$rootScope", "$state", "GumgaKeyboard", "$timeout"];
   function Table(GumgaUtils, $compile,$rootScope,$state,GumgaKeyboard,$timeout) {
    return {
      restrict: 'E',
      scope: {
        multi: '=?multiSelection',
        list: '=values',
        pages: '=pages',
        sort: '&?sortFunction',
        rowClass: '=?',
        onSelect: '&?',
        onSort: '&?'
      },
      link: LinkFn,
      transclude: true
    };

    function LinkFn(scope, elm, attrs, ctrl, transcludeFn) {
      var eventHandler = {
        select: (attrs.onSelect ? scope.onSelect : angular.noop),
        sort: (attrs.onSort ? scope.onSort: angular.noop)
      };

      scope.$on('_clean',function(){
       scope.cleanSearch();
     });

      var ColumnObject = {};
      scope.indexes = [];
      scope.trs = [];
      scope.$parent.selectedEntities = [];
      scope.objectColumn = [];
      scope.conditionalColumns = [];
      var rawTableConfig = {
        multi: scope.multi,
        list: [],
        pages: scope.pages || [10, 25, 50],
        sortFn: attrs.sort? scope.sort : angular.noop,
        sortDf: !!attrs.sortDefault? attrs.sortDefault.split(',') : false,
        size: attrs.size || 'large',
        class: attrs.tableClass || 'bordered',
        columns: attrs.columns.split(','),
        headings: [],
        translate: attrs.translateEntity,
      };
      var itemsPerPage = window.sessionStorage.getItem('itemsPerPage') || rawTableConfig.pages[0];
      scope.itemsPerPage = itemsPerPage;
      scope.$parent.itemsPerPage = itemsPerPage;

      scope.$watch('list', function () {
        if (scope.list) {
          scope.$parent.selectedEntities = [];
          scope.tableconfig.list = scope.list;
          scope.indexes = [];

        }
      });

      setColumnConfig(rawTableConfig);

      function setColumnConfig(rawConfig) {
        rawConfig.columns.forEach(function (elm) {
          var obj = {
            label: GumgaUtils.camelCase(elm),
            field: elm
          };
          rawConfig.headings.push({label: obj.label, way: null});
          rawConfig.columns.splice(rawConfig.columns.indexOf(elm), 1, obj);
        });

        transcludeFn(function (clone) {
          angular.forEach(clone, function (cloneEl) {
            if (cloneEl.nodeName != "#text") {
              switch (cloneEl.nodeName) {
                case 'GUMGA-BOOLEAN-MASK':
                rawConfig.columns.forEach(function (obj) {
                  if (obj.field == cloneEl.getAttribute('column')) {
                    $.extend(obj, {
                      trueValue: cloneEl.getAttribute('boolean-true'),
                      falseValue: cloneEl.getAttribute('boolean-false')
                    });
                  }
                });
                break;
                case 'BUTTONS-COLUMN':
                scope.buttonElements = cloneEl.children;
                rawConfig.headings.push({label: ' ', way: null});
                break;
                case 'EXTRA-COLUMN':
                scope.extraElements = cloneEl.children;
                rawConfig.headings.push({label: ' ', way: null});
                break;
                case 'OBJECT-COLUMN':
                scope.objectColumn.push({column: cloneEl.getAttribute('column'),value: cloneEl.getAttribute('property')});
                break;
                case 'COLUMN-CLASS':
                scope.conditionalColumns.push({column: cloneEl.getAttribute('column'),conditional: cloneEl.getAttribute('conditional-class')});
                break;

              }
            }
          });
});
scope.tableconfig = rawConfig;
generateTable(scope.tableconfig);
}
function getConditions(){
  var conditionText = attrs.rowClass || '';
  return conditionText.replace(/{/,'').replace(/}/,'').split(',');
}
function generateTable(config) {
  var template = [];
  if (scope.pages) {
    var pagination =
    '<select ng-model="itemsPerPage" ng-change="changeItemsPerPage(itemsPerPage)">' +
    '<option ng-repeat="p in pages" value="{{ p }}" ng-selected="p == itemsPerPage">{{ p }}</option>' +
    '</select>';
    template.push(pagination);
  }
  switch (config.size) {
    case 'large':
    template.push(
      '<div class="full-width-without-padding" style="margin-top: 1%">' +
      '<button class="btn btn-default btn-xs" style="margin-bottom: 0.25%" ng-click="selectAll()">Selecionar todos</button>' +
      '<button class="btn btn-default btn-xs" style="margin-bottom: 0.25%;margin-left:0.25%" ng-click="cleanSearch()"> Limpar pesquisa</button>' +
      '<table class="table table-' + config.class + ' ">');
    break;
    case 'medium':
    template.push(
      '<div class="col-md-8" style="padding-left:0;padding-right: 0;">' +
      '<table class="table table-' + config.class + '">');
    break;
    case 'small':
    template.push(
      '<div class="col-md-4" style="padding-left:0;padding-right: 0;">' +
      '<table class="table table-' + config.class + '">');
    break;
  }
  template.push('<thead>');
  template.push('<tr>');
  if (attrs.sortFunction) {
    template.push(' <td ng-repeat="head in tableconfig.headings track by $index" ng-click="head.label !== \' \' ? sortAux(head) : \'\'"');
    template.push('     ng-class="head.label != \' \' ? \'clickable-td\' : \' \' ">');
    template.push('         <small>{{::head.label}}<i ng-class="(head.way != null && head.label !== \' \') ? (head.way === true ? \'glyphicon glyphicon-menu-up\' : \'glyphicon glyphicon-menu-down\') : \'\'"></i></small></td>');
  } else {
    template.push('<td ng-repeat="head in tableconfig.headings track by $index">{{::head.label}}');
  }
  template.push(' </td>');
  template.push('</tr>');
  template.push('</thead>');
  template.push('<tbody>');
  if (config.multi === false) {
    template.push('<tr style="{{::getClassFromConditionalRow(entity)}}" ng-class="returnClass($index)" ng-repeat="entity in tableconfig.list" class="used" ng-click="handleSingle(entity,$index)" ng-dblclick="goToEdit(entity.id)">' + generateTableCell(config) + '</tr>');
  } else {
    template.push('<tr style="{{::getClassFromConditionalRow(entity)}}" ng-class="returnClass($index)" ng-repeat="entity in tableconfig.list" class="used" ng-click="handleMultiple(entity,$index)" ng-dblclick="goToEdit(entity.id)" >' + generateTableCell(config) + '</tr>');
  }
  template.push('</tbody>');
  template.push('</table></div>');
  elm.append($compile(template.join('\n'))(scope));

}
var selected = false;

scope.goToEdit = function(index){
  $state.go(scope.tableconfig.translate + '.' + 'edit',{id: index});
};
scope.changeItemsPerPage = function(itemsPerPage){
  window.sessionStorage.setItem('itemsPerPage', itemsPerPage);
  scope.$parent.itemsPerPage = itemsPerPage;
};
scope.selectAll = function(){
  if(!selected){
    for(var i = 0, len = scope.tableconfig.list.length;i < len;i++){
      scope.indexes.push(i);
    }
    scope.$parent.selectedEntities = scope.tableconfig.list;
  } else {
    scope.indexes = [];
    scope.$parent.selectedEntities = [];
  }
  selected = !selected;
};


scope.cleanSearch = function(){
  $rootScope.$broadcast('normal',{field:scope.tableconfig.columns[1],param: ''});
  scope.tableconfig.headings.forEach(function(elm){
    elm.way = null;
  })
};

scope.getClassFromConditionalRow = function (entity){
  var HelperObject = {};
  var conditionsFromTag = getConditions();
  conditionsFromTag.forEach(function(elm){
    HelperObject[elm.split(':')[0]] = eval(elm.split(':')[1]);
  });
  for(var key in HelperObject) if(HelperObject.hasOwnProperty(key) && HelperObject[key] === true){
    return 'border-left: 3px solid ' + key.trim();
  }
  return '';
};

function checkObject(field){
  for(var i = 0; i < scope.objectColumn.length;i++){
    if(scope.objectColumn[i].column === field){
      return '{{::entity.'+  scope.objectColumn[i].value +'}}';
    }
  }
  return -1;
}

function getClassFromConditionalCell(column,entity){
  scope.conditionalColumns.forEach(function(elm){
    if(elm.column.toLowerCase().trim() === column.toLowerCase().trim()){
      ColumnObject[elm.column] = {};
      elm.conditional.replace(/{/,'').replace(/}/,'').split(',')
      .forEach(function(arg){
        var x = arg.split(':');
        ColumnObject[elm.column][x[0].trim().replace(/"/g,'')] = x[1].trim();
      })
    }
  });
}


scope.getStyleFromCell = function(entity,column){
  if(ColumnObject[column.trim().toLowerCase()]){
    var auxObj = ColumnObject[column.trim().toLowerCase()];
    for(var key in auxObj) if(auxObj.hasOwnProperty(key) && eval(auxObj[key]) === true){
      return 'border-left: 3px solid ' + key.trim();
    }
  }
};

function generateTableCell(config) {
  var template = [];
  config.columns.forEach(function (elm) {
    getClassFromConditionalCell(elm.field);
    if (elm.trueValue) {
      template.push('<td style="{{::getStyleFromCell(entity,\' '+ elm.field + ' \')}}">{{::entity.' + elm.field + ' === true? \'' + elm.trueValue + '\' : \'' + elm.falseValue + '\'}}</td>');
    } else if(checkObject(elm.field) != -1){
      template.push('<td style="{{::getStyleFromCell(entity,\' '+ elm.field + ' \')}}">' + checkObject(elm.field) +' </td>');
    } else {
      template.push('<td style="{{::getStyleFromCell(entity,\' '+ elm.field + ' \')}}">{{::entity.'+ elm.field + '}} </td>');
    }
  });
  if (scope.buttonElements) {
    template.push('<td style="{{::getStyleFromCell(entity,\' '+ elm.field + ' \')}}">' + getSpecial(scope.buttonElements) + '</td>');
  }
  if (scope.extraElements) {
    template.push('<td style="{{::getStyleFromCell(entity,\' '+ elm.field + ' \')}}">' + getSpecial(scope.extraElements) + '</td>');
  }
  return template.join(' ');
}


function getSpecial(array) {
  var txt = [];
  angular.forEach(array, function (elm) {
    txt.push(elm.outerHTML);
  });
  return txt.join(' ');
}

            // Negação dupla transforma em boolean
            if (!!rawTableConfig.sortDf) {
              // Se houver o atributo sort-default monta o objeto e dispara o evento
              var objSortDefault = {
                field: rawTableConfig.sortDf[0],
                way: rawTableConfig.sortDf[1]
              };
              eventHandler.sort({field: objSortDefault.field});
              scope.sort(objSortDefault);
            }

            scope.sortAux = function (obj) {
                //Quando ele clica, ele verifica se já existe alguma coluna com sort, se já existir, retorna ela para null
                scope.tableconfig.headings.forEach(function (key) {
                  if (key != obj) {
                    if (key.way === true || key.way === false) {
                      key.way = null;
                    }
                  }
                });
                // Pega o index do objeto
                var index = scope.tableconfig.headings.indexOf(obj);
                //Seta o sort dele pra false ou true
                obj.way = !obj.way;
                //Remove da lista anterior o antigo e coloca o novo
                scope.tableconfig.headings.splice(index, 1, obj);
                var aux;
                // Se for true, é ascendente
                if (obj.way === true) {
                  aux = 'asc';
                } else {
                  aux = 'desc';
                }
                // Dispara o evento
                eventHandler.sort({field: obj.label.toLowerCase()});
                scope.sort({field: obj.label.toLowerCase(), way: aux});
              };

              scope.handleMultiple = function (entity, index) {
                if (GumgaUtils.areNotEqualInArray(scope.indexes, index) || scope.indexes.length < 1) {
                  scope.indexes.push(index);
                  scope.$parent.selectedEntities.push(entity);
                } else {
                  scope.indexes.splice(scope.indexes.indexOf(index), 1);
                  scope.$parent.selectedEntities.splice(scope.$parent.selectedEntities.indexOf(entity), 1);
                }
                eventHandler.select({selected: scope.$parent.selectedEntities});
              };

              scope.handleSingle = function (entity, index) {
                if (scope.indexes.length >= 1) {
                  scope.indexes = [];
                  scope.$parent.selectedEntities = [];
                }
                scope.selectedIndex = index;
                scope.indexes.push(index);
                scope.$parent.selectedEntities.push(entity);
                eventHandler.select({selected: scope.$parent.selectedEntities});
              };

              scope.returnClass = function (index) {
                if (!GumgaUtils.areNotEqualInArray(scope.indexes, index)) {
                  return 'info';
                }
                return '';
              };
            }
          }

          angular.module('gumga.directives.table',[])
          .directive('gumgaTable',Table);
        })();


(function(){
	'use strict';
	TranslateTag.$inject = ["GumgaTranslateHelper", "$compile"];
	function TranslateTag(GumgaTranslateHelper,$compile){
		var child;
		return {
			restrict: 'A',
			link: function(scope,elm,attrs){
				if(!attrs.gumgaTranslateTag) throw 'You must pass a valid value to gumgaTranslateTag';
				scope.__valueToTranslate = attrs.gumgaTranslateTag;
				if(GumgaTranslateHelper.getTranslate(scope.__valueToTranslate)){
					if(elm[0].childNodes.length > 0){
						scope.child = elm[0].childNodes[0];
						elm[0].innerHTML =  GumgaTranslateHelper.getTranslate(scope.__valueToTranslate);
						elm.append($compile(scope.child)(scope));
					} else {
						elm[0].innerHTML = GumgaTranslateHelper.getTranslate(scope.__valueToTranslate);
					}
				}
			}

		};
	}

	angular.module('gumga.directives.translatetag',['gumga.services.translate.helper','gumga.services.translate'])
		.directive('gumgaTranslateTag',TranslateTag);
})();
(function(){
	'use strict';
	angular.module('gumga.directives.translate',
		[
			'gumga.directives.translate.translatehelper',
			'gumga.directives.translate.translate',
			'gumga.directives.translate.translatetag'
		])
})();

(function(){
	'use strict';
	Upload.$inject = ["$http", "$parse", "$timeout"];
	/**
	 * @ngdoc directive
	 * @name gumga.core:gumgaUpload
	 * @restrict
	 * @description
	 * 	O componente gumgaUpload pode ser utilizado para fazer upload de imagens. O framework GUMGA usa um método de upload
	 * 	de imagens que faz o upload do arquivo para uma pasta temporária e retorna um token. Quando o registro é salvo, o framework gumga
	 * 	faz o bind da string que está no atributo com o arquivo temporário.
	 * 	@param {Objet} model Objeto que irá conter as informações da imagem.
	 * 	@param {Function} upload-method Função que será executada para fazer o upload da imagem para o arquivo temporário.
	 * 	@param {Function} delete-method Função que será executada para deletar a imagem do espaço temporário.
	 * 	@param {String} tooltip-text Mensagem que irá aparecer no tooltip da imagem.
	 */
	function Upload($http,$parse,$timeout){

		var img =
		'<div ng-click="fireClick()" ng-show="flag" class="col-md-1" tooltip="{{::tooltipText}}" tooltip-placement="right">'+
		'	<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="128px" height="128px" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve">'+
		'		<path id="avatar" fill="#cccccc" d="M490.579,383.029c-14.152-22.086-61.763-35.824-108.835-55.453c-47.103-19.633-58.268-26.439-58.268-26.439'+
		'			l-0.445-45.182c0,0,17.646-13.557,23.127-56.074c11.01,3.198,22.619-16.461,23.237-26.824c0.625-9.98-1.508-37.662-14.981-34.877' +
		'			c2.754-20.845,4.741-39.586,3.764-49.505c-3.495-36.295-39.23-74.578-94.182-74.578c-54.95,0-90.7,38.283-94.193,74.578' +
		'			c-0.978,9.919,1.019,28.661,3.758,49.505c-13.455-2.785-15.587,24.897-14.979,34.877c0.635,10.363,12.196,30.021,23.255,26.824' +
		'			c5.462,42.517,23.122,56.074,23.122,56.074l-0.441,45.182c0,0-11.178,6.807-58.268,26.439' +
		'			c-47.104,19.629-94.683,33.367-108.851,55.453c-12.7,19.777-8.882,114.875-8.882,114.875h470.946' +
		'			C499.462,497.904,503.281,402.806,490.579,383.029z"/>' +
		'	</svg>' +
		'</div>';

		var template =
		'<div class="full-width-without-padding">' +
		img +
		'   <img src="#" alt="Uploaded Image" ng-show="!flag" class="img-rounded" style="object-fit: cover"/>' +
		'   <input type="file" name="upload" id="upload" ng-hide="true"/>' +
		'   <div class="col-md-12" style="padding-left: 0">' +
		'   <button type="button" class="btn btn-link" ng-hide="flag" ng-click="deleteImage()"> Delete Image <span class="glyphicon glyphicon-trash"></span></button>' +
		'</div>' +
		'</div>';
		return {
			restrict: 'AE',
			scope: {
				model: '=attribute',
				uploadMethod: '&',
				deleteMethod: '&',
				tooltipText: '@'
			},
			template: template,
			link:function(scope,elm,attrs){
				var model = $parse(attrs.attribute),
				modelSetter = model.assign,
				element = elm.find('input'),
				image = elm.find('img')[0],
				reader = new FileReader();


				scope.fireClick = function(){
					$timeout(function(){
						document.getElementById('upload')
							.click();
					});
				}

				scope.$watch('model',function(){
					if(scope.model){
						if(scope.model.bytes){
							scope.flag = false;
							image.src = 'data:' + scope.model.mimeType + ';base64,' + scope.model.bytes;
							image.width = 200;
							image.height = 200;
						}
					} else {
						scope.model = {};
					}
				});

				if(!attrs.attribute){
					throw 'You must pass an attribute to GumgaUpload';
				}

				scope.flag = true;

				function scaleSize(maxW, maxH, currW, currH){
					var ratio = currH / currW;
					if(currW >= maxW && ratio <= 1){
						currW = maxW;
						currH = currW * ratio;
					} else if(currH >= maxH){
						currH = maxH;
						currW = currH / ratio;
					}
					return [currW, currH];
				}

				scope.deleteImage = function(){
					image.src = '';
					scope.flag = true;
					element[0].files = [];
					scope.deleteMethod();
				};

				element.bind('change',function(){
					scope.$apply(function(){
						var x;
						modelSetter(scope,element[0].files[0]);
						scope.flag = false;
						reader.onloadend = function(){
							image.src = reader.result;
							image.width = 200;
							image.height =200;
							var x = attrs.attribute.split('.');
							scope.uploadMethod({image: scope[x[0]][x[1]]})
							.then(function(val){
								scope.model.name = val.data;
							});
						};
						reader.readAsDataURL(element[0].files[0]);
					});
				});
			}
		};
	}

	angular.module('gumga.directives.upload',[])
		.directive('gumgaUpload',Upload);

})();

(function(){
	'use strict';
	AddressService.$inject = [];
	function AddressService(){
		return {
			everyUf: ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR',
			'RJ', 'RN', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO'],
			everyLogradouro: [	'Outros', 'Aeroporto', 'Alameda', 'Área', 'Avenida', 'Campo', 'Chácara', 'Colônia', 'Condomínio', 'Conjunto', 'Distrito',
			'Esplanada', 'Estação', 'Estrada', 'Favela', 'Fazenda', 'Feira', 'Jardim', 'Ladeira', 'Largo', 'Lago', 'Lagoa', 'Loteamento',
			'Núcleo', 'Parque', 'Passarela', 'Pátio', 'Praça', 'Quadra', 'Recanto', 'Residencial', 'Rodovia', 'Rua', 'Setor', 'Sítio',
			'Travessa', 'Trevo', 'Trecho', 'Vale', 'Vereda', 'Via', 'Viaduto', 'Viela', 'Via'],
			availableCountries: ['Brasil'],
			returnFormattedObject: function(){
				return {
					zipCode : null,
					premisseType: null,
					premisse: null,
					number: null,
					information: null,
					neighbourhood: null,
					localization: null,
					state: null,
					country: null
				}
			}
		}
	}

		angular.module('gumga.services.address',[])
		.factory('GumgaAddressService',AddressService);

	})();

(function(){
	'use strict';

	Alert.$inject = []
	/**
	 * @ngdoc service
	 * @name gumga.core:GumgaAlert
	 * @description O service GumgaAlert é uma nova versão da directive {@link gumga.core:gumgaAlert} e é utilizado para criar
	 * notificações growl-like. Para utilizar o service, basta incluir GumgaAlert como dependência.
	 * 
	 * *Observação: Para utilização do service no config do módulo, utilizar `GumgaAlertProvider`*
	 *
	 *
	 * ## Métodos
	 *
	 * O service GumgaAlert possui quatro métodos de criação de alerta, porém todos recebem o mesmo parâmetro. Foi optado por criar quatro
	 * métodos diferentes para aumentar a legibilidade.
	 * - createWarningMessage(title,message,options)
	 * - createDangerMessage(title,message,options)
	 * - createSuccessMessage(title,message,options)
	 * - createInfomessage(title,message,options)
	 *
	 *  ### Parâmetros
	 *  - `title`: Uma string que irá conter o título da mensagem que será criada.
	 *  - `message`: Uma string que irá conter o corpo da mensagem que será criada.
	 *  - `options`: Um objeto com opções adicionais para o alerta. Os atributos que podem ser passados para este objeto são:
	 *  	<pre>
	 *   		var config = {
	 *   		 offset: 50, //Tamanho da distância entre o alerta e tela.
	 *   		 timer: 100, //Tempo que irá demorar para a mensagem aparecer após
	 *   		 delay: 3500,
	 *   		 alowDismiss:true,
	 *   		 animationEnter: 'animated bounceInRight',
	 *   		 animationExit: 'animated bounceOutRight'
	 *   		}
	 * 		</pre> *Objeto com os valores padrões do alerta*
	 * 		
	 */
	function Alert(){
		return {
			$get: function(){
				return this;
			},
			__config: {
				warn: {
					icon: 'glyphicon glyphicon-warning-sign',
					type: 'warning'
				},
				danger: {
					icon: 'glyphicon glyphicon-exclamation-sign',
					type: 'danger' 
				},
				success: {
					icon:'glyphicon glyphicon-ok',
					type: 'success'
				},
				info: {
					icon: 'glyphicon glyphicon-info-sign',
					type: 'info'
				}
			},
			_notify: function(type,title,message,options){
				var config = this.__config[type]
				,		offset = options.offset || 50
				,		timer = options.timer || 100
				,		delay = options.delay || 3500
				,		alowDismiss = options.alowDismiss || true
				,		animationEnter = options.animationEnter || 'animated bounceInRight'
				,		animationExit = options.animationExit || 'animated bounceOutRight';
				$.notify({
					icon: config.icon,
					title: title,
					message: message
				},{
					type: type,
					offset: offset,
					timer: timer,
					delay: delay,
					alow_dismiss: alowDismiss,
					animate: {
							enter: animationEnter,
							exit: animationExit
						},
					template: '<div data-notify="container" class="col-xs-9 col-sm-3 alert alert-{0}" role="alert">' +
						'<button type="button" aria-hidden="true" class="close" data-notify="dismiss">×</button>' +
						'<span data-notify="icon"></span> ' +
						'<span data-notify="title"><b>{1}</b></span><br> ' +
						'<span data-notify="message">{2}</span>' +
						'</div>'
				})
			},
			createWarningMessage: function(title,message,options){
				if(!options) options = {};
				this._notify('warning',title,message,options);
			},
			createDangerMessage: function(title,message,options){
				if(!options) options = {};
				this._notify('danger',title,message,options);
			},
			createSuccessMessage: function(title,message,options){
				if(!options) options = {};
				this._notify('success',title,message,options);
			},
			createInfoMessage: function(title,message,options){
				if(!options) options = {};
				this._notify('info',title,message,options);
			}
		}
	}

	angular.module('gumga.services.alert',[])
		.provider('GumgaAlert',Alert);
})();
(function(){
	'use strict';

	Base.$inject = ["$http", "$q"];
	/**
	 * @ngdoc service
	 * @name gumga.core:GumgaBase
	 * @description
	 * 	O service GumgaBase pode ser utilizado como helper para fazer chamadas HTTP. Ele permite que o programador não precise incluir o service $http
	 * 	do AngularJS e já vem com algumas funções incluídas. Para utilizar o GumgaBase, basta íncluí-lo como dependência.
	 *
	 *
	 *  # Métodos
	 *  `GumgaBase.get(url,params)`
	 *
	 *  O método get aceita dois parâmetros `url` e `params` e retorna uma promise de uma chamada HTTP do tipo GET.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">url</label>  Endereço no qual a chamada http será feita.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label> <label class="label label-info">params</label> Parâmetros da query que será feita.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retona uma promise da chamada HTTP GET.
	 *  ---
 	 *  `GumgaBase.getById(url,id)`
	 *
	 *  O método getById aceita dois parâmetros `url` e `id` e retorna uma promise de uma chamada HTTP do tipo GET.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">url</label>  Endereço no qual a chamada http será feita.
	 *  - <label class="label label-warning" style="margin-right: 1%">[String|Number]</label> <label class="label label-info">id</label> Identificador do registro que será buscado.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retona uma promise da chamada HTTP GET.
	 *  ---
	 *  `GumgaBase.getNew(url)`
	 *
	 *  O método getById aceita um parâmetro `url` e retorna uma promise de uma chamada HTTP do tipo GET.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">url</label>  Endereço no qual a chamada http será feita e na qual
	 *   será feita a chamada para um novo registro.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP GET.
	 *  ---
 	 *  `GumgaBase.deleteAll(url,array)`
	 *
	 *  O método deleteAll aceita dois parâmetros `url` e `array` e retorna uma promise de uma série de chamadas http do tipo DELETE que serão resolvidas ao mesmo tempo.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">url</label>  Endereço no qual a chamada http será feita.
	 *  - <label class="label label-warning" style="margin-right: 1%">Array</label><label class="label label-info">array</label> Array com todas os registros que serão deletados
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise após todas as chamadas terem sido resolvidas.
	 *  ---
	 *  `GumgaBase.save(url,data)`
	 *
	 *  O método save aceita dois parâmetros `url` e `data` e retorna uma promise de de uma chamada HTTP POST.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">url</label>  Endereço no qual a chamada http será feita.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label><label class="label label-info">data</label> Objeto que deseja ser salvo.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP POST.
	 *  ---
 	 *  `GumgaBase.update(url,data)`
	 *
	 *  O método deleteAll aceita dois parâmetros `url` e `data` e retorna uma promise de de uma chamada HTTP PUT.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">url</label>  Endereço no qual a chamada http será feita.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label><label class="label label-info">data</label> Objeto que deseja ser atualizado.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP POST.
	 *  ---
 	 *  `GumgaBase.del(url,data)`
	 *
	 *  O método del aceita dois parâmetros `url` e `data` e retorna uma promise de de uma chamada HTTP DELETE. Esta função é chamada para cada registro passado dentro do Array
	 *  na função deleteAll.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">url</label>  Endereço no qual a chamada http será feita.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label><label class="label label-info">data</label> Objeto que deseja ser deletado.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP DELETE.
	 *  ---
	 *  `GumgaBase.postImage(url,attribute,data)`
	 *
	 *  O método postImage aceita três parâmetros `url`,`attribute` e `data` e retorna uma promise de de uma chamada HTTP POST FORM-DATA.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">url</label>  Endereço no qual a chamada http será feita.
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">attribute</label> Atributo no qual a imagem será feito o
	 *  bind após o form ter sido enviado completo.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label><label class="label label-info">data</label> Dados da imagem que foi selecionada..
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP POST. Nesta promise, será retornado o valor de uma String que deverá ser atribuída ao atributo
	 *  onde estava a imagem. Esta string é um identificador para quando o registro for enviado através de um post.
	 *  ---
 	 *  `GumgaBase.deleteImage(url,attribute,data)`
	 *
	 *  O método del aceita três parâmetros `url`, `attribute` e `data` e retorna uma promise de uma chamada HTTP DELETE FORM-DATA.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">url</label> Endereço no qual a chamada http será feita.
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">attribute</label> Atributo no qual a imagem será feito o
	 *  bind após o form ter sido enviado completo.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label><label class="label label-info">data</label> Dados da imagem que foi selecionada.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP DELETE.
	 *  ---
	 */
	function Base($http,$q){
		var defaultParams = {};
		this.get = get;
		this.getById = getById;
		this.getNew = getNew;
		this.deleteAll = deleteAll;
		this.save = save;
		this.update = update;
		this.del = del;
		this.postImage = postImage;
		this.deleteImage = deleteImage;

		function get(url,params) {
			if (!params) {
				params = defaultParams;
			}
			return $http.get(url, params);
		}

		function getById(url,id) {
			return $http.get(url + '/' + id);
		}

		function getNew(url){
			return $http.get(url+'/new');
		}

		function deleteAll(url,entities) {
			var promises = entities.map(function(entity){
				return del(url,entity);
			});
			return $q.all(promises);
		}

		function save(url,entity) {
			return $http.post(url, entity);
		}

		function update(url,entity) {
			return $http.put(url + '/' + entity.id, entity);
		}

		function del(url,entity) {
			return $http.delete(url + '/' + entity.id);
		}

		function postImage(url, attribute, model) {
			var fd = new FormData();
			fd.append(attribute, model);
			return $http.post(url + '/' + attribute + '/', fd, {
				transformRequest: angular.identity,
				headers: {'Content-Type': undefined}
			});
		}

		function deleteImage(url, attribute, value) {
			return $http.delete(url + '/' + attribute + '/' + value, {
				transformRequest: angular.identity,
				headers: {'Content-Type': undefined}
			});

		}
	}
	angular.module('gumga.services.base',[])
	.service('GumgaBase',Base);
})();


(function(){
	'use strict';
	DateService.$inject = [];
	function DateService(){
		return {
			formats: {
				DMY: /^(\d{1,2})\-(\d{1,2})\-(\d{4})$/,
				YMD: /^(\d{4})\-(\d{1,2})\-(\d{1,2})$/
			},
			validateFormat: function(format, date) {
				if (!this.formats.hasOwnProperty(format)) {
					throw 'Formato não suportado';
				}
				var regex = new RegExp(this.formats[format]);
				if (!regex.test(date)) {
					throw 'A data ' + date + ' não confere com o formato ' + format + '.';
				}
				return regex.test(date);
			}
		}
	}
	angular.module('gumga.services.date',[])
	.factory('GumgaDateService',DateService);
})();

(function(){
	'use strict';

	Keyboard.$inject = [];
	/**
	 * @ngdoc service
	 * @name gumga.core:GumgaKeyboard
	 * @description 
	 * 	A directive GumgaKeyboard é um Wrapper de uma biblioteca chamada [Mousetrap](https://craig.is/killing/mice) 
	 * 	que é utilizada para adicionar funcionalidades quando determinadas teclas são pressionadas.
	 *
	 * 	# Métodos
	 *
	 *  `GumgaKeyboard.addBind(key,function,event)`
	 *  
	 * 	O método `addBind` adiciona uma função a combinação de teclas passada como parâmetro. Ele recebe três parâmetros, `key` e `function` e `event`.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">key</label> Quais teclas serão clicadas para que a função seja executada.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label> <label class="label label-info">function</label> Função que será executada quando sequência de teclas especificadas for digitada pelo usuário.
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">event</label> Em qual evento de teclado será disparado, como por exemplo `keypress` ou`keydown`
	 *  ### Retorno
	 *  - <label class="label label-warning">Boolean</label> Retona um boolean. Se o bind foi feito, retorna true, caso ao contrário retorna false.
	 *  ---
 	 *  `GumgaKeyboard.removeBind(key)`
	 *  
	 * 	O método `removeBind` remove as funções que estão atribuídas a `key` que foi passada . Ele recebe um parâmetro `key`.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">key</label> Quais teclas que o desenvolvedor deseja remover o bind.
	 *  
	 *  ---
	 *  
 	 *  `GumgaKeyboard.triggerBoundedEvent(key)`
	 *  
	 * 	O método `triggerBoundedEvent` dispara o evento atribuído a `key` que foi passada.
	 * 	
	 *  ###Parâmetros
	 *  
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">key</label> Quais teclas que o desenvolvedor deseja remover o bind.
	 *  
	 *  ---
	 *
	 * 	`GumgaKeyboard.bindToElement(element,key,function,event)`
 	 *  
	 * 	O método `bindToElement` adiciona uma função a combinação de teclas passada como parâmetro em um elemento específico. Ele recebe quatro parâmetros,`element`, `key` e `function` e `event`.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">Element</label><label class="label label-info">element</label> Elemento no qual a sequência de teclas deve ser executada para disparar o evento.
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">key</label> Quais teclas serão clicadas para que a função seja executada.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label> <label class="label label-info">function</label> Função que será executada quando sequência de teclas especificadas for digitada pelo usuário.
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">event</label> Em qual evento de teclado será disparado, como por exemplo `keypress` ou`keydown`
	 *  ### Retorno
	 *  - <label class="label label-warning">Boolean</label> Retona um boolean. Se o bind foi feito, retorna true, caso ao contrário retorna false.
	 *  ---
	 *
 	 * 	`GumgaKeyboard.unbindFromElement(element,key)`
 	 *  
	 * 	O método `unbindFromElement` remove as teclas do elemento passado como parâmetro. Ele recebe dois parâmetros,`element` e `key`.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">Element</label><label class="label label-info">element</label> Elemento no qual a sequência de teclas vai ser retirada.
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">key</label> Quais teclas serão removidas do element.
	 *  ---
	 *  
	 * 	`GumgaKeyboard.bindToMultipleElement(array,key,function,event)`
 	 *  
	 * 	O método `bindToElement` adiciona uma função a combinação de teclas passada como parâmetro em um elemento específico. Ele recebe quatro parâmetros,`element`, `key` e `function` e `event`.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">Array</label><label class="label label-info">array</label> Lista dos elementos que serão adicionados a sequência de teclas.
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">key</label> Quais teclas serão clicadas para que a função seja executada.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label> <label class="label label-info">function</label> Função que será executada quando sequência de teclas especificadas for digitada pelo usuário.
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">event</label> Em qual evento de teclado será disparado, como por exemplo `keypress` ou`keydown`
	 *  ### Retorno
	 *  - <label class="label label-warning">Boolean</label> Retona um boolean. Se o bind foi feito, retorna true, caso ao contrário retorna false.
	 *  ---
	 *
 	 * 	`GumgaKeyboard.getBinds()`
 	 *  
	 * 	O método `getBinds` retorna todos os binds que foram adicionados.
	 *
	 * 
	 *  ### Retorno
	 *  - <label class="label label-warning">Array</label> Retorna uma lista de todos os binds já feitos.
	 *  
	 *  ---
	 */
	function Keyboard(){
		return {
			addBind: function(key,fn,event){
				if(key && fn){
					Mousetrap.bind(key,fn,event? event : '');
					this.__binds.push(key);
					return true;
				}
				return false;
			},removeBind: function(key){
				if(key){
					Mousetrap.unbind(key);
					this.__binds.splice(this.__binds.indexOf(key),1);
				}
			},
			triggerBoundedEvent: function(key){
				if(key){
					Mousetrap.trigger(key);
				}
			},
			bindToElement: function(element,key,fn,event){
				if(element && key && fn){
					Mousetrap(element).bind(key,fn,event ? event: '');
					this.__binds.push(key);
					return true;
				}
				return false;
			},
			unbindFromElement: function(element,key){
				if(element && key) {
					Mousetrap(element).unbind(key);
				}
			},
			bindToMultipleElements: function(arrayOfElements,key,fn,event){
				for(var i = 0, len = arrayOfElements.length; i < len; i++) if(key && fn){
					Mousetrap(arrayOfElements[i]).bind(key,fn,event? event: '');
					this.__binds.push(key);
				}
			},
			getBinds: function(){
				return this.__binds;
			},
			__binds: []
		}
	}
	angular.module('gumga.services.keyboard',[])
		.factory('GumgaKeyboard',Keyboard);
})();
(function(){

  function ListHelper(){
    return {
      'aux': [],
      'returnColumnConfig': function(item,config){
        var itemConfig = config.filter(function(val){ return val.name.toLowerCase().trim() == item.toLowerCase().trim()})[0] || {};
        return {
          title: itemConfig.title || item.toUpperCase(),
          size: itemConfig.size || '',
          name: itemConfig.name || item,
          content: this.contentWithoutParent(itemConfig.content,item),
          sortField: itemConfig.sortField || null,
          conditional: itemConfig.conditional || angular.noop
        }
      },
      'contentWithoutParent':function(content,item){
        if(content && content.indexOf('type="button"') != -1 && content.indexOf('ng-click="') != -1){
          return content.replace(/ng-click="/gi,'ng-click="$parent.$parent.');;
        }
        if(content){
          return content;
        }
        return '{{$value.'+item+'}}';
      },
      'ensureDefaultValues': function(arr,config){
        var self = this;
        return arr.map(function(item,$index){
          return self.returnColumnConfig(item,config);
        })
      },
      'loadDefaultColumns': function(firstObject){
        return Object.keys(firstObject).map(function(key,$index){
          if(key != '__checked'){
            return {
              title: key.toUpperCase(),
              size: '',
              name: 'key',
              content: '{{$value.' + key + '}}',
              sortField: null,
              conditional: angular.noop
            }
          }
        })
      },
      'sortColumns': function(aux,columns){
        return columns.sort(function(value1,value2){
          (aux.indexOf(value1.name) - aux.indexOf(value2.name))
        })
      },
      'addCheckbox': function(){
        return {
          title: '<label><input type="checkbox" ng-model="vm.checkAll" ng-change="vm.selectAll(vm.checkAll)"/><strong ><small>Selecionar Todos</small></strong></label>',
          size: 'col-md-1',
          name:'__checkbox',
          content: '<input name="__checkbox" type="checkbox" ng-model="$value.__checked"/>',
          sortField: null,
          conditional: angular.noop
        };
      },
      'mountTable':function (configuration) {
        function returnFormattableGlyphicon(string){
          return '<i ng-class="vm.selectedItem == \'' + string +'\' ? (vm.selectedItemDir == \'asc\' ? \'glyphicon glyphicon-menu-up\' : \'glyphicon glyphicon-menu-down\' ): \'\'"></i>';
        }
        function returnFormattableTableHeader(bool,string,sf){
          if(bool){
            return '<button type="button" class=" btn btn-link btn-sm" ng-click="vm.sortProxy(\''+ sf +'\',' + '\''.concat(sf).concat('\'') +')">' + string + returnFormattableGlyphicon(sf) + '</button>';
          }
          return string;
        }
        function mountHeader(prev, next){
          return prev+= '\t\t<td class="'+ next.size +'" >' + returnFormattableTableHeader(!!next.sortField,next.title,next.sortField) + '</td>\n';
        }
        function mountAllTableCell(prev,next){
          return prev += '<td ng-style="{borderLeft: {{::vm.conditionalTableCell($value,\''+ next.name +'\')}} }">' + next.content +'</td>';
        }

        configuration.columns.unshift(this.addCheckbox());
        configuration.columns = this.sortColumns(configuration.auxColumnsToSort, configuration.columns);
        var message = '<select ng-options="item for item in vm.config.itemsPerPage" ng-model="vm.$parent.itemsPerPage"></select>';
        message += '<table class="'+ configuration.class +'">\n';
        message += '<thead>';
        message += '\t<tr>\n';
        message = configuration.columns.reduce(mountHeader.bind(this),message);
        message += '\t</tr>\n';
        message += '</thead>';
        message += '<tbody>';
        message += '<tr ng-style="{borderLeft: {{::vm.conditional($value)}} }"  ng-dblclick="vm.double($value)" ng-class="$value.__checked ? \'active\' : \'\'" ng-repeat="$value in vm.data track by $index" ng-click="vm.selectRow($index,$value,$event)" >';
        message += configuration.columns.reduce(mountAllTableCell,'');
        message += '</tr>';
        message += '</tbody>';
        message += '</table>\n';
        return message;
      }
    }
  }

  angular.module('gumga.services.listhelper',[])
  .factory('GumgaListHelper',ListHelper);

})();

(function(){
	'use strict';

	Notification.$inject = ["$http", "$q"];
	/**
	 * @ngdoc service
	 * @name gumga.core:GumgaNotification
	 * @description
	 */
	function Notification($http,$q){
		var token = window.sessionStorage.getItem('token');
		var url = 'http://192.168.25.201:8084/security-api/notifications';
		var eventSource;

		this.getSource = getSource;
		this.newMessages = newMessages;
		this.newMessagesCount = newMessagesCount;
		this.isViewedMessage = isViewedMessage;

		function setUrl(url) {
			url = url;
		}
		function setToken(token) {
			token = token;
		}
		function getSource() {
			if (!token) throw "Informe um token.";
			return new EventSource(url.concat('/source?gumgaToken=' + token));
		}
		function newMessages() {
			getSource().addEventListener('message', function(event) {
				var data = JSON.parse(event.data);
				console.log(data.newMessages);
				return data.newMessages;
			}, false);
		}
		function newMessagesCount() {
			getSource().addEventListener('message', function(event) {
				var data = JSON.parse(event.data);
				console.log(data.newMessagesCount);
				return data.newMessagesCount;
			}, false);
		}
		function isViewedMessage(id) {
			if (!token) throw "Informe um token.";
			return $http.get(url.concat('/viewed/?id=' + id + '&gumgaToken=' + token));
		}
	}
	angular.module('gumga.services.notification',[])
	.service('GumgaNotification',Notification);
})();

(function(){
	'use strict';

	Populate.$inject = [];
	/**
	 * @ngdoc service
	 * @name gumga.core:$populateProvider
	 * @description O service **$populate** é utilizado para adicionar funções básicas de CRUD, que já fazem a conexão com o Service
	 *  (*Melhor utilizado com o service GumgaRest*), possibilitando assim que o $scope fique limpo. É possível também criar uma configuração
	 *  nova para ser utilizada, extender as já criadas e recuperar o objeto de controle da configuração.
	 *
	 * 	As funções criam um objeto com o nome do ID passado para armazenar os dados. Além disso, o identificador é utilizado para nomear as funções. Caso o Identificador
	 * 	passado seja `User` e a função seja `get`, o nome da função será `userGet`, para evitar colisão de nomes.
	 * 	Todas as funções possuem eventos que são disparados antes e depois da execução da função, para ajudar o desenvolvedor a extender as funcionalidades
	 * 	das funções sem precisar sobrescrever-las. Para utilizar estes eventos, basta adicionar um listener no $scope, como por exemplo:
	 *  <pre>
	 *  	$scope.$on('beforeGet',function(){
	 *    alert('Antes do Get!');
	 *  	})
	 *
	 * 		$scope.$on('afterGet',function(values){
	 *		  // values é retorno da função asíncrona.
	 * 		})
	 * 	</pre>
	 *
	 *
	 * # Como utilizar:
	 *
	 * 	Para utilizar o assistente, é necessário injetar como dependência no bloco de configuração do módulo:
	 * 	<pre>
	 *  	angular.module('sample',['gumga.core'])
	 *  	.config(function($populateProvider){
	 *     $stateProvider
   *   	 .state('crud.list', {
   *      url: '/list',
	 *      templateUrl: 'app/modules/crud/views/list.html',
	 *      controller: 'CrudController',
   *      resolve:  {
   *       populateScope: function(){
   *        return $populateProvider.populateScope;
   *       }
   *     }
   *   })
	 *   })
	 *  </pre>
	 *
	 * 	E depois no controller, utilizar ele executando a função populateScope que foi passada através do resolve:
	 * 	<pre>
	 * 		angular.module('sample')
	 * 		.controller('SampleController',
	 * 	   ['$scope','populateScope','UserService',function($scope,populateScope,UserService){
	 * 		   populateScope($scope,UserService,'User','base-list');
	 * 	   }])
	 * 	</pre>
	 *
	 * 	Pode-se optar também por não incluir no módulo de configuração, mas direto no controller:
	 * 	<pre>
	 * 		angular.module('sample')
	 * 		.controller('SampleController',
	 * 	   ['$scope','$populate','UserService',function($scope,$populate,UserService){
	 * 		   $populate.populateScope($scope,UserService,'User','base-list');
	 * 	   }])
	 * 	</pre>
	 *
	 * # Configurações:
	 *
	 * 	- `base-list`: A configuração `base-list` serve para incluir funções gerais que são necessárias em páginas de listagem, que são:
	 * 		- `get`
	 * 		- `resetAndGet`
	 * 		- `getById`
	 * 		- `update`
	 * 		- `saveQuery`
	 * 		- `getQuery`
	 * 		- `delete`
	 *
	 *    - `sort`
	 *    - `search`
	 *    - `advancedSearch`
	 *
	 *
	 * 	- `base-form`: A configuração `base-form` serve para incluir funções gerais que são necessárias em páginas de formulário, que são:
	 * 		- `getNew`
	 * 		- `getById`
	 * 		- `save`
	 * 		- `update`
	 * 		- `saveImage`
	 *
	 *    - `deleteImage`
	 *
	 *
	 * 	- `many-to-many`: A configuração `many-to-many` serve para incluir funções que comumente são utilizadas em relações muitos para muitos, que são:
	 * 		- `search`
	 * 		- `save`
	 * 		- `searchAsync`
	 * 		- `saveAsync`
	 *
	 * 	- `many-to-one`: A configuração `many-to-one` serve para incluir funções que comumente são utilizadas em relações muitos para um, que são:
	 * 		- `search`
	 * 		- `save`
	 * 		- `saveAsync`
	 *
	 *	## Implementações:
	 *		Para ver as implementações das funções acima, clique [aqui]().
	 *
	 *	# Métodos
	 *  `$populate.setConfig(name,value)`
	 *
	 *  O método setConfig aceita dois parâmetros `name` e `value`, o nome da configuração e o objeto que irá fazer a configuração.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">name</label> String que será usada para identificar o objeto que será criado.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label> <label class="label label-info">value</label> Objeto de configuração que será usado.
	 *   Para adicionar a função, coloque o nome da função e o valor dele como `true`
	 *
	 *  ---
	 *
	 *  `$populate.getConfig(name)`
	 *
	 *  O método getConfig aceita um parâmetro `name`, que é o nome da configuração desejada.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">name</label> String que será usada para identificar o objeto que será recuperado.
	 *   Para adicionar a função, coloque o nome da função e o valor dele como `true`
	 *
	 * 	### Retorno
	 *
	 *  - <label class="label label-info">Object</label> Configuração que será recuperada da função.
	 *
	 *
	 *  ---
	 *
	 *  `$populate.setMethod(name,config,function)`
	 *
	 *  O método setMethod aceita três parâmetros: `name`,`config`, `function`. Este método é utilizado para extender as funcionalidades de uma configuração.
	 *
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">name</label> String que será usada para identificar como será o nome da função a ser adicionada.
	 *   Para adicionar a função, coloque o nome da função e o valor dele como `true`
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">config</label> String que será usada para identificar qual objeto de configuração esta função será adicionada.
	 *   Para adicionar a função, coloque o nome da função e o valor dele como `true`
	 *  - <label class="label label-warning" style="margin-right: 1%">Function</label><label class="label label-info">function</label> Função que será adicionada ao $scope. *Ao passar a função, o desenvolvedor
	 *  tem acesso a 4 parâmetros que serão utilizados para definir a função no scope: `Scope`, `Service`,`Id`*.
	 *
	 *  ---
	 *
 	 *
	 *  `$populate.populateScope(scope,service,id,config)`
	 *
	 *  O método populateScope aceita quatro parâmetros: `scope`,`service`, `id` e `config`. Este método é utilizado para popular o $scope do controlador com as funções da configuração.
	 *
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label><label class="label label-info">scope</label> Objeto onde as funções são colocadas, caso sejam num controlador, no *$scope*.
	 *   Para adicionar a função, coloque o nome da função e o valor dele como `true`
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">id</label> Identificador que será utilizado para armazenar os dados no $scope, além de nomear
	 *  as funções.
 	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">config</label> String que será utilizada para definir qual configuração será utilizada.
	 *  ---
	 */

	function Populate(){
		var helpers = {}, configs = {}, methods = {};
		helpers.guaranteeString = function(s){ return (s && angular.isString(s))};
		helpers.guaranteeArray = function(a){ return (a && angular.isArray(a))};
		helpers.guaranteeIsDefined = function(d){ return angular.isDefined(d)};
		helpers.guaranteeBasicList = function(s){ return (s && this.guaranteeString(s) && s == 'basic-list')};
		configs['base-list']= {
			get: true,
			resetAndGet: true,
			getById: true,
			update: true,
			delete: true,
			sort: true,
			search: true,
			advancedSearch: true,
			saveQuery: true,
			getQuery: true,
			resetQuery: true
		};
		configs['base-form'] = {
			getNew: true,
			getById: true,
			save: true,
			update: true,
			saveImage: true,
			deleteImage: true
		};

		configs['many-to-many'] = {
			search: true,
			save: true,
			searchAsync: true,
			saveAsync: true
		}

		configs['many-to-one']={
			save: true,
			searchAsync: true,
			saveAsync: true
		}


		methods.searchAsync = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'AsyncSearch'] = function(field,value){
				return Service.getSearch(field, value)
				.then(function (data) {
					return data.data.values;
				});
			}
		}

		methods.getQuery = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'GetQuery'] = function(page){
				return Service.getQuery(page)
				.then(function(data){
					return data.data.values;
				})
			}
		}

		methods.saveQuery = function(Scope,Service,Id){
				Scope[Id.toLowerCase() + 'SaveQuery'] = function(query,name){
					Scope.$broadcast('beforeSaveQuery',{query: query, name: name});
					Service.saveQuery({query: query, name: name})
					.then(function(data){
						Scope.$broadcast('afterSaveQuery',data);
					})
				}
		}

		methods.saveAsync = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'AsyncSave'] = function(value,param){
				var obj = {};
				obj[param] = value;
				return Service.update(obj);
			}
		}
		methods.get = function(Scope,Service,Id){
			Scope[Id]= {};
			Scope.page = 0;
			Scope[Id.toLowerCase() + 'Get']= function(page) {
				Scope.$broadcast('beforeGet');
				Service.get(page)
				.then(function (values) {
					Scope[Id].content = values;
					Scope.$broadcast('afterGet',values);
				})
			}
			Scope[Id.toLowerCase() + 'Get']();
		};
		methods.resetAndGet = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'ResetAndGet'] = function(){
				Scope.page = 0;
				Scope.$broadcast('beforeResetAndGet');
				Service.resetAndGet()
				.then(function(values){
					Scope[Id].content = values;
					Scope.$broadcast('afterResetAndGet',values);
				})
			}
		};
		methods.getNew = function(Scope,Service,Id){
			Scope[Id] = Scope[Id] || {};
			Scope[Id.toLowerCase() + 'GetNew'] = function(){
				Scope.$broadcast('beforeGetNew');
				Service.getNew()
				.then(function(values){
					Scope.$broadcast('afterGetNew',values);
					Scope[Id]['new' + Id] = values;
				})
			}
		};
		methods.getById = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'GetById'] = function(id){
				Scope.$broadcast('beforeGetById');
				Service.getById(id)
				.then(function(values){
					Scope[Id]['id' + id] = values;
					Scope.$broadcast('afterGetById',values);
				})
			}
		};
		methods.save = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'Save'] = function(value,param){
				Scope.$broadcast('beforeSave',value);
				var obj = {};
				obj[param] = value;
				Service.update(obj)
				.then(function(values){
					Scope.$broadcast('afterSave',values);
				})
			}
		};
		methods.update = function(Scope,Service,Id){
			Scope[Id.toLowerCase()+'Update'] = function(value){
				Scope.$broadcast('beforeUpdate',value);
				Service.update(value)
				.then(function(values){
					Scope.$broadcast('afterUpdate',values);
				})
			}
		};
		methods.delete = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'Delete'] = function(value){
				Scope.$broadcast('beforeDelete');
				Service.deleteCollection(value)
				.then(function(values){
					Scope.$broadcast('afterDelete',values);
					Scope[Id.toLowerCase() + 'Get']();
				})
			}
		};
		methods.sort = function(Scope,Service,Id){
			Scope[Id.toLowerCase()+'Sort'] = function(field,way){
				Scope.$broadcast('beforeSort');
				Service.sort(field,way)
				.then(function(values){
					Scope[Id].content = values;
					Scope.$broadcast('afterSort',values);
				})
			}
		};
		methods.saveImage = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'SaveImage'] = function(attribute,model){
				Scope.$broadcast('beforeSaveImage');
				return Service.saveImage(attribute,model);
			}
		};
		methods.deleteImage = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'DeleteImage'] = function(attribute,model){
				Scope.$broadcast('beforeDeleteImage');
				Service.deleteImage(attribute,model)
				.then(function(values){
					Scope.$broadcast('afterDeleteImage',values);
				})
			}
		};
		methods.search = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'Search'] = function(field,param){
				Scope.$broadcast('beforeSearch');
				Service.getSearch(field,param)
				.then(function(values){
					Scope[Id].content = values;
					Scope.$broadcast('afterSearch',values);
				})
			}
		}
		methods.advancedSearch = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'AdvancedSearch'] = function(param){
				Scope.$broadcast('beforeAdvancedSearch',param)
				Service.getAdvancedSearch(param)
				.then(function(values){
					Scope[Id].content = values;
					Scope.$broadcast('afterAdvancedSearch',values)
				})
			}
		}
		methods.resetQuery = function(Scope,Service,id){
			Scope[id.toLowerCase() + 'ResetQuery'] = function(){
				Scope.page = 0;
				Service.resetQuery();
			}
		}
		methods
		return {
			setConfig: function(n,v){
				helpers.guaranteeString(n) && helpers.guaranteeIsDefined(v) ? (configs[n] = v) : angular.noop;
			},
			getConfig: function(string){
				return configs[string];
			},
			setMethod: function(name,config,fn){
				if(!(helpers.guaranteeString(name) && helpers.guaranteeString(config)))
					throw 'One of $populateProvider.setMethod arguments is wrong.';
				configs[config][name] = true;
				methods[name] = fn;
			},
			populateScope: function(scp,svc,id,config){
				if(!helpers.guaranteeIsDefined(scp)) throw 'The $scope passed for populateScope wasn\'t defined';
				if(!helpers.guaranteeIsDefined(id)) throw 'The identifier for populateScope must be passed';
				if(!helpers.guaranteeIsDefined(config)) throw 'The configuration for populateScope must be passed';
				if(!helpers.guaranteeIsDefined(svc)) throw 'The service for populateScope must be passed';
				if(configs[config]){
					scp[id] = {};
					scp[id].content = {};
					var configuration = configs[config];
					for (var key in configuration) if(configuration.hasOwnProperty(key)){
						methods[key](scp,svc,id);
					}
				}
			},
			$get: function(){
				return this;
			}
		}
	}
	angular.module('gumga.services.populate',[])
	.provider('$populate',Populate)
})();

(function(){
	'use strict';

	Base.$inject = ["$http", "$q"];
	/**
	 * @ngdoc service
	 * @name gumga.core:GumgaRest
	 * @description
	 * 	O service GumgaRest é uma evolução do service {@link gumga.core:GumgaBase}, pois sua configuração não necessita
	 * 	de nenhuma outra configuração adicional no service que irá chamá-lo.
	 *
	 * ## Exemplo
	 * <pre>
	 * angular.module('sample',['gumga.core'])
	 * .service('GumgaRest',function(GumgaRest){
	 * 	   //Exemplo de utilização.
	 * 	   var service = new GumgaRest('http://www.gumga.com.br/api');
	 *     // Ou, caso não queira adicionar nenhum método, utilizar:
	 *     // return new GumgaRest('http://www.gumga.com.br/api');
	 *
	 *	   service.get = function(page){
	 *	       alert('Modifiquei um método da service e chamei o padrão!');
	 *		     return GumgaRest.prototype.get.call(this,page);
	 *	   }
	 * 	   return service;
	 * })
	 * </pre>
	 *
	 * # Métodos
	 *
	 *  `GumgaRest.get(params)`
	 *
	 *  O método get aceita um parâmetro `url` e retorna uma promise de uma chamada HTTP do tipo GET.
	 *
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label> <label class="label label-info">params</label> Parâmetros da query que será feita.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retona uma promise da chamada HTTP GET.
	 *  ---
	 *  `GumgaRest.resetAndGet()`
	 *
	 *  O método resetAndGet reseta a query atual e performa uma chamada HTTP do tipo GET.
	 *
	 *  ### Retorno
	 *
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP GET.
	 *
	 * 	---
	 *
 	 *  `GumgaRest.getById(id)`
	 *
	 *  O método getById aceita um parâmetro `id` e retorna uma promise de uma chamada HTTP do tipo GET.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">[String|Number]</label> <label class="label label-info">id</label> Identificador do registro que será buscado.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retona uma promise da chamada HTTP GET.
	 *  ---
	 *  `GumgaRest.getNew()`
	 *
	 *  O método getById  retorna uma promise de uma chamada HTTP do tipo GET.
	 *  ### Retorno
	 *
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP GET.
	 *
	 *  ---
 	 *  `GumgaRest.delete(data)`
	 *
	 *  O método delete recebe como parâmetro um objeto que será deletado. O objeto deve ter um parâmetro ID,
	 *  que será passado para a url da chamada.
	 *
 	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label> <label class="label label-info">data</label> Registro que será deletado.
	 *
	 *  ### Retorno
	 *
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP DELETE.
	 *
	 *  ---
	 *
 	 *  `GumgaRest.sort(field,way)`
	 *
	 * O método sort recebe dois parâmetros para fazer a ordenação: `field` e `way`, que determinarão qual campo será ordenado
	 * e se será 'asc' ou 'desc'.
	 *
 	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label> <label class="label label-info">field</label> Qual campo será feita a ordenação
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label> <label class="label label-info">way</label> Em que sentido a ordenação será feita, se será ascendente `asc` ou descendente `desc`.
	 *  ### Retorno
	 *
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP GET.
	 *
	 *  ---
	 *
	 *  `GumgaRest.deleteCollection(array)`
	 *
	 *  O método deleteAll aceita um parâmetro `url`  e retorna uma promise de uma série de chamadas http do tipo DELETE que serão resolvidas ao mesmo tempo.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">Array</label><label class="label label-info">array</label> Array com todas os registros que serão deletados
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise após todas as chamadas terem sido resolvidas.
	 *  ---
	 *
 	 *  `GumgaRest.saveImage(attribute,data)`
	 *
	 *  O método saveImage aceita dois parâmetros `attribute` e `data` e retorna uma promise de de uma chamada HTTP POST FORM-DATA.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">attribute</label> Atributo no qual a imagem será feito o
	 *  bind após o form ter sido enviado completo.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label><label class="label label-info">data</label> Dados da imagem que foi selecionada..
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP POST. Nesta promise, será retornado o valor de uma String que deverá ser atribuída ao atributo
	 *  onde estava a imagem. Esta string é um identificador para quando o registro for enviado através de um post.
	 *  ---
 	 *  `GumgaRest.deleteImage(attribute,data)`
	 *
	 *  O método deleteImage aceita dois parâmetros `url` e `data` e retorna uma promise de de uma chamada HTTP DELETE FORM-DATA.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">attribute</label> Atributo no qual a imagem será feito o
	 *  bind após o form ter sido enviado completo.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label><label class="label label-info">data</label> Dados da imagem que foi selecionada.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP DELETE.
	 *  ---
 	 *
 	 *  `GumgaRest.getSearch(field,param)`
	 *
	 *  O método getSearch aceita dois parâmetros `field` e `param` e retorna uma promise de uma chamada HTTP do tipo GET.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">[String]</label> <label class="label label-info">field</label> Qual campo a busca será feita. Caso
	 *  queira fazer a busca em mais de um campo, passar uma string com os nomes separados por vírgula.
 	 *  - <label class="label label-warning" style="margin-right: 1%">[Object]</label> <label class="label label-info">param</label> Objeto que irá conter os parâmetros
 	 *  da busca.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retona uma promise da chamada HTTP GET.
	 *  ---
	 *
 	 *  `GumgaRest.getAdvancedSearch(param)`
	 *
	 *  O método getAdvancedSearch aceita um parâmetro `param` e retorna uma promise de uma chamada HTTP do tipo GET.
	 *  ### Parâmetros
 	 *  - <label class="label label-warning" style="margin-right: 1%">[Object]</label> <label class="label label-info">param</label> Objeto que irá conter os parâmetros
 	 *  da busca.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retona uma promise da chamada HTTP GET.
	 *  ---
   *
 	 *  `GumgaRest.resetDefaultState()`
	 *
	 *  O método resetDefaultState retorna o objeto de query ao seu estado padrão.
	 *
	 *  ---
	 *
	 *  `GumgaRest.saveQuery(query)`
	 *
	 *  O método saveQuery aceita um parâmetro `query` e retorna uma promise de uma chamada HTTP do tipo POST.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">[Object]</label> <label class="label label-info">query</label> Objeto que irá conter três atributos necessários
	 *  para salvar a query. Os atributos são: `page`, `data` e `name`. Onde `page` é o nome da página atual, `data` é a busca e `name` é o nome da query a ser salva.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retona uma promise da chamada HTTP POST.
	 *  ---
	 *
	 *  `GumgaRest.getQuery(page)`
	 *
	 *  O método getQuery aceita um parâmetro `page` e retorna uma promise de uma chamada HTTP do tipo GET. Este Parâmetro `page` é o valor de retorno do objeto `location.hash` disponível
	 *  através do browser. Exemplo: `GumgaRest.getQuery(location.hash);`. É necessário este atributo para pegar apenas as queries relacionadas a página. As informações do usuário já são
	 *  passadas através do token.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">[String]</label> <label class="label label-info">page</label> String que será utilizada para fazer a pesquisa das
	 *  queries relacionadas com a página.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retona uma promise da chamada HTTP GET.
	 *  ---
	 */
	function Base($http,$q){
		function RestPrototype(url){
			this._url = url;
			this._query = {params: {start: 0,pageSize: 10}};
		}
		RestPrototype.prototype.get = _get;
		RestPrototype.prototype.resetAndGet = _resetAndGet;
		RestPrototype.prototype.getNew = _getNew;
		RestPrototype.prototype.getById = _getById;
		RestPrototype.prototype.save = _save;
		RestPrototype.prototype.update= _update;
		RestPrototype.prototype.delete = _delete;
		RestPrototype.prototype.sort = _sort;
		RestPrototype.prototype.deleteCollection = _deleteCollection;
		RestPrototype.prototype.saveImage = _saveImage;
		RestPrototype.prototype.deleteImage = _deleteImage;
		RestPrototype.prototype.getSearch = _getSearch;
		RestPrototype.prototype.getAdvancedSearch = _getAdvancedSearch;
		RestPrototype.prototype.resetDefaultState = _resetQuery;
		RestPrototype.prototype.saveQuery = _saveQuery;
		RestPrototype.prototype.getQuery = _getQuery;
		function _get(page){
			if (page) {
				this._query.params.start = (page - 1) * this._query.params.pageSize;
				if (page < 1) throw 'Invalid page';
			}
			return $http.get(this._url,this._query);
		}
		function _getNew () {return $http.get(this._url + '/new')}
		function _getById(id){return $http.get(this._url + '/' + id);}
		function _save (v){return $http.post(this._url,v);}
		function _update (v){
			if(v.id){
				return $http.put(this._url + '/' + v.id ,v);
			}
			return this.save(v);
		}
		function _delete(v){return $http.delete(this._url + '/' + v.id);}
		function _resetQuery(){this._query = {params: {start: 0,pageSize: 10}};}

		function _resetAndGet(){
			this.resetDefaultState();
			return $http.get(this._url,this._query);
		}
		function _sort(f,w){
			this.resetDefaultState();
			this._query.params.sortField = f;
			this._query.params.sortDir = w;
			return $http.get(this._url,this._query);
		}
		function _deleteCollection(arr){
			var url = this._url;
			return $q.all(arr.map(function(v){
				return $http.delete(url + '/' + v.id);
			}))
		}
		function _saveImage(a,m){
			var fd = new FormData();
			fd.append(a,m);
			return $http.post(this._url + '/' +a + '/',fd,{
				transformRequest: angular.identity,
				headers: {'Content-Type': undefined}
			});
		}
		function _deleteImage(a){
			var fd = new FormData();
			fd.append(a,{});
			return $http.delete(this._url + '/' +a,fd,{
				transformRequest: angular.identity,
				headers: {'Content-Type': undefined}
			});
		}
		function _getSearch(f,p){
			this.resetDefaultState();
			(!p) ?  p = '' : angular.noop;
			this._query.params.q = p;
			this._query.params.searchFields = f;
			return this.get();
		}
		function _getAdvancedSearch(p){
			if(typeof p === 'string'){
				this._query.params = {}
				this._query.params.aq = p;
				return $http.get(this._url,this._query);
			}
			this._query.params = {};
			this._query.params.aq = p.hql;
			this._query.params.aqo = JSON.stringify(p.source);
			return $http.get(this._url,this._query);
		}

		function _saveQuery(q){
			var _aux = {
				page: location.hash.replace('#','').replace(/\//gi,'_'),
				data: JSON.stringify(q.query),
				name: q.name
			};
			return $http.post(this._url + '/saq',_aux);
		}

		function _getQuery(page){
				return $http.get(this._url + '/gumgauserdata/aq;' + page.replace('#','').replace(/\//gi,'_'));
		}
		return RestPrototype;
	}

	angular.module('gumga.services.rest',[])
	.service('GumgaRest',Base);

})();

(function(){
	'use strict';


		Translate.$inject= [];
		function Translate(){
			return {
				$get: ["$http", function($http){
					var self = this;
					$http.get('/i18n/'+self._language + '.json')
						.success(function SuccessGet(values){
							localStorage.setItem('GUMGA'+ self._language,JSON.stringify(values));
							localStorage.setItem('GUMGACurrent',self._language);
						})
					return self;
				}],
				setLanguage: function(language){
					if(!language) throw 'You must pass a language to GumgaTranslate';
					this._language.toLowerCase() !== language.toLowerCase() ? this._language = language : function(){};
				},
				_language: 'pt-br'
			}
		}

		angular.module('gumga.services.translate',['gumga.services.translate.helper'])
		.provider('$gumgaTranslate',Translate)
})();
(function(){
	'use strict';

	TranslateHelper.$inject = [];

	function TranslateHelper() {
		return {
			_translation: {},
			__getFromLocalStorage: function(){
				var language = localStorage.getItem('GUMGACurrent')
				,		self = this;
				function iterate(obj,string){
					for(var key in obj) if(obj.hasOwnProperty(key)){
						(typeof obj[key] == 'object') ? 
							iterate(obj[key], string + '.' + key) : self._translation[(string + '.' + key).substring(1)] = obj[key];
					}
				}
				if(language && localStorage.getItem('GUMGA' + language)){
					iterate(JSON.parse(localStorage.getItem('GUMGA' + language)),'');
					return true;
				}
				
			},
			getTranslate: function(toTranslate){
				var self = this;
				if (Object.getOwnPropertyNames(self._translation).length === 0)
					self.__getFromLocalStorage();
				if(!toTranslate || typeof toTranslate != 'string')  
					throw 'The value passed to GumgaTranslate is Wrong!';
				if(self._translation[toTranslate])
					return self._translation[toTranslate];
				return toTranslate;
			}
		}
	}

	angular.module('gumga.services.translate.helper',[])
	.factory('GumgaTranslateHelper',TranslateHelper)

})();
(function(){
  'use strict';

  Utils.$inject = [];

  function Utils(){
    return {
      areNotEqualInArray: function (array, index) {
        var aux = array.filter(function (element) {
          return element == index;
        });
        return (aux.length < 1);
      },
      camelCase: function (string) {
        return string.slice(0, 1).toUpperCase() + string.slice(1, string.length);
      },
      objInArray: function (array, field) {
        var arrayAux = array.filter(function (obj) {
          return obj.field == field;
        });
        return arrayAux.length > 0;
      },
      checkIndex: function (array, txt) {
        var flag = -1;
        array.forEach(function (obj, index) {
          if (obj.field == txt) {
            flag = index;
          }
        });
        return flag;
      },
      errorMessages: {
        max: "You've typed more than the maximum!",
        min: "You've typed less than the minimum!",
        req: "This field is required"
      }
    }
  }
  angular.module('gumga.services.utils',[])
  .factory('GumgaUtils',Utils);
})();

(function(){
	'use strict';

	WebStorage.$inject = [];
	/**
	 * @ngdoc service
	 * @name gumga.core:GumgaWebStorage
	 * @description 
	 * 
	 * 	O service GumgaWebStorage é utilizado para ajudar o desenvolvedor a trabalhar com o storage do Browser.
	 *
	 * 	#Métodos
	 *
	 *	---
	 * 
	 *  `GumgaWebStorage.setSessionStorageItem(key,value)`
	 *  
	 *  O método setSessionStorageItem aceita dois parâmetros `key` e `value`.
 	 *  
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label> <label class="label label-info">key</label> Qual o identificador do valor que será salvo.
	 *  - <label class="label label-warning" style="margin-right: 1%">[String|Number|Object]</label> <label class="label label-info">value</label> Valor que será salvo no sessionStorage.
	 *  ---
 	 * 
	 *  `GumgaWebStorage.getSessionStorageItem(key)`
	 *  
	 *  O método setSessionStorageItem aceita um parâmetro `key`.
 	 *  
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label> <label class="label label-info">key</label> Qual o identificador do valor que será salvo.
	 *
	 *  ### Retorno
	 *  - <label class="label label-warning" style="margin-right: 1%">[String|Number|Object]</label> <label class="label label-info">key</label> Retorna o valor que estiver na sessionStorage daquela key específica. Caso não encontre,
	 *  o valor retornado é null.
	 *  ---
	 *
 	 *  `GumgaWebStorage.removeSessionStorageItem(key)`
	 *  
	 *  O método removeSessionStorageItem aceita um parâmetro `key`.
 	 *  
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label> <label class="label label-info">key</label> Qual o identificador do valor que será removido da sessionStorage.
	 *
	 *  --- 
	 *
	 *  `GumgaWebStorage.clearSessionStorage()`
	 *  
	 *  O método clearSessionStorage não aceita nenhum parâmetro e limpa a sessionStorage.
 	 *  
	 *  --- 
	 *
 	 *
	 *  `GumgaWebStorage.getNumberOfItemsInSessionStorage()`
	 *  
	 *  O método getNumberOfItemsInSessionStorage não aceita nenhum parâmetro, e retorna o número de itens no localStorage.
 	 *  
	 *  --- 
	 *
 	 * 
	 *  `GumgaWebStorage.setLocalStorageItem(key,value)`
	 *  
	 *  O método setLocalStorageItem aceita dois parâmetros `key` e `value`.
 	 *  
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label> <label class="label label-info">key</label> Qual o identificador do valor que será salvo.
	 *  - <label class="label label-warning" style="margin-right: 1%">[String|Number|Object]</label> <label class="label label-info">value</label> Valor que será salvo no LocalStorage.
	 *  ---
 	 * 
	 *  `GumgaWebStorage.getLocalStorageItem(key)`
	 *  
	 *  O método setLocalStorageItem aceita um parâmetro `key`.
 	 *  
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label> <label class="label label-info">key</label> Qual o identificador do valor que será salvo.
	 *
	 *  ### Retorno
	 *  - <label class="label label-warning" style="margin-right: 1%">[String|Number|Object]</label> <label class="label label-info">key</label> Retorna o valor que estiver na LocalStorage daquela key específica. Caso não encontre,
	 *  o valor retornado é null.
	 *  ---
	 *
 	 *  `GumgaWebStorage.removeLocalStorageItem(key)`
	 *  
	 *  O método removeLocalStorageItem aceita um parâmetro `key`.
 	 *  
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label> <label class="label label-info">key</label> Qual o identificador do valor que será removido da LocalStorage.
	 *
	 *  --- 
	 *
	 *  `GumgaWebStorage.clearLocalStorage()`
	 *  
	 *  O método clearLocalStorage não aceita nenhum parâmetro e limpa o localStorage.
 	 *  
	 *  --- 
 	 *
	 *  `GumgaWebStorage.getNumberOfItemsInLocalStorage()`
	 *  
	 *  O método getNumberOfItemsInLocalStorage não aceita nenhum parâmetro, e retorna o número de itens no localStorage.
 	 *  
	 *  --- 
	 */
	function WebStorage(){
		return {
			setSessionStorageItem: function(key,value){
				var _value = value;
				if(typeof value == 'object'){
					_value = angular.toJson(value);
				}
				window.sessionStorage.setItem(key,_value);
			},
			getSessionStorageItem: function(key){
				var g = window.sessionStorage.getItem(key);
				if(!g){
					return null;
				}
				try {
					angular.fromJson(g);
				}catch(e){
					return g;
				}
				return angular.fromJson(g);
			},
			removeSessionStorageItem: function(key){
				window.sessionStorage.removeItem(key);
			},
			clearSessionStorage: function(){
				window.sessionStorage.clear();
			},
			getNumberOfItemsInSessionStorage: function(){
				return window.sessionStorage.length;
			},
			setLocalStorageItem: function(key,value){
				window.localStorage.setItem(key,angular.toJson(value));
			},
			getLocalStorageItem: function(key){
				var g = window.localStorage.getItem(key);
				try {
					angular.fromJson(g);
				}catch(e){
					return g;
				}
				return angular.fromJson(g);
			},
			removeLocalStorageItem: function(key){
				window.localStorage.removeItem(key);
			},
			clearLocalStorage: function(){
				window.localStorage.clear();
			},
			getNumberOfItemsInLocalStorage: function(){
				return window.localStorage.length;
			}
		}
	}

	angular.module('gumga.services.webstorage',[])
	.factory('GumgaWebStorage',WebStorage)
})();
(function(){
	'use strict';
   /**
    * @ngdoc directive
    * @name gumga.core:gumgaError
    * @element input
    * @restrict A
    * @description O componente gumgaError serve para mostrar mensagens de validações abaixo do input responsável pelo erro.
    *
    * @example
    *  Um exemplo da directive gumgaError funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
    *  <pre>
    *    <form name="myForm">
    *      <input type="number" name="minNumber" ng-model="minNumber" gumga-error gumga-min-number="20">
    *    </form>
    *  </pre>
   */
  Error.$inject = ["$compile"];
  function Error($compile) {
    return {
      restrict: 'A',
			scope: {},
      require: '^form',
      link: function (scope, elm, attrs, ctrl) {
				scope.errors = [];

				scope.errorsContains = function(errors, error) {
					for (var k in errors) {
						if (angular.equals(errors[k], error)) {
							return k;
						}
					}
					return false;
				}

				scope.addError = function(error) {
					if (!scope.errorsContains(scope.errors, error)) {
						scope.errors.push(error);
					}
				}

				scope.removeError = function(error) {
					var errorCopy = angular.copy(error);
					errorCopy.valid = !errorCopy.valid;
					var exist = scope.errorsContains(scope.errors, errorCopy);
					if (exist) {
						scope.errors.splice(exist, 1);
					}
				}
				scope.$on('$errorMessage', function(event, data) {
          if (elm[0].name == data.name) {
            if (data.valid == false) {
  						scope.addError(data);
  					} else {
  						scope.removeError(data);
  					}
          }
				});

        var template = '<ol class="list-errors text-danger"><li ng-repeat="error in errors" >{{ error.fieldMessage }}</li></ol>';
        elm.after($compile(template)(scope));
      }
    }
  }
	angular.module('gumga.directives.form.error',[])
	.directive('gumgaError',Error);
})();

(function(){
	'use strict';
	/**
	 * @ngdoc directive
	 * @name gumga.core:gumgaErrors
	 * @restrict E
	 * @description O componente gumgaErrors serve para mostrar todas mensagens de validações do formulário de forma agrupada.
	 *
	 * @param {String} placement Onde irá aparecer, o padrão é top, mas também aceita right, bottom e left.
	 * @param {String} icon Ícone do botão, por padrão é glyphicon glyphicon-info-sign
	 * @param {String} label Texto do botão
	 * @param {String} title Título do popover de erros
	 *
	 * @example
	 *  Um exemplo da directive gumgaErrors funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
	 *  <pre>
	 *    <form name="myForm">
	 *      <input type="number" name="minNumber" ng-model="minNumber" gumga-min-number="20">
	 *      <gumga-errors placement="right" icon="glyphicon glyphicon-info-sign" label="Campos inválidos" title="Campos inválidos"></gumga-errors>
	 *    </form>
	 *  </pre>
	*/
	Errors.$inject = ["$compile"];
  function Errors($compile) {
    return {
      restrict: 'E',
			scope: {
				errors: '='
			},
      require: '^form',
      link: function (scope, elm, attrs, ctrl) {
				scope.errors = [];

				scope.errorsContains = function(errors, error) {
					for (var k in errors) {
						if (angular.equals(errors[k], error)) {
							return k;
						}
					}
					return false;
				}

				scope.addError = function(error) {
					if (!scope.errorsContains(scope.errors, error)) {
						scope.errors.push(error);
					}
				}

				scope.removeError = function(error) {
					// error.valid = !error.valid;
					var errorCopy = angular.copy(error);
					errorCopy.valid = !errorCopy.valid;
					var exist = scope.errorsContains(scope.errors, errorCopy);
					if (exist) {
						scope.errors.splice(exist, 1);
					}
				}
				scope.$on('$errorMessage', function(event, data) {
					if (data.valid == false) {
						scope.addError(data);
					} else {
						scope.removeError(data);
					}
				});

				var title = attrs.title || 'Erros';
				var placement = attrs.placement || 'top';
				var icon = attrs.icon || 'glyphicon glyphicon-info-sign';

				var template = [
					'<button popover-placement="'+placement+'" popover-template="\'template.html\'" popover-title="'+title+'" type="button" class="btn btn-sm btn-danger">'
				,	'<i class="'+icon+'"></i>'
				, attrs.label
				,	'</button>'
				,	'<script id="template.html" type="text/ng-template">'
				,	'<ol class="list-errors text-danger"><li ng-repeat="error in errors" >{{ error.message }}</li></ol>'
				,	'</script>'
				].join("\n");
				elm.append($compile(template)(scope));

      }
    }
  }
	angular.module('gumga.directives.form.errors',['ui.bootstrap'])
	.directive('gumgaErrors',Errors);
})();

(function(){
	'use strict';
	Form.$inject = ["$timeout", "$rootScope"];
	/**
	* @ngdoc directive
	* @name gumga.core:gumgaForm
	* @restrict A
	* @element form
	* @description A directive gumgaForm é utilizada em conjunto com as directives de validação de input. Ela contém funções que serão
	* usadas para manipular o formulário. Ela expõe no $scope um objeto GumgaForm para agrupar as funções em um lugar só.
	*
	*	# Como utilizar
	*
	* O componente GumgaForm deve ser incluído no elemento `form`, que necessita ter um atributo name. É necessário também que os inputs que serão utilizados tenham um atributo name,
	* pois o controle deles é feito a partir deste atributo.
	*
	*	<pre>
	*  <form name="UserForm" gumga-form>
	*	   ...
	*  </form>
	* </pre>
	*
	*	# Métodos
	*
	*`$scope.GumgaForm.getMessages(name,error)`
  *
  *  O método `getMessages` aceita dois parâmetros `name` e `error`, onde name é o nome do input que desejada
  *  recuperar a mensagem e o erro. Caso o parâmetro error não seja passado, é retornado o objeto com todas as mensagens do campo.
  *  ### Parâmetros
  *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">name</label> String que terá o nome do in put para retornar os errors.
  *   Para adicionar a função, coloque o nome da função e o valor dele como `true`
	*  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">error</label> String que será terá o nome do erro que será retornado. Caso
	*  não seja passado este parâmetro, será retornado um objeto com todos os erros.
  * 	### Retorno
  *
  *  - <label class="label label-info">[Object|String]</label> String que conterá a mensagem de erro ou o objeto com todas as mensagens de erro.
	*
	* ----
	*
	*`$scope.GumgaForm.changeMessage(name,error,message)`
	*
	*  O método `changeMessage` aceita três parâmetros, `name`,`error` e `message`, onde `name` é o nome do input que desejada
	*  recuperar a mensagem, `error` é qual erro que a mensagem será alterada e `message` qual será a nova mensagem .
	*  ### Parâmetros
	*  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">name</label> String que terá o nome do input para retornar os errors.
	*   Para adicionar a função, coloque o nome da função e o valor dele como `true`
	*  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">error</label> String que será terá o nome do erro que será retornado. Caso
	*  não seja passado este parâmetro, será retornado um objeto com todos os erros.
	*  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">message</label> String que será usada como mensagem de erro para a directive.
	* 	### Retorno
	*
	*  - <label class="label label-info">Boolean</label> True caso a mensagem tenha sido alterada, False caso não.
	*
	* ----
	*
	*`$scope.GumgaForm.setFormValid()`
	*
	*  O método `setFormValid` é utilizado para limpar todos os erros que estiverem ativos no formulário. Ele percorre o objeto de erro que o Angular.js cria automaticamente e valida todos os campos
	*  que estiverem com erro.
	*
	* ----
  *
	*`$scope.GumgaForm.setFormPristine()`
	*
	*  O método `setFormPristine` é utilizado para colocar todos os campos em um estado de $pristine, ou seja, quando ainda não foram atualizados pelo usuário.
	*
	* ----
	*
	*`$scope.GumgaForm.clearForm()`
	*
	*  O método `clearForm` é utilizado para limpar todos os campos do formulário e, além disso, colocar eles em um estado de $pristine.
	*
	* ----
	*
	*`$scope.GumgaForm.getFormErrors()`
	*
	*  O método `getFormErrors` é utilizado para quando deseja-se obter todos os erros que estão presentes no formulário.
	*
	* ### Retorno
	*
	*  - <label class="label label-info">[Array]</label> Lista que irá conter todos os erros que estão no formulário.
	*
	* ----
	*/
	function Form($timeout,$rootScope) {
		return {
			restrict: 'A',
			require: '^form',
			scope: false,
			link: function(scope, elm, attrs, ctrl) {
				if(!attrs.name) throw 'É necessário passar um valor para o atributo "name" do element <form>';
				scope.GumgaForm = {};
				var _form = scope[attrs.name];
				var _formControllers = [];
				(function() {
					angular.forEach(elm.find('input'),function(input){
						_formControllers.push({
							name: angular.element(input).controller('ngModel').$name,
							controller: angular.element(input).controller('ngModel'),
							errorMessages: {
								maxdate: 'A data especificada no campo {0} não deve ultrapassar o limite de: {1}.',
								maxlength: 'O texto especificado no campo {0} não deve ultrapassar o limite de: {1}.',
								maxnumber: 'O número especificado no campo {0} não deve ultrapassar o limite de: {1}.',
								mindate: 'A data especificada no campo {0} não deve ser menor que o limite mínimo de: {1}.',
								minlength: 'O texto especificado no campo {0} não deve ser menor que o limite mínimo de: {1}.',
								minnumber: 'O número especificado no campo {0} não deve ser menor que o limite mínimo de: {1}.',
								pattern: 'O texto especificado no campo {0} deve estar dentro do padrão: {1}.',
								rangedate:'A data especificada no campo {0} deve estar dentro do intervalo: {1}.',
								rangenumber: 'O número especificado no campo {0} deve estar dentro do intervalo: {1}.',
								required: 'O campo {0} é obrigatório.'
							}
						})
					})
				})();

				function returnObject(name){
					return _formControllers.filter(function($v){
						return $v.name.trim().toLowerCase() === name.trim().toLowerCase();
					})[0];
				}

				scope.$on('$error',function(ev,data){
					$timeout(function(){
						if (data.error.substring(0,5) == 'range') {
							var auxValue = scope.$eval(data.value);
							data.value = 'mínimo de ' + auxValue.min + ' e máximo de ' + auxValue.max;
						}
						var _aux = returnObject(data.name)
						,		message = _aux.errorMessages[data.error].replace('{1}',data.value)
						,		auxMessage = message;
						if (data.error != 'required') {
							auxMessage = auxMessage.replace('no campo {0}','');
						} else {
							auxMessage = auxMessage.replace('{0}','');
						}
						message = message.replace('{0}',data.label);
						$rootScope.$broadcast('$errorMessage',{
							name: data.name,
							message: message,
							fieldMessage: auxMessage,
							valid: data.valid,
						})
					})
				})
				scope.GumgaForm.getMessages = function(name,error){
					if(!error){
						return returnObject(name).errorMessages;
					}
					if(returnObject(name).errorMessages){
						return returnObject(name).errorMessages[error] || null;
					}
				}
				scope.GumgaForm.changeMessage = function(input,which,message){
					if(!input || !which || !message) throw 'Valores passados errados para a função GumgaForm.changeMessage(input,message)'
					var aux = _formControllers.filter(function(value){
						return input == value.name;
					})[0];
					if(aux.errorMessages && aux.errorMessages[which]){
						aux.errorMessages[which] = message;
						return true;
					}
					return false;
				}
				scope.GumgaForm.setFormValid = function () {
					for(var key in _form.$error) if(_form.$error.hasOwnProperty(key)){
						_form.$error[key].forEach(function (value) {
							value.$setValidity(key,true);
						})
					}
					scope.$apply();
				}
				scope.GumgaForm.clearForm = function(){
					_formControllers.forEach(function(controller){
						controller.controller.$setViewValue('');
						controller.controller.$setPristine();
					})
					scope.$apply();
				}

				scope.GumgaForm.setFormPristine = function () {
					_formControllers.forEach(function(controller){
						controller.controller.$setPristine();
					})
					scope.$apply();
				}

				scope.GumgaForm.getFormErrors = function(){
					var _arr = []
					,		name
					,		aux = [];
					for(var key in _form.$error) if(_form.$error.hasOwnProperty(key)){
						_form.$error[key].forEach(function (value) {
							aux.push(value.$name);
						})
						_arr.push({type: key,fields: aux});
						aux = [];
					}
					return _arr;
				}

			}
		}
	}
	angular.module('gumga.directives.form.form',[])
	.directive('gumgaForm',Form);
})();

(function(){
	'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaMaxDate
   * @element input
   * @restrict A
   * @scope false
   * @description O componente GumgaMaxDate serve para validar datas máximas em entradas de formulários.
   *
   * ## Nota
   * Esta diretiva suporta apenas **inputs** do tipo **date**. O valor do atributo/diretiva é **obrigatório** e deve ser uma **data**.
   *
	 * @param {String} label Usado na integração com {@link gumga.core:gumgaErrors} para indicar em qual campo se encontra o erro.
	 * Se o atributo for omitido, a diretiva usará o atributo name do input.
	 *
   * @example
   *  Um exemplo da directive gumgaMaxDate funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
   *  <pre>
   *    <form name="myForm">
   *      <input type="date" name="maxDate" ng-model="maxDate" gumga-max-date="2015-07-20">
   *      <p ng-show="myForm.maxDate.$error.maxdate" class="text-danger">Data superior a esperada</p>
   *    </form>
   *  </pre>
   */
   MaxDate.$inject = ["$filter"];
   function MaxDate($filter) {
     return {
      restrict: 'A',
      require: 'ngModel',
      link: function (scope, elm, attrs, ctrl) {
	      if (attrs.type != 'date') {
	        throw 'Esta diretiva suporta apenas inputs do tipo date';
	      }
	      if (!attrs.gumgaMaxDate) {
	        throw "O valor da diretiva gumga-max-date não foi informado.";
	      }
        var validateMaxDate = function (inputValue) {
					var error = 'maxdate';
        	var format = 'yyyy-MM-dd';
        	var input = $filter('date')(inputValue, format);
        	var max = $filter('date')(attrs.gumgaMaxDate, format);
        	var isValid = input <= max;
        	ctrl.$setValidity(error, isValid);
					scope.$broadcast('$error', {
						name: attrs.name,
						label: attrs.label || attrs.name,
						valid: isValid,
						error: error,
						value: attrs.gumgaMaxDate
					});
        	return inputValue;
        };
        ctrl.$parsers.unshift(validateMaxDate);
        ctrl.$formatters.push(validateMaxDate);
        attrs.$observe('gumgaMaxDate', function () {
        	validateMaxDate(ctrl.$viewValue);
        });
      }
    }
  }
  angular.module('gumga.directives.form.max.date',[])
  .directive('gumgaMaxDate',MaxDate);
})();

(function(){
	'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaMaxLength
   * @element input
   * @restrict A
   * @scope false
   * @description O componente GumgaMaxLength serve para validar quantidades máximas de caracteres em entradas de formulários.
   *
   * ## Nota
   * O valor do atributo/diretiva é **obrigatório** e deve ser um **número**.
   *
	 * @param {String} label Usado na integração com {@link gumga.core:gumgaErrors} para indicar em qual campo se encontra o erro.
	 * Se o atributo for omitido, a diretiva usará o atributo name do input.
	 *
   * @example
   *  Um exemplo da directive GumgaMaxLength funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
   *  <pre>
   *    <form name="myForm">
   *      <input type="date" name="maxLength" ng-model="maxLength" gumga-max-length="20" id="maxLength">
   *      <p ng-show="myForm.maxLength.$error.maxlength" class="text-danger">Tamanho superior ao esperado</p>
   *    </form>
   *  </pre>
   */
   MaxLength.$inject = [];
   function MaxLength() {
    return {
      restrict: 'A',
      require: 'ngModel',
      link: function (scope, elm, attrs, ctrl) {
        if (!attrs.gumgaMaxLength) {
          throw "O valor da diretiva gumga-max-length não foi informado.";
        }
        var validateMaxLength = function (inputValue) {
					var error = 'maxlength';
          var input = (inputValue == undefined) ? -1 : inputValue.length;
          var max = attrs.gumgaMaxLength;
          var isValid = input <= max && input != -1;
          ctrl.$setValidity(error, isValid);
					scope.$broadcast('$error', {
						name: attrs.name,
						label: attrs.label || attrs.name,
						valid: isValid,
						error: error,
						value: attrs.gumgaMaxLength
					});
          return inputValue;
        };
        ctrl.$parsers.unshift(validateMaxLength);
        ctrl.$formatters.push(validateMaxLength);
        attrs.$observe('gumgaMaxLength', function () {
          validateMaxLength(ctrl.$viewValue);
        });
      }
    }
  }
  angular.module('gumga.directives.form.max.length',[])
  .directive('gumgaMaxLength',MaxLength);
})();

(function(){
	'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaMaxNumber
   * @element input
   * @restrict A
   * @scope false
   * @description O componente GumgaMaxNumber serve para validar números máximos em entradas de formulários.
   *
   * ## Nota
   * Esta diretiva suporta apenas **inputs** do tipo **number**. O valor do atributo/diretiva é **obrigatório** e deve ser um **número**.
   *
	 * @param {String} label Usado na integração com {@link gumga.core:gumgaErrors} para indicar em qual campo se encontra o erro.
	 * Se o atributo for omitido, a diretiva usará o atributo name do input.
	 *
   * @example
   *  Um exemplo da directive GumgaMaxNumber funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
   *  <pre>
   *    <form name="myForm">
   *      <input type="number" name="maxNumber" ng-model="maxNumber" gumga-max-number="20">
   *      <p ng-show="myForm.maxNumber.$error.maxnumber" class="text-danger">Número superior ao esperado</p>
   *    </form>
   *  </pre>
   */
   MaxNumber.$inject = [];
   function MaxNumber() {
     return {
      restrict: 'A',
      require: 'ngModel',
      link: function (scope, elm, attrs, ctrl) {
       if (attrs.type != 'number') {
        throw 'Esta diretiva suporta apenas inputs do tipo number';
      }
      if (!attrs.gumgaMaxNumber) {
        throw "O valor da diretiva gumga-max-number não foi informado.";
      }
      var validateMaxNumber = function (inputValue) {
				var error = 'maxnumber';
        var input = parseInt(inputValue);
        var max = parseInt(attrs.gumgaMaxNumber);
        var isValid = input <= max;
        ctrl.$setValidity(error, isValid);
				scope.$broadcast('$error', {
					name: attrs.name,
					label: attrs.label || attrs.name,
					valid: isValid,
					error: error,
					value: attrs.gumgaMaxNumber
				});
        return inputValue;
      };
      ctrl.$parsers.unshift(validateMaxNumber);
      ctrl.$formatters.push(validateMaxNumber);
      attrs.$observe('gumgaMaxNumber', function () {
        validateMaxNumber(ctrl.$viewValue);
      });

      scope.$on('clearFields',function(event, data) {
       ctrl.$modelValue = null;
       console.log('directive date clear');
					// console.log(elm);
					// console.log();
				});
    }
  }
}
angular.module('gumga.directives.form.max.number',[])
.directive('gumgaMaxNumber',MaxNumber);
})();

(function(){
	'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaMinDate
   * @element input
   * @restrict A
   * @description O componente GumgaMinDate serve para validar datas mínimas em entradas de formulários.
   *
   * ## Nota
   * Esta diretiva suporta apenas **inputs** do tipo **date**. O valor do atributo/diretiva é **obrigatório** e deve ser uma **data**.
   *
	 * @param {String} label Usado na integração com {@link gumga.core:gumgaErrors} para indicar em qual campo se encontra o erro.
	 * Se o atributo for omitido, a diretiva usará o atributo name do input.
	 *
   * @example
   *  Um exemplo da directive GumgaMinDate funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
   *  <pre>
   *    <form name="myForm">
   *      <input type="date" name="minDate" ng-model="minDate" gumga-min-date="2015-07-20">
   *      <p ng-show="myForm.minDate.$error.mindate" class="text-danger">Data inferior a esperada</p>
   *    </form>
   *  </pre>
  */
	 MinDate.$inject = ["$filter"];
	 function MinDate($filter) {
	 	return {
	 		restrict: 'A',
	 		require: 'ngModel',
	 		link: function (scope, elm, attrs, ctrl) {
	 			if (attrs.type != 'date') {
	 				throw 'Esta diretiva suporta apenas inputs do tipo date';
	 			}
	 			if (!attrs.gumgaMinDate) {
	 				throw "O valor da diretiva gumga-min-date não foi informado.";
	 			}
        // if (!GumgaDateService.validateFormat('YMD', attrs.gumgaMinDate)) {
        //   throw 'O valor da diretiva não corresponde ao formato yyyy-mm-dd';
        // }
        var validateMinDate = function (inputValue) {
					var error = 'mindate';
					var format = 'yyyy-MM-dd';
					var input = $filter('date')(inputValue, format);
					var min = $filter('date')(attrs.gumgaMinDate, format);
					var isValid = input >= min;
					ctrl.$setValidity(error, isValid);
					scope.$broadcast('$error', {
						name: attrs.name,
						label: attrs.label || attrs.name,
						valid: isValid,
						error: error,
						value: attrs.gumgaMinDate
					});
					return inputValue;
				};
				ctrl.$parsers.unshift(validateMinDate);
				ctrl.$formatters.push(validateMinDate);
				attrs.$observe('gumgaMinDate', function () {
					validateMinDate(ctrl.$viewValue);
				});
			}
		}
	}
	angular.module('gumga.directives.form.min.date',[])
	.directive('gumgaMinDate',MinDate);
})();

(function(){
	'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaMinLength
   * @element input
   * @restrict A
   * @description O componente GumgaMinLength serve para validar quantidades mínimas de caracteres em entradas de formulários.
   *
   * ## Nota
   * O valor do atributo/diretiva é **obrigatório** e deve ser um **número**.
   *
	 * @param {String} label Usado na integração com {@link gumga.core:gumgaErrors} para indicar em qual campo se encontra o erro.
	 * Se o atributo for omitido, a diretiva usará o atributo name do input.
	 *
   * @example
   *  Um exemplo da directive GumgaMinLength funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
   *  <pre>
   *    <form name="myForm">
   *      <input type="date" name="minLength" ng-model="minLength" gumga-min-length="20" id="minLength">
   *      <p ng-show="myForm.minLength.$error.minlength" class="text-danger">Tamanho inferior ao esperado</p>
   *    </form>
   *  </pre>
  */
	MinLength.$inject = [];
	function MinLength() {
    return {
      restrict: 'A',
      require: 'ngModel',
      link: function (scope, elm, attrs, ctrl) {
        if (!attrs.gumgaMinLength) {
          throw "O valor da diretiva gumga-min-length não foi informado.";
        }
        var validateMinLength = function (inputValue) {
					var error = 'minlength';
          var input = (inputValue == undefined) ? -1 : inputValue.length;
          var min = attrs.gumgaMinLength;
          var isValid = input >= min;
          ctrl.$setValidity(error, isValid);
					scope.$broadcast('$error', {
						name: attrs.name,
						label: attrs.label || attrs.name,
						valid: isValid,
						error: error,
						value: attrs.gumgaMinLength
					});
          return inputValue;
        };
	 			ctrl.$parsers.unshift(validateMinLength);
	 			ctrl.$formatters.push(validateMinLength);
	 			attrs.$observe('gumgaMinLength', function () {
	 				validateMinLength(ctrl.$viewValue);
	 			});
	 		}
	 	}
	 }
	 angular.module('gumga.directives.form.min.length',[])
	 .directive('gumgaMinLength',MinLength);
	})();

(function(){
	'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaMinNumber
   * @element input
   * @restrict A
   * @description O componente GumgaMinNumber serve para validar números mínimos para entradas em formulários.
   *
   * ## Nota
   * Esta diretiva suporta apenas **inputs** do tipo **number**. O valor do atributo/diretiva é **obrigatório** e deve ser um **número**.
   *
	 * @param {String} label Usado na integração com {@link gumga.core:gumgaErrors} para indicar em qual campo se encontra o erro.
	 * Se o atributo for omitido, a diretiva usará o atributo name do input.
	 *
   * @example
   *  Um exemplo da directive GumgaMinNumber funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
   *  <pre>
   *    <form name="myForm">
   *      <input type="number" name="minNumber" ng-model="minNumber" gumga-min-number="20">
   *      <p ng-show="myForm.minNumber.$error.minnumber" class="text-danger">Número inferior ao esperado</p>
   *    </form>
   *  </pre>
  */
	 MinNumber.$inject = [];
	 function MinNumber() {
	 	return {
	 		restrict: 'A',
	 		require: 'ngModel',
	 		link: function (scope, elm, attrs, ctrl) {
	 			if (attrs.type != 'number') {
	 				throw 'Esta diretiva suporta apenas inputs do tipo number';
	 			}
	 			if (!attrs.gumgaMinNumber) {
	 				throw "O valor da diretiva gumga-min-number não foi informado.";
	 			}
	 			var validateMinNumber = function (inputValue) {
					var error = 'minnumber';
	 				var input = parseInt(inputValue);
	 				var min = parseInt(attrs.gumgaMinNumber);
	 				var isValid = input >= min;
	 				ctrl.$setValidity(error, isValid);
					scope.$broadcast('$error', {
						name: attrs.name,
						label: attrs.label || attrs.name,
						valid: isValid,
						error: error,
						value: attrs.gumgaMinNumber
					});
	 				return inputValue;
	 			};
	 			ctrl.$parsers.unshift(validateMinNumber);
	 			ctrl.$formatters.push(validateMinNumber);
	 			attrs.$observe('gumgaMinNumber', function () {
	 				validateMinNumber(ctrl.$viewValue);
	 			});
	 		}
	 	}
	 }
	 angular.module('gumga.directives.form.min.number',[])
	 .directive('gumgaMinNumber',MinNumber);
	})();

(function(){
	'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaPattern
   * @element input
   * @restrict A
   * @description O componente GumgaPattern serve para validar expressões regulares de formulários.
   *
   * ## Nota
   * O valor do atributo/diretiva é **obrigatório** e deve ser uma **expressão regular**.
   *
	 * @param {String} label Usado na integração com {@link gumga.core:gumgaErrors} para indicar em qual campo se encontra o erro.
	 * Se o atributo for omitido, a diretiva usará o atributo name do input.
	 *
   * @example
   *  Um exemplo da directive GumgaPattern funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
   *  <pre>
   *    <form name="myForm">
   *      <input type="text" name="cep" ng-model="cep" gumga-pattern="(\d{5})\-(\d{3})" id="cep" placeholder="99999-999">
   *      <p ng-show="myForm.cep.$error.pattern" class="text-danger">Expressão não corresponde com o formato esperado</p>
   *    </form>
   *  </pre>
  */
	Pattern.$inject = [];
  function Pattern() {
    return {
			restrict: 'A',
	 		require: 'ngModel',
      link: function (scope, elm, attrs, ctrl) {
				if (!attrs.gumgaPattern) {
					throw "O valor da diretiva gumga-pattern não foi informado.";
				}
				var validatePattern = function (inputValue) {
					var error = 'pattern';
					var regex = new RegExp('^' + attrs.gumgaPattern + '$');
					var isValid = regex.test(inputValue);
					ctrl.$setValidity(error, isValid);
					scope.$broadcast('$error', {
						name: attrs.name,
						label: attrs.label || attrs.name,
						valid: isValid,
						error: error,
						value: attrs.patternAlias || attrs.gumgaPattern
					});
					return inputValue;
				};
				ctrl.$parsers.unshift(validatePattern);
				ctrl.$formatters.push(validatePattern);
				attrs.$observe('gumgaPattern', function () {
					validatePattern(ctrl.$viewValue);
				});
      }
    }
  }
  angular.module('gumga.directives.form.pattern',[])
  .directive('gumgaPattern',Pattern);
})();

(function(){
	'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaRangeDate
   * @restrict A
   * @element input
   * @description
	 * O componente GumgaRangeDate serve para validar datas mínimas e máximas para entradas em formulários com campos do tipo date.
   *
   * ## Nota
   * O valor do atributo/diretiva é **obrigatório** e deve ser um **objeto** contendo duas propriedades, **min** e **max**
   * com os valores de suas respectivas datas para execução da validação range.
   *
   * ## Exemplo
   * Um exemplo da directive GumgaRangeDate funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
   *
	 * @param {String} label Usado na integração com {@link gumga.core:gumgaErrors} para indicar em qual campo se encontra o erro.
	 * Se o atributo for omitido, a diretiva usará o atributo name do input.
	 *
   * @example
   *  <pre>
   *    <form name="myForm">
   *      <input type="date" name="rangeDate" ng-model="rangeDate" gumga-range-date="{min: '1986-12-29', max: '2015-07-20'}" id="rangedate">
   *      <p ng-show="myForm.cep.$error.rangedate" class="text-danger">A data informada não está entre os valores esperados</p>
   *    </form>
   *  </pre>
	 */
	 RangeDate.$inject = ["$filter"];
	 function RangeDate($filter) {
	 	return {
	 		restrict: 'A',
	 		require: 'ngModel',
	 		link: function (scope, elm, attrs, ctrl) {
	 			if (attrs.type != 'date') {
	 				throw 'Esta diretiva suporta apenas inputs do tipo date';
	 			}
	 			if (!attrs.gumgaRangeDate) {
	 				throw "O valor da diretiva gumga-range-date não foi informado.";
	 			}
        var validateRangeDate = function (inputValue) {
					var error = 'rangedate';
          var format = 'yyyy-MM-dd';
          var range = scope.$eval(attrs.gumgaRangeDate);
        	var input = $filter('date')(inputValue, format);
          var min = $filter('date')(range.min, format);
        	var max = $filter('date')(range.max, format);
        	var isValid = input >= min && input <= max;
        	ctrl.$setValidity(error, isValid);
					scope.$broadcast('$error', {
						name: attrs.name,
						label: attrs.label || attrs.name,
						valid: isValid,
						error: error,
						value: attrs.gumgaRangeDate
					});
        	return inputValue;
        };
        ctrl.$parsers.unshift(validateRangeDate);
        ctrl.$formatters.push(validateRangeDate);
        attrs.$observe('gumgaRangeDate', function () {
        	validateRangeDate(ctrl.$viewValue);
        });
      }
    }
  }
  angular.module('gumga.directives.form.range.date',[])
  .directive('gumgaRangeDate',RangeDate);
})();

(function(){
	'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaRangeNumber
   * @restrict A
   * @element input
   * @description
	 * O componente GumgaRangeNumber serve para validar números mínimos e máximos em entradas de formulários com campos do tipo number.
   *
   * ## Nota
   * O valor do atributo/diretiva é **obrigatório** e deve ser um **objeto** contendo duas propriedades, **min** e **max**
   * com os valores de suas respectivas datas para execução da validação range.
   *
   * ## Exemplo
   * Um exemplo da directive GumgaRangeNumber funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
   *
	 * @param {String} label Usado na integração com {@link gumga.core:gumgaErrors} para indicar em qual campo se encontra o erro.
	 * Se o atributo for omitido, a diretiva usará o atributo name do input.
	 *
   * @example
   *  <pre>
   *    <form name="myForm">
   *      <input type="date" name="rangeNumber" ng-model="rangeNumber" gumga-number-date="{min: 0, max: 20}">
   *      <p ng-show="myForm.rangeNumber.$error.rangenumber" class="text-danger">O número informado não está entre os valores esperados</p>
   *    </form>
   *  </pre>
	 */
	 RangeNumber.$inject = [];
	 function RangeNumber() {
	 	return {
	 		restrict: 'A',
	 		require: 'ngModel',
	 		link: function (scope, elm, attrs, ctrl) {
	 			if (attrs.type != 'number') {
	 				throw 'Esta diretiva suporta apenas inputs do tipo number';
	 			}
	 			if (!attrs.gumgaRangeNumber) {
	 				throw "O valor da diretiva gumga-range-number não foi informado.";
	 			}
	 			var validateRangeNumber = function (inputValue) {
					var error = 'rangenumber';
          var range = scope.$eval(attrs.gumgaRangeNumber);
          var input = parseInt(inputValue);
          var isValid = input >= range.min && input <= range.max;
          ctrl.$setValidity(error, isValid);
					scope.$broadcast('$error', {
						name: attrs.name,
						label: attrs.label || attrs.name,
						valid: isValid,
						error: error,
						value: attrs.gumgaRangeNumber
					});
	 				return inputValue;
	 			};
	 			ctrl.$parsers.unshift(validateRangeNumber);
	 			ctrl.$formatters.push(validateRangeNumber);
	 			attrs.$observe('gumgaRangeNumber', function () {
	 				validateRangeNumber(ctrl.$viewValue);
	 			});
	 		}
	 	}
	 }
	 angular.module('gumga.directives.form.range.number',[])
	 .directive('gumgaRangeNumber',RangeNumber);
	})();

(function(){
  'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaRequired
   * @restrict A
   * @element ANY
   * @description
   * O componente GumgaRequired serve para validar campos obrigatórios.
   *
   * ## Exemplo
   * Um exemplo da directive GumgaRequired funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
   *
   * @param {String} label Usado na integração com {@link gumga.core:gumgaErrors} para indicar em qual campo se encontra o erro.
   * Se o atributo for omitido, a diretiva usará o atributo name do input.
	 *
   * @example
   *  <pre>
   *    <form name="myForm">
   *      <input type="text" name="required" ng-model="required" gumga-required>
   *      <p ng-show="myForm.required.$error.required" class="text-danger">Campo obrigatório</p>
   *    </form>
   *  </pre>
   */
  Required.$inject = [];
  function Required() {
    return {
      restrict: 'A',
      require: 'ngModel',
      link: function (scope, elm, attrs, ctrl) {
        attrs.required = true;
        var validateRequired = function (inputValue) {
          var error = 'required';
          var isValid = !attrs.required || !ctrl.$isEmpty(inputValue);
          ctrl.$setValidity(error, isValid);
          scope.$broadcast('$error', {
            name: attrs.name,
            label: attrs.label || attrs.name,
            valid: isValid,
            error: error,
            value: attrs.gumgaRequired
          });
          return inputValue;
        };
        ctrl.$parsers.unshift(validateRequired);
        ctrl.$formatters.push(validateRequired);
        attrs.$observe('gumgaRequired', function () {
          validateRequired(ctrl.$viewValue);
        });
      }
    }
  }
  angular.module('gumga.directives.form.required',[])
  .directive('gumgaRequired',Required);
})();

(function(){
	'use strict';

	AdvancedLabel.$inject = [];
	function AdvancedLabel(){
		var template =
		'<div class="btn-group">' +
		'   <button class="btn btn-default btn-xs" ng-disabled="disabled" id="btn{{attr}}" ng-click="orOrAnd(value)"><strong>{{attr}}</strong> {{hql}} <strong>{{value}}</strong></button>' +
		'   <button class="btn btn-default btn-xs" ng-disabled="disabled" ng-click="emitDelete()" ng-if="getVisibility(value)"><span aria-hidden="true">&times;</span></button>' +
		'</div>';

		return {
			restrict: 'E',
			template: template,
			scope: {
				attr: '@',
				hql: '@',
				value: '=',
				index: '=',
				disabled: '='
			},
			link: function(scope,$elm,$attrs){
				if(!$attrs.disabled) scope.disabled = false;
				scope.bol = false;

				scope.orOrAnd = function(){

					if(typeof scope.value === 'string' && scope.value.toUpperCase() === 'OR' && !scope.hql){
						scope.value = 'AND';
					}   else  if(scope.value.toUpperCase() === 'AND' && !scope.hql){
						scope.value = 'OR';
					}
				};

				scope.emitDelete = function(){
					scope.$emit('deletepls',scope.index);
				};


				scope.getVisibility = function(val){
					return !(val == 'AND' || val == 'OR');
				}
			}
		};
	}
	angular.module('gumga.directives.search.advancedlabel',[])
	.directive('gumgaAdvancedLabel',AdvancedLabel)
})();

(function(){
	'use strict';

	AdvancedSearch.$inject = ["GumgaSearchHelper"];
	function AdvancedSearch(GumgaSearchHelper){
		var template =
		'   <div class="input-group">' +
		'       	<span class="input-group-btn" dropdown is-open="status.isopen">'+
		'						<span dropdown on-toggle="toggled(open)">'+
		'							<a href id="simple-dropdown" class="btn btn-default" style="margin-right:-3px;" dropdown-toggle>'+
		'								<i class="glyphicon glyphicon-hourglass"></i>	'+
		'							</a>'+
		'							<ul class="dropdown-menu" aria-labelledby="simple-dropdown" style="width: auto;">'+
		'								<li ng-repeat="choice in $parent.availableQueries">'+
		'									<a href ng-click="doQuery(choice)">{{choice.description}}</a>'+
		'								</li>'+
		'							</ul>'+
		'						</span>'+
		'       	</span>' +
		'       <input type="text" ng-model="searchInputText" class="form-control" ng-disabled="isPanelOpen" id="textMain"/> ' +
		'       <span class="input-group-btn">' +
		'           <button class="my-button btn-default" ng-click="showLittlePanel = !showLittlePanel"><span class="glyphicon glyphicon-chevron-down"></span></button>' +
		'           <button class="my-button btn-default" type="button" ng-click="isPanelOpen = !isPanelOpen"><span class="glyphicon glyphicon-filter"></span>' +
		'           <button class="my-button btn-primary last" type="button" ng-disabled="isPanelOpen" ng-click="doSearch(searchInputText)">Search <span class="glyphicon glyphicon-search"></span>' +
		'       </span>' +
		'   </div>' +
		'   <div class="panel-advanced" ng-show="isPanelOpen">' +
		'       <div class="panel-body">' +
		'           <div class="col-md-3">' +
		'           <h3 style="margin-top: 0;margin-bottom: 0"><small>Advanced Search</small></h3>' +
		'           </div>' +
		'           <div class="form-inline col-md-9">' +
		'               <div class="form-group">' +
		'                   <div class="list-holder">' +
		'                           <ul class="list-selectable" ng-show="selectAttribute">\n' +
		'                               <li ng-repeat="attr in attributes" ng-click="attributeHasChanged(attr)" class="hover-list"><button class="btn btn-link">{{attr.name}}</button></li>\n' +
		'                           </ul>\n' +
		'                       </div>' +
		'                       <button type=button class="btn btn-default" ng-click="selectAttribute = !selectAttribute" >{{query.attribute.name || \'Attribute\'}}<span class="caret"></span></button>' +
		'                      <div class="list-holder">' +
		'                           <ul class="list-selectable" ng-show="selectHQL">\n' +
		'                               <li ng-repeat="opt in hqlOpts" class="hover-list" ng-click="handleHqlOption(opt)"><button class="btn btn-link" >{{opt.label}}</button></li>\n' +
		'                           </ul>\n' +
		'                       </div>' +
		'                    <button type="button" class="btn btn-default" ng-click="selectHQL = !selectHQL"> {{ query.hql.label || \'HQL\'  }} <span class="caret"></span></button>  '+
		'                   <input type="{{typeInput}}" class="form-control col-x-3" ng-model="query.value" id="selectableAdvancedValue" ng-init="input = this"/>' +
		'                   <button type="button" class="btn btn-default" ng-click="addQuery(query)" ng-disabled="query.value.length > 0 ? false : true"><span class="glyphicon glyphicon-plus"></span></button>' +
		'               </div>' +
		'           </div>' +
		'       </div>'+
		'           <hr/>' +
		'       <div class="col-md-12" style="padding-bottom: 2%">' +
		'       <gumga-advanced-label ng-repeat="query in queries" attr="{{query.attribute.name}}" hql="{{query.hql.label}}" value="query.value" index="$index" style="margin-right: 1%"></gumga-advanced-label>' +
		'       <div class="col-md-12" style="margin-top: 1%;">' +
		'       <button class="btn btn-primary pull-right" type="button" ng-disabled="queries.length == 0" ng-click="showArray(queries)">Advanced Search<span class="glyphicon glyphicon-search"></span>' +
		'       </div>' +
		'       </div>' +
		'       <div class="clearfix" style="margin-bottom: 2%"></div>' +
		'   </div>' +
		'<div class="little-panel" ng-show="showLittlePanel">' +
		'   <div class="panel-body">' +
		'       <label ng-repeat="field in normalFields" style="display: block" ><input type="checkbox" ng-model="models[field.value]" style="margin-right: 1%" ><span>{{field.value}}</span></label>' +
		'   </div>' +
		'</div>';
		return {
			restrict: 'E',
			template: template,
			scope: false,
			require: '^?gumgaSearch',
			link: function(scope,elm,attrs,ctrl){
				scope.isPanelOpen = false;
				scope.selectHQL = false;
				scope.models = {};
				scope.searchField = '';
				scope.translate = scope.$parent.entityToTranslate;

				scope.doQuery = function (choice) {
					var query = JSON.parse(choice.value);
					scope.$emit('advanced', {hql: GumgaSearchHelper.translateArrayToHQL(query), source: query});
				}

				scope.$on('_doSearch',function(){
					if(scope.queries.length != 0){
						scope.showArray(scope.queries);
					} else {
						if(scope.searchInputText){
							scope.doSearch(scope.searchInputText);
						}
					}
				});

				scope.$on('_focus',function(){
					if(scope.isPanelOpen){
						document.getElementById('selectableAdvancedValue').focus();
					} else {
						document.getElementById('textMain').focus();
					}
				});

				if(!scope.$parent.normalFields.length > 0 || !scope.$parent.entityToTranslate){
					throw 'Missing some parameters in GumgaSearch';
				}

				scope.normalFields = scope.$parent.normalFields.map(function(elm,$index){
					scope.models[elm] = false;
					$index == 0 && (scope.models[elm] = true);
					return {
						name: elm.slice(0,1).toUpperCase() + elm.slice(1,elm.length).toLowerCase(),
						value: elm
					};
				});


				scope.$on('showPanel',function(){
					scope.isPanelOpen = !scope.isPanelOpen;
					scope.$apply();
				});

				scope.models.returnString = function(){
					var txt = '';
					for(var key in this) if(this.hasOwnProperty(key) && key != 'returnString' && this[key]){
						txt += key + ',';
					}
					if(txt.length == 0){
						return scope.normalFields[0].value;
					}
					return txt.slice(0,-1);
				};

				scope.$watch('isPanelOpen',function(){
					if(scope.isPanelOpen === true){
						scope.selectAttribute = true;
					} else {
						scope.queries = [];
					}
					scope.query = {};
				});
				scope.attributes = scope.$parent.attributes;
				scope.hqlOpts = [];
				scope.queries = [];

				scope.attributeHasChanged = function(attribute) {
					scope.query.attribute = attribute;
					if(attribute.type === 'date'){
						scope.typeInput = 'date';
					} else {
						scope.typeInput = 'text';
					}
					scope.hqlOpts = GumgaSearchHelper.getTypeListOfHQLPossibilities(attribute.type);
					scope.selectHQL = true ;
					scope.selectAttribute = false;
				};

				scope.handleHqlOption = function(hq){
					scope.query.hql = hq;
					scope.selectHQL = false;
				};

				angular.element(document.getElementById('selectableAdvancedValue'))
				.on('keydown',function(ev){
					if(ev.keyCode == 13 && ev.target.value.length > 0){
						scope.addQuery(scope.query);
					}
					scope.$apply();
				});

				angular.element(document.getElementById('textMain'))
				.on('keydown',function(ev){
					if(ev.keyCode == 13 && ev.target.value.length > 0){
						scope.$emit('normal',{field: scope.models.returnString(),param:scope.searchInputText || ''});
						if(scope.showLittlePanel){
							scope.showLittlePanel = !scope.showLittlePanel;
						}
					}
				});

				scope.addQuery = function(query){
					if(scope.queries.length === 0){
						scope.queries.push(query);
					} else if(scope.queries.length >= 1){
						scope.queries.splice(scope.queries.length,1,{value: 'AND'},query);
					}
					scope.query = {};
					scope.typeInput = 'text';
				};

				scope.$on('deletepls',function(ev,data){
					scope.queries.splice(data,1);
				});

				scope.showArray = function(array){
					scope.isPanelOpen = false;
					scope.$emit('advanced',{hql: GumgaSearchHelper.translateArrayToHQL(array),source: array});
				};

				scope.doSearch = function(txt){
					scope.$emit('normal',{field: scope.models.returnString(),param:txt || ''});
					scope.searchInputText = '';
				};
			}
		};
	}
	angular.module('gumga.directives.search.advancedsearch',['gumga.directives.search.searchhelper'])
	.directive('gumgaAdvancedSearch',AdvancedSearch)
})();

(function(){
	'use strict';
	
	NormalSearch.$inject = [];
	function NormalSearch(){
		var template =
		'<div class="input-group">' +
		'   <input type="text" class="form-control" ng-model="searchField" placeholder="Search"/>' +
		'   <span class="input-group-btn">' +
		'       <button class="my-button btn-default" ng-click="showLittlePanel = !showLittlePanel"><span class="glyphicon glyphicon-chevron-down"></span></button>' +
		'       <button class="my-button btn-primary last" type="button" ng-disabled="!searchField" ng-click="doSearch(searchField)" >Search <span class="glyphicon glyphicon-search"></span></button>' +
		'   </span>' +
		'</div>' +
		'<div class="little-panel" ng-show="showLittlePanel">' +
		'   <div class="panel-body">' +
		'       <label ng-repeat="field in normalFields" style="display: block" ><input type="checkbox" ng-model="models[field.value]" style="margin-right: 1%" ><span>{{field.value}}</span></label>' +
		'   </div>' +
		'</div>';
		return {
			restrict: 'E',
			template: template,
			link: function(scope,elm,attrs){
				if(!scope.$parent.normalFields.length > 0 || !scope.$parent.entityToTranslate){
					throw 'Missing some parameters in GumgaSearch';
				}
				scope.models = {};
				scope.searchField = '';
				scope.translate = scope.$parent.entityToTranslate;
				scope.normalFields = scope.$parent.normalFields.map(function(elm,$index){
					scope.models[elm] = false;
					$index == 0 && (scope.models[elm] = true);
					return {
						name: elm.slice(0,1).toUpperCase() + elm.slice(1,elm.length).toLowerCase(),
						value: elm
					};
				});

				scope.models.returnString = function(){
					var txt = '';
					for(var key in this) if(this.hasOwnProperty(key) && key != 'returnString' && this[key]){
						txt += key + ',';
					}
					if(txt.length == 0){
						return scope.normalFields[0].value;
					}
					return txt.slice(0,-1);
				};

				elm.find('input')
				.bind('keypress',function(ev){
					if(ev.keyCode == 13 && scope.searchField.length > 0){
						scope.$emit('normal',{field: scope.models.returnString(),param:scope.searchField});
						if(scope.showLittlePanel){
							scope.showLittlePanel = !scope.showLittlePanel;
						}
					}
				});

				scope.doSearch = function(txt){
					scope.$emit('normal',{field: scope.models.returnString(),param:txt || ''});
					scope.showLittlePanel = !scope.showLittlePanel;
					scope.searchField = '';
				};

			}
		};
	}
	angular.module('gumga.directives.search.normalsearch',[])
	.directive('gumgaNormalSearch',NormalSearch)
})();
(function(){
	'use strict';

	Search.$inject = [];
	function Search(){
		var template =
		'<div class="full-width-without-padding">' +
		'     <div ng-if="!adv">' +
		'         <gumga-normal-search></gumga-normal-search>' +
		'     </div>' +
		'     <div ng-if="adv">' +
		'         <gumga-advanced-search></gumga-advanced-search>' +
		'     </div>' +
		'</div>';
		return {
			restrict: 'E',
			template: template,
			transclude: true,
			scope : {
				advanced: '&advancedMethod',
				normal: '&searchMethod',
				onSearch: '&',
				onAdvancedSearch: '&',
				getQueries: '&?'
			},
			link: function(scope,elm,attrs,controller,transcludeFn){
				scope.adv = false;
				scope.attributes = [];
				scope.normalFields = attrs.fields.split(',');
				scope.entityToTranslate = attrs.translateEntity;
				scope.$parent.searchQueries = [];
				scope.availableQueries = [];
				scope.saveQuery = false;
				if(attrs.getQueries){
					scope.saveQuery = true;
					scope.getQueries({page: location.hash})
					.then(function(data){
						scope.availableQueries = data;
					})
				}

				var eventHandler = {
					search: attrs.onSearch ? scope.onSearch : angular.noop,
					advanced: attrs.onAdvancedSearch ? scope.onAdvancedSearch : angular.noop
				}
				if(attrs.advanced === "true"){
					scope.adv = true;
				}

				scope.getAttributes = function (){
					transcludeFn(function(clone){
						angular.forEach(clone,function(cloneEl){
							if(cloneEl.nodeName == 'ADVANCED-FIELD'){
								scope.attributes.push({
									name: cloneEl.getAttribute('name'),
									type: cloneEl.getAttribute('type')
								});
							}
						});
					});
				};

				scope.$on('advanced',function(ev,data){
					scope.$parent.searchQueries = [];
					scope.$parent.searchQueries = data.source;
					scope.advanced({param: data});
					eventHandler.advanced();
        });

				scope.$on('normal',function(ev,data){
					scope.normal({field: data.field,param: data.param});
					eventHandler.search()
        });

				scope.getAttributes();
			}
		};
	}
	angular.module('gumga.directives.search.search',[])
	.directive('gumgaSearch',Search)
})();

(function(){
	'use strict';

	SearchHelper.$inject = [];
	function SearchHelper(){
		var types ={
			"string": {
				"HQLPossibilities": [
				{hql:"eq",label: "igual" , before: "='",after:"'"},
				{hql:"ne",label: "diferente de" , before: "!='",after:"'"},
				{hql: "contains",label: "contém" , before: " like '\%",after:"\%'"},
				{hql: "not_contains",label:"não contém" , before: " not like '\%",after:"\%'"},
				{hql: "starts_with",label:"começa com" , before: "like '",after:"\%'"},
				{hql: "ends_with",label: "termina com" , before: "like '\%",after:"'"},
				{hql: "ge",label:"maior igual" , before: ">='",after:"'"},
				{hql: "le",label: "menor igual" , before: "<='",after:"'"}]
			},
			"number": {
				"HQLPossibilities": [
				{hql:"eq",label: "igual", before: "=",after:""},
				{hql:"ne",label: "diferente de", before: "!=",after:""},
				{hql: "gt",label:"maior que", before: ">",after:""},
				{hql: "ge",label:"maior igual", before: ">=",after:""},
				{hql: "lt",label:"menor que", before: "<",after:""},
				{hql: "le",label:"menor igual", before: "<=",after:""}]
			},
			"money": {
				"HQLPossibilities": [
				{hql:"eq",label: "igual", before: "=",after:""},
				{hql:"ne",label: "diferente de", before: "!=",after:""},
				{hql: "gt",label:"maior que", before: ">",after:""},
				{hql: "ge",label:"maior igual", before: ">=",after:""},
				{hql: "lt",label:"menor que", before: "<",after:""},
				{hql: "le",label:"maior igual", before: "<=",after:""}]

			},
			"boolean": {
				"HQLPossibilities": [{hql:"eq",label: "igual" , before: "='",after:"'"}]
			},
			"date": {
				"HQLPossibilities": [
				{hql: "eq", label: "igual", before: "='", after: "'"},
				{hql: "ge", label: "maior igual", before: ">='", after: "'"},
				{hql: "le", label: "menor igual", before: "<='", after: "'"}]
			}
		};
		return {
			getTypeListOfHQLPossibilities: function(type){
				if(angular.isDefined(types[type]))
					return types[type].HQLPossibilities;
				throw 'Type doesn\'t exist';
			},
			translateArrayToHQL: function(array){
				return array
				.map(function(element) {
					return (
						(angular.isDefined(element.attribute) ? 'obj.' + element.attribute.name : '!')
						+ '' +
						(angular.isDefined(element.hql) ? element.hql.before : ' !')
						+ '' +
						element.value
						+ (angular.isDefined(element.hql) ? element.hql.after : ' !') );
				}).map(function(element){
					if(element.indexOf('!') != -1){
						return element.replace(/!/g,'');
					}
					return element;
				}).join("");
			}
		};
	}
	angular.module('gumga.directives.search.searchhelper',[])
	.factory('GumgaSearchHelper',SearchHelper)
})();

(function(){
	'use strict';
	Translate.$inject = ["$http", "TranslateHelper"];
	function Translate($http,TranslateHelper){
		var ch = 0;
		return {
			restrict: 'AEC',
			scope: false,
			link: function($scope,$elm,$attrs){
				var language = $attrs.gumgaTranslate.toLowerCase() || navigator.language.toLowerCase();
				if(!TranslateHelper.getSessionStorageItem(language)){
					$http.get('./i18n/' + language + '.json')
					.success(function(values){
						TranslateHelper.setTranslators(language,values);
					});
				}

			}
		};
	}

	angular.module('gumga.directives.translate.translate',['gumga.directives.translate.translatehelper'])
	.directive('gumgaTranslate',Translate);
})();
(function(){
	'use strict';

	function TranslateHelper(){
		return {
			getSessionStorageItem: function(key){
				var g = window.sessionStorage.getItem(key);
				if(!g){
					return null;
				}
				try {
					angular.fromJson(g);
				}catch(e){
					return g;
				}
				this.translators = angular.fromJson(angular.fromJson(g));
				return angular.fromJson(angular.fromJson(g));
			},
			translators: {},
			setTranslators: function(language,obj){
				this.translators = obj;
				this.setSessionStorageItem(language,JSON.stringify(obj));
			},
			setSessionStorageItem: function(key,value){
				window.sessionStorage.setItem(key,angular.toJson(value));
			},
			returnTranslation: function(string){
				var array = string.split('.');
				try {
					return this.translators[array[0].toLowerCase().trim()][array[1].toLowerCase().trim()];
				} catch(e){}
			}
		};
	}

	angular.module('gumga.directives.translate.translatehelper',[])
	.factory('TranslateHelper',TranslateHelper);

})();

(function(){
  'use strict';
  TranslateTag.$inject = ["TranslateHelper", "$compile"];
  function TranslateTag(TranslateHelper,$compile){
    var child;
    return {
      restrict: 'A',
      link: function(scope,elm,attrs){
        if(!attrs.gumgaTranslateTag) throw 'You must pass a valid value to gumgaTranslateTag';
        if(TranslateHelper.returnTranslation(attrs.gumgaTranslateTag)){
          if(elm[0].childNodes.length > 0){
            scope.child = elm[0].childNodes[0];
            elm[0].innerHTML =  TranslateHelper.returnTranslation(attrs.gumgaTranslateTag);
            elm.append($compile(scope.child)(scope));
          } else {
            elm[0].innerHTML = TranslateHelper.returnTranslation(attrs.gumgaTranslateTag);
          }
        }
      }

    };
  }

  angular.module('gumga.directives.translate.translatetag',['gumga.directives.translate.translatehelper'])
  .directive('gumgaTranslateTag',TranslateTag);
})();

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LmpzIiwiY29udHJvbGxlcnMvbW9kdWxlLmpzIiwiZGlyZWN0aXZlcy9tb2R1bGUuanMiLCJzZXJ2aWNlcy9tb2R1bGUuanMiLCJkaXJlY3RpdmVzL0FkZHJlc3MvQWRkcmVzcy5qcyIsImRpcmVjdGl2ZXMvQWxlcnQvQWxlcnQuanMiLCJkaXJlY3RpdmVzL0JyZWFkY3J1bWIvQnJlYWRjcnVtYi5qcyIsImRpcmVjdGl2ZXMvQ291bnRlci9Db3VudGVyLmpzIiwiZGlyZWN0aXZlcy9Gb3JtL0Zvcm0uanMiLCJkaXJlY3RpdmVzL0Zvcm0vbW9kdWxlLmpzIiwiZGlyZWN0aXZlcy9Gb3JtQnV0dG9ucy9Gb3JtQnV0dG9ucy5qcyIsImRpcmVjdGl2ZXMvTGlzdC9MaXN0LmpzIiwiZGlyZWN0aXZlcy9NYW55VG9NYW55L01hbnlUb01hbnkuanMiLCJkaXJlY3RpdmVzL01hbnlUb09uZS9NYW55VG9PbmUuanMiLCJkaXJlY3RpdmVzL01hc2svTWFzay5qcyIsImRpcmVjdGl2ZXMvTWVudS9NZW51LmpzIiwiZGlyZWN0aXZlcy9OYXYvTmF2LmpzIiwiZGlyZWN0aXZlcy9PbmVUb01hbnkvT25lVG9NYW55LmpzIiwiZGlyZWN0aXZlcy9RdWVyeS9RdWVyeS5qcyIsImRpcmVjdGl2ZXMvU2VhcmNoL1NlYXJjaC5qcyIsImRpcmVjdGl2ZXMvU2VhcmNoL21vZHVsZS5qcyIsImRpcmVjdGl2ZXMvVGFibGUvVGFibGUuanMiLCJkaXJlY3RpdmVzL1RyYW5zbGF0ZS9UcmFuc2xhdGUuanMiLCJkaXJlY3RpdmVzL1RyYW5zbGF0ZS9UcmFuc2xhdGVUYWcuanMiLCJkaXJlY3RpdmVzL1RyYW5zbGF0ZS9tb2R1bGUuanMiLCJkaXJlY3RpdmVzL1VwbG9hZC9VcGxvYWQuanMiLCJzZXJ2aWNlcy9BZGRyZXNzU2VydmljZS9BZGRyZXNzU2VydmljZS5qcyIsInNlcnZpY2VzL0FsZXJ0L0FsZXJ0LmpzIiwic2VydmljZXMvQmFzZS9CYXNlLmpzIiwic2VydmljZXMvQnJvYWRjYXN0ZXIvQnJvYWRjYXN0ZXIuanMiLCJzZXJ2aWNlcy9EYXRlL0RhdGUuanMiLCJzZXJ2aWNlcy9LZXlib2FyZC9LZXlib2FyZC5qcyIsInNlcnZpY2VzL0xpc3RIZWxwZXIvTGlzdEhlbHBlci5qcyIsInNlcnZpY2VzL05vdGlmaWNhdGlvbi9Ob3RpZmljYXRpb24uanMiLCJzZXJ2aWNlcy9Qb3B1bGF0ZVByb3ZpZGVyL1BvcHVsYXRlUHJvdmlkZXIuanMiLCJzZXJ2aWNlcy9SZXN0L1Jlc3QuanMiLCJzZXJ2aWNlcy9UcmFuc2xhdGUvVHJhbnNsYXRlLmpzIiwic2VydmljZXMvVHJhbnNsYXRlL1RyYW5zbGF0ZUhlbHBlci5qcyIsInNlcnZpY2VzL1V0aWxzL1V0aWxzLmpzIiwic2VydmljZXMvV2ViU3RvcmFnZS9XZWJTdG9yYWdlLmpzIiwiZGlyZWN0aXZlcy9Gb3JtL0Vycm9yL0Vycm9yLmpzIiwiZGlyZWN0aXZlcy9Gb3JtL0Vycm9ycy9FcnJvcnMuanMiLCJkaXJlY3RpdmVzL0Zvcm0vRm9ybS9Gb3JtLmpzIiwiZGlyZWN0aXZlcy9Gb3JtL01heC9EYXRlLmpzIiwiZGlyZWN0aXZlcy9Gb3JtL01heC9MZW5ndGguanMiLCJkaXJlY3RpdmVzL0Zvcm0vTWF4L051bWJlci5qcyIsImRpcmVjdGl2ZXMvRm9ybS9NaW4vRGF0ZS5qcyIsImRpcmVjdGl2ZXMvRm9ybS9NaW4vTGVuZ3RoLmpzIiwiZGlyZWN0aXZlcy9Gb3JtL01pbi9OdW1iZXIuanMiLCJkaXJlY3RpdmVzL0Zvcm0vUGF0dGVybi9QYXR0ZXJuLmpzIiwiZGlyZWN0aXZlcy9Gb3JtL1JhbmdlL0RhdGUuanMiLCJkaXJlY3RpdmVzL0Zvcm0vUmFuZ2UvTnVtYmVyLmpzIiwiZGlyZWN0aXZlcy9Gb3JtL1JlcXVpcmVkL1JlcXVpcmVkLmpzIiwiZGlyZWN0aXZlcy9TZWFyY2gvQWR2YW5jZWRMYWJlbC9BZHZhbmNlZExhYmVsLmpzIiwiZGlyZWN0aXZlcy9TZWFyY2gvQWR2YW5jZWRTZWFyY2gvQWR2YW5jZWRTZWFyY2guanMiLCJkaXJlY3RpdmVzL1NlYXJjaC9Ob3JtYWxTZWFyY2gvTm9ybWFsU2VhcmNoLmpzIiwiZGlyZWN0aXZlcy9TZWFyY2gvU2VhcmNoL1NlYXJjaC5qcyIsImRpcmVjdGl2ZXMvU2VhcmNoL1NlYXJjaEhlbHBlci9TZWFyY2hIZWxwZXIuanMiLCJkaXJlY3RpdmVzL1RyYW5zbGF0ZS9UcmFuc2xhdGUvVHJhbnNsYXRlLmpzIiwiZGlyZWN0aXZlcy9UcmFuc2xhdGUvVHJhbnNsYXRlSGVscGVyL1RyYW5zbGF0ZUhlbHBlci5qcyIsImRpcmVjdGl2ZXMvVHJhbnNsYXRlL1RyYW5zbGF0ZVRhZy9UcmFuc2xhdGVUYWcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3pDQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDak9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMzTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzlEQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN2WEE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdktBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM1WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ3VtZ2EubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5hbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuY29yZScsXG5cdFsnZ3VtZ2Euc2VydmljZXMnLFxuXHQnZ3VtZ2EuY29udHJvbGxlcnMnLFxuXHQnZ3VtZ2EuZGlyZWN0aXZlcyddKTtcbiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cblx0YW5ndWxhci5tb2R1bGUoJ2d1bWdhLmNvbnRyb2xsZXJzJyxbXSk7XG5cbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGFuZ3VsYXIubW9kdWxlKCdndW1nYS5kaXJlY3RpdmVzJyxcblx0XHRbXG5cdFx0J2d1bWdhLmRpcmVjdGl2ZXMuYWRkcmVzcycsXG5cdFx0J2d1bWdhLmRpcmVjdGl2ZXMucXVlcmllcycsXG5cdFx0J2d1bWdhLmRpcmVjdGl2ZXMuYWxlcnQnLFxuXHRcdCdndW1nYS5kaXJlY3RpdmVzLmJyZWFkY3J1bWInLFxuXHRcdCdndW1nYS5kaXJlY3RpdmVzLmNvdW50ZXInLFxuXHRcdCdndW1nYS5kaXJlY3RpdmVzLmZvcm1idXR0b25zJyxcblx0XHQnZ3VtZ2EuZGlyZWN0aXZlcy5tYW55dG9tYW55Jyxcblx0XHQnZ3VtZ2EuZGlyZWN0aXZlcy5tYW55dG9vbmUnLFxuXHRcdCdndW1nYS5kaXJlY3RpdmVzLm1lbnUnLFxuXHRcdCdndW1nYS5kaXJlY3RpdmVzLm5hdicsXG5cdFx0J2d1bWdhLmRpcmVjdGl2ZXMub25ldG9tYW55Jyxcblx0XHQnZ3VtZ2EuZGlyZWN0aXZlcy5zZWFyY2gnLFxuXHRcdCdndW1nYS5kaXJlY3RpdmVzLnRhYmxlJyxcblx0XHQnZ3VtZ2EuZGlyZWN0aXZlcy51cGxvYWQnLFxuXHRcdCdndW1nYS5kaXJlY3RpdmVzLmZvcm0nLFxuXHRcdCdndW1nYS5kaXJlY3RpdmVzLm1hc2snLFxuXHRcdCdndW1nYS5kaXJlY3RpdmVzLmxpc3QnLFxuXHRcdCdndW1nYS5kaXJlY3RpdmVzLnRyYW5zbGF0ZSdcblx0XHRdKTtcblxufSkoKTtcbiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cblx0YW5ndWxhci5tb2R1bGUoJ2d1bWdhLnNlcnZpY2VzJyxbXG5cdFx0J2d1bWdhLnNlcnZpY2VzLmFkZHJlc3MnLFxuXHRcdCdndW1nYS5zZXJ2aWNlcy5rZXlib2FyZCcsXG5cdFx0J2d1bWdhLnNlcnZpY2VzLmJhc2UnLFxuXHRcdCdndW1nYS5zZXJ2aWNlcy51dGlscycsXG5cdFx0J2d1bWdhLnNlcnZpY2VzLmFsZXJ0Jyxcblx0XHQnZ3VtZ2Euc2VydmljZXMudHJhbnNsYXRlJyxcblx0XHQnZ3VtZ2Euc2VydmljZXMud2Vic3RvcmFnZScsXG5cdFx0J2d1bWdhLnNlcnZpY2VzLnBvcHVsYXRlJyxcblx0XHQnZ3VtZ2Euc2VydmljZXMucmVzdCcsXG5cdFx0J2d1bWdhLnNlcnZpY2VzLm5vdGlmaWNhdGlvbidcblx0XHRdKTtcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXHQvKipcblx0ICogQG5nZG9jIGRpcmVjdGl2ZVxuXHQgKiBAbmFtZSBndW1nYS5jb3JlOmd1bWdhQWRkcmVzc1xuXHQgKiBAcmVzdHJpY3QgRVxuXHQgKiBAZGVzY3JpcHRpb24gTyBjb21wb25lbnRlIEd1bWdhQWRkcmVzcyByZWNlYmUgdW0gb2JqZXRvIHF1ZSBzZXLDoSBwcmVlbmNoaWRvIGNvbSBvIGVuZGVyZcOnbywgcXVlIHBvZGUgc2VyIHBlc3F1aXNhZG8gYXRyYXbDqXMgZG8gQ0VQIChVdGlsaXphbmRvIHVtIFdlYlNlcnZpY2UgR1VNR0EpLFxuXHQgKiBvdSBwcmVlbmNoaWRvIG1hbnVhbG1lbnRlIHBlbG8gdXN1w6FyaW8uIEVzdGUgb2JqZXRvIGRlIGVudHJhZGEgcG9kZSBzZXIgdmF6aW8gb3UgcHJlZmVyaXZlbG1lbnRlIG5vIGZvcm1hdG8gZG8gb2JqZXRvIEdVTUdBLlxuICAgICAgICogIyMgRXhlbXBsb1xuICAgICAgICogVmVqYSB1bSBleGVtcGxvIGVtIGZ1bmNpb25hbWVudG8gW2FxdWldKGh0dHA6Ly9lbWJlZC5wbG5rci5jby83dDltWnRMbDliUHVWaG1pZzBvSS8pLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgQXRyaWJ1dG8gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciBvIG5vbWUgZG8gb2JqZXRvIG5vICRzY29wZSBubyBxdWFsIG9zIHZhbG9yZXMgZG8gRW5kZXJlw6dvIHNlcsOjbyBjb2xvY2Fkb3MuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIEF0cmlidXRvIG9icmlnYXTDs3JpbyBlIMO6bmljbyBxdWUgaXLDoSBjb250ZXIgdW0gbm9tZSBkZSBpZGVudGlmaWNhZG9yIHBhcmEgYSBkaXJlY3RpdmUuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0aXRsZSBBdHJpYnV0byBvcGNpb25hbCBxdWUgaXLDoSBjb250ZXIgbyB0w610dWxvIHBhcmEgbyBwYW5lbCBkYSBkaXJlY3RpdmUuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9uU2VhcmNoQ2VwU3RhcnQgQXRyaWJ1dG8gb3BjaW9uYWwgcXVlIGlyw6EgY29udGVyIG8gbm9tZSBkZSB1bWEgZnVuw6fDo28gcXVlIHNlcsOhIGV4ZWN1dGFkYSBxdWFuZG8gYSBidXNjYSBwZWxvIENFUCBjb21lw6dhci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gb25TZWFyY2hDZXBTdWNjZXNzIEF0cmlidXRvIG9wY2lvbmFsIHF1ZSBpcsOhIGNvbnRlciBvIG5vbWUgZGUgdW1hIGZ1bsOnw6NvIHF1ZSBzZXLDoSBleGVjdXRhZGEgcXVhbmRvIGEgYnVzY2EgcGVsbyBDRVAgcmV0b3JuYXIgc3VjZXNzby5cbiAgICAgICAqICBQb2RlIHNlciBjaGFtYWRhIGNvbSB1bSBhdHJpYnV0byBjb20gb3MgdmFsb3JlcyBgb24tc2VhcmNoLWNlcC1zdWNjZXNzPVwiZG9Tb21ldGhpbmcoJHZhbHVlKVwiYFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblNlYXJjaENlcEVycm9yIEF0cmlidXRvIG9wY2lvbmFsIHF1ZSBpcsOhIGNvbnRlciBvIG5vbWUgZGUgdW1hIGZ1bsOnw6NvIHF1ZSBzZXLDoSBleGVjdXRhZGEgcXVhbmRvIGEgYnVzY2EgcGVsbyBDRVAgcmV0b3JuYXIgZXJyby5cbiAgICAgICAqICBQb2RlIHNlciBjaGFtYWRhIGNvbSB1bSBhdHJpYnV0byBjb20gb3MgdmFsb3JlcyBgb24tc2VhcmNoLWNlcC1lcnJvcj1cImRvU29tZXRoaW5nKCR2YWx1ZSlcImBcbiAgICAgICovXG5cdEFkZHJlc3NEaXJlY3RpdmUuJGluamVjdCA9IFtcIkd1bWdhQWRkcmVzc1NlcnZpY2VcIiwgXCIkaHR0cFwiXTtcbiAgICAgIGZ1bmN0aW9uIEFkZHJlc3NEaXJlY3RpdmUoR3VtZ2FBZGRyZXNzU2VydmljZSwkaHR0cCl7XG4gICAgICBcdHZhciB0ZW1wbGF0ZSA9IFtcbiAgICAgIFx0JzxkaXYgY2xhc3M9XCJhZGRyZXNzXCIgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6IDBcIj4nLFxuICAgICAgXHQnICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtOCBjb2wtc20tMTIgY29sLXhzLTEyXCIgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6IDBcIj4nLFxuICAgICAgXHQnICAgICAgICAgIDxhY2NvcmRpb24+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICA8YWNjb3JkaW9uLWdyb3VwIHN0eWxlPVwibWFyZ2luLXRvcDogMSVcIiBpcy1vcGVuPVwidHJ1ZVwiIGhlYWRpbmc9XCJ7ezo6dGl0bGV9fVwiPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC0xMlwiPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cImlucHV0e3s6OmlkfX1cIj5DRVA8L2xhYmVsPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwXCI+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIG5nLW1vZGVsPVwidmFsdWUuemlwQ29kZVwiIGlkPVwiaW5wdXR7ezo6aWR9fVwiIG5nLWtleXByZXNzPVwiY3VzdG9tKCRldmVudCx2YWx1ZS56aXBDb2RlKVwiPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1idG5cIj4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXByaW1hcnlcIiB0eXBlPVwiYnV0dG9uXCIgbmctY2xpY2s9XCJzZWFyY2hDZXAodmFsdWUuemlwQ29kZSlcIiBuZy1kaXNhYmxlZD1cImxvYWRlcnt7OjppZH19XCIgaWQ9XCJidXR0b25TZWFyY2h7ezo6aWR9fVwiPlNlYXJjaCA8aSBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tc2VhcmNoXCI+PC9pPjwvYnV0dG9uPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNFwiPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cInRpcG9Mb2dyYWRvdXJvXCI+PHNtYWxsPlRpcG8gTG9ncmFkb3Vybzwvc21hbGw+PC9sYWJlbD4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3QgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cInZhbHVlLnByZW1pc3NlVHlwZVwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgbmctb3B0aW9ucz1cImxvZyBmb3IgbG9nIGluIGZhY3RvcnlEYXRhLmxvZ3NcIj48L3NlbGVjdD4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC01XCIgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6IDA7IHBhZGRpbmctcmlnaHQ6IDBcIj4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJMb2dyYWRvdXJvXCI+PHNtYWxsPkxvZ3JhZG91cm88L3NtYWxsPjwvbGFiZWw+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cInZhbHVlLnByZW1pc3NlXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2wgaWQ9XCJvaVwiLz4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC0zXCI+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwiTsO6bWVyb1wiPjxzbWFsbD4gTsO6bWVybyA8L3NtYWxsPjwvbGFiZWw+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cInZhbHVlLm51bWJlclwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJudW1iZXJJbnB1dHt7OjppZH19XCIvPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTEyXCI+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwiQ29tcGxlbWVudG9cIj48c21hbGw+Q29tcGxlbWVudG88L3NtYWxsPjwvbGFiZWw+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cInZhbHVlLmluZm9ybWF0aW9uXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIi8+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtN1wiPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cIkJhaXJyb1wiPjxzbWFsbD4gQmFpcnJvIDwvc21hbGw+PC9sYWJlbD4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLW1vZGVsPVwidmFsdWUubmVpZ2hib3VyaG9vZFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIvPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTVcIj4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJMb2NhbGlkYWRlXCI+PHNtYWxsPiBMb2NhbGlkYWRlIDwvc21hbGw+PC9sYWJlbD4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLW1vZGVsPVwidmFsdWUubG9jYWxpemF0aW9uXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIi8+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNFwiPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cIlVGXCI+PHNtYWxsPiBVRiA8L3NtYWxsPjwvbGFiZWw+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IG5nLW1vZGVsPVwidmFsdWUuc3RhdGVcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIG5nLW9wdGlvbnM9XCJ1ZiBmb3IgdWYgaW4gZmFjdG9yeURhdGEudWZzXCI+PC9zZWxlY3Q+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNFwiPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cIlBhw61zXCI+PHNtYWxsPiBQYcOtcyA8L3NtYWxsPjwvbGFiZWw+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IG5nLW1vZGVsPVwidmFsdWUuY291bnRyeVwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgbmctb3B0aW9ucz1cInBhaXMgZm9yIHBhaXMgaW4gZmFjdG9yeURhdGEuYXZhaWxhYmxlQ291bnRyaWVzXCI+PC9zZWxlY3Q+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNFwiIHN0eWxlPVwicGFkZGluZy10b3A6IDIlXCI+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cImJ0biBidG4tZGVmYXVsdCBwdWxsLXJpZ2h0XCIgbmctaHJlZj1cInt7cmV0dXJuTGluayh2YWx1ZSl9fVwiIHRhcmdldD1cIl9ibGFua1wiPk1hcHMgPGkgY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLWdsb2JlXCI+PC9pPjwvYT4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgPC9hY2NvcmRpb24tZ3JvdXA+JyxcbiAgICAgIFx0JyAgICAgICAgICA8L2FjY29yZGlvbj4nLFxuICAgICAgXHQnICAgIDwvZGl2PicsXG4gICAgICBcdCc8L2Rpdj4nXTtcbiAgICAgIFx0cmV0dXJuIHtcbiAgICAgIFx0XHRyZXN0cmljdDogJ0UnLFxuICAgICAgXHRcdHNjb3BlOiB7XG4gICAgICBcdFx0XHR2YWx1ZTogJz0nLFxuICAgICAgXHRcdFx0b25TZWFyY2hDZXBTdGFydDogJyY/JyxcbiAgICAgIFx0XHRcdG9uU2VhcmNoQ2VwU3VjY2VzczogJyY/JyxcbiAgICAgIFx0XHRcdG9uU2VhcmNoQ2VwRXJyb3I6ICcmPydcbiAgICAgIFx0XHR9LFxuICAgICAgXHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5qb2luKCdcXG4nKSxcbiAgICAgIFx0XHRsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsbSwgYXR0cnMsIGN0cmwpIHtcblx0XHRcdFx0XHRcdGZ1bmN0aW9uIGlzRW1wdHkob2JqKXtcbiAgICBcdFx0XHRcdFx0Zm9yKHZhciBrZXkgaW4gb2JqKSBpZihvYmouaGFzT3duUHJvcGVydHkoa2V5KSl7XG4gICAgICAgIFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuICAgIFx0XHRcdFx0XHR9XG4gICAgXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHQgICAgICAgICAgaWYoaXNFbXB0eShzY29wZS52YWx1ZSkpIHNjb3BlLnZhbHVlID0gR3VtZ2FBZGRyZXNzU2VydmljZS5yZXR1cm5Gb3JtYXR0ZWRPYmplY3QoKTtcblx0ICAgICAgICAgIGlmKCFhdHRycy5uYW1lKSB0aHJvdyBcIsOJIG5lY2Vzc8OhcmlvIHBhc3NhciB1bSBwYXLDom1ldHJvICduYW1lJyBjb21vIGlkZW50aWZpY2Fkb3IgcGFyYSBHdW1nYUFkZHJlc3NcIjtcbiAgICAgIFx0XHRcdHNjb3BlLnRpdGxlID0gYXR0cnMudGl0bGUgfHwgJ0VuZGVyZcOnbyc7XG4gICAgICBcdFx0XHRzY29wZS5pZCA9IGF0dHJzLm5hbWU7XG4gICAgICBcdFx0XHRzY29wZVsnbG9hZGVyJyArIHNjb3BlLmlkXSA9IGZhbHNlO1xuICAgICAgICAgICAgc2NvcGUuZmFjdG9yeURhdGEgPSB7XG4gICAgICAgICAgICAgICAgdWZzOiBHdW1nYUFkZHJlc3NTZXJ2aWNlLmV2ZXJ5VWYsXG4gICAgICAgICAgICAgICAgbG9nczogR3VtZ2FBZGRyZXNzU2VydmljZS5ldmVyeUxvZ3JhZG91cm8sXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlQ291bnRyaWVzOiBHdW1nYUFkZHJlc3NTZXJ2aWNlLmF2YWlsYWJsZUNvdW50cmllc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBldmVudEhhbmRsZXIgPSB7XG4gICAgICAgICAgICAgICAgICBzZWFyY2hDZXBTdGFydDogKGF0dHJzLm9uU2VhcmNoQ2VwU3RhcnQgPyBzY29wZS5vblNlYXJjaENlcFN0YXJ0IDogYW5ndWxhci5ub29wKSxcbiAgICAgICAgICAgICAgICAgIHNlYXJjaENlcFN1Y2Nlc3M6IChhdHRycy5vblNlYXJjaENlcFN1Y2Nlc3MgPyBzY29wZS5vblNlYXJjaENlcFN1Y2Nlc3MgOiBhbmd1bGFyLm5vb3ApLFxuICAgICAgICAgICAgICAgICAgc2VhcmNoQ2VwRXJyb3I6IChhdHRycy5vblNlYXJjaENlcEVycm9yID8gc2NvcGUub25TZWFyY2hDZXBFcnJvcjogYW5ndWxhci5ub29wKVxuICAgICAgICAgICAgfTtcbiAgICAgIFx0XHRcdHNjb3BlLmN1c3RvbSA9IGZ1bmN0aW9uICgkZXZlbnQsIGNlcCkge1xuICAgICAgICAgICAgICAkZXZlbnQuY2hhckNvZGUgPT0gMTM/IHNjb3BlLnNlYXJjaENlcChjZXApIDogYW5ndWxhci5ub29wO1xuICAgICAgXHRcdFx0fTtcblxuICAgICAgXHRcdFx0c2NvcGUucmV0dXJuTGluayA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgXHRcdFx0XHRpZiAoIXZhbHVlLm51bWJlcikge1xuICAgICAgXHRcdFx0XHRcdHZhbHVlLm51bWJlciA9ICcnO1xuICAgICAgXHRcdFx0XHR9XG4gICAgICBcdFx0XHRcdHJldHVybiAnaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS5ici9tYXBzL3BsYWNlLycgKyB2YWx1ZS5wcmVtaXNzZVR5cGUgKyAnICcgKyB2YWx1ZS5wcmVtaXNzZSArICcsJyArIHZhbHVlLm51bWJlcisgJywnICsgdmFsdWUubG9jYWxpemF0aW9uO1xuICAgICAgXHRcdFx0fTtcbiAgICAgIFx0XHRcdHNjb3BlLnNlYXJjaENlcCA9IGZ1bmN0aW9uIChjZXApIHtcbiAgICAgIFx0XHRcdFx0c2NvcGVbJ2xvYWRlcicgKyBzY29wZS5pZF0gPSB0cnVlO1xuICAgICAgXHRcdFx0XHRldmVudEhhbmRsZXIuc2VhcmNoQ2VwU3RhcnQoKTtcbiAgICAgIFx0XHRcdFx0JGh0dHAuZ2V0KCdodHRwOi8vd3d3Lmd1bWdhLmNvbS5ici9zZXJ2aWNlcy1hcGkvcHVibGljL2NlcC8nK2NlcClcbiAgICAgIFx0XHRcdFx0LnN1Y2Nlc3MoZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgXHRcdFx0XHRcdGV2ZW50SGFuZGxlci5zZWFyY2hDZXBTdWNjZXNzKHskdmFsdWU6IHZhbHVlc30pO1xuICAgICAgXHRcdFx0XHRcdHNjb3BlWydsb2FkZXInICsgc2NvcGUuaWRdID0gZmFsc2U7XG4gICAgICBcdFx0XHRcdFx0aWYgKHBhcnNlSW50KHZhbHVlcy5yZXN1bHRhZG8pID09IDEpIHtcbiAgICAgIFx0XHRcdFx0XHRcdHNjb3BlLnZhbHVlLnByZW1pc3NlVHlwZSA9IHZhbHVlcy50aXBvX2xvZ3JhZG91cm87XG4gICAgICBcdFx0XHRcdFx0XHRzY29wZS52YWx1ZS5wcmVtaXNzZSA9IHZhbHVlcy5sb2dyYWRvdXJvO1xuICAgICAgXHRcdFx0XHRcdFx0c2NvcGUudmFsdWUubG9jYWxpemF0aW9uID0gdmFsdWVzLmNpZGFkZTtcbiAgICAgIFx0XHRcdFx0XHRcdHNjb3BlLnZhbHVlLm5laWdoYm91cmhvb2QgPSB2YWx1ZXMuYmFpcnJvO1xuICAgICAgXHRcdFx0XHRcdFx0c2NvcGUudmFsdWUuc3RhdGUgPSB2YWx1ZXMudWY7XG4gICAgICBcdFx0XHRcdFx0XHRzY29wZS52YWx1ZS5jb3VudHJ5ID0gJ0JyYXNpbCc7XG4gICAgICBcdFx0XHRcdFx0fVxuXG4gICAgICBcdFx0XHRcdH0pXG4gICAgICBcdFx0XHRcdC5lcnJvcihmdW5jdGlvbihkYXRhKXtcbiAgICAgIFx0XHRcdFx0XHRldmVudEhhbmRsZXIuc2VhcmNoQ2VwRXJyb3IoeyR2YWx1ZTogZGF0YX0pO1xuICAgICAgXHRcdFx0XHR9KVxuICAgICAgXHRcdFx0fTtcbiAgICAgIFx0XHRcdGlmIChzY29wZS52YWx1ZS56aXBDb2RlKSB7XG4gICAgICBcdFx0XHRcdHNjb3BlLnNlYXJjaENlcChzY29wZS52YWx1ZS56aXBDb2RlKTtcbiAgICAgIFx0XHRcdH1cbiAgICAgIFx0XHR9XG4gICAgICBcdH07XG4gICAgICB9XG4gICAgICBhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5hZGRyZXNzJyxbJ2d1bWdhLnNlcnZpY2VzLmFkZHJlc3MnXSlcbiAgICAgIC5kaXJlY3RpdmUoJ2d1bWdhQWRkcmVzcycsQWRkcmVzc0RpcmVjdGl2ZSk7XG4gICAgfSkoKTtcbiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cdC8qKlxuXHQgKiBAbmdkb2MgZGlyZWN0aXZlXG5cdCAqIEBuYW1lIGd1bWdhLmNvcmU6Z3VtZ2FBbGVydFxuXHQgKiBAcmVzdHJpY3QgRUFcblx0ICogQGVsZW1lbnQgQU5ZXG5cdCAqIEBkZXNjcmlwdGlvbiBPIGNvbXBvbmVudGUgZ3VtZ2FBbGVydCBzZXJ2ZSBwYXJhIGNyaWFyIG5vdGlmaWNhw6fDtWVzIGdyb3dsLWxpa2UgZSDDqSBiYXNlYWRhIGVtIGV2ZW50b3MuXG5cdCAqIFBhcmEgbyBmdW5jaW9uYW1lbnRvIGRhIGRpcmVjdGl2ZSwgw6kgbmVjZXNzw6FyaW8gaW5jbHXDrS1sYSBhcGVuYXMgdW1hIHZleiBubyBzZXUgY8OzZGlnbyBodG1sIChkZSBwcmVmZXLDqm5jaWEgbm8gaW5kZXguaHRtbCksXG5cdCAqIHBhcmEgcXVlIG9zIGxpc3RlbmVycyBzZWphbSBhZGljaW9uYWRvcyhBdHVhbG1lbnRlLCBuYSBub3ZhIHZlcnPDo28gaXN0byBuw6NvIMOpIG1haXMgbmVjZXNzw6FyaW8sIHZlciB7QGxpbmsgZ3VtZ2EuY29yZTpHdW1nYUFsZXJ0fSkuIFxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAjIyBQYXJhIHF1ZSBvIGFsZXJ0YSBzZWphIHJlYWxpemFkbywgdXRpbGl6ZSB1bSBkb3MgZXZlbnRvczpcblx0ICogPHByZT5cblx0ICogXHQkc2NvcGUuJGVtaXQoJ2Rhbmdlck1lc3NhZ2UnLHt0aXRsZTogJ0Vycm9yJyAsbWVzc2FnZTogJ0Vycm9yIDQwNCd9KTtcblx0ICogXHQkc2NvcGUuJGVtaXQoJ3N1Y2Nlc3NNZXNzYWdlJyx7dGl0bGU6ICdQYXJhYsOpbnMhJyAsbWVzc2FnZTogJ1N1YSBzb2xpY2l0YcOnw6NvIGZvaSBhY2VpdGEgY29tIHN1Y2Vzc28hJ30pO1xuXHQgKiAgJHNjb3BlLiRlbWl0KCd3YXJuaW5nTWVzc2FnZScse3RpdGxlOiAnQ3VpZGFkbyEnICxtZXNzYWdlOiAnQSDDoXJlYSBxdWUgdm9jw6ogZXN0w6EgZW50cmFuZG8gw6kgcmVzdHJpdGEuJ30pO1xuICAgKiBcdCRzY29wZS4kZW1pdCgnaW5mb01lc3NhZ2UnLHt0aXRsZTogJ1NhbHZhcicgLG1lc3NhZ2U6ICdQYXJhIHNhbHZhciwgZW50cmUgZW0gY29udGF0byBjb20gbyBhZG1pbmlzdHJhZG9yLid9KTtcblx0ICogPC9wcmU+XG5cdCAqICBQYXJhIHZlciB1bSBleGVtcGxvIGVtIGZ1bmNpb25hbWVudG8sIGNsaXF1ZSBbYXF1aV0oaHR0cDovL2VtYmVkLnBsbmtyLmNvL3dkbEk3VTRuUWY5a05oR2x5Q2ZVLylcblx0ICovXG5cdEFsZXJ0LiRpbmplY3QgPSBbXCIkcm9vdFNjb3BlXCJdO1xuXHRmdW5jdGlvbiBBbGVydCgkcm9vdFNjb3BlKXtcblx0XHRyZXR1cm4ge1xuXHRcdFx0cmVzdHJpY3Q6ICdFQScsXG5cdFx0XHRzY29wZTogZmFsc2UsXG5cdFx0XHRjb21waWxlOiBmdW5jdGlvbigpe1xuXHRcdFx0XHRmdW5jdGlvbiBub3RpZnkoaWNvbiwgdGl0bGUsIG1lc3NhZ2UsIHR5cGUpIHtcblx0XHRcdFx0XHQkLm5vdGlmeSh7XG5cdFx0XHRcdFx0XHRpY29uOiBpY29uLFxuXHRcdFx0XHRcdFx0dGl0bGU6IHRpdGxlLFxuXHRcdFx0XHRcdFx0bWVzc2FnZTogbWVzc2FnZVxuXHRcdFx0XHRcdH0sIHtcblx0XHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0XHRvZmZzZXQ6IDUwLFxuXHRcdFx0XHRcdFx0dGltZXI6IDEwMCxcblx0XHRcdFx0XHRcdGRlbGF5OiAzNTAwLFxuXHRcdFx0XHRcdFx0b25TaG93OiAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ29uTm90aWZpY2F0aW9uU2hvdycpLFxuXHRcdFx0XHRcdFx0b25DbG9zZTogJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdvbk5vdGlmaWNhdGlvbkNsb3NlJyksXG5cdFx0XHRcdFx0XHRhbGxvd19kaXNtaXNzOiB0cnVlLFxuXHRcdFx0XHRcdFx0YW5pbWF0ZToge1xuXHRcdFx0XHRcdFx0XHRlbnRlcjogJ2FuaW1hdGVkIGJvdW5jZUluUmlnaHQnLFxuXHRcdFx0XHRcdFx0XHRleGl0OiAnYW5pbWF0ZWQgYm91bmNlT3V0UmlnaHQnXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0dGVtcGxhdGU6ICc8ZGl2IGRhdGEtbm90aWZ5PVwiY29udGFpbmVyXCIgY2xhc3M9XCJjb2wteHMtOSBjb2wtc20tMyBhbGVydCBhbGVydC17MH1cIiByb2xlPVwiYWxlcnRcIj4nICtcblx0XHRcdFx0XHRcdCc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzcz1cImNsb3NlXCIgZGF0YS1ub3RpZnk9XCJkaXNtaXNzXCI+w5c8L2J1dHRvbj4nICtcblx0XHRcdFx0XHRcdCc8c3BhbiBkYXRhLW5vdGlmeT1cImljb25cIj48L3NwYW4+ICcgK1xuXHRcdFx0XHRcdFx0JzxzcGFuIGRhdGEtbm90aWZ5PVwidGl0bGVcIj48Yj57MX08L2I+PC9zcGFuPjxicj4gJyArXG5cdFx0XHRcdFx0XHQnPHNwYW4gZGF0YS1ub3RpZnk9XCJtZXNzYWdlXCI+ezJ9PC9zcGFuPicgK1xuXHRcdFx0XHRcdFx0JzwvZGl2Pidcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdCRyb290U2NvcGUuJG9uKCdkYW5nZXJNZXNzYWdlJywgZnVuY3Rpb24gKGV2LCBkYXRhKSB7XG5cdFx0XHRcdFx0bm90aWZ5KCdnbHlwaGljb24gZ2x5cGhpY29uLWV4Y2xhbWF0aW9uLXNpZ24nLCBkYXRhLnRpdGxlLCBkYXRhLm1lc3NhZ2UsICdkYW5nZXInKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdCRyb290U2NvcGUuJG9uKCdzdWNjZXNzTWVzc2FnZScsIGZ1bmN0aW9uIChldiwgZGF0YSkge1xuXHRcdFx0XHRcdG5vdGlmeSgnZ2x5cGhpY29uIGdseXBoaWNvbi1vaycsIGRhdGEudGl0bGUsIGRhdGEubWVzc2FnZSwgJ3N1Y2Nlc3MnKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdCRyb290U2NvcGUuJG9uKCd3YXJuaW5nTWVzc2FnZScsIGZ1bmN0aW9uIChldiwgZGF0YSkge1xuXHRcdFx0XHRcdG5vdGlmeSgnZ2x5cGhpY29uIGdseXBoaWNvbi13YXJuaW5nLXNpZ24nLCBkYXRhLnRpdGxlLCBkYXRhLm1lc3NhZ2UsICd3YXJuaW5nJyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHQkcm9vdFNjb3BlLiRvbignaW5mb01lc3NhZ2UnLCBmdW5jdGlvbiAoZXYsIGRhdGEpIHtcblx0XHRcdFx0XHRub3RpZnkoJ2dseXBoaWNvbiBnbHlwaGljb24taW5mby1zaWduJywgZGF0YS50aXRsZSwgZGF0YS5tZXNzYWdlLCAnaW5mbycpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0YW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMuYWxlcnQnLFtdKVxuXHQuZGlyZWN0aXZlKCdndW1nYUFsZXJ0JyxBbGVydCk7XG59KSgpOyIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cblx0QnJlYWRjcnVtYi4kaW5qZWN0ID0gW1wiJHJvb3RTY29wZVwiXTtcblx0LyoqXG5cdCAqIEBuZ2RvYyBkaXJlY3RpdmVcblx0ICogQG5hbWUgZ3VtZ2EuY29yZTpndW1nYUJyZWFkY3J1bWJcblx0ICogQHJlc3RyaWN0IEVcblx0ICogQGRlc2NyaXB0aW9uIE8gY29tcG9uZW50ZSBHdW1nYUJyZWFkY3J1bWIgc2VydmUgcGFyYSBtb3N0cmFyIGFvIHVzdcOhcmlvIGEgbGlzdGEgZGFzIHDDoWdpbmFzIHZpc2l0YWRhcy4gRXN0ZSBjb21wb25lbnRlIGF0dWFtZW50ZVxuXHQgKiBmdW5jaW9uYSBjYXNvIGV4aXN0YSBkZXBlbmTDqm5jaWEgZG8gW3VpLXJvdXRlcl0oaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXItdWkvdWktcm91dGVyKS5cblx0ICogXG5cdCAqIE8gY29tcG9uZW50ZSBHdW1nYUJyZWFkY3J1bWIgb3V2ZSBhbyBldmVudG8gYGJyZWFkQ2hhbmdlZGAsIHF1ZSByZWNlYmUgb3Mgc3RhdGVzIHF1ZSBlc3TDo28gc2VuZG8gdmlzaXRhZG9zLiBVbWEgZGFzIGltcGxlbWVudGHDp8O1ZXMgcG9zc8OtdmVpcyBwYXJhIGVzc2Vcblx0ICogZXZlbnRvIGJyZWFkQ2hhbmdlZCDDqSBhIHNlZ3VpbnRlOlxuXHQgKiA8cHJlPlxuXHQgKiAkcm9vdFNjb3BlLmJyZWFkY3J1bWJzID0gW107XG4gICAgICAkcm9vdFNjb3BlLiRvbignJHN0YXRlQ2hhbmdlU3VjY2VzcycsIGZ1bmN0aW9uIChldmVudCwgdG9TdGF0ZSkge1xuICAgICAgICB1cGRhdGVCcmVhZGNydW1iKHRvU3RhdGUubmFtZSwgdG9TdGF0ZS5kYXRhLmlkKTtcbiAgICAgIH0pO1xuICAgICAgZnVuY3Rpb24gdXBkYXRlQnJlYWRjcnVtYihzdGF0ZSwgaWQpIHtcbiAgICAgICAgICBmdW5jdGlvbiBnZXQoaWQpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9ICRyb290U2NvcGUuYnJlYWRjcnVtYnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLmJyZWFkY3J1bWJzW2ldLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpZCAmJiBnZXQoaWQpID49IDApIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5icmVhZGNydW1icy5zcGxpY2UoZ2V0KGlkKSwgJHJvb3RTY29wZS5icmVhZGNydW1icy5sZW5ndGggLSBnZXQoaWQpLCB7c3RhdGU6IHN0YXRlLCBpZDogaWR9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLmJyZWFkY3J1bWJzLnB1c2goe3N0YXRlOiBzdGF0ZSwgaWQ6IGlkfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgICFpZCA/ICRyb290U2NvcGUuYnJlYWRjcnVtYnMgPSBbXSA6IGFuZ3VsYXIubm9vcDtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2JyZWFkQ2hhbmdlZCcpO1xuICAgICAgfVxuXHQgKiA8L3ByZT4gXG5cdCAqIEVzdGUgY8OzZGlnbyBmb2kgY29sb2NhZG8gZGVudHJvIGRvIGBydW5gIGRvIG3Ds2R1bG8gcHJpbmNpcGFsIGRhIGFwbGljYcOnw6NvLlxuXHQgKi9cblxuXHRmdW5jdGlvbiBCcmVhZGNydW1iKCRyb290U2NvcGUpe1xuXHRcdHZhciB0ZW1wbGF0ZSA9IFtcblx0XHQnPG9sIGNsYXNzPVwiYnJlYWRjcnVtYlwiPicsXG5cdFx0JzxsaSBuZy1yZXBlYXQ9XCJicmVhZCBpbiBicmVhZGNydW1ic1wiID48YSB1aS1zcmVmPVwie3s6OmJyZWFkLnN0YXRlfX1cIj57ezo6YnJlYWQuc3RhdGV9fTwvYT48L2xpPicsXG5cdFx0Jzwvb2w+J1xuXHRcdF07XG5cdFx0cmV0dXJuIHtcblx0XHRcdHJlc3RyaWN0OiAnRScsXG5cdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuam9pbignXFxuJyksXG5cdFx0XHRyZXBsYWNlOiB0cnVlLFxuXHRcdFx0bGluazogZnVuY3Rpb24oJHNjb3BlLCAkZWxtLCAkYXR0cnMpe1xuXHRcdFx0XHQkc2NvcGUuJG9uKCdicmVhZENoYW5nZWQnLGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0JHNjb3BlLmJyZWFkY3J1bWJzID0gJHJvb3RTY29wZS5icmVhZGNydW1icy5maWx0ZXIoZnVuY3Rpb24oZSl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZS5zdGF0ZS5zcGxpdCgnLicpLmxlbmd0aCA+PTIgO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cdGFuZ3VsYXIubW9kdWxlKCdndW1nYS5kaXJlY3RpdmVzLmJyZWFkY3J1bWInLFtdKVxuXHQuZGlyZWN0aXZlKCdndW1nYUJyZWFkY3J1bWInLEJyZWFkY3J1bWIpO1xufSkoKTsiLCIvLyBkZWZpbmUgPSBSZXF1aXJlLmpzXG4oZnVuY3Rpb24oKXtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgQ291bnRlci4kaW5qZWN0ID0gW1wiJGNvbXBpbGVcIl07XG4gICAgICAvKipcbiAgICAgICAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAgICAgICAqIEBuYW1lIGd1bWdhLmNvcmU6Z3VtZ2FDb3VudGVyXG4gICAgICAgKiBAZWxlbWVudCBpbnB1dFxuICAgICAgICogQGRlc2NyaXB0aW9uIE8gY29tcG9uZW50ZSBndW1nYUNvdW50ZXIgcGVybWl0ZSBlc2NvbGhlciB1bSB0YW1hbmhvIG3DoXhpbW8gcGVybWl0aWRvIG5vIGNhbXBvLCB0YW1iw6ltIGNyaWEgdW0gY29udGFkb3IgZGUgY2FyYWN0ZXJlcyBpbmRpY2FuZG8gc2Ugb3MgY2FyYWN0ZXJlc1xuICAgICAgICogcGFzc2FyYW0gZG8gbGltaXRlIG91IG7Do28uIFxuICAgICAgICogXG4gICAgICAgKiBDYXNvIHVtIHZhbG9yIHNlamEgcGFzc2FkbyBwYXJhIGEgZGlyZWN0aXZlLCBlbGEgYXR1YWxpemFyw6EgbyBjb250YWRvciBiYXNlYWRvIG5lc3NlIG7Dum1lcm8uIENhc28gbsOjbywgZWxhIHBlZ2Fyw6EgbyB2YWxvclxuICAgICAgICogcGFzc2FkbyBwYXJhIGEgZGlyZWN0aXZlIHtAbGluayBndW1nYS5jb3JlOmd1bWdhTWF4TGVuZ3RofVxuICAgICAgICogXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogIFVtIGV4ZW1wbG8gZGEgZGlyZWN0aXZlIGd1bWdhQ291bnRlciBmdW5jaW9uYW5kbyBwb2RlIHNlciBlbmNvbnRyYWRvIFthcXVpXShodHRwOi8vZW1iZWQucGxua3IuY28vNnhKdVV1aUk0NTZrcWJYTjNRNmYvKS5cbiAgICAgICAqIDxwcmU+XG4gICAgICAgKiA8aW5wdXQgbmFtZT1cImV4YW1wbGVcIiBuZy1tb2RlbD1cImV4YW1wbGVcIiBndW1nYS1jb3VudGVyPVwiMTVcIiAvPlxuICAgICAgICogPC9wcmU+XG4gICAgICAqL1xuXG4gICAgICBmdW5jdGlvbiBDb3VudGVyKCRjb21waWxlKXtcbiAgICAgICAgICAgIHJldHVybntcbiAgICAgICAgICAgICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbSwgYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuX21heCA9IHBhcnNlSW50KGF0dHJzLmd1bWdhTWF4TGVuZ3RoVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VJbnQoYXR0cnMuZ3VtZ2FDb3VudGVyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLl9tYXggPSBwYXJzZUludChhdHRycy5ndW1nYUNvdW50ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9ICc8cCBjbGFzcz1cInt7X21heCA8PSB0ZXN0ZS5sZW5ndGggPyBcXCd0ZXh0LWRhbmdlclxcJyA6IFxcJ3RleHQtbXV0ZWRcXCd9fVwiPnt7X21heCA8PSAnKyBhdHRycy5uZ01vZGVsICsnLmxlbmd0aCA/IFwiVm9jw6ogcGFzc291IG8gbGltaXRlIGRlICcrc2NvcGUuX21heCsnIGNhcmFjdGVyZXNcIiA6IF9tYXggLSAnKyBhdHRycy5uZ01vZGVsICsnLmxlbmd0aCArIFwiIGNhcmFjdGVyZXMgcmVzdGFudGVzXCIgfX08L3A+JztcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5hZnRlcigkY29tcGlsZSh0ZW1wbGF0ZSkoc2NvcGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5jb3VudGVyJywgW10pXG4gICAgICAgIC5kaXJlY3RpdmUoJ2d1bWdhQ291bnRlcicsIENvdW50ZXIpO1xuXG5cbn0pKCk7XG4iLCIiLCIoZnVuY3Rpb24gKCkge1xuXG5cbiAgYW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMuZm9ybScsW1xuICAgICdndW1nYS5kaXJlY3RpdmVzLmZvcm0uZm9ybScsXG4gICAgJ2d1bWdhLmRpcmVjdGl2ZXMuZm9ybS5lcnJvcnMnLFxuICAgICdndW1nYS5kaXJlY3RpdmVzLmZvcm0uZXJyb3InLFxuICAgICdndW1nYS5kaXJlY3RpdmVzLmZvcm0ubWF4LmRhdGUnLFxuICAgICdndW1nYS5kaXJlY3RpdmVzLmZvcm0ubWF4Lmxlbmd0aCcsXG4gICAgJ2d1bWdhLmRpcmVjdGl2ZXMuZm9ybS5tYXgubnVtYmVyJyxcbiAgICAnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtLm1pbi5kYXRlJyxcbiAgICAnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtLm1pbi5sZW5ndGgnLFxuICAgICdndW1nYS5kaXJlY3RpdmVzLmZvcm0ubWluLm51bWJlcicsXG4gICAgJ2d1bWdhLmRpcmVjdGl2ZXMuZm9ybS5wYXR0ZXJuJyxcbiAgICAnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtLnJhbmdlLmRhdGUnLFxuICAgICdndW1nYS5kaXJlY3RpdmVzLmZvcm0ucmFuZ2UubnVtYmVyJyxcbiAgICAnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtLnJlcXVpcmVkJyxcbiAgICAnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtYnV0dG9ucydcbiAgXSlcblxuXG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBAbmdkb2MgZGlyZWN0aXZlXG4gICAgICogQG5hbWUgZ3VtZ2EuY29yZTpndW1nYUZvcm1CdXR0b25zXG4gICAgICogQHJlc3RyaWN0IEVcbiAgICAgKiBAZGVzY3JpcHRpb24gTyBjb21wb25lbnRlIGd1bWdhRm9ybUJ1dHRvbnMgcG9kZSBzZXIgdXRpbGl6YWRvIHBhcmEgcXVhbmRvIG5lY2Vzc2l0ZSBkZSBib3TDtWVzIHBhcmEgbyBmb3JtdWzDoXJpbyxcbiAgICAgKiB0YW50byBkZSBjb250aW51YXIgaW5zZXJpbmRvLCBkZSBzYWx2YXIgZSByZXRyb2NlZGVyLlxuICAgICAqXG4gICAgICogIEBwYXJhbSB7RnVuY3Rpb259IHN1Ym1pdCBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgY29udMOpbSB1bWEgZnVuw6fDo28gcXVlIHNlcsOhIGV4ZWN1dGFkYSBxdWFuZG8gbyBib3TDo28gZGUgY29udGludWFyIGZvciBjbGljYWRvLlxuICAgICAqICBAcGFyYW0ge2Jvb2xlYW59IHZhbGlkIFBhcsOibWV0cm8gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bSB2YWxvciBib29sZWFubyBwYXJhIHZhbGlkYXIgY2FzbyBvIGZvcm11bMOhcmlvIMOpIHbDoWxpZG8gcGFyYSBsaWJlcmFyIG8gYm90w6NvIGRlIHNhbHZhci5cbiAgICAgKiAgQHBhcmFtIHtPYmplY3R9IGNvbnRpbnVlIE9iamVjdCBxdWUgZGV2ZXLDoSBjb250ZXIgdW0gYXRyaWJ1dG8gYm9vbGVhbm8gY2hhbWFkbyBgdmFsdWVgLCBwYXJhIGNvbnRyb2xhciBjYXNvIGNvbnRpbnVhcsOhIGluc2VyaW5kbyBvdSBuw6NvLiBFc3NhIFxuICAgICAqICBvcMOnw6NvIGFwYXJlY2Vyw6EgYXBlbmFzIHF1YW5kbyBvIG9iamV0byAkc3RhdGVQYXJhbXMocGVydGVuY2VudGUgYW8gdWktcm91dGVyKSBuw6NvIHBvc3N1aXIgdW0gaWQsIG91IHNlamEsIGNhc28gZXN0ZWphIG51bWEgdGVsYSBkZSBpbnNlcsOnw6NvLlxuICAgICAqICBAcGFyYW0ge2Jvb2xlYW59IGNvbmZpcm0tZGlydHkgUGFyw6JtZXRybyBuw6NvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW0gYm9vbGVhbm8gcGFyYSBpbmRpY2FyIGNhc28gZGVzZWplIHRlciB1bWEgY29uZmlybWHDp8OjbyBkZSBzYcOtZGEgZG8gZm9ybXVsw6FyaW9cbiAgICAgKiAgcXVhbmRvIGVzdGUgZm9pIGFsdGVyYWRvIGFsZ3VtYSB2ZXouXG4gICAgICovXG5cdEZvcm1CdXR0b25zLiRpbmplY3QgPSBbXCIkc3RhdGVcIiwgXCIkc3RhdGVQYXJhbXNcIiwgXCIkbW9kYWxcIiwgXCIkcm9vdFNjb3BlXCJdO1xuICAgIGZ1bmN0aW9uIEZvcm1CdXR0b25zKCRzdGF0ZSwgJHN0YXRlUGFyYW1zLCRtb2RhbCwkcm9vdFNjb3BlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgICAgICBkbzogJyZzdWJtaXQnLFxuICAgICAgICAgICAgICAgIHZhbGlkOiAnPScsXG4gICAgICAgICAgICAgICAgY29udGludWU6ICc9PycsXG4gICAgICAgICAgICAgICAgY29uZmlybURpcnR5OiAnPT8nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGU6XG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZ1bGwtd2lkdGgtd2l0aG91dC1tYXJnaW5cIj4nK1xuICAgICAgICAgICAgJyAgIDxzY29wZT48L3Njb3BlPicrXG4gICAgICAgICAgICAnICAgPGRpdiBuZy1jbGFzcz1cImdldFBvc2l0aW9uKClcIj4nICtcbiAgICAgICAgICAgICcgICAgICAgPGxhYmVsIGlkPVwiY29udGludWFySW5zZXJpbmRvXCIgbmctaWY9XCJjb250aW51ZVwiID4nK1xuICAgICAgICAgICAgJyAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5hbWU9XCJjb250aW51YXJcIiBuZy1tb2RlbD1cImNvbnRpbnVlLnZhbHVlXCIvPicgK1xuICAgICAgICAgICAgJyAgICAgICAgICAgPHNwYW4+Q29udGludWFyIEluc2VyaW5kbzwvc3Bhbj4nK1xuICAgICAgICAgICAgJyAgICAgICA8L2xhYmVsPicgK1xuICAgICAgICAgICAgJyAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDAuOGVtXCIgbmctY2xpY2s9XCJiYWNrKClcIiB0eXBlPVwiYnV0dG9uXCI+PGkgY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLWZsb3BweS1yZW1vdmVcIj48L2k+IEJhY2s8L2J1dHRvbj4nICtcbiAgICAgICAgICAgICcgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAwXCIgbmctY2xpY2s9XCJkbygpXCIgbmctZGlzYWJsZWQ9XCIhdmFsaWRcIiB0eXBlPVwiYnV0dG9uXCI+PGkgY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLWZsb3BweS1zYXZlZFwiPjwvaT4gU2F2ZTwvYnV0dG9uPicgK1xuICAgICAgICAgICAgJyAgIDwvZGl2PicrXG4gICAgICAgICAgICAnPGRpdj4nLFxuICAgICAgICAgICAgcmVxdWlyZTogJ15mb3JtJyxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxtLCBhdHRycywgY3RybCkge1xuICAgICAgICAgICAgICAgIGlmKCFhdHRycy5jb25maXJEaXJ0eSkgc2NvcGUuY29uZmlybURpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZighJHN0YXRlUGFyYW1zLmlkKSBzY29wZS5pbk5ldyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYoIWF0dHJzLmNvbnRpbnVlKSBzY29wZS5jb250aW51ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgc2NvcGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRycy5wb3NpdGlvbiA9PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAncHVsbC1sZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3B1bGwtcmlnaHQnO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBzY29wZS5iYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZihzY29wZS5jb25maXJtRGlydHkgJiYgY3RybC4kZGlydHkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGFsID0gJG1vZGFsLm9wZW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2PicrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyAgIDxzZWN0aW9uIGNsYXNzPVwibW9kYWwtYm9keVwiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgICAgICAgPGg0PkRlc2VqYSBzYWlyIHNlbSBzYWx2YXIgYXMgYWx0ZXJhw6fDtWVzPzwvaDQ+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyAgIDwvc2VjdGlvbj4nK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgICA8ZGl2IGNsYXNzPVwibW9kYWwtZm9vdGVyXCI+JytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLWRlZmF1bHRcIiBuZy1jbGljaz1cImhhbmRsZUNsb3NlKGZhbHNlKVwiPk7Do288L2J1dHRvbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLWRlZmF1bHRcIiBuZy1jbGljaz1cImhhbmRsZUNsb3NlKHRydWUpXCI+U2ltPC9idXR0b24+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyAgIDwvZGl2PicrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2Ryb3A6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleWJvYXJkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiAnc20nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtcIiRzY29wZVwiLCBcIiRtb2RhbEluc3RhbmNlXCIsIFwiJHN0YXRlXCIsIFwiJHJvb3RTY29wZVwiLCBmdW5jdGlvbigkc2NvcGUsJG1vZGFsSW5zdGFuY2UsJHN0YXRlLCRyb290U2NvcGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuaGFuZGxlQ2xvc2UgPSBmdW5jdGlvbihfYm9vbGVhbil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYm9vbGVhbiA/ICRtb2RhbEluc3RhbmNlLmNsb3NlKHRydWUpIDogJG1vZGFsSW5zdGFuY2UuY2xvc2UoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9OyAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCRzdGF0ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY3VycmVudFN0YXRlID0kc3RhdGUuY3VycmVudC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kb24oJyRzdGF0ZUNoYW5nZVN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihldmVudCwgdG9TdGF0ZSwgdG9QYXJhbXMsIGZyb21TdGF0ZSwgZnJvbVBhcmFtcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtb2RhbEluc3RhbmNlLmRpc21pc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kYWwucmVzdWx0LnRoZW4oZnVuY3Rpb24oc2hvdWxkSUdvKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzaG91bGRJR28pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oYXR0cnMuYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbyhhdHRycy5iYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG4gICAgfVxuXG5hbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtYnV0dG9ucycsWyd1aS5ib290c3RyYXAnLCd1aS5yb3V0ZXInXSlcbi5kaXJlY3RpdmUoJ2d1bWdhRm9ybUJ1dHRvbnMnLEZvcm1CdXR0b25zKTtcblxufSkoKTsiLCIoZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgTGlzdC4kaW5qZWN0ID0gW1wiR3VtZ2FMaXN0SGVscGVyXCIsIFwiJGNvbXBpbGVcIl07XG5cbiAgZnVuY3Rpb24gTGlzdChHdW1nYUxpc3RIZWxwZXIsJGNvbXBpbGUpe1xuICAgIC8qKlxuICAgICogQG5nZG9jIGRpcmVjdGl2ZVxuICAgICogQG5hbWUgZ3VtZ2EuY29yZTpndW1nYUxpc3RcbiAgICAqIEByZXN0cmljdCBFXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqIFx0QSBkaXJlY3RpdmUgZ3VtZ2FMaXN0IGZvaSBkZXNlbnZvbHZpZGEgcGFyYSBzdWJzdGl0dWlyIGEgYW50aWdhIGd1bWdhVGFibGUuIEVsYSDDqSBtYWlzIGNvbmZpZ3Vyw6F2ZWwgcXVlIGEgYW50aWdhIHRhYmxlLCBlIHRyYXogdW0gbWVpbyBtYWlzIGbDoWNpbCBkZSBjb25maWd1cmFyLlxuICAgICogIFx0TyBjb21wb25lbnRlIHBvc3N1aSBkb2lzIHRpcG9zIGRlIGNvbmZpZ3VyYcOnw6NvOiBkaXJldGFtZW50ZSBubyBodG1sIGUgYXRyYXbDqXMgZGUgdW0gb2JqZXRvIGphdmFzY3JpcHQuXG4gICAgKlxuICAgICogXHQjIENvbmZpZ3VyYcOnw6NvIGRhIHRhYmxlIGF0cmF2w6lzIGRlIHVtIE9iamV0byBKYXZhc2NyaXB0XG4gICAgKlxuICAgICpcdFx0UGFyYSBhcGxpY2FyIGEgY29uZmlndXJhw6fDo28gbmEgdGFibGUsIGV4aXN0ZW0gb3Mgc2VndWludGVzIGF0cmlidXRvczpcbiAgICAqXG4gICAgKiB8IFBhcmFtIHwgVHlwZSAgfCBEZWZhdWx0IHwgRGV0YWlscyB8XG4gICAgKiB8LS0tLS0tLXwtLS0tLS0tfC0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tfFxuICAgICogfHNlbGVjdGlvbnxTdHJpbmd8IHNpbmdsZSB8IFZhbG9yIHF1ZSBzZXLDoSB1dGlsaXphZG8gcGFyYSBkZWZpbmlyIGNvbW8gc2Vyw6EgYSBzZWxlw6fDo28gZGEgdGFiZWxhLiBQb3Nzw612ZWlzIHZhbG9yZXM6IDxsYWJlbCBjbGFzcz1cImxhYmVsIHR5cGUtaGludCB0eXBlLWhpbnQtc3RyaW5nXCI+W211bHRpIC8gc2luZ2xlXTwvbGFiZWw+IHxcbiAgICAqIHxpdGVtc1BlclBhZ2V8QXJyYXl8IFsxMCwyMCwzMCw0MCw1MF0gfCBWYWxvciBxdWUgc2Vyw6EgdXRpbGl6YWRvIHBhcmEgZGVmaW5pciBvIG7Dum1lcm8gZGUgcmVnaXN0cm9zIHNlbGVjaW9uYWRvIHBlbG8gdXN1w6FyaW8uIE8gdmFsb3IgZXNjb2xoaWRvIHNlcsOhIGV4cG9zdG8gbm8gJHNjb3BlIGF0cmF2w6lzIGRhIHZhcmnDoXZlbCBpdGVtc1BlclBhZ2UgfFxuICAgICogfHNvcnREZWZhdWx0IHwgU3RyaW5nIHwgfCBWYWxvciBxdWUgc2Vyw6EgdXRpbGl6YWRvIHBhcmEgZGVmaW5pciBxdWFsIG8gY2FtcG8gcGFkcsOjbyBkZSBvcmRlbmHDp8Ojby4gRXN0ZSB2YWxvciBzZXLDoSBvIGlkZW50aWZpY2Fkb3IgZGEgY29sdW5hLlxuICAgICogfGNvbHVtbnMgfFN0cmluZ3wgfCBWYWxvciBxdWUgaXLDoSBkZWZpbmlyIHF1YWlzIGFzIGNvbHVuYXMgZSBhIG9yZGVuYcOnw6NvIGRlbGFzLiBPIGZvcm1hdG8gZGV2ZSBlc3RhciBubyBzZWd1aW50ZSBwYWRyw6NvOiA8bGFiZWwgY2xhc3M9XCJsYWJlbCB0eXBlLWhpbnQgdHlwZS1oaW50LXN0cmluZ1wiPltjb2x1bW4xLGNvbHVtbjIsLi4uLGNvbHVtbk5dPC9sYWJlbD5cbiAgICAqIHxjb25kaXRpb25hbCB8IEZ1bmN0aW9uIHwgYW5ndWxhci5ub29wIHwgVmFsb3IgcXVlIHNlcsOhIHV0aWxpemFkbyBwYXJhIGZhemVyIGEgZm9ybWF0YcOnw6NvIGNvbmRpY2lvbmFsIGRvIHJlZ2lzdHJvLiBBIGZ1bsOnw6NvIGRldmUgcmV0b3JuYXIgdW0gb2JqZXRvIHF1ZSBjb250w6ltIGEgY2xhc3NlIGUgYSBjb21wYXJhw6fDo28gdXRpbGl6YWRhIDxsYWJlbCBjbGFzcz1cImxhYmVsIHR5cGUtaGludCB0eXBlLWhpbnQtc3RyaW5nXCI+W2Z1bmN0aW9uKHZhbHVlKXsgcmV0dXJuIHsnMnB4IHNvbGlkIHJlZCc6IHZhbHVlLmFnZSA8IDE4fSB9XTwvbGFiZWw+XG4gICAgKiB8Y29sdW1uc0NvbmZpZyB8QXJyYXkgfFtdfCBBcnJheSBxdWUgc2Vyw6EgdXRpbGl6YWRvIHBhcmEgY29uZmlndXJhciBhcyBjb2x1bmFzIHF1ZSBmb3JhbSBkZWZpbmlkYXMgbm8gYXRyaWJ1dG8gY29sdW1ucy5cbiAgICAqXG4gICAgKiAjIENvbmZpZ3VyYcOnw6NvIGRhIGNvbHVuYSBhdHJhdsOpcyBkZSB1bSBPYmpldG8gSmF2YXNjcmlwdFxuICAgICpcdFBhcmEgY29uZmlndXJhciBhcyBjb2x1bmFzLCBkZW50cm8gZG8gYXRyaWJ1dG8gY29sdW1uc0NvbmZpZywgc8OjbyBjcmlhZG9zIG9iamV0b3MgcXVlIHBvZGVyw6NvIHRlciBhcyBzZWd1aW50ZXMgY29uZmlndXJhw6fDtWVzOlxuICAgICpcbiAgICAqIHwgUGFyYW0gfCBUeXBlICB8IERlZmF1bHQgfCBEZXRhaWxzIHxcbiAgICAqIHwtLS0tLS0tfC0tLS0tLS18LS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS18XG4gICAgKiB8bmFtZSB8IFN0cmluZyB8ICB8IFZhbG9yIHF1ZSBzZXLDoSB1dGlsaXphZG8gcGFyYSBpZGVudGlmaWNhciBhIGNvbHVuYS4gRXN0ZSBuYW1lIGRldmUgc2VyIG8gbWVzbW8gcXVlIGVzdMOhIG5vIGF0cmlidXRvICdjb2x1bW5zJyxcbiAgICAqIHx0aXRsZXxTdHJpbmd8IE5PTUVfREFfQ09MVU5BLnRvVXBwZXJDYXNlKCkgfCBWYWxvciBxdWUgc2Vyw6EgcmVuZGVyaXphZG8gbm8gdMOtdHVsbyBkYSBjb2x1bmEuXG4gICAgKiB8c2l6ZXxTdHJpbmd8ICdjb2wtbWQtMycgfCBUYW1hbmhvIGRhIGNvbHVuYSBiYXNlYWRvIG5vcyB2YWxvcmVzIGRvIGJvb3RzdHJhcC4gRXhlbXBsbzogKiogY29sLW1kLXggKipcbiAgICAqIHxjb250ZW50IHxTdHJpbmd8e3skdmFsdWUuTk9NRV9EQV9DT0xVTkF9fSB8IFZhbG9yIHF1ZSBzZXLDoSByZW5kZXJpemFkbyBubyBjb250ZcO6ZG8gZGEgY29sdW5hLlxuICAgICogfHNvcnRGaWVsZCB8U3RyaW5nIHwgfCBTdHJpbmcgcXVlIHNlcsOhICB1c2FkYSBwYXJhIGZhemVyIGEgb3JkZW5hw6fDo28sIGUgcXVlIGlyw6EgY29tbyBwYXLDom1ldHJvIG5hIGZ1bsOnw6NvIGRlIG9yZGVuYcOnw6NvLi5cbiAgICAqIHxjb25kaXRpb25hbCB8IEZ1bmN0aW9uIHwgYW5ndWxhci5ub29wIHwgVmFsb3IgcXVlIHNlcsOhIHV0aWxpemFkbyBwYXJhIGZhemVyIGEgZm9ybWF0YcOnw6NvIGNvbmRpY2lvbmFsIGRvIHJlZ2lzdHJvLiBBIGZ1bsOnw6NvIGRldmUgcmV0b3JuYXIgdW0gb2JqZXRvIHF1ZSBjb250w6ltIGEgY2xhc3NlIGUgYSBjb21wYXJhw6fDo28gdXRpbGl6YWRhIDxsYWJlbCBjbGFzcz1cImxhYmVsIHR5cGUtaGludCB0eXBlLWhpbnQtc3RyaW5nXCI+W2Z1bmN0aW9uKHZhbHVlKXsgcmV0dXJuIHsnMnB4IHNvbGlkIHJlZCc6IHZhbHVlLmFnZSA8IDE4fSB9XTwvbGFiZWw+XG4gICAgKlxuICAgICpcbiAgICAqXHQgIEBwYXJhbSB7RnVuY3Rpb259IHNvcnQgUGFyw6JtZXRybyBxdWUgY29udMOpbSB1bWEgZnVuw6fDo28gcXVlIHNlcsOhIGNoYW1hZGEgcGFyYSBxdWUgbyBkZXNlbnZvbHZlZG9yIHBvc3NhIGZhemVyIGEgb3JkZW5hw6fDo28gZG9zIHJlZ2lzdHJvcy5cbiAgICAqXHQgIEBwYXJhbSB7U3RyaW5nfSBjbGFzcyBQYXLDom1ldHJvIHBhcmEgYXBsaWNhciBuYSB0YWJsZSB1bWEgY2xhc3NlIGVzcGVjw61maWNhLlxuICAgICpcdCAgQHBhcmFtIHtBcnJheX0gZGF0YSBQYXLDom1ldHJvIHF1ZSBpcsOhIGNvbnRlciBvcyBkYWRvcyBxdWUgc2Vyw6NvIG1vc3RyYWRvcyBuYSB0YWJlbGEuXG4gICAgKlx0ICBAcGFyYW0ge0Z1bmN0aW9ufSBvbkNsaWNrIEZ1bsOnw6NvIHF1ZSBzZXLDoSBleGVjdXRhZGEgcXVhbmRvIG8gdXN1w6FyaW8gY2xpY2FyIGVtIHVtIHJlZ2lzdHJvXG4gICAgKlx0ICBAcGFyYW0ge0Z1bmN0aW9ufSBvblNvcnQgRnVuw6fDo28gcXVlIHNlcsOhIGV4ZWN1dGFkYSBxdWFuZG8gYSBvcmRlbmHDp8OjbyBmb3IgcmVhbGl6YWRhXG4gICAgKlx0ICBAcGFyYW0ge0Z1bmN0aW9ufSBvbkRvdWJsZUNsaWNrIEZ1bsOnw6NvIHF1ZSBzZXLDoSBleGVjdXRhZGEgcXVhbmRvIG8gdXN1w6FyaW8gY2xpY2FyIGR1YXMgdmV6ZXMgZW0gdW0gcmVnaXN0cm8uXG4gICAgKi9cblxuXG4gICAgZnVuY3Rpb24gY3RybCgkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMsICR0cmFuc2NsdWRlKXtcbiAgICAgIGZ1bmN0aW9uIHZlcmlmeUVtcHR5KCR2LG90aGVyKXtyZXR1cm4gKCEkYXR0cnMuJHYgPyBvdGhlciA6IHZtWyR2XSl9O1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIC8vIFZhbG9yZXMgdXRpbGl6YWRvcyBwZWxhIGFwbGljYcOnw6NvXG4gICAgICB2bS5zZWxlY3RlZEluZGV4ZXMgPSBbXVxuICAgICAgdm0uc2VsZWN0ZWRJdGVtO1xuICAgICAgdm0uc2VsZWN0ZWRJdGVtRGlyO1xuICAgICAgdm0uJHBhcmVudCA9ICRzY29wZS4kcGFyZW50O1xuXG4gICAgICAvLyBGdW7Dp8O1ZXMgdXRpbGl6YWRhc1xuICAgICAgdm0uc29ydFByb3h5ID0gc29ydFByb3h5O1xuICAgICAgdm0uc2VsZWN0Um93ID0gc2VsZWN0Um93O1xuICAgICAgdm0uZG91YmxlID0gZG91YmxlOycnXG4gICAgICB2bS5jb25kaXRpb25hbCA9IGNvbmQ7XG4gICAgICB2bS5jb25kaXRpb25hbFRhYmxlQ2VsbCA9IGNvbmRpdGlvbmFsVGFibGVDZWxsO1xuICAgICAgdm0uc2VsZWN0QWxsID0gc2VsZWN0QWxsO1xuICAgICAgLy8gVmFsb3JlcyBxdWUgc2Vyw6NvIGV4cG9zdG9zIG5vICRzY29wZVxuICAgICAgJHNjb3BlLiRwYXJlbnQuc2VsZWN0ZWRWYWx1ZXMgPSBbXTtcbiAgICAgICRzY29wZS4kcGFyZW50Lml0ZW1zUGVyUGFnZTtcbiAgICAgIC8vIE7Dum1lcm8gZGUgaXRlbnMgbmEgcMOhZ2luYVxuICAgICAgdm0ucGFnZSA9ICRzY29wZS4kcGFyZW50Lml0ZW1zUGVyUGFnZTtcblxuICAgICAgdm0ub3JpZ2luYWxEYXRhID0gdm0uZGF0YTtcbiAgICAgIHZtLmRhdGEgPSBhbmd1bGFyLmNvcHkodm0uZGF0YSkgfHwgW107XG4gICAgICB2bS5jb25maWcgPSB2bS5jb25maWcgfHwge31cbiAgICAgIHZtLmRhdGEuZm9yRWFjaChmdW5jdGlvbih2YWwpe3ZhbC5fX2NoZWNrZWQgPSBmYWxzZTt9KTtcbiAgICAgIHZtLmNvbmZpZy5zZWxlY3Rpb24gPSB2bS5jb25maWcuc2VsZWN0aW9uIHx8ICdzaW5nbGUnO1xuICAgICAgdm0uY29uZmlnLnNvcnREZWZhdWx0ID0gdm0uY29uZmlnLnNvcnREZWZhdWx0O1xuICAgICAgdm0uY29uZmlnLml0ZW1zUGVyUGFnZSA9IHZtLmNvbmZpZy5pdGVtc1BlclBhZ2UgfHwgWzEwLDIwLDMwLDQwLDUwXTtcbiAgICAgIHZtLmNvbmZpZy5jb2x1bW5zQ29uZmlnID0gdm0uY29uZmlnLmNvbHVtbnNDb25maWcgfHwgW107XG4gICAgICB2bS5jb25maWcuY29uZGl0aW9uYWwgPSB2bS5jb25maWcuY29uZGl0aW9uYWwgfHwgYW5ndWxhci5ub29wO1xuICAgICAgdm0uY29uZmlnLnNvcnQgPSB2ZXJpZnlFbXB0eSgnc29ydCcsYW5ndWxhci5ub29wKTtcbiAgICAgIHZtLmNvbmZpZy5jbGFzcyA9ICRhdHRycy5jbGFzcyA/ICd0YWJsZSAnICsgJGF0dHJzLmNsYXNzIDogJ3RhYmxlJztcbiAgICAgIHZtLmNvbmZpZy5vbkNsaWNrID0gdmVyaWZ5RW1wdHkoJ29uQ2xpY2snLGFuZ3VsYXIubm9vcCk7XG4gICAgICB2bS5jb25maWcub25Eb3VibGVDbGljayA9IHZlcmlmeUVtcHR5KCdvbkRvdWJsZWxpY2snLGFuZ3VsYXIubm9vcCk7XG4gICAgICB2bS5jb25maWcub25Tb3J0ID0gdmVyaWZ5RW1wdHkoJ29uU29ydCcsYW5ndWxhci5ub29wKTtcbiAgICAgIGlmKHZtLmNvbmZpZy5zb3J0RGVmYXVsdClzb3J0UHJveHkodm0uY29uZmlnLnNvcnREZWZhdWx0KTtcbiAgICAgIGlmICh2bS5kYXRhICYmIHZtLmRhdGEubGVuZ3RoID4gMCl7XG4gICAgICAgIHZtLmNvbmZpZy5jb2x1bW5zID1cbiAgICAgICAgISF2bS5jb25maWcuY29sdW1ucyA/XG4gICAgICAgIEd1bWdhTGlzdEhlbHBlci5lbnN1cmVEZWZhdWx0VmFsdWVzKHZtLmNvbmZpZy5jb2x1bW5zLnNwbGl0KCcsJyksdm0uY29uZmlnLmNvbHVtbnNDb25maWcpIDogR3VtZ2FMaXN0SGVscGVyLmxvYWREZWZhdWx0Q29sdW1ucyh2bS5kYXRhWzBdKTtcbiAgICAgICAgdm0uY29uZmlnLmF1eENvbHVtbnNUb1NvcnQgPSB2bS5jb25maWcuY29sdW1ucztcbiAgICAgIH1cblxuICAgICAgJGVsZW1lbnQuYXBwZW5kKCRjb21waWxlKEd1bWdhTGlzdEhlbHBlci5tb3VudFRhYmxlKHZtLmNvbmZpZykpKCRzY29wZSkpO1xuXG4gICAgICBmdW5jdGlvbiBzZWxlY3RBbGwoY2hlY2tib3hCb29sZWFuKXtcbiAgICAgICAgY2xlYW5BcnJheXMoKTtcbiAgICAgICAgdm0uZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEsaW5kZXgpe1xuICAgICAgICAgIGRhdGEuX19jaGVja2VkID0gY2hlY2tib3hCb29sZWFuO1xuICAgICAgICAgIGlmKGNoZWNrYm94Qm9vbGVhbilwdXNoVG9BcnJheXMoZGF0YSxpbmRleCk7XG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZpbmRJbk9yaWdpbmFsQXJyYXkodmFsKXtcbiAgICAgICAgdmFyIGNvcHlXaXRob3V0Q2hlY2tlZEF0dHJpYnV0ZXMgPSBhbmd1bGFyLmNvcHkodmFsKTtcbiAgICAgICAgZGVsZXRlIGNvcHlXaXRob3V0Q2hlY2tlZEF0dHJpYnV0ZXMuX19jaGVja2VkO1xuICAgICAgICByZXR1cm4gdm0ub3JpZ2luYWxEYXRhLmZpbHRlcihmdW5jdGlvbihvcmlnaW5hbFJlZ2lzdHJ5KXtcbiAgICAgICAgICByZXR1cm4gYW5ndWxhci5lcXVhbHMob3JpZ2luYWxSZWdpc3RyeSxjb3B5V2l0aG91dENoZWNrZWRBdHRyaWJ1dGVzKTtcbiAgICAgICAgfSlbMF07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjbGVhbkFycmF5cygpe1xuICAgICAgICAkc2NvcGUuJHBhcmVudC5zZWxlY3RlZFZhbHVlcyA9IFtdO1xuICAgICAgICB2bS5zZWxlY3RlZEluZGV4ZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHB1c2hUb0FycmF5cyh2YWwsaW5kZXgpe1xuICAgICAgICB2bS5zZWxlY3RlZEluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICRzY29wZS4kcGFyZW50LnNlbGVjdGVkVmFsdWVzLnB1c2goZmluZEluT3JpZ2luYWxBcnJheSh2YWwpKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHNldEV2ZXJ5Q2hlY2tlZFRvQm9vbGVhbihib29sKXtcbiAgICAgICAgdm0uZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGVsbSl7XG4gICAgICAgICAgZWxtLl9fY2hlY2tlZCA9IGJvb2w7XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjbGVhblZhbHVlQW5kQXJyYXlzKGNsYXVzZSx2YWx1ZSl7XG4gICAgICAgIGlmKGNsYXVzZSl7XG4gICAgICAgICAgc2V0RXZlcnlDaGVja2VkVG9Cb29sZWFuKGZhbHNlKTtcbiAgICAgICAgICBjbGVhbkFycmF5cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHZhbHVlKSB2YWx1ZSA9IGZhbHNlO1xuICAgICAgfVxuXG5cbiAgICAgIGZ1bmN0aW9uIHNlbGVjdFJvdyhuZ1JlcGVhdEluZGV4LG5nUmVwZWF0VmFsdWUsJGV2ZW50KXtcbiAgICAgICAgaWYoJGV2ZW50LnRhcmdldC50eXBlID09ICdidXR0b24nIHx8ICRldmVudC50YXJnZXQudGFnTmFtZSA9PSAnQScpe1xuICAgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VsZWN0ZWRWYWx1ZXMgPSAkc2NvcGUuJHBhcmVudC5zZWxlY3RlZFZhbHVlcztcbiAgICAgICAgY2xlYW5WYWx1ZUFuZEFycmF5cyh2bS5jaGVja0FsbCx2bS5jaGVja0FsbCk7XG4gICAgICAgIGlmKCRhdHRycy5vbkNsaWNrKXZtLm9uQ2xpY2soe3ZhbHVlOiBuZ1JlcGVhdFZhbHVlfSk7XG4gICAgICAgIGlmKHZtLmNvbmZpZy5zZWxlY3Rpb24gPT0gJ3NpbmdsZScpe1xuICAgICAgICAgIGlmKG5nUmVwZWF0VmFsdWUuX19jaGVja2VkKXtcbiAgICAgICAgICAgIG5nUmVwZWF0VmFsdWUuX19jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgICBjbGVhbkFycmF5cygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhblZhbHVlQW5kQXJyYXlzKHZtLnNlbGVjdGVkSW5kZXhlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcHVzaFRvQXJyYXlzKG5nUmVwZWF0VmFsdWUsbmdSZXBlYXRJbmRleCk7XG4gICAgICAgICAgICBuZ1JlcGVhdFZhbHVlLl9fY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5nUmVwZWF0VmFsdWUuX19jaGVja2VkID0gdm0uc2VsZWN0ZWRJbmRleGVzLmZpbHRlcihmdW5jdGlvbih2YWwpe3JldHVybiB2YWwgPT0gbmdSZXBlYXRJbmRleH0pLmxlbmd0aCA8IDE7XG4gICAgICAgICAgaWYoKG5nUmVwZWF0VmFsdWUuX19jaGVja2VkKSB8fCB2bS5zZWxlY3RlZEluZGV4ZXMubGVuZ3RoID09IDAgKXtcbiAgICAgICAgICAgIHB1c2hUb0FycmF5cyhuZ1JlcGVhdFZhbHVlLG5nUmVwZWF0SW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleE9mVmFsdWVTZWxlY3RlZDtcbiAgICAgICAgICBzZWxlY3RlZFZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbCxpbmR4KXtcbiAgICAgICAgICAgIGlmKGFuZ3VsYXIuZXF1YWxzKHZhbCxuZ1JlcGVhdFZhbHVlKSkgaW5kZXhPZlZhbHVlU2VsZWN0ZWQgPSBpbmR4O1xuICAgICAgICAgIH0pXG4gICAgICAgICAgJHNjb3BlLiRwYXJlbnQuc2VsZWN0ZWRWYWx1ZXMuc3BsaWNlKGluZGV4T2ZWYWx1ZVNlbGVjdGVkLCAxKTtcbiAgICAgICAgICB2bS5zZWxlY3RlZEluZGV4ZXMuc3BsaWNlKHZtLnNlbGVjdGVkSW5kZXhlcy5pbmRleE9mKG5nUmVwZWF0SW5kZXgpLDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNvcnRQcm94eShmaWVsZCl7XG4gICAgICAgIGlmKCRhdHRycy5vblNvcnQpIHZtLm9uU29ydCh7ZmllbGQ6IHZtLnNlbGVjdGVkSXRlbSwgZGlyOiB2bS5zZWxlY3RlZEl0ZW1EaXJ9KTtcbiAgICAgICAgaWYoISRhdHRycy5zb3J0KSB0aHJvdyAnWW91IGhhdmUgdG8gcGFzcyBhIHNvcnQgZnVuY3Rpb24gdG8gR3VtZ2FMaXN0IFtzb3J0PVwic29ydChmaWVsZCxkaXIpXCJdJztcbiAgICAgICAgdm0uc2VsZWN0ZWRJdGVtID0gZmllbGQ7XG4gICAgICAgIHZtLnNlbGVjdGVkSXRlbURpciA9PSAnYXNjJyA/IHZtLnNlbGVjdGVkSXRlbURpciA9ICdkZXNjJyA6IHZtLnNlbGVjdGVkSXRlbURpciA9ICdhc2MnO1xuICAgICAgICB2bS5zb3J0KHtmaWVsZDogdm0uc2VsZWN0ZWRJdGVtLCBkaXI6IHZtLnNlbGVjdGVkSXRlbURpcn0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkb3VibGUodmFsdWUpe1xuICAgICAgICBpZigkYXR0cnMub25Eb3VibGVDbGljaykgdm0ub25Eb3VibGVDbGljayh7dmFsdWU6IHZhbHVlfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNvbmRpdGlvbmFsVGFibGVDZWxsKHZhbHVlLG9yZGVyaW5nKXtcbiAgICAgICAgdmFyIGNvbHVtblRvR2V0VGhlQ29uZGl0aW9uYWwgPSB2bS5jb25maWcuY29sdW1ucy5maWx0ZXIoZnVuY3Rpb24odmFsKXtyZXR1cm4gdmFsLm5hbWUgPT0gb3JkZXJpbmd9KTtcbiAgICAgICAgaWYoY29sdW1uVG9HZXRUaGVDb25kaXRpb25hbFswXSl7XG4gICAgICAgICAgdmFyIG9iaiA9IGNvbHVtblRvR2V0VGhlQ29uZGl0aW9uYWxbMF0uY29uZGl0aW9uYWwodmFsdWUpXG4gICAgICAgICAgLCAgIHRydWVWYWx1ZSwgZmFsc2VWYWx1ZTtcbiAgICAgICAgICBmb3IodmFyIGtleSBpbiBvYmope1xuICAgICAgICAgICAgaWYob2JqW2tleV0gPT09IHRydWUpe1xuICAgICAgICAgICAgICB0cnVlVmFsdWUgPSBrZXk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmYWxzZVZhbHVlID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJ1xcXCInLmNvbmNhdCh0cnVlVmFsdWUpLmNvbmNhdCgnXFxcIicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnXFwnXFwnJztcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGNvbmQodmFsdWUpe1xuICAgICAgICB2YXIgb2JqID0gdm0uY29uZmlnLmNvbmRpdGlvbmFsKHZhbHVlKSx0cnVlVmFsdWVcbiAgICAgICAgLCAgIGZhbHNlVmFsdWU7XG4gICAgICAgIGZvcih2YXIga2V5IGluIG9iail7XG4gICAgICAgICAgb2JqW2tleV0gPT09IHRydWUgP3RydWVWYWx1ZSA9IGtleSA6IGZhbHNlVmFsdWUgPSBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodHJ1ZVZhbHVlKXtcbiAgICAgICAgICByZXR1cm4gJ1xcXCInLmNvbmNhdCh0cnVlVmFsdWUpLmNvbmNhdCgnXFxcIicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnXFwnXFwnJztcbiAgICAgIH1cbiAgICB9XG4gICAgY3RybC4kaW5qZWN0ID0gW1wiJHNjb3BlXCIsIFwiJGVsZW1lbnRcIiwgXCIkYXR0cnNcIiwgXCIkdHJhbnNjbHVkZVwiXTs7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICBzY29wZTp7XG4gICAgICAgICdzb3J0JzogJyY/JyxcbiAgICAgICAgJ2NsYXNzJzogJyY/JyxcbiAgICAgICAgJ2RhdGEnOiAnPScsXG4gICAgICAgICdvbkNsaWNrJzogJyY/JyxcbiAgICAgICAgJ29uRG91YmxlQ2xpY2snOiAnJj8nLFxuICAgICAgICAnb25Tb3J0JzogJyY/JyxcbiAgICAgICAgJ2NvbmZpZyc6ICc9Y29uZmlndXJhdGlvbidcbiAgICAgIH0sXG4gICAgICBjb250cm9sbGVyOiBjdHJsLFxuICAgICAgY29udHJvbGxlckFzOiAndm0nLFxuICAgICAgYmluZFRvQ29udHJvbGxlcjogdHJ1ZVxuICAgIH1cbiAgfVxuICBhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5saXN0JyxbJ2d1bWdhLnNlcnZpY2VzLmxpc3RoZWxwZXInXSlcbiAgLmRpcmVjdGl2ZSgnZ3VtZ2FMaXN0JyxMaXN0KTtcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdE1hbnlNYW55LiRpbmplY3QgPSBbXCIkbW9kYWxcIiwgXCIkY29tcGlsZVwiLCBcIiR0aW1lb3V0XCJdO1xuXHQvKipcblx0ICogQG5nZG9jIGRpcmVjdGl2ZVxuXHQgKiBAbmFtZSBndW1nYS5jb3JlOmd1bWdhTWFueVRvTWFueVxuXHQgKiBAcmVzdHJpY3QgRVxuXHQgKiBAZGVzY3JpcHRpb25cblx0ICogXHRPIGNvbXBvbmVudGUgZ3VtZ2FNYW55VG9NYW55IMOpIHVtIGNvbXBvbmVudGUgcXVlIMOpIHV0aWxpemFkbyBwYXJhIG1vc3RyYXIgZHVhcyBsaXN0YXMgbGFkbyBhIGxhZG8sIGUgcGVybWl0aXIgcXVlIHVtIHJlZ2lzdHJvIHNlamEgdHJvY2FkbyBkZSB1bWEgbGlzdGEgcGFyYSBvdXRyYSxcblx0ICogXHRhc3NpbSBjb21vIHRhbWLDqW0gdmlzdWFsaXphZG8gb3Mgc2V1cyB2YWxvcmVzKGNhc28gc2VqYSB1bSBvYmpldG8pLiBVbSBleGVtcGxvIGRvIGNvbXBvbmVudGUgcG9kZSBzZXIgZW5jb250cmFkbyBbYXF1aV0oaHR0cDovL2VtYmVkLnBsbmtyLmNvL2d5cnFBS1FRR3VFSHdwMm5wdjhHLykuXG5cdCAqXG5cdCAqIC0tLVxuXHQgKiAjIyBDb25maWd1cmHDp8OjbyBkZSBjb21vIHNlcsOhIG1vc3RyYWRvIG8gdmFsb3IgbmEgbGlzdGFcblx0ICpcblx0ICpQYXJhIHF1ZSBvIHByb2dyYW1hZG9yIHBvc3NhIGVzY29saGVyIGNvbW8gb3MgdmFsb3JlcyBzZXLDo28gZGVtb25zdHJhZG9zLCBmb3JhbSBkZXNlbnZvbHZpZGFzIGR1YXMgdGFncyBxdWUgZGV2ZW0gZXN0YXIgZGVudHJvIGRvIGNvbXBvbmVudGUgbWFueVRvTWFueS5cblx0ICogXHRcdDxwcmU+IDxsZWZ0LWZpZWxkPnt7JHZhbHVlfX08L2xlZnQtZmllbGQ+XG5cdCAqIFx0XHQ8cmlnaHQtZmllbGQ+e3skdmFsdWV9fTwvcmlnaHQtZmllbGQ+PC9wcmU+XG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGxlZnQtbGlzdCBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIHZhcmnDoXZlbCBxdWUgcG9zc3VpcsOhIHVtIGFycmF5LCBwYXJhIHNlciBtb3N0cmFkbyBuYSBsaXN0YSBkYSBlc3F1ZXJkYS5cblx0ICogICpBIGxpc3RhIGRhIGVzcXVlcmRhIHNlcsOhIGZpbHRyYWRhIGUgbsOjbyBjb250ZXLDoSByZXN1bHRhZG9zIGlndWFpcyBhIGRhIGxpc3RhIGRhIGRpcmVpdGEuKlxuXHQgKiBAcGFyYW0ge0FycmF5fSByaWdodC1saXN0IFBhcsOibWV0cm8gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgdmFyacOhdmVsIHF1ZSBwb3NzdWlyw6EgdW0gYXJyYXksIHBhcmEgc2VyIG1vc3RyYWRvIG5hIGxpc3RhIGRhIGRpcmVpdGEuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGxlZnQtc2VhcmNoIFBhcsOibWV0cm8gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgdmFyacOhdmVsIHF1ZSBwb3NzdWlyw6EgdW1hIGZ1bsOnw6NvIHF1ZSBpcsOhIHNlciBleGVjdXRhZGEgdG9kYSB2ZXpcblx0ICogcXVlIG8gdXN1w6FyaW8gZGlnaXRhciBhbGdvIG5vIGlucHV0IGFjaW1hIGRhIGxpc3RhLiBFc3NhIGZ1bsOnw6NvIHRlcsOhIG8gdmFsb3IgZG8gaW5wdXQgY29tbyBwYXLDom1ldHJvLiBPIHBhcsOibWV0cm8gZGV2ZXLDoSBzZXIgZXN0ZTogYGxlZnQtc2VhcmNoPVwiZG9TZWFyY2godGV4dClcImBcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gcmlnaHQtc2VhcmNoIFBhcsOibWV0cm8gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgdmFyacOhdmVsIHF1ZSBwb3NzdWlyw6EgdW1hIGZ1bsOnw6NvIHF1ZSBpcsOhIHNlciBleGVjdXRhZGEgdG9kYSB2ZXpcblx0ICogcXVlIG8gdXN1w6FyaW8gZGlnaXRhciBhbGdvIG5vIGlucHV0IGFjaW1hIGRhIGxpc3RhLiBFc3NhIGZ1bsOnw6NvIHRlcsOhIG8gdmFsb3IgZG8gaW5wdXQgY29tbyBwYXLDom1ldHJvLiBPIHBhcsOibWV0cm8gZGV2ZXLDoSBzZXIgZXN0ZTogYHJpZ2h0LXNlYXJjaD1cImRvU2VhcmNoKHRleHQpXCJgXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHBvc3QtbWV0aG9kIFBhcsOibWV0cm8gbsOjbyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSB2YXJpw6F2ZWwgcXVlIHBvc3N1aXLDoSB1bWEgZnVuw6fDo28gcXVlIGlyw6Egc2VyIGV4ZWN1dGFkYSBxdWFuZG8gbyB1c3XDoXJpbyBkZXNlamFyIGFkaWNpb25hciB1bSB2YWxvclxuXHQgKiBjYXNvIHN1YSBidXNjYSBuw6NvIHRlbmhhIHRyYXppZG8gcmVzdWx0YWRvcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gb24tbGlzdC1jaGFuZ2UgUGFyw6JtZXRybyBuw6NvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIHZhcmnDoXZlbCBxdWUgcG9zc3VpcsOhIHVtYSBmdW7Dp8OjbyBxdWUgaXLDoSBzZXIgZXhlY3V0YWRhIHF1YW5kbyBvIHVzdcOhcmlvIHRpdmVyIGNsaWNhZG8gZW0gdW0gcmVnaXN0cm9cblx0ICogZSBvIG1lc21vIHRpdmVyIHRyb2NhZG8gZGUgbGlzdGEuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9uLXZhbHVlLXZpc3VhbGl6YXRpb24tb3BlbmVkIFBhcsOibWV0cm8gbsOjbyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSB2YXJpw6F2ZWwgcXVlIHBvc3N1aXLDoSB1bWEgZnVuw6fDo28gcXVlIGlyw6Egc2VyIGV4ZWN1dGFkYSBxdWFuZG8gbyB1c3XDoXJpbyB0aXZlciBhYmVydG8gbyBtb2RhbFxuXHQgKiBwYXJhIHZpc3VhbGl6YcOnw6NvIGRlIGRhZG9zXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9uLXZhbHVlLXZpc3VhbGl6YXRpb24tY2xvc2VkIFBhcsOibWV0cm8gbsOjbyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSB2YXJpw6F2ZWwgcXVlIHBvc3N1aXLDoSB1bWEgZnVuw6fDo28gcXVlIGlyw6Egc2VyIGV4ZWN1dGFkYSBxdWFuZG8gbyB1c3XDoXJpbyB0aXZlciBmZWNoYWRvIG8gbW9kYWxcblx0ICogcGFyYSB2aXN1YWxpemHDp8OjbyBkZSBkYWRvc1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGF1dGhvcml6ZS1hZGQgUGFyw6JtZXRybyBuw6NvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIHZhcmnDoXZlbCBxdWUgcG9zc3VpcsOhIHVtIGJvb2xlYW5vIHF1ZSBpcsOhIGZhemVyIG8gY29udHJvbGUgcGFyYSBtb3N0cmFyIG8gYm90w6NvIGRlIGFkaWNpb25hciB1bSByZWdpc3RybyBjYXNvIGEgYnVzY2EgbsOjb1xuXHQgKiB0ZW5oYSByZXRvcm5hZG8gbmVuaHVtIHJlZ2lzdHJvXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBsZWZ0LWxhYmVsIFBhcsOibWV0cm8gbsOjbyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSBTdHJpbmcgcXVlIGlyw6EgYXBhcmVjZXIgYWNpbWEgZG8gaW5wdXQgZSBkYSBsaXN0YS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHJpZ2h0LWxhYmVsIFBhcsOibWV0cm8gbsOjbyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSBTdHJpbmcgcXVlIGlyw6EgYXBhcmVjZXIgYWNpbWEgZG8gaW5wdXQgZSBkYSBsaXN0YS5cblx0ICpcblxuXHQgKi9cblx0ZnVuY3Rpb24gTWFueU1hbnkoJG1vZGFsLCRjb21waWxlLCR0aW1lb3V0KXtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRyZXN0cmljdDogJ0UnLFxuXHRcdFx0c2NvcGU6IHtcblx0XHRcdFx0bGVmdDogJz1sZWZ0TGlzdCcsXG5cdFx0XHRcdHJpZ2h0OiAnPXJpZ2h0TGlzdCcsXG5cdFx0XHRcdGxlZnRGbjogJyZsZWZ0U2VhcmNoJyxcblx0XHRcdFx0cmlnaHRGbjogJyZyaWdodFNlYXJjaCcsXG5cdFx0XHRcdHBvc3RNZXRob2Q6ICcmJyxcblx0XHRcdFx0b25MaXN0Q2hhbmdlOiAnJj8nLFxuXHRcdFx0XHRvbk5ld1ZhbHVlQWRkZWQ6ICcmPycsXG5cdFx0XHRcdG9uVmFsdWVWaXN1YWxpemF0aW9uT3BlbmVkOiAnJj8nLFxuXHRcdFx0XHRvblZhbHVlVmlzdWFsaXphdGlvbkNsb3NlZDogJyY/Jyxcblx0XHRcdFx0YXV0aG9yaXplQWRkOiAnPT8nXG5cdFx0XHR9LFxuXHRcdFx0dHJhbnNjbHVkZTogdHJ1ZSxcblx0XHRcdGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxtLCBhdHRycywgY3RybCwgdHJhbnNjbHVkZUZuKSB7XG5cdFx0XHRcdHNjb3BlLmxlZnQgPSBzY29wZS5sZWZ0IHx8IFtdO1xuXHRcdFx0XHRzY29wZS5yaWdodCA9IHNjb3BlLnJpZ2h0IHx8IFtdO1xuXHRcdFx0XHRpZiAoIWF0dHJzLmF1dGhvcml6ZUFkZCkgc2NvcGUuYXV0aG9yaXplQWRkID0gdHJ1ZTtcblx0XHRcdFx0dmFyIG1vY2tPYmplY3QgPSB7fTtcblx0XHRcdFx0c2NvcGUudGV4dHMgPSB7bGVmdDogJycscmlnaHQ6ICcnfTtcblx0XHRcdFx0c2NvcGUudGVtcGxhdGUgPSAnJztcblx0XHRcdFx0c2NvcGUubGFiZWxzID0ge2xlZnQ6IGF0dHJzLmxlZnRMYWJlbCxyaWdodDogYXR0cnMucmlnaHRMYWJlbH07XG5cdFx0XHRcdHZhciBldmVudEhhbmRsZXIgPSB7XG5cdFx0XHRcdFx0bGlzdENoYW5nZTogKGF0dHJzLm9uTGlzdENoYW5nZT8gc2NvcGUub25MaXN0Q2hhbmdlIDogYW5ndWxhci5ub29wKSxcblx0XHRcdFx0XHRuZXdWYWx1ZUFkZGVkOiAoYXR0cnMub25OZXdWYWx1ZUFkZGVkID8gc2NvcGUub25OZXdWYWx1ZUFkZGVkIDogYW5ndWxhci5ub29wKSxcblx0XHRcdFx0XHR2YWx1ZVZpc3VhbGl6YXRpb25PcGVuZWQ6IChhdHRycy5vblZhbHVlVmlzdWFsaXphdGlvbk9wZW5lZCA/IHNjb3BlLm9uVmFsdWVWaXN1YWxpemF0aW9uT3BlbmVkIDphbmd1bGFyLm5vb3ApLFxuXHRcdFx0XHRcdHZhbHVlVmlzdWFsaXphdGlvbkNsb3NlZDogKGF0dHJzLm9uVmFsdWVWaXN1YWxpemF0aW9uQ2xvc2VkID8gc2NvcGUub25WYWx1ZVZpc3VhbGl6YXRpb25DbG9zZWQgOmFuZ3VsYXIubm9vcClcblx0XHRcdFx0fTtcblx0XHRcdFx0dHJhbnNjbHVkZUZuKHNjb3BlLGZ1bmN0aW9uKGNsb25lRWwpe1xuXHRcdFx0XHRcdGFuZ3VsYXIuZm9yRWFjaChjbG9uZUVsLGZ1bmN0aW9uKGNsKXtcblx0XHRcdFx0XHRcdHZhciBlbGVtZW50ID0gYW5ndWxhci5lbGVtZW50KGNsKVswXTtcblx0XHRcdFx0XHRcdHN3aXRjaChlbGVtZW50Lm5vZGVOYW1lKXtcblx0XHRcdFx0XHRcdFx0Y2FzZSAnTEVGVC1GSUVMRCc6XG5cdFx0XHRcdFx0XHRcdHNjb3BlLnRleHRzLmxlZnQgPSBlbGVtZW50LmlubmVySFRNTDtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ1JJR0hULUZJRUxEJzpcblx0XHRcdFx0XHRcdFx0c2NvcGUudGV4dHMucmlnaHQgPSBlbGVtZW50LmlubmVySFRNTDtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Y2hlY2tFcnJvcnMoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdG1vdW50UmVuZGVyZWRDb250ZW50KCk7XG5cdFx0XHRcdHNjb3BlLiR3YXRjaCgnbGVmdCcsZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRjaGVja0Vycm9ycygpO1xuXHRcdFx0XHRcdGNvcHlPYmplY3Qoc2NvcGUubGVmdFswXSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRmdW5jdGlvbiBjb3B5T2JqZWN0KG9iaikge1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBvYmopIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdFx0bW9ja09iamVjdFtrZXldID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnVuY3Rpb24gY2hlY2tFcnJvcnMoKXtcblx0XHRcdFx0XHR2YXIgZXJyb3JUZXh0cyA9IFtdO1xuXHRcdFx0XHRcdGlmKCFzY29wZS50ZXh0cy5sZWZ0IHx8ICFzY29wZS50ZXh0cy5yaWdodCl7XG5cdFx0XHRcdFx0XHRlcnJvclRleHRzLnB1c2goJ1lvdSBoYXZlXFwnbnQgcHJvdmlkZWQgdGhlIGNvbnRlbnQgdG8gR3VtZ2FNYW55VG9NYW55IGRpcmVjdGl2ZScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlcnJvclRleHRzLmZvckVhY2goZnVuY3Rpb24odHh0KXtcblx0XHRcdFx0XHRcdHRocm93IHR4dDtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZW1vdmVEdXBsaWNhdGVzKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlcygpe1xuXHRcdFx0XHRcdGZ1bmN0aW9uIGZpbHRlck9uUmlnaHQodGV4dCl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc2NvcGUucmlnaHQuZmlsdGVyKGZ1bmN0aW9uKCRlbG0pe1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gJGVsbVthdHRycy5maWx0ZXJQYXJhbWV0ZXJdID09IHRleHQ7XG5cdFx0XHRcdFx0XHR9KS5sZW5ndGhcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2NvcGUubGVmdEF1eCA9IHNjb3BlLmxlZnQuZmlsdGVyKGZ1bmN0aW9uKGVsbSl7XG5cdFx0XHRcdFx0XHRpZihmaWx0ZXJPblJpZ2h0KGVsbVthdHRycy5maWx0ZXJQYXJhbWV0ZXJdKSA9PSAwKXtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGVsbTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmdW5jdGlvbiBtb3VudFJlbmRlcmVkQ29udGVudCgpe1xuXHRcdFx0XHRcdHZhciB0ZXh0ID1cblx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZ1bGwtd2lkdGgtd2l0aG91dC1wYWRkaW5nXCI+XFxuJytcblx0XHRcdFx0XHQnICAgPGRpdiBjbGFzcz1cImNvbC1tZC02XCIgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6IDBcIj5cXG4nK1xuXHRcdFx0XHRcdCcgICAgICAgPHN0cm9uZz48c21hbGw+e3s6OmxhYmVscy5sZWZ0fX08L3NtYWxsPjwvc3Ryb25nPlxcbicgK1xuXHRcdFx0XHRcdCcgICAgICAgPGRpdiBjbGFzcz1cInt7c2hvd0NsYXNzKCl9fVwiPicrXG5cdFx0XHRcdFx0JyAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cIm1hbnltYW55bGVmdFwiIG5nLW1vZGVsPVwibGVmdEZpbHRlclwiIG5vdmFsaWRhdGUgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIicgKyBkb2VzSXRIYXZlRnVuY3Rpb24oJ2xlZnQnLDApICsgJyBuZy1jaGFuZ2U9XCJsZWZ0Rm4oe3BhcmFtOiBsZWZ0RmlsdGVyfSlcIiBuZy1tb2RlbC1vcHRpb25zPVwieyB1cGRhdGVPbjogXFwnZGVmYXVsdCBibHVyXFwnLCBkZWJvdW5jZToge1xcJ2RlZmF1bHRcXCc6IDMwMCwgXFwnYmx1clxcJzogMH0gfVwiLz5cXG4nICtcblx0XHRcdFx0XHQnICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLWFkZG9uXCIgbmctc2hvdz1cInNob3dQbHVzKGxlZnRGaWx0ZXIpXCI+ICcgK1xuXHRcdFx0XHRcdCcgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBzdHlsZT1cImJvcmRlcjogMDtiYWNrZ3JvdW5kLWNvbG9yOiAjRUVFXCIgbmctY2xpY2s9XCJhZGROZXcobGVmdEZpbHRlcilcIj48aSBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tcGx1c1wiPjwvaT48L2J1dHRvbj4nICtcblx0XHRcdFx0XHQnICAgICAgICAgICA8L3NwYW4+JyArXG5cdFx0XHRcdFx0JyAgICAgICA8L2Rpdj4nICtcblx0XHRcdFx0XHQnICAgICAgIDx1bCBjbGFzcz1cImxpc3QtZ3JvdXBcIiBzdHlsZT1cIm1heC1oZWlnaHQ6IDIwMHB4O292ZXJmbG93OiBhdXRvO1wiPlxcbicgK1xuXHRcdFx0XHRcdCcgICAgICAgICAgIDxsaSBjbGFzcz1cImxpc3QtZ3JvdXAtaXRlbVwiIHN0eWxlPVwiZGlzcGxheTpmbGV4O3BhZGRpbmc6IDdweCAxNXB4O1wiIG5nLXJlcGVhdD1cIiR2YWx1ZSBpbiBsZWZ0QXV4ICcgKyBkb2VzSXRIYXZlRnVuY3Rpb24oJ2xlZnQnLDEpICsgJ1wiPicgK1xuXHRcdFx0XHRcdCcgICAgICAgICAgICAgICA8YSBjbGFzcz1cImluc2lkZS1saXN0LWFuY2hvclwiIG5nLWNsaWNrPVwicmVtb3ZlRnJvbUFuZEFkZFRvKGxlZnRBdXgscmlnaHQsJHZhbHVlKVwiPicgKyBzY29wZS50ZXh0cy5sZWZ0ICsgJzwvYT4nICtcblx0XHRcdFx0XHQnICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYmFkZ2VcIiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6ICM4MUFFREE7Y3Vyc29yOiBwb2ludGVyO2JvcmRlcjogMFwiIG5nLWNsaWNrPVwiaGFscCgkdmFsdWUpXCI+PGkgY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXJlc2l6ZS1mdWxsXCI+PC9pPjwvYnV0dG9uPicgK1xuXHRcdFx0XHRcdCcgICAgICAgICAgIDwvbGk+XFxuJytcblx0XHRcdFx0XHQnICAgICAgIDwvdWw+Jytcblx0XHRcdFx0XHQnICAgPC9kaXY+XFxuJytcblx0XHRcdFx0XHQnICAgPGRpdiBjbGFzcz1cImNvbC1tZC02XCIgc3R5bGU9XCJwYWRkaW5nLXJpZ2h0OiAwXCI+XFxuJytcblx0XHRcdFx0XHQnICAgICAgIDxzdHJvbmc+PHNtYWxsPnt7OjpsYWJlbHMucmlnaHR9fTwvc21hbGw+PC9zdHJvbmc+XFxuJytcblx0XHRcdFx0XHQnICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJtYW55bWFueWxlZnRcIiBuZy1tb2RlbD1cInJpZ2h0RmlsdGVyXCIgbm92YWxpZGF0ZSBjbGFzcz1cImZvcm0tY29udHJvbFwiJyArIGRvZXNJdEhhdmVGdW5jdGlvbigncmlnaHQnLDApICsgJy8+XFxuJytcblx0XHRcdFx0XHQnICAgICAgIDx1bCBjbGFzcz1cImxpc3QtZ3JvdXBcIiBzdHlsZT1cIm1heC1oZWlnaHQ6IDIwMHB4O292ZXJmbG93OiBhdXRvO1wiPlxcbicgK1xuXHRcdFx0XHRcdCcgICAgICAgICAgIDxsaSBjbGFzcz1cImxpc3QtZ3JvdXAtaXRlbVwiIHN0eWxlPVwiZGlzcGxheTpmbGV4O3BhZGRpbmc6IDdweCAxNXB4O1wiIG5nLXJlcGVhdD1cIiR2YWx1ZSBpbiByaWdodCAnICsgZG9lc0l0SGF2ZUZ1bmN0aW9uKCdyaWdodCcsMSkgKyAnXCI+JyArXG5cdFx0XHRcdFx0JyAgICAgICAgICAgICAgIDxhIGNsYXNzPVwiaW5zaWRlLWxpc3QtYW5jaG9yXCIgbmctY2xpY2s9XCJyZW1vdmVGcm9tQW5kQWRkVG8ocmlnaHQsbGVmdEF1eCwkdmFsdWUpXCI+JyArIHNjb3BlLnRleHRzLnJpZ2h0ICsgJzwvYT4nICtcblx0XHRcdFx0XHQnICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYmFkZ2UgYmFkZ2UtaGVscGVyXCIgbmctY2xpY2s9XCJoYWxwKCR2YWx1ZSlcIj48aSBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tcmVzaXplLWZ1bGxcIj48L2k+PC9idXR0b24+JyArXG5cdFx0XHRcdFx0JyAgICAgICAgICAgPC9saT5cXG4nK1xuXHRcdFx0XHRcdCcgICAgICAgPC91bD5cXG4nK1xuXHRcdFx0XHRcdCcgICA8L2Rpdj5cXG4nK1xuXHRcdFx0XHRcdCc8L2Rpdj5cXG4nO1xuXHRcdFx0XHRcdGVsbS5hcHBlbmQoJGNvbXBpbGUodGV4dCkoc2NvcGUpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzY29wZS5yZW1vdmVGcm9tQW5kQWRkVG8gPSBmdW5jdGlvbihyZW1vdmVGcm9tLGFkZFRvLHZhbHVlKXtcblx0XHRcdFx0XHRyZW1vdmVGcm9tLnNwbGljZShyZW1vdmVGcm9tLmluZGV4T2YodmFsdWUpLDEpO1xuXHRcdFx0XHRcdGV2ZW50SGFuZGxlci5saXN0Q2hhbmdlKHskdmFsdWU6dmFsdWV9KTtcblx0XHRcdFx0XHRhZGRUby5wdXNoKHZhbHVlKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0c2NvcGUuYWRkTmV3ID0gZnVuY3Rpb24odGV4dCl7XG5cdFx0XHRcdFx0c2NvcGUubGVmdEZpbHRlciA9ICcnO1xuXHRcdFx0XHRcdHNjb3BlLnBvc3RNZXRob2Qoe3ZhbHVlOiB0ZXh0IH0pO1xuXHRcdFx0XHRcdGV2ZW50SGFuZGxlci5uZXdWYWx1ZUFkZGVkKCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHNjb3BlLnNob3dDbGFzcyA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0aWYoc2NvcGUuc2hvd1BsdXMoKSl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJ2lucHV0LWdyb3VwJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRzY29wZS5oYWxwID0gZnVuY3Rpb24ob2JqKXtcblx0XHRcdFx0XHRzY29wZS50ZW1wbGF0ZSA9XG5cdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJtb2RhbC1ib2R5XCI+XFxuJztcblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkgJiYga2V5ICE9ICckJGhhc2hLZXknICYmIGtleSAhPSAnb2knICYmIGtleSAhPSAndmVyc2lvbicpIHtcblx0XHRcdFx0XHRcdHNjb3BlLnRlbXBsYXRlICs9ICcgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPlxcbic7XG5cdFx0XHRcdFx0XHRzY29wZS50ZW1wbGF0ZSArPSAnICAgICAgIDxsYWJlbD48c21hbGw+Jysga2V5ICsnPC9zbWFsbD48L2xhYmVsPlxcbic7XG5cdFx0XHRcdFx0XHRzY29wZS50ZW1wbGF0ZSArPSAnICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLW1vZGVsPVwiJHZhbHVlLicgKyBrZXkgKydcIiBkaXNhYmxlZCBjbGFzcz1cImZvcm0tY29udHJvbFwiLz5cXG4nO1xuXHRcdFx0XHRcdFx0c2NvcGUudGVtcGxhdGUgKz0gJyAgIDwvZGl2Plxcbic7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNjb3BlLnRlbXBsYXRlICs9ICcgICA8ZGl2IGNsYXNzPVwibW9kYWwtZm9vdGVyXCI+XFxuJztcblx0XHRcdFx0XHRzY29wZS50ZW1wbGF0ZSArPSAnICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi13YXJuaW5nXCIgbmctY2xpY2s9XCJiYWNrKClcIj5CYWNrPC9idXR0b24+XFxuJztcblx0XHRcdFx0XHRzY29wZS50ZW1wbGF0ZSArPSAnICAgPC9kaXY+XFxuJztcblx0XHRcdFx0XHRzY29wZS50ZW1wbGF0ZSArPSAnPC9kaXY+XFxuJztcblx0XHRcdFx0XHRldmVudEhhbmRsZXIudmFsdWVWaXN1YWxpemF0aW9uT3BlbmVkKCk7XG5cdFx0XHRcdFx0dmFyIG1pID0gJG1vZGFsLm9wZW4oe1xuXHRcdFx0XHRcdFx0dGVtcGxhdGU6IHNjb3BlLnRlbXBsYXRlLFxuXHRcdFx0XHRcdFx0c2l6ZTogJ3NtJyxcblx0XHRcdFx0XHRcdGNvbnRyb2xsZXI6IFtcIiRzY29wZVwiLCBcIiR2YWx1ZVwiLCBcIiRtb2RhbEluc3RhbmNlXCIsIGZ1bmN0aW9uKCRzY29wZSwkdmFsdWUsJG1vZGFsSW5zdGFuY2Upe1xuXHRcdFx0XHRcdFx0XHQkc2NvcGUuJHZhbHVlID0gJHZhbHVlO1xuXHRcdFx0XHRcdFx0XHQkc2NvcGUuYmFjayA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdFx0JG1vZGFsSW5zdGFuY2UuZGlzbWlzcygpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XSxcblx0XHRcdFx0XHRcdHJlc29sdmU6IHtcblx0XHRcdFx0XHRcdFx0JHZhbHVlOiBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdG1pLnJlc3VsdC50aGVuKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRldmVudEhhbmRsZXIudmFsdWVWaXN1YWxpemF0aW9uQ2xvc2VkKCk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fTtcblx0XHRcdFx0c2NvcGUuc2hvd1BsdXMgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGZ1bmN0aW9uIGZpbHRlckxlZnQoKXtcblx0XHRcdFx0XHRcdHJldHVybiBzY29wZS5sZWZ0QXV4LmZpbHRlcihmdW5jdGlvbihlbCl7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBlbFthdHRycy5maWx0ZXJQYXJhbWV0ZXJdID09IHNjb3BlLmxlZnRGaWx0ZXI7XG5cdFx0XHRcdFx0XHR9KS5sZW5ndGggPCAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmdW5jdGlvbiBmaWx0ZXJSaWdodCgpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIHNjb3BlLnJpZ2h0LmZpbHRlcihmdW5jdGlvbihlbCl7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBlbFthdHRycy5maWx0ZXJQYXJhbWV0ZXJdID09IHNjb3BlLmxlZnRGaWx0ZXI7XG5cdFx0XHRcdFx0XHR9KS5sZW5ndGggPCAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihzY29wZS5hdXRob3JpemVBZGQgPT0gdHJ1ZSl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmlsdGVyTGVmdCgpICYmIGZpbHRlclJpZ2h0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRzY29wZS5kb2VzSXRIYXZlQ2xhc3MgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGlmKHNjb3BlLmxlZnQubGVuZ3RoID4gMCl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiAnaW5wdXQtZ3JvdXAnO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRmdW5jdGlvbiBkb2VzSXRIYXZlRnVuY3Rpb24oZmllbGQscGxhY2Upe1xuXHRcdFx0XHRcdGlmKHBsYWNlID09IDApe1xuXHRcdFx0XHRcdFx0aWYoZmllbGQgPT0gJ2xlZnQnICYmIGF0dHJzLmxlZnRGbil7XG5cdFx0XHRcdFx0XHRcdHJldHVybiAgJ25nLWNoYW5nZT0gXCInICsgYXR0cnMubGVmdEZuICArJyh7dGV4dDogbGVmdEZpbHRlcn0pXCIgJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKGZpZWxkID09ICdyaWdodCcgJiYgYXR0cnMucmlnaHRGbil7XG5cdFx0XHRcdFx0XHRcdHJldHVybiAgJ25nLWNoYW5nZT0gXCInICsgYXR0cnMubGVmdEZuICArJyh7dGV4dDogcmlnaHRGaWx0ZXJ9KVwiICc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmKGZpZWxkID09ICdsZWZ0JyAmJiAhYXR0cnMubGVmdEZuKXtcblx0XHRcdFx0XHRcdFx0cmV0dXJuICcgfCBmaWx0ZXI6IGxlZnRGaWx0ZXInO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYoZmllbGQgPT0gJ3JpZ2h0JyAmJiAhYXR0cnMucmlnaHRGbil7XG5cdFx0XHRcdFx0XHRcdHJldHVybiAnIHwgZmlsdGVyOiByaWdodEZpbHRlcidcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiAnJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRcdGFuZ3VsYXIubW9kdWxlKCdndW1nYS5kaXJlY3RpdmVzLm1hbnl0b21hbnknLFsndWkuYm9vdHN0cmFwJ10pXG5cdFx0LmRpcmVjdGl2ZSgnZ3VtZ2FNYW55VG9NYW55JyxNYW55TWFueSlcblx0fSkoKTtcbiIsIihmdW5jdGlvbigpe1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIE1hbnlUb09uZS4kaW5qZWN0ID0gW1wiJHRlbXBsYXRlQ2FjaGVcIiwgXCJHdW1nYUtleWJvYXJkXCIsIFwiJG1vZGFsXCJdO1xuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAgICAgKiBAbmFtZSBndW1nYS5jb3JlOmd1bWdhTWFueVRvT25lXG4gICAgICogQHJlc3RyaWN0IEVcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgQSBkaXJlY3RpdmUgZ3VtZ2FNYW55VG9PbmUgcG9kZSBzZXIgdXNhZGEgcGFyYSBxdWFuZG8gbyBwcm9ncmFtYWRvciBwcmVjaXNlIGRlIHVtIHNlbGVjdCBxdWUgZmlsdHJlIHVtYSBsaXN0YSBhc3PDrW5jcm9uYW1lbnRlLlxuICAgICAqICBFbGEgdGFtYsOpbSBwZXJtaXRlIGFkaWNpb25hciB1bSByZWdpc3RybyBjYXNvIGEgYnVzY2EgcmV0b3JuZSB1bWEgbGlzdGEgdmF6aWEgZSBwZXJtaXRlIHRhbWLDqW0gdmlzdWFsaXphciBvcyBhdHJpYnV0b3MgZG8gcmVnaXN0cm8gc2VsZWNpb25hZG8uXG4gICAgICogIC0tLVxuICAgICAqICAjRXhlbXBsbyBiw6FzaWNvIGRlIHV0aWxpemHDp8OjbyBkbyBHdW1nYU1hbnlUb09uZVxuICAgICAqICBPIGV4ZW1wbG8gZGVzc2UgY29tcG9uZW50ZSBwb2RlIHNlciBlbmNvbnRyYWRvIFthcXVpXShodHRwOi8vZW1iZWQucGxua3IuY28vTllMM2dJdFZzV0xGY0d4dDVpdHovKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIHZhcmnDoXZlbCBxdWUgc2Vyw6EgbyByZWdpc3RybyBlc2NvbGhpZG8gbmEgbGlzdGEuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIGxpc3RhIGRvcyByZWdpc3Ryb3MgcXVlIGZvcmFtIGJ1c2NhZG9zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNlYXJjaC1tZXRob2QgUGFyw6JtZXRybyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSBmdW7Dp8OjbyBxdWUgZmFyw6EgYSBidXNjYSBuYSBsaXN0YSBhc3PDrW5jcm9uYW1lbnRlLiBgc2VhcmNoLW1ldGhvZD1cImdldFNlYXJjaChwYXJhbSlcImBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwb3N0LW1ldGhvZCBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIGZ1bsOnw6NvIHF1ZSBkZXBlbmRlbmRvIGRvIHBhcsOibWV0cm8gYGFzeW5jYCwgY2hhbWFyw6EgYSBmdW7Dp8OjbyBhc3luYyBjb20gbyBwYXLDom1ldHJvXG4gICAgICogYHBvc3QtbWV0aG9kPVwicG9zdCh2YWx1ZSlcImAgZSBjYXNvIG8gcGFyw6JtZXRybyBhc3luYyBuw6NvIGVzdGVqYSBwcmVzZW50ZSBvdSBzZWphIGZhbHNvLCBmYXLDoSB1bSBwdXNoIG5hIGxpc3RhLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZCBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgbyBhdHJpYnV0byBkbyByZWdpc3RybyBxdWUgZXN0w6Egc2VuZG8gcHJvY3VyYWRvIGUgbyBxdWUgZXN0YXLDoSBuYSBsaXN0YS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGF1dGhvcml6ZS1hZGQgUGFyw6JtZXRybyBuw6NvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIHZhcmnDoXZlbCBxdWUgcG9zc3VpcsOhIHVtIGJvb2xlYW5vIHF1ZSBpcsOhIGZhemVyIG8gY29udHJvbGUgcGFyYSBtb3N0cmFyIG8gYm90w6NvIGRlIGFkaWNpb25hciB1bSByZWdpc3RybyBjYXNvIGEgYnVzY2EgbsOjb1xuICAgICAqIHRlbmhhIHJldG9ybmFkbyBuZW5odW0gcmVnaXN0cm9cbiAgICAgKiBAcGFyYW0ge0J0YXZhIHZlb29sZWFufSBhc3luYyBQYXLDom1ldHJvIG7Do28gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGRpemVyIGNhc28gY29tcG9uZW50ZSBmYXLDoSB1bSBwb3N0IGNoYW1hbmRvIGEgZnVuw6fDo28gcGFzc2FkYSBvdSB1bSBwdXNoIG5hIGxpc3RhLiBQb3IgZGVmYXVsdCwgbyB2YWxvciDDqVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uLW5ldy12YWx1ZS1hZGRlZCBQYXLDom1ldHJvIG7Do28gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgdmFyacOhdmVsIHF1ZSBwb3NzdWlyw6EgdW1hIGZ1bsOnw6NvIHF1ZSBpcsOhIHNlciBleGVjdXRhZGEgcXVhbmRvIG8gdXN1w6FyaW8gYWRpY2lvbmFyIHVtIG5vdm8gdmFsb3IuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb24tdmFsdWUtdmlzdWFsaXphdGlvbi1vcGVuZWQgUGFyw6JtZXRybyBuw6NvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIHZhcmnDoXZlbCBxdWUgcG9zc3VpcsOhIHVtYSBmdW7Dp8OjbyBxdWUgaXLDoSBzZXIgZXhlY3V0YWRhIHF1YW5kbyBvIHVzdcOhcmlvIHRpdmVyIGFiZXJ0byBvIG1vZGFsXG4gICAgICogcGFyYSB2aXN1YWxpemHDp8OjbyBkZSBkYWRvc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uLXZhbHVlLXZpc3VhbGl6YXRpb24tY2xvc2VkIFBhcsOibWV0cm8gbsOjbyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSB2YXJpw6F2ZWwgcXVlIHBvc3N1aXLDoSB1bWEgZnVuw6fDo28gcXVlIGlyw6Egc2VyIGV4ZWN1dGFkYSBxdWFuZG8gbyB1c3XDoXJpbyB0aXZlciBmZWNoYWRvIG8gbW9kYWxcbiAgICAgKiBwYXJhIHZpc3VhbGl6YcOnw6NvIGRlIGRhZG9zXG4gICAgICovXG5cblxuXG4gICAgZnVuY3Rpb24gTWFueVRvT25lKCR0ZW1wbGF0ZUNhY2hlLEd1bWdhS2V5Ym9hcmQsJG1vZGFsKXtcbiAgICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdtdG9JdGVtLmh0bWwnLFxuICAgICAgICAgICAgJzxzcGFuIGJpbmQtaHRtbC11bnNhZmU9XCJtYXRjaC5sYWJlbCB8IHR5cGVhaGVhZEhpZ2hsaWdodDpxdWVyeVwiIHN0eWxlPVwiY3Vyc29yOiBwb2ludGVyO1wiPjwvc3Bhbj4nKTtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0nPGRpdiBjbGFzcz1cImZ1bGwtd2lkdGgtd2l0aG91dC1wYWRkaW5nXCI+JztcbiAgICAgICAgdGVtcGxhdGUgKz0gJyAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+JztcbiAgICAgICAgdGVtcGxhdGUgKz0gJyAgICAgICA8ZGl2IG5nLWNsYXNzPVwic2hvd0Z1bGxWaWV3KCkgfHwgYXV0aG9yaXplQWRkID8gXFwnaW5wdXQtZ3JvdXBcXCcgOiBcXCdcXCdcIj4nO1xuICAgICAgICB0ZW1wbGF0ZSArPSAnICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiAgbmctbW9kZWw9XCJtb2RlbFwiIHR5cGU9XCJ0ZXh0XCIgdHlwZWFoZWFkPVwiJHZhbHVlIGFzICR2YWx1ZVtmaWVsZF0gZm9yICR2YWx1ZSBpbiBwcm94eVNlYXJjaE1ldGhvZCgpXCI+JztcbiAgICAgICAgdGVtcGxhdGUgKz0gJyAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvblwiIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IHBhZGRpbmc6IDNweCAxMnB4O2JvcmRlci1sZWZ0OjBcIiBuZy1zaG93PVwic2hvd0Z1bGxWaWV3KClcIj4gJztcbiAgICAgICAgdGVtcGxhdGUgKz0gJyAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJiYWRnZVwiIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjogIzZFQ0ZGRjtib3JkZXI6IDBcIiBuZy1jbGljaz1cImhhbHAobW9kZWwpXCIgPjxpIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZXNpemUtZnVsbFwiPjwvaT48L2J1dHRvbj4nO1xuICAgICAgICB0ZW1wbGF0ZSArPSAnICAgICAgICAgICA8L3NwYW4+JztcbiAgICAgICAgdGVtcGxhdGUgKz0gJyAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvblwiIHN0eWxlPVwicGFkZGluZzogMCAwLjI1JVwiIG5nLXNob3c9XCJhdXRob3JpemVBZGRcIj4gJztcbiAgICAgICAgdGVtcGxhdGUgKz0gJyAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIHN0eWxlPVwiYm9yZGVyOiAwO2JhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50XCIgbmctY2xpY2s9XCJhZGROZXcobW9kZWwpXCIgPjxpIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1wbHVzXCI+PC9pPjwvYnV0dG9uPic7XG4gICAgICAgIHRlbXBsYXRlICs9ICcgICAgICAgICAgIDwvc3Bhbj4nO1xuICAgICAgICB0ZW1wbGF0ZSArPSAnICAgICAgIDwvZGl2Pic7XG4gICAgICAgIHRlbXBsYXRlICs9ICcgICA8L2Rpdj4nO1xuICAgICAgICB0ZW1wbGF0ZSArPSAnPC9kaXY+JztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0IDogJ0UnLFxuICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgICAgICAgICAgcmVxdWlyZTogJ15mb3JtJyxcbiAgICAgICAgICAgIHNjb3BlIDoge1xuICAgICAgICAgICAgICAgIG1vZGVsOic9dmFsdWUnLFxuICAgICAgICAgICAgICAgIGxpc3Q6ICc9JyxcbiAgICAgICAgICAgICAgICBzZWFyY2hNZXRob2Q6ICcmJyxcbiAgICAgICAgICAgICAgICBwb3N0TWV0aG9kOiAnJmFkZE1ldGhvZCcsXG4gICAgICAgICAgICAgICAgZmllbGQ6ICdAJyxcbiAgICAgICAgICAgICAgICBvbk5ld1ZhbHVlQWRkZWQ6ICcmPycsXG4gICAgICAgICAgICAgICAgb25WYWx1ZVZpc3VhbGl6YXRpb25PcGVuZWQ6ICcmPycsXG4gICAgICAgICAgICAgICAgb25WYWx1ZVZpc3VhbGl6YXRpb25DbG9zZWQ6ICcmPydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxtLCBhdHRycyxjdHJsKXtcbiAgICAgICAgICAgICAgICBzY29wZS5mb3JtQ3RybCA9IGN0cmw7XG4gICAgICAgICAgICAgICAgdmFyIG5nTW9kZWxDdHJsID0gZWxtLmZpbmQoJ2lucHV0JykuY29udHJvbGxlcignbmdNb2RlbCcpLFxuICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVBZGRlZDogKGF0dHJzLm9uTmV3VmFsdWVBZGRlZCA/IHNjb3BlLm9uTmV3VmFsdWVBZGRlZCA6IGFuZ3VsYXIubm9vcCksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlVmlzdWFsaXphdGlvbk9wZW5lZDogKGF0dHJzLm9uVmFsdWVWaXN1YWxpemF0aW9uT3BlbmVkID8gc2NvcGUub25WYWx1ZVZpc3VhbGl6YXRpb25PcGVuZWQgOmFuZ3VsYXIubm9vcCksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlVmlzdWFsaXphdGlvbkNsb3NlZDogKGF0dHJzLm9uVmFsdWVWaXN1YWxpemF0aW9uQ2xvc2VkID8gc2NvcGUub25WYWx1ZVZpc3VhbGl6YXRpb25DbG9zZWQgOmFuZ3VsYXIubm9vcClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFzeW5jO1xuICAgICAgICAgICAgICAgICFhdHRycy5hdXRob3JpemVBZGQgPyBzY29wZS5hdXRob3JpemVBZGQgPSB0cnVlIDogc2NvcGUuYXV0aG9yaXplQWRkID0gSlNPTi5wYXJzZShhdHRycy5hdXRob3JpemVBZGQpO1xuICAgICAgICAgICAgICAgICFhdHRycy5hc3luYyA/IGFzeW5jID0gdHJ1ZSA6IGFzeW5jID0gSlNPTi5wYXJzZShhdHRycy5hc3luYyk7XG4gICAgICAgICAgICAgICAgc2NvcGUubGlzdCA9IHNjb3BlLmxpc3QgfHwgW107XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2hlY2tJZkl0SXNTdHJpbmcoc3RyaW5nKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgodHlwZW9mIHN0cmluZykudG9VcHBlckNhc2UoKS50cmltKCkpID09PSAnc3RyaW5nJy50b1VwcGVyQ2FzZSgpLnRyaW0oKSAmJiBzdHJpbmcubGVuZ3RoID4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2NvcGUuJHdhdGNoKCdtb2RlbCcsZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tJZkl0SXNTdHJpbmcoc2NvcGUubW9kZWwpID9cbiAgICAgICAgICAgICAgICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ0d1bWdhTWFueVRvT25lJyxmYWxzZSkgOiBjdHJsLiRzZXRWYWxpZGl0eSgnR3VtZ2FNYW55VG9PbmUnLHRydWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIEd1bWdhS2V5Ym9hcmQuYmluZFRvRWxlbWVudChlbG0uZmluZCgnaW5wdXQnKVswXSwnZG93bicsZnVuY3Rpb24oKXtuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKCcgJyl9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGUpe1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2NvcGUuc2hvd0Z1bGxWaWV3ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgodHlwZW9mIHNjb3BlLm1vZGVsKS50b1VwcGVyQ2FzZSgpLnRyaW0oKSkgPT09ICdvYmplY3QnLnRvVXBwZXJDYXNlKCkudHJpbSgpICYmIHNjb3BlLm1vZGVsICE9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgc2NvcGUuc2hvd1BsdXMgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCgodHlwZW9mIHNjb3BlLm1vZGVsKS50b1VwcGVyQ2FzZSgpLnRyaW0oKSkgPT09ICdzdHJpbmcnLnRvVXBwZXJDYXNlKCkudHJpbSgpICYmIHNjb3BlLmF1dGhvcml6ZUFkZCA9PT0gdHJ1ZSkgO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBzY29wZS5wcm94eVNlYXJjaE1ldGhvZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuc2VhcmNoTWV0aG9kKHtwYXJhbTogbmdNb2RlbEN0cmwuJHZpZXdWYWx1ZX0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2NvcGUuYWRkTmV3ID0gZnVuY3Rpb24odGV4dCl7XG4gICAgICAgICAgICAgICAgICAgIGlmKGFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wb3N0TWV0aG9kKHt2YWx1ZTogdGV4dH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5tb2RlbCA9IHZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5saXN0LnB1c2godGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNjb3BlLmhhbHAgPSBmdW5jdGlvbihvYmope1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgPVxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cIm1vZGFsLWJvZHlcIj5cXG4nO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkgJiYga2V5ICE9ICckJGhhc2hLZXknICYmIGtleSAhPSAnb2knICYmIGtleSAhPSAndmVyc2lvbicgJiYga2V5ICE9ICdwYXNzd29yZCcgJiYgdHlwZW9mIG9ialtrZXldICE9ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZSArPSAnICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgKz0gJyAgICAgICA8bGFiZWw+PHNtYWxsPicrIGtleSArJzwvc21hbGw+PC9sYWJlbD5cXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgKz0gJyAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cIiR2YWx1ZS4nICsga2V5ICsnXCIgZGlzYWJsZWQgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIi8+XFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlICs9ICcgICA8L2Rpdj5cXG4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlICs9ICcgICA8ZGl2IGNsYXNzPVwibW9kYWwtZm9vdGVyXCI+XFxuJztcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgKz0gJyAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4td2FybmluZ1wiIG5nLWNsaWNrPVwiYmFjaygpXCI+QmFjazwvYnV0dG9uPlxcbic7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlICs9ICcgICA8L2Rpdj5cXG4nO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZSArPSAnPC9kaXY+XFxuJztcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyLnZhbHVlVmlzdWFsaXphdGlvbk9wZW5lZCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWkgPSAkbW9kYWwub3Blbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiAnc20nLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogW1wiJHNjb3BlXCIsIFwiJHZhbHVlXCIsIFwiJG1vZGFsSW5zdGFuY2VcIiwgZnVuY3Rpb24oJHNjb3BlLCR2YWx1ZSwkbW9kYWxJbnN0YW5jZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiR2YWx1ZSA9ICR2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYmFjayA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRtb2RhbEluc3RhbmNlLmRpc21pc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdmFsdWU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbWkucmVzdWx0LnRoZW4oZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlci52YWx1ZVZpc3VhbGl6YXRpb25DbG9zZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgICAgICBhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5tYW55dG9vbmUnLFsndWkuYm9vdHN0cmFwJywnZ3VtZ2Euc2VydmljZXMua2V5Ym9hcmQnXSlcbiAgICAgICAgLmRpcmVjdGl2ZSgnZ3VtZ2FNYW55VG9PbmUnLE1hbnlUb09uZSk7XG4gICAgfSkoKTtcbiIsIihmdW5jdGlvbigpe1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBAbmdkb2MgZGlyZWN0aXZlXG4gICAqIEBuYW1lIGd1bWdhLmNvcmU6Z3VtZ2FNYXNrXG4gICAqIEByZXN0cmljdCBBXG4gICAqIEBkZXNjcmlwdGlvbiBPIGNvbXBvbmVudGUgKipHdW1nYU1hc2sqKiBzZXJ2ZSBwYXJhIGFkaWNpb25hciBtw6FzY2FyYXMgYW9zIGVsZW1lbnRvcyBpbnB1dHMgcXVlIHNlIGZhemVtIG5lY2Vzc8OhcmlvLCBjb21vIENQRiwgQ05QSiwgdGVsZWZvbmUgZSBldGMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIFVtIGV4ZW1wbG8gZGEgZGlyZWN0aXZlIGd1bWdhVGFibGUgZnVuY2lvbmFuZG8gcG9kZSBzZXIgZW5jb250cmFkbyBbYXF1aV0oaHR0cDovL2VtYmVkLnBsbmtyLmNvL1NBTGtwNWJLUloxYXl3c3JwbUVYKS5cbiAgICogIDxwcmU+XG4gICAqICBcdDxmb3JtIGNsYXNzPVwiXCIgYWN0aW9uPVwiaW5kZXguaHRtbFwiIG1ldGhvZD1cInBvc3RcIj5cbiAgICogIFx0XHQ8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwibmFtZVwiIHZhbHVlPVwiXCIgbmctbW9kZWw9XCJjcGZcIiBndW1nYS1tYXNrPVwiOTk5Ljk5OS45OTktOTlcIiBndW1nYS1tYXNrLW9wdGlvbnM9XCJtYXNrT3B0aW9uc1wiPlxuICAgKiAgXHQ8L2Zvcm0+XG4gICAqICAgIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiPlxuICAgKiAgICAkc2NvcGUubWFza09wdGlvbnMgPSB7XG4gICAqICAgIFx0bWFza0RlZmluaXRpb25zOiB7XG4gICAqICAgIFx0XHQnc2V1UmVnZXgnOiAvW3JlZ2V4XS9cbiAgICogICAgXHR9LFxuICAgKiAgICBcdGNsZWFyT25CbHVyOiBmYWxzZSxcbiAgICogICAgXHRldmVudHNUb0hhbmRsZTogWydpbnB1dCcsICdrZXl1cCcsICdjbGljaycsICdmb2N1cyddXG4gICAqICAgIH07XG4gICAqICAgIDwvc2NyaXB0PlxuICAgKiAgPC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBndW1nYS1tYXNrIFBvciBwYWRyw6NvIG8gY29tcG9uZW50ZSB0ZW0gMyB0aXBvcyBkZSByZWdleCBhY2VpdGFzLCBxdWUgc8OjbyAqKjkqKiAobnVtw6lyaWNvcyksICoqQSoqIChhbGZhbnVtw6lyaWNvcykgZSAqKiAqICoqIChhbGZhbnVtw6lyaWNvcylcbiAgICogQHBhcmFtIHtPYmplY3R9IGd1bWdhLW1hc2stb3B0aW9ucyBPYmpldG8gZW0gJHNjb3BlIGNvbSByZWdleCBleHRyYXMgb3Ugc29icmVlc2NyZXZlciBjb25maWd1cmHDp8O1ZXMgZGVmYXVsdC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGd1bWdhLW1hc2stcGxhY2Vob2xkZXIgVHJhYmFsaGEgZW0gY29uanVudG8gY29tIG8gcGxhY2Vob2xkZXIgbmF0aXZvLCBjb250dWRvLCBvICoqZ3VtZ2EtbWFzay1wbGFjZWhvbGRlcioqIGRldmUgc2VndWlyIG8gbWVzbW8gcGFkcsOjb1xuICAgKiBkZSBjYXJhY3RlcmVzIGRvIGluZm9ybWFkbyBubyAqKmd1bWdhLW1hc2sqKi4gRW5xdWFudG8gbyBuYXRpdm8gZmljYSBhdGl2byBzZW0gYXRpdmlkYWRlIG5vIGlucHV0LCBhbyBkaXNwYXJhciBvIGV2ZW50byBmb2N1cywgbyBndW1nYS1tYXNrLXBsYWNlaG9sZGVyXG4gICAqIGZpY2Fyw6EgYXRpdm8uXG4gICAqL1xuICBNYXNrLiRpbmplY3QgPSBbXCIkcGFyc2VcIl07XG5cbiAgZnVuY3Rpb24gTWFzaygkcGFyc2UpIHtcbiAgICBmdW5jdGlvbiBpc0ZvY3VzZWQgKGVsZW0pIHtcbiAgICAgIHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHByaW9yaXR5OiAxMDAsXG4gICAgICByZXF1aXJlOiAnbmdNb2RlbCcsXG4gICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgc2NvcGU6IHtcbiAgICAgICAgZ3VtZ2FNYXNrT3B0aW9uczogJz1ndW1nYU1hc2tPcHRpb25zJ1xuICAgICAgfSxcbiAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uIGd1bWdhTWFza0NvbXBpbGluZ0Z1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBtYXNrRGVmaW5pdGlvbnM6IHtcbiAgICAgICAgICAgIC8vIE51bcOpcmljb3NcbiAgICAgICAgICAgICc5JzogL1xcZC8sXG4gICAgICAgICAgICAvLyBBbGZhXG4gICAgICAgICAgICAnQSc6IC9bYS16QS1aXS8sXG4gICAgICAgICAgICAvLyBBbGZhbnVtw6lyaWNvc1xuICAgICAgICAgICAgJyonOiAvW2EtekEtWjAtOV0vXG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLyBTZSB0cnVlLCBsaW1wYSBvIGNhbXBvIGNhc28gaW52w6FsaWRvIG5vIGV2ZW50byBvbkJsdXJcbiAgICAgICAgICBjbGVhck9uQmx1cjogdHJ1ZSxcbiAgICAgICAgICAvLyBFdmVudG9zIHBhcmEgcHJvY2Vzc2FtZW50b1xuICAgICAgICAgIGV2ZW50c1RvSGFuZGxlOiBbJ2lucHV0JywgJ2tleXVwJywgJ2NsaWNrJywgJ2ZvY3VzJ11cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZ3VtZ2FNYXNrTGlua2luZ0Z1bmN0aW9uKHNjb3BlLCBlbG0sIGF0dHJzLCBjdHJsKSB7XG4gICAgICAgICAgdmFyIG1hc2tQcm9jZXNzZWQgPSBmYWxzZSwgZXZlbnRzQm91bmQgPSBmYWxzZSxcbiAgICAgICAgICBtYXNrQ2FyZXRNYXAsIG1hc2tQYXR0ZXJucywgbWFza1BsYWNlaG9sZGVyLCBtYXNrQ29tcG9uZW50cyxcbiAgICAgICAgICBtaW5SZXF1aXJlZExlbmd0aCxcbiAgICAgICAgICB2YWx1ZSwgdmFsdWVNYXNrZWQsIGlzVmFsaWQsXG4gICAgICAgICAgb3JpZ2luYWxQbGFjZWhvbGRlciA9IGF0dHJzLnBsYWNlaG9sZGVyLFxuICAgICAgICAgIG9yaWdpbmFsTWF4bGVuZ3RoID0gYXR0cnMubWF4bGVuZ3RoLFxuICAgICAgICAgIC8vIC8vIFZhcmnDoXZlaXMgdXNhZGFzIGV4Y2x1c2l2YW1lbnRlIHBhcmEgZXZlbnRvc1xuICAgICAgICAgIG9sZFZhbHVlLCBvbGRWYWx1ZVVubWFza2VkLCBvbGRDYXJldFBvc2l0aW9uLCBvbGRTZWxlY3Rpb25MZW5ndGg7XG5cbiAgICAgICAgICBmdW5jdGlvbiBpbml0aWFsaXplKG1hc2tBdHRyKSB7XG4gICAgICAgICAgICBpZiAoIWFuZ3VsYXIuaXNEZWZpbmVkKG1hc2tBdHRyKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdW5pbml0aWFsaXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9jZXNzUmF3TWFzayhtYXNrQXR0cik7XG4gICAgICAgICAgICBpZiAoIW1hc2tQcm9jZXNzZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVuaW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5pdGlhbGl6ZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIGJpbmRFdmVudExpc3RlbmVycygpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaW5pdFBsYWNlaG9sZGVyKHBsYWNlaG9sZGVyQXR0cikge1xuICAgICAgICAgICAgaWYgKCFwbGFjZWhvbGRlckF0dHIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXNrUGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlckF0dHI7XG4gICAgICAgICAgICAvLyBBdHVhbGl6YW1vcyBvIHZhbG9yIGRvIGlucHV0XG4gICAgICAgICAgICBpZiAobWFza1Byb2Nlc3NlZCkge1xuICAgICAgICAgICAgICBlbG0udmFsKG1hc2tWYWx1ZSh1bm1hc2tWYWx1ZShlbG0udmFsKCkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZm9ybWF0dGVyKGZyb21Nb2RlbFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIW1hc2tQcm9jZXNzZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZyb21Nb2RlbFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSB1bm1hc2tWYWx1ZShmcm9tTW9kZWxWYWx1ZSB8fCAnJyk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gdmFsaWRhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICBjdHJsLiRzZXRWYWxpZGl0eSgnbWFzaycsIGlzVmFsaWQpO1xuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWQgJiYgdmFsdWUubGVuZ3RoID8gbWFza1ZhbHVlKHZhbHVlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBwYXJzZXIoZnJvbVZpZXdWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFtYXNrUHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmcm9tVmlld1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSB1bm1hc2tWYWx1ZShmcm9tVmlld1ZhbHVlIHx8ICcnKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSB2YWxpZGF0ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIGN0cmwuJHZpZXdWYWx1ZSA9IHZhbHVlLmxlbmd0aCA/IG1hc2tWYWx1ZSh2YWx1ZSkgOiAnJztcbiAgICAgICAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCdtYXNrJywgaXNWYWxpZCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICcnICYmIGF0dHJzLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCdyZXF1aXJlZCcsICFjdHJsLiRlcnJvci5yZXF1aXJlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNWYWxpZCA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBsaW5rT3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAgICAgICBpZiAoc2NvcGUuZ3VtZ2FNYXNrT3B0aW9ucykge1xuICAgICAgICAgICAgbGlua09wdGlvbnMgPSBzY29wZS5ndW1nYU1hc2tPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNPYmplY3QobGlua09wdGlvbnMpKSB7XG4gICAgICAgICAgICAgIGxpbmtPcHRpb25zID0gKGZ1bmN0aW9uKG9yaWdpbmFsLCBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBvcmlnaW5hbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcmlnaW5hbCwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRbaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRbaV0gPSBhbmd1bGFyLmNvcHkob3JpZ2luYWxbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZXh0ZW5kKGN1cnJlbnRbaV0sIG9yaWdpbmFsW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgICAgICAgfSkob3B0aW9ucywgbGlua09wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaW5rT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXR0cnMuJG9ic2VydmUoJ2d1bWdhTWFzaycsIGluaXRpYWxpemUpO1xuICAgICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5ndW1nYU1hc2tQbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKCdndW1nYU1hc2tQbGFjZWhvbGRlcicsIGluaXRQbGFjZWhvbGRlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXR0cnMuJG9ic2VydmUoJ3BsYWNlaG9sZGVyJywgaW5pdFBsYWNlaG9sZGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG1vZGVsVmlld1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgYXR0cnMuJG9ic2VydmUoJ21vZGVsVmlld1ZhbHVlJywgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICBpZiAodmFsID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgICAgbW9kZWxWaWV3VmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNjb3BlLiR3YXRjaChhdHRycy5uZ01vZGVsLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIGlmIChtb2RlbFZpZXdWYWx1ZSAmJiB2YWwpIHtcbiAgICAgICAgICAgICAgdmFyIG1vZGVsID0gJHBhcnNlKGF0dHJzLm5nTW9kZWwpO1xuICAgICAgICAgICAgICBtb2RlbC5hc3NpZ24oc2NvcGUsIGN0cmwuJHZpZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY3RybC4kZm9ybWF0dGVycy5wdXNoKGZvcm1hdHRlcik7XG4gICAgICAgICAgY3RybC4kcGFyc2Vycy5wdXNoKHBhcnNlcik7XG5cbiAgICAgICAgICBmdW5jdGlvbiB1bmluaXRpYWxpemUoKSB7XG4gICAgICAgICAgICBtYXNrUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICB1bmJpbmRFdmVudExpc3RlbmVycygpO1xuXG4gICAgICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQob3JpZ2luYWxQbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgICAgZWxtLmF0dHIoJ3BsYWNlaG9sZGVyJywgb3JpZ2luYWxQbGFjZWhvbGRlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbG0ucmVtb3ZlQXR0cigncGxhY2Vob2xkZXInKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKG9yaWdpbmFsTWF4bGVuZ3RoKSkge1xuICAgICAgICAgICAgICBlbG0uYXR0cignbWF4bGVuZ3RoJywgb3JpZ2luYWxNYXhsZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHIoJ21heGxlbmd0aCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbG0udmFsKGN0cmwuJG1vZGVsVmFsdWUpO1xuICAgICAgICAgICAgY3RybC4kdmlld1ZhbHVlID0gY3RybC4kbW9kZWxWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpbml0aWFsaXplRWxlbWVudCgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gb2xkVmFsdWVVbm1hc2tlZCA9IHVubWFza1ZhbHVlKGN0cmwuJG1vZGVsVmFsdWUgfHwgJycpO1xuICAgICAgICAgICAgdmFsdWVNYXNrZWQgPSBvbGRWYWx1ZSA9IG1hc2tWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gdmFsaWRhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgdmlld1ZhbHVlID0gaXNWYWxpZCAmJiB2YWx1ZS5sZW5ndGggPyB2YWx1ZU1hc2tlZCA6ICcnO1xuICAgICAgICAgICAgaWYgKGF0dHJzLm1heGxlbmd0aCkgeyAvLyBEb3VibGUgbWF4bGVuZ3RoIHRvIGFsbG93IHBhc3RpbmcgbmV3IHZhbCBhdCBlbmQgb2YgbWFza1xuICAgICAgICAgICAgICBlbG0uYXR0cignbWF4bGVuZ3RoJywgbWFza0NhcmV0TWFwW21hc2tDYXJldE1hcC5sZW5ndGggLSAxXSAqIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCAhIG9yaWdpbmFsUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgZWxtLmF0dHIoJ3BsYWNlaG9sZGVyJywgbWFza1BsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsbS52YWwodmlld1ZhbHVlKTtcbiAgICAgICAgICAgIGN0cmwuJHZpZXdWYWx1ZSA9IHZpZXdWYWx1ZTtcbiAgICAgICAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCdtYXNrJywgaXNWYWxpZCk7XG4gICAgICAgICAgICAvLyBOw6NvIHVzYW5kbyAkc2V0Vmlld1ZhbHVlLCBlbnTDo28gbsOjbyBzb2JyZWVzY3JldmVcbiAgICAgICAgICAgIC8vIG8gdmFsb3IgZG8gbW9kZWwgc2VtIGludGVyYcOnw6NvIGRvIHVzdcOhcmlvLlxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgICAgIGlmIChldmVudHNCb3VuZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbG0uYmluZCgnYmx1cicsIGJsdXJIYW5kbGVyKTtcbiAgICAgICAgICAgIGVsbS5iaW5kKCdtb3VzZWRvd24gbW91c2V1cCcsIG1vdXNlRG93blVwSGFuZGxlcik7XG4gICAgICAgICAgICBlbG0uYmluZChsaW5rT3B0aW9ucy5ldmVudHNUb0hhbmRsZS5qb2luKCcgJyksIGV2ZW50SGFuZGxlcik7XG4gICAgICAgICAgICBlbG0uYmluZCgncGFzdGUnLCBvblBhc3RlSGFuZGxlcik7XG4gICAgICAgICAgICBldmVudHNCb3VuZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gdW5iaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50c0JvdW5kKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsbS51bmJpbmQoJ2JsdXInLCBibHVySGFuZGxlcik7XG4gICAgICAgICAgICBlbG0udW5iaW5kKCdtb3VzZWRvd24nLCBtb3VzZURvd25VcEhhbmRsZXIpO1xuICAgICAgICAgICAgZWxtLnVuYmluZCgnbW91c2V1cCcsIG1vdXNlRG93blVwSGFuZGxlcik7XG4gICAgICAgICAgICBlbG0udW5iaW5kKCdpbnB1dCcsIGV2ZW50SGFuZGxlcik7XG4gICAgICAgICAgICBlbG0udW5iaW5kKCdrZXl1cCcsIGV2ZW50SGFuZGxlcik7XG4gICAgICAgICAgICBlbG0udW5iaW5kKCdjbGljaycsIGV2ZW50SGFuZGxlcik7XG4gICAgICAgICAgICBlbG0udW5iaW5kKCdmb2N1cycsIGV2ZW50SGFuZGxlcik7XG4gICAgICAgICAgICBlbG0udW5iaW5kKCdwYXN0ZScsIG9uUGFzdGVIYW5kbGVyKTtcbiAgICAgICAgICAgIGV2ZW50c0JvdW5kID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gVmFsaWRhIG8gdGFtYW5obyBtw61uaW1vIHJlcXVlcmlkbyBkYSBtw6FzY2FyYVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA/IHZhbHVlLmxlbmd0aCA+PSBtaW5SZXF1aXJlZExlbmd0aCA6IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVtb3ZlIG3DoXNjYXJhXG4gICAgICAgICAgZnVuY3Rpb24gdW5tYXNrVmFsdWUodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZVVubWFza2VkID0gJycsXG4gICAgICAgICAgICBtYXNrUGF0dGVybnNDb3B5ID0gbWFza1BhdHRlcm5zLnNsaWNlKCk7XG4gICAgICAgICAgICAvLyBQcm9jZXNzbyBwYXJhIHJldGlyYXIgY29tcG9uZW50ZXMgZG8gdmFsb3JcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtYXNrQ29tcG9uZW50cywgZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShjb21wb25lbnQsICcnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHZhbHVlLnNwbGl0KCcnKSwgZnVuY3Rpb24oY2hyKSB7XG4gICAgICAgICAgICAgIGlmIChtYXNrUGF0dGVybnNDb3B5Lmxlbmd0aCAmJiBtYXNrUGF0dGVybnNDb3B5WzBdLnRlc3QoY2hyKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlVW5tYXNrZWQgKz0gY2hyO1xuICAgICAgICAgICAgICAgIG1hc2tQYXR0ZXJuc0NvcHkuc2hpZnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVVbm1hc2tlZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBZGljaW9uYSBtw6FzY2FyYVxuICAgICAgICAgIGZ1bmN0aW9uIG1hc2tWYWx1ZSh1bm1hc2tlZFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVNYXNrZWQgPSAnJyxcbiAgICAgICAgICAgIG1hc2tDYXJldE1hcENvcHkgPSBtYXNrQ2FyZXRNYXAuc2xpY2UoKTtcblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKG1hc2tQbGFjZWhvbGRlci5zcGxpdCgnJyksIGZ1bmN0aW9uKGNociwgaSkge1xuICAgICAgICAgICAgICBpZiAodW5tYXNrZWRWYWx1ZS5sZW5ndGggJiYgaSA9PT0gbWFza0NhcmV0TWFwQ29weVswXSkge1xuICAgICAgICAgICAgICAgIHZhbHVlTWFza2VkICs9IHVubWFza2VkVmFsdWUuY2hhckF0KDApIHx8ICdfJztcbiAgICAgICAgICAgICAgICB1bm1hc2tlZFZhbHVlID0gdW5tYXNrZWRWYWx1ZS5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgbWFza0NhcmV0TWFwQ29weS5zaGlmdCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlTWFza2VkICs9IGNocjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVNYXNrZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTyBhdHJpYnV0byBwYWRyw6NvIHBsYWNlaG9sZGVyIGZ1bmNpb25hIG5vcm1hbG1lbnRlLFxuICAgICAgICAgIC8vIG8gYXRyaWJ1dG8gZ3VtZ2FNYXNrUGxhY2Vob2xkZXIgZGVmaW5lIGEgbcOhc2NhcmEgY29tIG8gcGxhY2Vob2xkZXJcbiAgICAgICAgICAvLyBlIGRldmUgYXRlbmRlciBhIHF1YW50aWRhZGUgZGUgY2FyYWN0ZXJlcyBkYSBtw6FzY2FyYS5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRQbGFjZWhvbGRlckNoYXIoaSkge1xuICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMuZ3VtZ2FNYXNrUGxhY2Vob2xkZXIpID8gYXR0cnMuZ3VtZ2FNYXNrUGxhY2Vob2xkZXIgOiBhdHRycy5wbGFjZWhvbGRlcjtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwbGFjZWhvbGRlciAhPT0gJ3VuZGVmaW5lZCcgJiYgcGxhY2Vob2xkZXJbaV0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyW2ldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdfJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRNYXNrQ29tcG9uZW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXNrUGxhY2Vob2xkZXIucmVwbGFjZSgvW19dKy9nLCAnXycpLnJlcGxhY2UoLyhbXl9dKykoW2EtekEtWjAtOV0pKFteX10pL2csICckMSQyXyQzJykuc3BsaXQoJ18nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzUmF3TWFzayhtYXNrKSB7XG4gICAgICAgICAgICB2YXIgY2hhcmFjdGVyQ291bnQgPSAwO1xuXG4gICAgICAgICAgICBtYXNrQ2FyZXRNYXAgPSBbXTtcbiAgICAgICAgICAgIG1hc2tQYXR0ZXJucyA9IFtdO1xuICAgICAgICAgICAgbWFza1BsYWNlaG9sZGVyID0gJyc7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWFzayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgbWluUmVxdWlyZWRMZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAgIHZhciBpc09wdGlvbmFsID0gZmFsc2UsXG4gICAgICAgICAgICAgIG51bWJlck9mT3B0aW9uYWxDaGFyYWN0ZXJzID0gMCxcbiAgICAgICAgICAgICAgc3BsaXRNYXNrID0gbWFzay5zcGxpdCgnJyk7XG5cbiAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNwbGl0TWFzaywgZnVuY3Rpb24oY2hyLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmtPcHRpb25zLm1hc2tEZWZpbml0aW9uc1tjaHJdKSB7XG5cbiAgICAgICAgICAgICAgICAgIG1hc2tDYXJldE1hcC5wdXNoKGNoYXJhY3RlckNvdW50KTtcblxuICAgICAgICAgICAgICAgICAgbWFza1BsYWNlaG9sZGVyICs9IGdldFBsYWNlaG9sZGVyQ2hhcihpIC0gbnVtYmVyT2ZPcHRpb25hbENoYXJhY3RlcnMpO1xuICAgICAgICAgICAgICAgICAgbWFza1BhdHRlcm5zLnB1c2gobGlua09wdGlvbnMubWFza0RlZmluaXRpb25zW2Nocl0pO1xuXG4gICAgICAgICAgICAgICAgICBjaGFyYWN0ZXJDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc09wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pblJlcXVpcmVkTGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNociA9PT0gJz8nKSB7XG4gICAgICAgICAgICAgICAgICBpc09wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIG51bWJlck9mT3B0aW9uYWxDaGFyYWN0ZXJzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbWFza1BsYWNlaG9sZGVyICs9IGNocjtcbiAgICAgICAgICAgICAgICAgIGNoYXJhY3RlckNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBvc2nDp8OjbyBkbyBjdXJzb3IgaW1lZGlhdGFtZW50ZSBhcMOzcyDDumx0aW1hIHBvc2nDp8OjbyB2w6FsaWRhXG4gICAgICAgICAgICBtYXNrQ2FyZXRNYXAucHVzaChtYXNrQ2FyZXRNYXAuc2xpY2UoKS5wb3AoKSArIDEpO1xuXG4gICAgICAgICAgICBtYXNrQ29tcG9uZW50cyA9IGdldE1hc2tDb21wb25lbnRzKCk7XG4gICAgICAgICAgICBtYXNrUHJvY2Vzc2VkID0gbWFza0NhcmV0TWFwLmxlbmd0aCA+IDEgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gYmx1ckhhbmRsZXIoKSB7XG4gICAgICAgICAgICAvLyBTZSBjbGVhck9uQmx1ciBmb3IgdHJ1ZSBlbSBvcHRpb25zLFxuICAgICAgICAgICAgLy8gbGltcGEgbyBjYW1wbyBjYXNvIGVzdGVqYSBpbnbDoWxpZG8uXG4gICAgICAgICAgICBpZiAobGlua09wdGlvbnMuY2xlYXJPbkJsdXIpIHtcbiAgICAgICAgICAgICAgb2xkQ2FyZXRQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgIG9sZFNlbGVjdGlvbkxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgIGlmICghaXNWYWxpZCB8fCB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZU1hc2tlZCA9ICcnO1xuICAgICAgICAgICAgICAgIGVsbS52YWwoJycpO1xuICAgICAgICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGN0cmwuJHNldFZpZXdWYWx1ZSgnJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBtb3VzZURvd25VcEhhbmRsZXIoZSkge1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgICAgICAgZWxtLmJpbmQoJ21vdXNlb3V0JywgbW91c2VvdXRIYW5kbGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsbS51bmJpbmQoJ21vdXNlb3V0JywgbW91c2VvdXRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbG0uYmluZCgnbW91c2Vkb3duIG1vdXNldXAnLCBtb3VzZURvd25VcEhhbmRsZXIpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gbW91c2VvdXRIYW5kbGVyKCkge1xuICAgICAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gICAgICAgICAgICBvbGRTZWxlY3Rpb25MZW5ndGggPSBnZXRTZWxlY3Rpb25MZW5ndGgodGhpcyk7XG4gICAgICAgICAgICBlbG0udW5iaW5kKCdtb3VzZW91dCcsIG1vdXNlb3V0SGFuZGxlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gb25QYXN0ZUhhbmRsZXIoKSB7XG4gICAgICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cbiAgICAgICAgICAgIHNldENhcmV0UG9zaXRpb24odGhpcywgZWxtLnZhbCgpLmxlbmd0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZXZlbnRIYW5kbGVyKGUpIHtcbiAgICAgICAgICAgIC8qanNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICAgICAgICAgICAgZSA9IGUgfHwge307XG4gICAgICAgICAgICAvLyBQZXJtaXRlIHVtYSBtaW5pZmljYcOnw6NvIG1haXMgZWZpY2llbnRlXG4gICAgICAgICAgICB2YXIgZXZlbnRXaGljaCA9IGUud2hpY2gsXG4gICAgICAgICAgICBldmVudFR5cGUgPSBlLnR5cGU7XG5cbiAgICAgICAgICAgIGlmIChldmVudFdoaWNoID09PSAxNiB8fCBldmVudFdoaWNoID09PSA5MSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2YWwgPSBlbG0udmFsKCksXG4gICAgICAgICAgICB2YWxPbGQgPSBvbGRWYWx1ZSxcbiAgICAgICAgICAgIHZhbE1hc2tlZCxcbiAgICAgICAgICAgIHZhbFVubWFza2VkID0gdW5tYXNrVmFsdWUodmFsKSxcbiAgICAgICAgICAgIHZhbFVubWFza2VkT2xkID0gb2xkVmFsdWVVbm1hc2tlZCxcbiAgICAgICAgICAgIGNhcmV0UG9zID0gZ2V0Q2FyZXRQb3NpdGlvbih0aGlzKSB8fCAwLFxuICAgICAgICAgICAgY2FyZXRQb3NPbGQgPSBvbGRDYXJldFBvc2l0aW9uIHx8IDAsXG4gICAgICAgICAgICBjYXJldFBvc0RlbHRhID0gY2FyZXRQb3MgLSBjYXJldFBvc09sZCxcbiAgICAgICAgICAgIGNhcmV0UG9zTWluID0gbWFza0NhcmV0TWFwWzBdLFxuICAgICAgICAgICAgY2FyZXRQb3NNYXggPSBtYXNrQ2FyZXRNYXBbdmFsVW5tYXNrZWQubGVuZ3RoXSB8fCBtYXNrQ2FyZXRNYXAuc2xpY2UoKS5zaGlmdCgpLFxuICAgICAgICAgICAgc2VsZWN0aW9uTGVuT2xkID0gb2xkU2VsZWN0aW9uTGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICBpc1NlbGVjdGVkID0gZ2V0U2VsZWN0aW9uTGVuZ3RoKHRoaXMpID4gMCxcbiAgICAgICAgICAgIHdhc1NlbGVjdGVkID0gc2VsZWN0aW9uTGVuT2xkID4gMCxcbiAgICAgICAgICAgIC8vIENhc2U6IERpZ2l0YW5kbyB1bSBjYXJhY3RlciBwYXJhIHN1YnN0aXR1aXIgdW1hIHNlbGXDp8Ojb1xuICAgICAgICAgICAgaXNBZGRpdGlvbiA9ICh2YWwubGVuZ3RoID4gdmFsT2xkLmxlbmd0aCkgfHwgKHNlbGVjdGlvbkxlbk9sZCAmJiB2YWwubGVuZ3RoID4gdmFsT2xkLmxlbmd0aCAtIHNlbGVjdGlvbkxlbk9sZCksXG4gICAgICAgICAgICAvLyBDYXNlOiBEZWxldGUgZSBiYWNrc3BhY2Ugc2UgY29tcG9ydGFtIGRlIGZvcm1hIGlkw6pudGljYSBlbSB1bWEgc2VsZcOnw6NvXG4gICAgICAgICAgICBpc0RlbGV0aW9uID0gKHZhbC5sZW5ndGggPCB2YWxPbGQubGVuZ3RoKSB8fCAoc2VsZWN0aW9uTGVuT2xkICYmIHZhbC5sZW5ndGggPT09IHZhbE9sZC5sZW5ndGggLSBzZWxlY3Rpb25MZW5PbGQpLFxuICAgICAgICAgICAgaXNTZWxlY3Rpb24gPSAoZXZlbnRXaGljaCA+PSAzNyAmJiBldmVudFdoaWNoIDw9IDQwKSAmJiBlLnNoaWZ0S2V5LCAvLyBBcnJvdyBrZXkgY29kZXNcblxuICAgICAgICAgICAgaXNLZXlMZWZ0QXJyb3cgPSBldmVudFdoaWNoID09PSAzNyxcbiAgICAgICAgICAgIC8vIE5lY2Vzc8OhcmlhIGRldmlkbyBhbyBldmVudG8gbsOjbyBmb3JuZWNlciB1bSBrZXljb2RlXG4gICAgICAgICAgICBpc0tleUJhY2tzcGFjZSA9IGV2ZW50V2hpY2ggPT09IDggfHwgKGV2ZW50VHlwZSAhPT0gJ2tleXVwJyAmJiBpc0RlbGV0aW9uICYmIChjYXJldFBvc0RlbHRhID09PSAtMSkpLFxuICAgICAgICAgICAgaXNLZXlEZWxldGUgPSBldmVudFdoaWNoID09PSA0NiB8fCAoZXZlbnRUeXBlICE9PSAna2V5dXAnICYmIGlzRGVsZXRpb24gJiYgKGNhcmV0UG9zRGVsdGEgPT09IDApICYmICF3YXNTZWxlY3RlZCksXG4gICAgICAgICAgICAvLyBMaWRhIGNvbSBjYXNvcyBvbmRlIGFjZW50byBjaXJjdW5mbGV4byDDqSBtb3ZpZG8gZSBjb2xvY2FkbyBuYSBmcmVudGUgZGEgcG9zacOnw6NvIG1hc2tDYXJldE1hcCBpbnbDoWxpZG8uXG4gICAgICAgICAgICAvLyBMb2dpYyBhYmFpeG8gYXNzZWd1cmEgcXVlLCBhbyBjbGljYXIgb3UgcG9zaWNpb25hbWVudG8gYWNlbnRvIGNpcmN1bmZsZXhvIHBhcmEgYSBlc3F1ZXJkYSwgYWNlbnRvXG4gICAgICAgICAgICAvLyBjaXJjdW5mbGV4byDDqSBtb3ZpZG8gcGFyYSBhIGVzcXVlcmRhIGF0w6kgw6AgZGlyZWl0YSBkaXJlY3RhbWVudGUgZGUgY2Fyw6F0ZXIgbsOjby1tw6FzY2FyYS5cbiAgICAgICAgICAgIC8vIFRhbWLDqW0gYXBsaWNhZG8gcGFyYSBjbGljYXIgdW1hIHZleiBxdWUgb3MgdXN1w6FyaW9zIHPDo28gKGRpc2N1dGl2ZWxtZW50ZSkgbWFpcyBwcm9wZW5zb3MgYSB2b2x0YXJcbiAgICAgICAgICAgIC8vIGF0csOhcyBjb20gdW0gcGVyc29uYWdlbSBhbyBjbGljYXIgZGVudHJvIGRlIHVtYSBlbnRyYWRhIGNoZWlhLlxuICAgICAgICAgICAgY2FyZXRCdW1wQmFjayA9IChpc0tleUxlZnRBcnJvdyB8fCBpc0tleUJhY2tzcGFjZSB8fCBldmVudFR5cGUgPT09ICdjbGljaycpICYmIGNhcmV0UG9zID4gY2FyZXRQb3NNaW47XG5cbiAgICAgICAgICAgIG9sZFNlbGVjdGlvbkxlbmd0aCA9IGdldFNlbGVjdGlvbkxlbmd0aCh0aGlzKTtcblxuICAgICAgICAgICAgLy8gRXZlbnRvcyBxdWUgbsOjbyByZXF1ZXJlbSBuZW5odW1hIGHDp8Ojb1xuICAgICAgICAgICAgaWYgKGlzU2VsZWN0aW9uIHx8IChpc1NlbGVjdGVkICYmIChldmVudFR5cGUgPT09ICdjbGljaycgfHwgZXZlbnRUeXBlID09PSAna2V5dXAnKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb250cm9sZSBkZSB2YWxvcmVzXG4gICAgICAgICAgICAvLyA9PT09PT09PT09PT09PVxuXG4gICAgICAgICAgICAvLyBVc2VyIGF0dGVtcHRlZCB0byBkZWxldGUgYnV0IHJhdyB2YWx1ZSB3YXMgdW5hZmZlY3RlZC0tY29ycmVjdCB0aGlzIGdyaWV2b3VzIG9mZmVuc2VcbiAgICAgICAgICAgIC8vIE8gdXN1w6FyaW8gdGVudG91IGFwYWdhciwgbWFzIHZhbG9yIGJydXRvIG7Do28gZm9pIGFmZXRhZG8gLSBjb3JyaWdpciBlc3RlIGdyYXZlIG9mZW5zYVxuICAgICAgICAgICAgaWYgKChldmVudFR5cGUgPT09ICdpbnB1dCcpICYmIGlzRGVsZXRpb24gJiYgIXdhc1NlbGVjdGVkICYmIHZhbFVubWFza2VkID09PSB2YWxVbm1hc2tlZE9sZCkge1xuICAgICAgICAgICAgICB3aGlsZSAoaXNLZXlCYWNrc3BhY2UgJiYgY2FyZXRQb3MgPiBjYXJldFBvc01pbiAmJiAhaXNWYWxpZENhcmV0UG9zaXRpb24oY2FyZXRQb3MpKSB7XG4gICAgICAgICAgICAgICAgY2FyZXRQb3MtLTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAoaXNLZXlEZWxldGUgJiYgY2FyZXRQb3MgPCBjYXJldFBvc01heCAmJiBtYXNrQ2FyZXRNYXAuaW5kZXhPZihjYXJldFBvcykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY2FyZXRQb3MrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgY2hhckluZGV4ID0gbWFza0NhcmV0TWFwLmluZGV4T2YoY2FyZXRQb3MpO1xuICAgICAgICAgICAgICAvLyBTdHJpcCBvdXQgbm9uLW1hc2sgY2hhcmFjdGVyIHRoYXQgdXNlciB3b3VsZCBoYXZlIGRlbGV0ZWQgaWYgbWFzayBoYWRuJ3QgYmVlbiBpbiB0aGUgd2F5LlxuICAgICAgICAgICAgICB2YWxVbm1hc2tlZCA9IHZhbFVubWFza2VkLnN1YnN0cmluZygwLCBjaGFySW5kZXgpICsgdmFsVW5tYXNrZWQuc3Vic3RyaW5nKGNoYXJJbmRleCArIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBdHVhbGl6YSB2YWxvclxuICAgICAgICAgICAgdmFsTWFza2VkID0gbWFza1ZhbHVlKHZhbFVubWFza2VkKTtcblxuICAgICAgICAgICAgb2xkVmFsdWUgPSB2YWxNYXNrZWQ7XG4gICAgICAgICAgICBvbGRWYWx1ZVVubWFza2VkID0gdmFsVW5tYXNrZWQ7XG4gICAgICAgICAgICBlbG0udmFsKHZhbE1hc2tlZCk7XG4gICAgICAgICAgICBjdHJsLiRzZXRWaWV3VmFsdWUodmFsVW5tYXNrZWQpO1xuXG4gICAgICAgICAgICAvLyBQb3Npw6fDo28gZG8gY3Vyc29yXG4gICAgICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09XG5cbiAgICAgICAgICAgIC8vIENhcmFjdGVyZSBkaWdpdGFkbyBhIGZyZW50ZSBub3MgY2Fzb3MgZW0gcXVlIG8gcHJpbWVpcm8gY2FyYWN0ZXJlIGRlIGVudHJhZGEgw6kgdW0gY2hhciBtw6FzY2FyYSBlIG8gY3Vyc29yXG4gICAgICAgICAgICAvLyBmb3IgY29sb2NhZG8gbmEgcG9zacOnw6NvIDAuXG4gICAgICAgICAgICBpZiAoaXNBZGRpdGlvbiAmJiAoY2FyZXRQb3MgPD0gY2FyZXRQb3NNaW4pKSB7XG4gICAgICAgICAgICAgIGNhcmV0UG9zID0gY2FyZXRQb3NNaW4gKyAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2FyZXRCdW1wQmFjaykge1xuICAgICAgICAgICAgICBjYXJldFBvcy0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXJldFBvcyA9IGNhcmV0UG9zID4gY2FyZXRQb3NNYXggPyBjYXJldFBvc01heCA6IGNhcmV0UG9zIDwgY2FyZXRQb3NNaW4gPyBjYXJldFBvc01pbiA6IGNhcmV0UG9zO1xuXG4gICAgICAgICAgICB3aGlsZSAoIWlzVmFsaWRDYXJldFBvc2l0aW9uKGNhcmV0UG9zKSAmJiBjYXJldFBvcyA+IGNhcmV0UG9zTWluICYmIGNhcmV0UG9zIDwgY2FyZXRQb3NNYXgpIHtcbiAgICAgICAgICAgICAgY2FyZXRQb3MgKz0gY2FyZXRCdW1wQmFjayA/IC0xIDogMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKChjYXJldEJ1bXBCYWNrICYmIGNhcmV0UG9zIDwgY2FyZXRQb3NNYXgpIHx8IChpc0FkZGl0aW9uICYmICFpc1ZhbGlkQ2FyZXRQb3NpdGlvbihjYXJldFBvc09sZCkpKSB7XG4gICAgICAgICAgICAgIGNhcmV0UG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbGRDYXJldFBvc2l0aW9uID0gY2FyZXRQb3M7XG4gICAgICAgICAgICBzZXRDYXJldFBvc2l0aW9uKHRoaXMsIGNhcmV0UG9zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc1ZhbGlkQ2FyZXRQb3NpdGlvbihwb3MpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXNrQ2FyZXRNYXAuaW5kZXhPZihwb3MpID4gLTE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0Q2FyZXRQb3NpdGlvbihpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCFpbnB1dClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgaWYgKGlucHV0LnNlbGVjdGlvblN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlucHV0LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgaWYgKGlzRm9jdXNlZChlbG1bMF0pKSB7XG4gICAgICAgICAgICAgICAgLy8gTWFsZGl0byBzZWphIG8gSUVcbiAgICAgICAgICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24ubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBpbnB1dC52YWx1ZSA/IC1pbnB1dC52YWx1ZS5sZW5ndGggOiAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBzZXRDYXJldFBvc2l0aW9uKGlucHV0LCBwb3MpIHtcbiAgICAgICAgICAgIGlmICghaW5wdXQpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGlmIChpbnB1dC5vZmZzZXRXaWR0aCA9PT0gMCB8fCBpbnB1dC5vZmZzZXRIZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuOyAvLyBJbnB1dHMgZXNjb25kaWRvc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlucHV0LnNldFNlbGVjdGlvblJhbmdlKSB7XG4gICAgICAgICAgICAgIGlmIChpc0ZvY3VzZWQoZWxtWzBdKSkge1xuICAgICAgICAgICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UocG9zLCBwb3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnB1dC5jcmVhdGVUZXh0UmFuZ2UpIHtcbiAgICAgICAgICAgICAgLy8gTWFsZGl0byBzZWphIG8gSUVcbiAgICAgICAgICAgICAgdmFyIHJhbmdlID0gaW5wdXQuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBwb3MpO1xuICAgICAgICAgICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHBvcyk7XG4gICAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGdldFNlbGVjdGlvbkxlbmd0aChpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCFpbnB1dClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgaWYgKGlucHV0LnNlbGVjdGlvblN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChpbnB1dC5zZWxlY3Rpb25FbmQgLSBpbnB1dC5zZWxlY3Rpb25TdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkudGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFuZ3VsYXIubW9kdWxlKCdndW1nYS5kaXJlY3RpdmVzLm1hc2snLCBbXSlcbiAgLmRpcmVjdGl2ZSgnZ3VtZ2FNYXNrJywgTWFzayk7XG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0Jztcblx0TWVudS4kaW5qZWN0ID0gW1wiJGh0dHBcIiwgXCIkY29tcGlsZVwiXTtcblx0LyoqXG5cdCAqIEBuZ2RvYyBkaXJlY3RpdmVcblx0ICogQG5hbWUgIGd1bWdhLmNvcmU6Z3VtZ2FNZW51XG5cdCAqIEByZXN0cmljdCBFXG5cdCAqIEBkZXNjcmlwdGlvblxuXHQgKiAgTyBjb21wb25lbnRlIGd1bWdhTWVudSDDqSB1bWEgZGlyZWN0aXZlIHF1ZSBjcmlhIHVtIG1lbnUgbmEgbGF0ZXJhbCBlc3F1ZXJkYSBkYSB0ZWxhIHBhcmEgZmFjaWxpdGFyIGEgbmF2ZWdhw6fDo28gZG8gdXN1w6FyaW8gbm8gc2lzdGVtYS5cblx0ICogIFNldXMgaXRlbnMgc8OjbyBjYXJyZWdhZG9zIGRlIGZvcm1hIGRpbsOibWljYSBhdHJhdsOpcyBkZSB1bSBhcnF1aXZvIGBqc29uYCBxdWUgw6kgY2FycmVnYWRvIGF0cmF2w6lzIGRlIHVtYSByZXF1aXNpw6fDo28gSFRUUC4gQWzDqW0gZGlzc28sXG5cdCAqICBlbGUgZmF6IHVtIGZpbHRybyBkZSBhY29yZG8gY29tIGFzIGtleXMgcGFzc2FkYXMgcGFyYSBlbGUgdGFtYsOpbSBhdHJhdsOpcyBkZSB1bSBhcnF1aXZvIGBqc29uYC5cblx0ICogICMjIEV4ZW1wbG9cbiAgICAgKiAgVmVqYSB1bSBleGVtcGxvIGVtIGZ1bmNpb25hbWVudG8gW2FxdWldKGh0dHA6Ly9lbWJlZC5wbG5rci5jby9VY010QW9yNnNVQTZzMG9abkppdS9wcmV2aWV3KS5cblx0ICogIEBwYXJhbSB7U3RyaW5nfSBtZW51LXVybCBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIHZhcmnDoXZlbCBjb20gbyBlbmRlcmXDp28gZG8gYXJxdWl2byBganNvbmAgcGFyYSBxdWUgc2VqYSBjYXJyZWdhZGEgYXMgZW50cmFkYXMgZG8gbWVudS5cblx0ICogIEBwYXJhbSB7U3RyaW5nfSBrZXlzLXVybCBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIHZhcmnDoXZlbCBjb20gbyBlbmRlcmXDp28gZG8gYXJxdWl2byBganNvbmAgcGFyYSBxdWUgc2VqYSBjYXJyZWdhZGEgYXMgY2hhdmVzIHF1ZSBmYXLDo28gbyBmaWx0cm8gZG8gbWVudS5cblx0ICogIEBwYXJhbSB7U3RyaW5nfSBpbWFnZSBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIHZhcmnDoXZlbCBjb20gbyBlbmRlcmXDp28gZGEgaW1hZ2VtIHF1ZSBmaWNhcsOhIG5vIG1lbnUuXG5cdCAqXG4gXHQgKiAjIyBFeGFtcGxlXG5cdCAqIFx0IyMjRXhlbXBsbyBkZSBqc29uIHBhcmEgbyBtZW51OlxuXHQgKiA8cHJlPlxuICAgIFtcbiAgICAgIHtcbiAgICAgICAgXCJsYWJlbFwiOiBcIkhvbWVcIixcbiAgICAgICAgXCJVUkxcIjogXCJ3ZWxjb21lXCIsXG4gICAgICAgIFwia2V5XCI6IFwiQ1JVRC1CQVNFXCIsXG4gICAgICAgIFwiaWNvblwiOiBcImdseXBoaWNvbiBnbHlwaGljb24taG9tZVwiLFxuICAgICAgICBcImljb25fY29sb3JcIjogXCJcIixcbiAgICAgICAgXCJpbWFnZVVybFwiOiBcIlwiLFxuICAgICAgICBcImltYWdlV2lkdGhcIjogXCJcIixcbiAgICAgICAgXCJpbWFnZUhlaWdodFwiOiBcIlwiLFxuICAgICAgICBcImZpbGhvc1wiOiBbXVxuICAgICAgfVxuICAgIF1cblx0ICogXHQ8L3ByZT5cblx0ICogXHQjIyNFeGVtcGxvIGRlIGpzb24gcGFyYSBhcyBrZXlzOlxuXHQgKiBcdDxwcmU+XG4gICAgW1xuICAgICAgXCJDUlVELUJBU0VcIixcbiAgICAgIFwiQ1JVRC1Vc2VyXCJcbiAgICBdXG5cdCAqIFx0PC9wcmU+XG5cdCAqXG5cdCAqXG5cdCAqICBAcGFyYW0ge1N0cmluZ30gbWVudS11cmwgUGFyw6JtZXRybyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSB2YXJpw6F2ZWwgY29tIG8gZW5kZXJlw6dvIGRvIGFycXVpdm8gYGpzb25gIHBhcmEgcXVlIHNlamEgY2FycmVnYWRhIGFzIGVudHJhZGFzIGRvIG1lbnUuXG5cdCAqICBAcGFyYW0ge1N0cmluZ30ga2V5cy11cmwgUGFyw6JtZXRybyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSB2YXJpw6F2ZWwgY29tIG8gZW5kZXJlw6dvIGRvIGFycXVpdm8gYGpzb25gIHBhcmEgcXVlIHNlamEgY2FycmVnYWRhIGFzIGNoYXZlcyBxdWUgZmFyw6NvIG8gZmlsdHJvIGRvIG1lbnUuXG5cdCAqICBAcGFyYW0ge1N0cmluZ30gaW1hZ2UgUGFyw6JtZXRybyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSB2YXJpw6F2ZWwgY29tIG8gZW5kZXJlw6dvIGRhIGltYWdlbSBxdWUgZmljYXLDoSBubyBtZW51LlxuXHQgKlxuXG5cdCAqL1xuXHRmdW5jdGlvbiBNZW51KCRodHRwLCAkY29tcGlsZSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRyZXN0cmljdDogJ0UnLFxuXHRcdFx0cmVwbGFjZTogdHJ1ZSxcblx0XHRcdHNjb3BlOiB7fSxcblx0XHRcdGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWwsIGF0dHJzKSB7XG5cdFx0XHRcdHNjb3BlLnYgPSBbXTtcblx0XHRcdFx0dmFyIGluZGV4cyA9IFtdO1xuXHRcdFx0XHR2YXIgY291bnQgPSAwO1xuXG5cdFx0XHRcdHZhciBtZW51T3BlbiA9IGZhbHNlO1xuXG5cdFx0XHRcdCRodHRwLmdldChhdHRycy5tZW51VXJsKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0XHRcdFx0c2NvcGUuZGFkb3MgPSBkYXRhLmRhdGE7XG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0XHRcdFx0dGhyb3cgJ0Vycm86JyArIGRhdGE7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdCRodHRwLmdldChhdHRycy5rZXlzVXJsKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0XHRcdFx0c2NvcGUua2V5cyA9IGRhdGEuZGF0YTtcblx0XHRcdFx0fSwgZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRcdFx0XHR0aHJvdyAnRXJybzonICsgZGF0YTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0c2NvcGUuJHdhdGNoR3JvdXAoWydkYWRvcycsICdrZXlzJ10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAoc2NvcGUuZGFkb3MgJiYgc2NvcGUua2V5cykge1xuXHRcdFx0XHRcdFx0Z2VyYXRlTWVudXMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHZhciBnZXJhdGVNZW51cyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR2YXIgdGVtcGxhdGUgPSBbJzxkaXY+J107XG5cdFx0XHRcdFx0dGVtcGxhdGUucHVzaCgnPGJ1dHRvbiBpZD1cImJ0bi1tZW51XCIgY2xhc3M9XCJidG4gYnRuLWxpbmtcIiBuZy1jbGljaz1cIm1vc3RyYXJNZW51KClcIj48aSBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tYWxpZ24tanVzdGlmeVwiPjwvaT48L2J1dHRvbj4nKTtcblx0XHRcdFx0XHR0ZW1wbGF0ZS5wdXNoKCc8bmF2IGlkPVwibWVudVwiIGNsYXNzPVwiY29sLXNtLTNcIiBuYW1lPVwibWVudVwiPicpO1xuXHRcdFx0XHRcdHRlbXBsYXRlLnB1c2goJzx1bCBjbGFzcz1cIm1lbnUtaG9sZGVyXCI+Jyk7XG5cdFx0XHRcdFx0dGVtcGxhdGUucHVzaCgnPGltZyBuZy1zcmM9XCInICsgYXR0cnMuaW1hZ2UgKyAnXCIgYWx0PVwibG9nb1wiIHdpZHRoPVwiNDAlXCIgY2xhc3M9XCJpbWctY2VudGVyZWRcIj4nKTtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNjb3BlLmRhZG9zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAoa2V5SXNWYWxpZChzY29wZS5kYWRvc1tpXS5rZXkpKSB7XG5cdFx0XHRcdFx0XHRcdHRlbXBsYXRlLnB1c2goZ2VyYXJOYXZQaWxsKHNjb3BlLmRhZG9zW2ldLCAnbWVudScsIHtjb3VudDogLTEsIGxhYmVsOiBudWxsfSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0ZW1wbGF0ZS5wdXNoKCc8L3VsPicpO1xuXHRcdFx0XHRcdHRlbXBsYXRlLnB1c2goJzwvbmF2PicpO1xuXHRcdFx0XHRcdHRlbXBsYXRlLnB1c2goJzwvZGl2PicpO1xuXHRcdFx0XHRcdHRlbXBsYXRlID0gdGVtcGxhdGUuam9pbignXFxuJyk7XG5cdFx0XHRcdFx0ZWwuYXBwZW5kKCRjb21waWxlKHRlbXBsYXRlKShzY29wZSkpO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHZhciBnZXJhck5hdlBpbGwgPSBmdW5jdGlvbiAocGFyYW0sIHR5cGUsIHBhcmVudCkge1xuXG5cdFx0XHRcdFx0c2NvcGUudltjb3VudF0gPSB7XG5cdFx0XHRcdFx0XHRpc0FjdGl2ZTogZmFsc2UsXG5cdFx0XHRcdFx0XHRwYXJlbnQ6IHBhcmVudC5jb3VudFxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHR2YXIgdXJsU2VsZWN0ZWQgPSBsb2NhdGlvbi5oYXNoO1xuXHRcdFx0XHRcdHZhciB1cmwgPSBhbmd1bGFyLmNvcHkocGFyYW0uVVJMKTtcblx0XHRcdFx0XHR1cmwgPSAnIy8nK3VybC5yZXBsYWNlKCcuJywnLycpXG5cdFx0XHRcdFx0aWYgKHVybFNlbGVjdGVkPT11cmwpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRlbXBsYXRlID0gWyc8bGkgY2xhc3M9XCInICsgdHlwZSArICctb3B0aW9uXCIgc3R5bGU9XCJiYWNrZ3JvdW5kOiAjNGNhMDg5XCIgPiddO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0ZW1wbGF0ZSA9IFsnPGxpIGNsYXNzPVwiJyArIHR5cGUgKyAnLW9wdGlvblwiPiddO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChwYXJhbS5maWxob3MubGVuZ3RoID4gMCAmJiB2ZXJpZmljYXJQZXJtaWNhb0ZpbGhvKHBhcmFtLmZpbGhvcykpIHtcblx0XHRcdFx0XHRcdHRlbXBsYXRlLnB1c2goJzxpICBuZy1jbGFzcz1cInZbJyArIGNvdW50ICsgJ10uaXNBY3RpdmUgPyBcXCcgZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWRvd24gXFwnIDogXFwnZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXJpZ2h0XFwnXCIgY2xhc3M9XCJmYSAnICsgdHlwZSArICctY29sb3JcIiAgbmctY2xpY2s9XCJyZXNldGFyTWVudSgnICsgY291bnQgKyAnKVwiPjwvaT4nKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKHBhcmFtLmljb24pIHtcblx0XHRcdFx0XHRcdFx0aWYgKHBhcmFtLmljb25fY29sb3IpIHtcblx0XHRcdFx0XHRcdFx0XHR0ZW1wbGF0ZS5wdXNoKCc8aSAgY2xhc3M9XCIgJyArIHBhcmFtLmljb24gKyAnIFwiIHN0eWxlPVwiY29sb3I6ICcgKyBwYXJhbS5pY29uX2NvbG9yICsgJ1wiIG5nLWNsaWNrPVwicmVzZXRhck1lbnUoJyArIGNvdW50ICsgJylcIj48L2k+Jyk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGVtcGxhdGUucHVzaCgnPGkgIGNsYXNzPVwiICcgKyBwYXJhbS5pY29uICsgJyBcIiBzdHlsZT1cImNvbG9yOiAjZmZmXCIgbmctY2xpY2s9XCJyZXNldGFyTWVudSgnICsgY291bnQgKyAnKVwiPjwvaT4nKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRlbXBsYXRlLnB1c2goJzxhIHVpLXNyZWY9XCInICsgcGFyYW0uVVJMICsgJ1wiIG5nLWNsYXNzPVwidlsnICsgY291bnQgKyAnXS5pc0FjdGl2ZSA/IFxcJ2lzLWFjdGl2ZVxcJyA6IFxcJyBcXCdcIicpO1xuXHRcdFx0XHRcdGlmIChwYXJlbnQubGFiZWwgPT09IG51bGwgfHwgcGFyYW0uZmlsaG9zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdHRlbXBsYXRlLnB1c2goJ2d1bWdhLXRyYW5zbGF0ZS10YWc9XCInICsgcGFyYW0ubGFiZWwudG9Mb3dlckNhc2UoKSArICcubWVudUxhYmVsXCI+Jyk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwYXJhbS5maWxob3MubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHR0ZW1wbGF0ZS5wdXNoKCdndW1nYS10cmFuc2xhdGUtdGFnPVwiJyArIHBhcmVudC5sYWJlbC50b0xvd2VyQ2FzZSgpICsgJy4nICsgcGFyYW0ubGFiZWwudG9Mb3dlckNhc2UoKSArICdcIj4nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGVtcGxhdGUucHVzaChwYXJhbS5sYWJlbCk7XG5cdFx0XHRcdFx0dGVtcGxhdGUucHVzaCgnPC9hPicpO1xuXG5cdFx0XHRcdFx0aWYgKHBhcmFtLmltYWdlVXJsKSB7XG5cdFx0XHRcdFx0XHRpZihwYXJhbS5pbWFnZVdpZHRoICYmIHBhcmFtLmltYWdlSGVpZ2h0KXtcblx0XHRcdFx0XHRcdFx0dGVtcGxhdGUucHVzaCgnPGEgdWktc3JlZj1cIicgKyBwYXJhbS5VUkwgKyAnXCI+PGltZyAgc3JjPVwiJyArIHBhcmFtLmltYWdlVXJsICsgJ1wiIHN0eWxlPVwid2lkdGg6ICcrcGFyYW0uaW1hZ2VXaWR0aCsnOyBoZWlnaHQ6ICcrcGFyYW0uaW1hZ2VIZWlnaHQrJztcIiBuZy1jbGljaz1cInJlc2V0YXJNZW51KCcgKyBjb3VudCArICcpXCI+PC9pPjwvYT4nKTtcblx0XHRcdFx0XHRcdH1lbHNlXG5cdFx0XHRcdFx0XHR0ZW1wbGF0ZS5wdXNoKCc8YSB1aS1zcmVmPVwiJyArIHBhcmFtLlVSTCArICdcIj48aW1nICBzcmM9XCInICsgcGFyYW0uaW1hZ2VVcmwgKyAnXCIgc3R5bGU9XCJ3aWR0aDogMjBweDsgaGVpZ2h0OiAyMHB4O1wiIG5nLWNsaWNrPVwicmVzZXRhck1lbnUoJyArIGNvdW50ICsgJylcIj48L2k+PC9hPicpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBhdXggPSBjb3VudDtcblxuXHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdFx0aWYgKHBhcmFtLmZpbGhvcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0XHR0ZW1wbGF0ZS5wdXNoKCc8dWwgbmctY2xhc3M9XCJ2WycgKyAoY291bnQgLSAxKSArICddLmlzQWN0aXZlID8gXFwnIHN1Ym1lbnUtZ3JvdXAtYXRpdm9cXCcgOiBcXCdzdWJtZW51LWdyb3VwXFwnXCIgY2xhc3M9XCJtZW51LWhvbGRlclwiPicpO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbS5maWxob3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0aWYgKGtleUlzVmFsaWQocGFyYW0uZmlsaG9zW2ldLmtleSkpIHtcblx0XHRcdFx0XHRcdFx0XHR0ZW1wbGF0ZS5wdXNoKGdlcmFyTmF2UGlsbChwYXJhbS5maWxob3NbaV0sICdzdWJtZW51Jywge2NvdW50OiBhdXgsIGxhYmVsOiBwYXJhbS5sYWJlbH0pKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGVtcGxhdGUucHVzaCgnPC91bD4nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGVtcGxhdGUucHVzaCgnPC9saT4nKTtcblx0XHRcdFx0XHRyZXR1cm4gdGVtcGxhdGUuam9pbignXFxuJyk7XG5cdFx0XHRcdH07XG5cblxuXHRcdFx0XHRzY29wZS5yZXNldGFyTWVudSA9IGZ1bmN0aW9uIChpbmRleCkge1xuXHRcdFx0XHRcdHZhciBpO1xuXHRcdFx0XHRcdGlmIChzY29wZS52W2luZGV4XS5pc0FjdGl2ZSkge1xuXHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHNjb3BlLnYubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0c2NvcGUudltpbmRleF0uaXNBY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHNldGFyVHJ1ZShzY29wZS52W2luZGV4XS5wYXJlbnQpO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBzY29wZS52Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHNjb3BlLnZbaV0uaXNBY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHNldGFyVHJ1ZShpbmRleCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dmFyIGtleUlzVmFsaWQgPSBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNjb3BlLmtleXMuaW5kZXhPZihrZXkpICE9IC0xO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGZ1bmN0aW9uIHNldGFyVHJ1ZShpbmRleCkge1xuXHRcdFx0XHRcdGlmIChpbmRleCA+PSAwKSB7XG5cdFx0XHRcdFx0XHRzY29wZS52W2luZGV4XS5pc0FjdGl2ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRzZXRhclRydWUoc2NvcGUudltpbmRleF0ucGFyZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5tb3N0cmFyTWVudSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRtZW51T3BlbiA9ICFtZW51T3BlbjtcblxuXHRcdFx0XHRcdHZhciBlbG0gPSBlbC5maW5kKCduYXYnKTtcblx0XHRcdFx0XHRpZiAobWVudU9wZW4pIHtcblx0XHRcdFx0XHRcdGVsbS5hZGRDbGFzcygnb3Blbi1tZW51Jyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGVsbS5yZW1vdmVDbGFzcygnb3Blbi1tZW51Jyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGZ1bmN0aW9uIHZlcmlmaWNhclBlcm1pY2FvRmlsaG8oZmlsaG9zKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmaWxob3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgc2NvcGUua2V5cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0XHRpZiAoZmlsaG9zW2ldLmtleSA9PSBzY29wZS5rZXlzW2pdKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0YW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMubWVudScsW10pXG5cdC5kaXJlY3RpdmUoJ2d1bWdhTWVudScsTWVudSk7XG5cbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblxuICAndXNlIHN0cmljdCc7XG4gIE5hdi4kaW5qZWN0ID0gW1wiJHN0YXRlXCIsIFwiR3VtZ2FXZWJTdG9yYWdlXCIsIFwiJG1vZGFsXCIsIFwiJHJvb3RTY29wZVwiLCBcIiR0aW1lb3V0XCJdO1xuICAvKipcbiAgKiBAbmdkb2MgZGlyZWN0aXZlXG4gICogQG5hbWUgIGd1bWdhLmNvcmU6Z3VtZ2FOYXZcbiAgKiBAcmVzdHJpY3QgRVxuICAqIEBkZXNjcmlwdGlvbiBPIGNvbXBvbmVudGUgZ3VtZ2FOYXYgw6kgdW1hIGRpcmVjdGl2ZSBxdWUgY3JpYSB1bWEgYmFycmEgZGUgbmF2ZWdhw6fDo28gc3VwZXJpb3IsIHBhcmEgYWp1ZGFyIG8gdXN1w6FyaW8uIERlbnRybyBkYSBiYXJyYSBkZSBuYXZlZ2HDp8OjbyxcbiAgKiAgcG9zc3XDrW1vcyB1bWEgYnVzY2EgcXVlLCBxdWFuZG8gbyBib3TDo28gRU5URVIgw6kgcHJlc3Npb25hZG8sIGVsZSByZWRpcmVjaW9uYSBwYXJhIGEgcMOhZ2luYSBkZSBCdXNjYSBNdWx0aS1lbnRpZGFkZXMuIFBvc3N1aSB0YW1iw6ltIGluZm9ybWHDp8O1ZXMgc29icmUgbyB1c3XDoXJpbyBxdWUgZXN0w6EgbG9nYWRvLFxuICAqICB1bWEgb3DDp8OjbyBwYXJhIGZhemVyIG8gbG9nb3V0IGUgb3V0cmEgcGFyYSBhbHRlcmFyIGEgc2VuaGEuXG4gICogICMjIEV4ZW1wbG9cbiAgKiAgVmVqYSB1bSBleGVtcGxvIGVtIGZ1bmNpb25hbWVudG8gW2FxdWldKGh0dHA6Ly9lbWJlZC5wbG5rci5jby9QZUpIQVM2dml1dHVla3c2MTRaTC9wcmV2aWV3KS5cbiAgKiAgQHBhcmFtIHtTdHJpbmd9IHRpdGxlIFBhcsOibWV0cm8gbsOjbyBvYnJpZ2F0w7NyaW8gcXVlIGNvbnTDqW0gdW1hIHN0cmluZyBxdWUgc2Vyw6EgbyB0w610dWxvIHF1ZSBhcGFyZWNlcsOhIG5hIGJhcnJhIGRlIG5hdmVnYcOnw6NvLlxuICAqICBAcGFyYW0ge0Jvb2xlYW59IG11bHRpLWVudGl0eSBQYXLDom1ldHJvIG5hbyBvYnJpZ2F0w7NyaW8gcXVlIGNvbnTDqW0gdW0gdmFsb3IgYm9vbGVhbm8gcGFyYSBjb21waWxhciBvdSBuw6NvIGEgYnVzY2EgbXVsdGllbnRpZGFkZS4gUG9yIHBhZHLDo28sIG8gdmFsb3Igw6kgdHJ1ZS5cbiAgKiAgQHBhcmFtIHtTdHJpbmd9IHB1dC11cmwgUGFyw6JtZXRybyBuw6NvIG9icmlnYXTDs3JpbyBxdWUgY29udMOpbSB1bWEgU3RyaW5nIG91IHVtYSB2YXJpw6F2ZWwgcXVlIGVzdGFyw6Egbm8gJHNjb3BlIGRhIGRpcmVjdGl2ZSBwYXJhIGF0cmlidWlyIHVtYSB1cmwgcGFyYSBmYXplciBvIHB1dCBkbyBhbHRlcmFyIGEgc2VuaGEuXG4gICogIEBwYXJhbSB7U3RyaW5nfSBzdGF0ZSBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgY29udMOpbSB1bWEgU3RyaW5nIGNvbSBvICRzdGF0ZSBwYXJhIHF1YWwgc2Vyw6EgcmVkaXJlY2lvbmFkbyBxdWFuZG8gbyB1c3XDoXJpbyBjbGljYXIgZW0gTG9nb3V0LlxuICAqL1xuICBmdW5jdGlvbiBOYXYoJHN0YXRlLCBHdW1nYVdlYlN0b3JhZ2UsICRtb2RhbCwgJHJvb3RTY29wZSwgJHRpbWVvdXQpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBbXG4gICAgICAnPG5hdiBpZD1cIm5hdmJhclwiPicsXG4gICAgICAnIDxhIGhyZWY9XCIjXCIgY2xhc3M9XCJuYXZiYXItbG9nb1wiIHN0eWxlPVwiIGZsb2F0OiBsZWZ0O1wiPnt7dGl0bGUgfCB1cHBlcmNhc2V9fTwvYT4nLFxuICAgICAgJyA8c3BhbiBzdHlsZT1cImNvbG9yOiB3aGl0ZTsgZm9udC1zaXplOiAxLjRlbTttYXJnaW4tbGVmdDogMiU7IGZsb2F0OiBsZWZ0O1wiPjxzbWFsbD57e2luZm8ub3JnYW5pemF0aW9ufX08L3NtYWxsPjwvc3Bhbj4nLFxuICAgICAgJyA8ZGl2IGNsYXNzPVwibmF2YmFyLWZvcm0gbmF2YmFyLWxlZnRcIiBuZy10cmFuc2NsdWRlPjwvZGl2PicsXG4gICAgICAnIDxiIGNsYXNzPVwicHVsbC1yaWdodFwiPicsXG4gICAgICAnICAgPGltZyBuZy1zaG93PVwiaW5mby5waWN0dXJlXCIgY2xhc3M9XCJpbWctY2lyY2xlXCIgc3R5bGU9XCJ3aWR0aDogNDBweDsgaGVpZ2h0OiA0MHB4OyBtYXJnaW4tcmlnaHQ6MTBweDtcIiBzcmM9XCJ7e2luZm8ucGljdHVyZX19XCIgLz4nLFxuICAgICAgJyAgIDxhIGhyZWYgbmctYmx1cj1cImhpZGVQYW5lbCgpXCIgY2xhc3M9XCJzdGF0dXMtbmF2YmFyXCIgbmctY2xpY2s9XCJzaG93UGFuZWxOYXZCYXIoKVwiPicsXG4gICAgICAnICAgICA8c21hbGwgIHN0eWxlPVwiZm9udC1zaXplOiA4NSU7XCI+e3tpbmZvLm5hbWV9fSAmbmJzcDsmbmJzcDsgPGkgY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXRyaWFuZ2xlLWJvdHRvbVwiIHN0eWxlPVwibWFyZ2luLWxlZnQ6IDFweFwiPjwvaT4gPC9zbWFsbD4nLFxuICAgICAgJyAgIDwvYT4nLFxuICAgICAgJyA8L2I+JyxcbiAgICAgICcgPHNwYW4gbmctaWY9XCJtdWx0aWVudGl0eVwiIG5nLWNsaWNrPVwidHJlYXRVcmwoKVwiIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1zZWFyY2ggYnRuIHB1bGwtcmlnaHRcIiBzdHlsZT1cImNvbG9yOiNmZmY7IHBhZGRpbmctdG9wOiAxJTsgbWFyZ2luLXJpZ2h0OiA1JTsgaGVpZ2h0OiAxMDAlO1wiPjwvc3Bhbj4nLFxuICAgICAgJyA8aW5wdXQgbmctaWY9XCJtdWx0aWVudGl0eVwiIHR5cGU9XCJ0ZXh0XCIgaWQ9XCJpbnB1dFNlYXJjaFwiIG5nLWtleXVwPVwic3VibWl0U2VhcmNoKCRldmVudClcIiBzdHlsZT1cImJhY2tncm91bmQ6IG5vbmUgcmVwZWF0IHNjcm9sbCAwIDAgcmdiYSgyNDQsIDIxNCwgMjE0LCAwLjE1KTsgYm9yZGVyOiBkb3VibGU7IGZvbnQtc2l6ZTogMTRweDsgb3V0bGluZTogMDsgY29sb3I6ICNmZmY7IGhlaWdodDogMTAwJTsgbWFyZ2luOiAwOyBib3JkZXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMCk7IHotaW5kZXg6IDIwMDA7XCIgbmctbW9kZWw9XCJzZWFyY2hcIiBuZy1zaG93PVwiaW5wdXRWaXNpYmxlXCIgY2xhc3M9XCJuYXZiYXItaW5wdXQgZmxpcC1yaWdodFwiIHBsYWNlaG9sZGVyPVwiU2VhcmNoXCI+JyxcbiAgICAgICc8L25hdj4nLFxuICAgICAgJzxkaXYgY2xhc3M9XCJuYXYtcGFuZWxcIiBuZy1zaG93PVwic2hvd1BhbmVsTmF2XCI+JyxcbiAgICAgICcgPGRpdiBjbGFzcz1cInBhbmVsLWJvZHlcIiBpZD1cIm5hdlBhbmVsQm9keVwiPicsXG4gICAgICAnICAgPGJ1dHRvbiBuZy1yZXBlYXQ9XCJsaW5rIGluIG5hdmxpbmtzXCIgbmctY2xpY2s9XCJoYW5kbGUobGluaylcIiBjbGFzcz1cImJ0biBidG4tbGlua1wiIHN0eWxlPVwiZGlzcGxheTpibG9jazt3aWR0aDogMTAwJTtjb2xvcjogYmxhY2s7IGZvbnQtc2l6ZTogMC45ZW07XCI+PGkgY2xhc3M9XCJ7e2xpbmsuZ2x5cGhpY29ufX1cIj4gPC9pPnt7bGluay50ZXh0fX0gPC9idXR0b24+JyxcbiAgICAgICcgPC9kaXY+JyxcbiAgICAgICc8L2Rpdj4nXG4gICAgXTtcblxuICAgIHZhciBtb2RhbFRlbXBsYXRlID0gW1xuICAgICAgJzxkaXYgY2xhc3M9XCJtb2RhbC1oZWFkZXJcIj5DaGFuZ2UgUGFzc3dvcmQ8L2Rpdj4nLFxuICAgICAgJzxkaXYgY2xhc3M9XCJtb2RhbC1ib2R5XCI+JyArXG4gICAgICAnICAgPGZvcm0gbmFtZT1cIk1vZGFsRm9ybVwiIG5vdmFsaWRhdGU+JyArXG4gICAgICAnICAgPGxhYmVsPiA8c21hbGw+T2xkIFBhc3N3b3JkPC9zbWFsbD48L2xhYmVsPicgK1xuICAgICAgJyAgIDxpbnB1dCB0eXBlPVwicGFzc3dvcmRcIiBuZy1rZXl1cD1cInZhbGlkUGFzc3dvcmQodXNlci5uZXdwYXNzLCB1c2VyLm9sZHBhc3MpXCIgbmctZm9jdXM9XCJvbGRQYXNzd29yZEludmFsaWQ9ZmFsc2VcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIG5nLW1vZGVsPVwidXNlci5vbGRwYXNzXCIgcmVxdWlyZWQvPicgK1xuICAgICAgJyAgIDxsYWJlbCBjbGFzcz1cInRleHQtZGFuZ2VyXCIgc3R5bGU9XCJ3aWR0aDogMTAwJTtcIiAgbmctc2hvdz1cIm9sZFBhc3N3b3JkSW52YWxpZFwiPkVzdGEgbsOjbyDDqSBzdWEgc2VuaGEgYW50aWdhPC9sYWJlbD4nICtcbiAgICAgICcgICA8bGFiZWw+PHNtYWxsPiBOZXcgUGFzc3dvcmQ8L3NtYWxsPjwvbGFiZWw+JyArXG4gICAgICAnICAgPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgbmcta2V5dXA9XCJ2YWxpZFBhc3N3b3JkKHVzZXIubmV3cGFzcywgdXNlci5vbGRwYXNzKVwiIG5nLW1vZGVsPVwidXNlci5uZXdwYXNzXCIgcmVxdWlyZWQvPicgK1xuICAgICAgJyAgIDxsYWJlbCBjbGFzcz1cInRleHQtZGFuZ2VyXCIgc3R5bGU9XCJ3aWR0aDogMTAwJTtcIiAgbmctc2hvdz1cIm5ld1Bhc3N3b3JkSW52YWxpZFwiPlBvciBmYXZvciBpbnNpcmEgdW1hIHNlbmhhIGRpZmVyZW50ZSBkYSBhbnRpZ2EuPC9sYWJlbD4nICtcbiAgICAgICcgICA8bGFiZWw+PHNtYWxsPiBOZXcgUGFzc3dvcmQgKGFnYWluKTwvc21hbGw+PC9sYWJlbD4nICtcbiAgICAgICcgICA8aW5wdXQgdHlwZT1cInBhc3N3b3JkXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBuZy1rZXl1cD1cInZhbGlkUGFzc3dvcmRDb25maXJtKHVzZXIubmV3cGFzcyx1c2VyLm5ld3Bhc3NjaGVjaylcIiBuZy1tb2RlbD1cInVzZXIubmV3cGFzc2NoZWNrXCIgcmVxdWlyZWQvPicgK1xuICAgICAgJyAgIDxsYWJlbCBjbGFzcz1cInRleHQtZGFuZ2VyXCIgc3R5bGU9XCJ3aWR0aDogMTAwJTtcIiAgbmctc2hvdz1cIm5ld1Bhc3N3b3JkQ29uZmlybVwiPlJlcGl0YSBhIG5vdmEgc2VuaGEgY29ycmV0YW1lbnRlLjwvbGFiZWw+JyArXG4gICAgICAnPC9kaXY+JyxcbiAgICAgICc8ZGl2IGNsYXNzPVwibW9kYWwtZm9vdGVyXCI+JyArXG4gICAgICAnICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiIG5nLWNsaWNrPVwib2sodXNlcilcIiB0eXBlPVwic3VibWl0XCIgbmctZGlzYWJsZWQ9XCJNb2RhbEZvcm0uJGludmFsaWQgfHwgIWJ0bkVuYWJsZWRcIj4gU2F2ZTwvYnV0dG9uPicgK1xuICAgICAgJyAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXdhcm5pbmdcIiBuZy1jbGljaz1cImNhbmNlbCgpXCIgdHlwZT1cImJ1dHRvblwiPiBDYW5jZWw8L2J1dHRvbj4nICtcbiAgICAgICc8L2Rpdj4nICtcbiAgICAgICc8L2Zvcm0+J107XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICBzY29wZTogZmFsc2UsXG4gICAgICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZS5qb2luKCdcXG4nKSxcbiAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbCwgYXR0cnMpIHtcbiAgICAgICAgICB2YXIgcHV0VXJsID0gYXR0cnMucHV0VXJsO1xuICAgICAgICAgIGlmKGF0dHJzLm11bHRpRW50aXR5ID09IFwidHJ1ZVwiIHx8ICFhdHRycy5tdWx0aUVudGl0eSkgc2NvcGUubXVsdGllbnRpdHkgPSB0cnVlO1xuICAgICAgICAgICghc2NvcGVbYXR0cnMucHV0VXJsXSkgPyBwdXRVcmwgPSBzY29wZVthdHRycy5wdXRVcmxdIDogYW5ndWxhci5ub29wO1xuICAgICAgICAgIHNjb3BlLmluZm8gPSBHdW1nYVdlYlN0b3JhZ2UuZ2V0U2Vzc2lvblN0b3JhZ2VJdGVtKCd1c2VyJyk7XG4gICAgICAgICAgc2NvcGUubmF2bGlua3MgPSBbe3RleHQ6ICdDaGFuZ2UgUGFzc3dvcmQnLCBnbHlwaGljb246ICdnbHlwaGljb24gZ2x5cGhpY29uLXVzZXInLCB2YWx1ZTogJ3Bhc3MnfSwge3RleHQ6ICdMb2dvdXQnLCBnbHlwaGljb246ICdnbHlwaGljb24gZ2x5cGhpY29uLWxvZy1vdXQnLCB2YWx1ZTogJ2xvZ291dCd9XTtcbiAgICAgICAgICBzY29wZS5pbnB1dFZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICBzY29wZS50aXRsZSA9IGF0dHJzLnRpdGxlIHx8ICcnO1xuICAgICAgICAgIHNjb3BlLnRyZWF0VXJsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2NvcGUuaW5wdXRWaXNpYmxlID0gIXNjb3BlLmlucHV0VmlzaWJsZTtcbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lucHV0U2VhcmNoJykuZm9jdXMoKTtcbiAgICAgICAgICAgIH0sMjAwKTtcblxuICAgICAgICAgIH07XG4gICAgICAgICAgc2NvcGUuJG9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNjb3BlLnNob3dQYW5lbE5hdiA9IGZhbHNlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNjb3BlLnNob3dQYW5lbE5hdkJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNjb3BlLnNob3dQYW5lbE5hdiA9ICFzY29wZS5zaG93UGFuZWxOYXY7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgb2JqID0ge307XG5cbiAgICAgICAgICBzY29wZS5zdWJtaXRTZWFyY2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBrZXlfY29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgICAgICAgICBpZiAoa2V5X2NvZGUgPT09IDEzKVxuICAgICAgICAgICAgJHN0YXRlLmdvKCdtdWx0aWVudGl0eScsIHsnc2VhcmNoJzogc2NvcGUuc2VhcmNofSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY29wZS5oaWRlUGFuZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHNjb3BlLnNob3dQYW5lbE5hdiA9IGZhbHNlO1xuICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgc2NvcGUuaGFuZGxlID0gZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICAgIHNjb3BlLnNob3dQYW5lbE5hdiA9ICFzY29wZS5zaG93UGFuZWxOYXY7XG4gICAgICAgICAgICBzd2l0Y2ggKGxpbmsudmFsdWUpIHtcbiAgICAgICAgICAgICAgY2FzZSAncGFzcyc6XG4gICAgICAgICAgICAgIHZhciBtb2RhbEluc3RhbmNlID0gJG1vZGFsLm9wZW4oe1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBtb2RhbFRlbXBsYXRlLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgICAgIHNpemU6ICdzbScsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogW1wiJHNjb3BlXCIsIFwiJG1vZGFsSW5zdGFuY2VcIiwgXCIkaHR0cFwiLCBcIkd1bWdhV2ViU3RvcmFnZVwiLCBmdW5jdGlvbiAoJHNjb3BlLCAkbW9kYWxJbnN0YW5jZSwgJGh0dHAsIEd1bWdhV2ViU3RvcmFnZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHVzZXJTZXNzaW9uID0gR3VtZ2FXZWJTdG9yYWdlLmdldFNlc3Npb25TdG9yYWdlSXRlbSgndXNlcicpO1xuICAgICAgICAgICAgICAgICAgJHNjb3BlLmJ0bkVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICRzY29wZS5vbGRQYXNzd29yZEludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICRzY29wZS5uZXdQYXNzd29yZENvbmZpcm0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICRzY29wZS5uZXdQYXNzd29yZEludmFsaWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgJHNjb3BlLnZhbGlkUGFzc3dvcmRDb25maXJtID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBjb25maW1QYXNzd29yZCl7XG4gICAgICAgICAgICAgICAgICAgIGlmKHBhc3N3b3JkICE9PSBjb25maW1QYXNzd29yZCl7XG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm5ld1Bhc3N3b3JkQ29uZmlybSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5uZXdQYXNzd29yZENvbmZpcm0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZW5hYmxlZEJ0bigpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAkc2NvcGUudmFsaWRQYXNzd29yZCA9IGZ1bmN0aW9uIChwYXNzd29yZCwgb2xkUGFzc3dvcmQpe1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUudXNlci5uZXdwYXNzY2hlY2sgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYocGFzc3dvcmQgPT0gb2xkUGFzc3dvcmQgJiYgcGFzc3dvcmQpe1xuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5uZXdQYXNzd29yZEludmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUubmV3UGFzc3dvcmRJbnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmVuYWJsZWRCdG4oKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgJHNjb3BlLmVuYWJsZWRCdG4gPSBmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoISRzY29wZS5uZXdQYXNzd29yZENvbmZpcm0gJiYgISRzY29wZS5uZXdQYXNzd29yZEludmFsaWQpe1xuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5idG5FbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmJ0bkVuYWJsZWQ9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICRzY29wZS5vayA9IGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICRodHRwLnB1dChhdHRycy5wdXRVcmwsIHtcbiAgICAgICAgICAgICAgICAgICAgICB1c2VyOiB1c2VyU2Vzc2lvbi51c2VyLFxuICAgICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiB1c2VyLm9sZHBhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgbmV3UGFzc3dvcmQ6IHVzZXIubmV3cGFzc30pXG4gICAgICAgICAgICAgICAgICAgICAgLnN1Y2Nlc3MoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnJlc3BvbnNlID09ICdCQURfUEFTU1dPUkQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5vbGRQYXNzd29yZEludmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnJlc3BvbnNlID09ICdPSycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRlbWl0KCdzdWNjZXNzTWVzc2FnZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1NlbmhhIGFsdGVyYWRhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnU3VhIHNlbmhhIGZvaSBhbHRlcmFkYSBjb20gc3VjZXNzby4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICRtb2RhbEluc3RhbmNlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAkbW9kYWxJbnN0YW5jZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICRtb2RhbEluc3RhbmNlLmRpc21pc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICByZXNvbHZlOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG1vZGFsSW5zdGFuY2UucmVzdWx0LnRoZW4oZnVuY3Rpb24gKHNlbGVjdGVkSXRlbSkge1xuICAgICAgICAgICAgICAgICAgc2NvcGUuc2VsZWN0ZWQgPSBzZWxlY3RlZEl0ZW07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbG9nb3V0JzpcbiAgICAgICAgICAgICAgICAkc3RhdGUuZ28oYXR0cnMuc3RhdGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZWwuZmluZCgnaW5wdXQnKVxuICAgICAgICAgICAgLm9uKCdrZXlwcmVzcycsIGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgIGlmIChrLmtleUNvZGUgPT0gMTMpXG4gICAgICAgICAgICAgIHNjb3BlLnRyZWF0VXJsKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgYW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMubmF2JyxbJ3VpLmJvb3RzdHJhcCddKVxuICAgICAgLmRpcmVjdGl2ZSgnZ3VtZ2FOYXYnLE5hdilcbiAgICB9KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRPbmVUb01hbnkuJGluamVjdCA9IFtcIiRtb2RhbFwiLCBcIiRwb3B1bGF0ZVwiXTtcblx0LyoqXG5cdCAqIEBuZ2RvYyBkaXJlY3RpdmVcblx0ICogQG5hbWUgZ3VtZ2EuY29yZTpndW1nYU9uZVRvTWFueVxuXHQgKiBAcmVzdHJpY3QgRVxuXHQgKiBAZGVzY3JpcHRpb25cblx0ICogXHRBIGRpcmVjdGl2ZSBndW1nYU9uZVRvTWFueSBwb2RlIHNlciB1c2FkYSBxdWFuZG8gw6kgbmVjZXNzw6FyaWEgYSBjcmlhw6fDo28gZGUgdW1hIGxpc3RhIGRlIG9iamV0b3MgZGVudHJvIGRvIGZvcm11bMOhcmlvLCBlc3BlY2lhbG1lbnRlIHF1YW5kbyBlc3Nlc1xuXHQgKiBcdG9iamV0b3MgYWNlc3NhbSBvdXRyb3MgU2VydmljZXMuIEVsYSBsYW7Dp2EgdW0gbW9kYWwgcGFyYSBhIGNyaWHDp8OjbyBkZXN0ZXMgb2JqZXRvcywgcXVlIHBvZGVtIHNlciByZWN1cnNpdm9zLiBBbMOpbSBkaXNzbywgcG9zc3VpIHN1cG9ydGUgYSBlZGnDp8OjbyBlIHJlbW/Dp8Ojb1xuXHQgKiBcdGRlc3RlcyByZWdpc3Ryb3MuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNoaWxkcmVuIFBhcsOibWV0cm8gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bSBBcnJheSBxdWUgc2Vyw6EgdXRpbGl6YWRvIHBhcmEgY29uc3RydWlyIGEgbGlzdGEuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZS11cmwgUGFyw6JtZXRybyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSBzdHJpbmcgcmVmZXJlbmNpYW5kbyBhIHVybCBuYSBxdWFsIG8gdGVtcGxhdGUgZG8gbW9kYWwgZXN0YXLDoS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFBhcsOibWV0cm8gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgc3RyaW5nIGNvbSBhIHByb3ByaWVkYWRlIGRvIG9iamV0byBxdWUgc2Vyw6EgbW9zdHJhZGEgbmEgbGlzdGEuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lICpVdGlsaXphciBtb2RhbC10aXRsZSouXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBtb2RhbC10aXRsZSBQYXLDom1ldHJvIG7Do28gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgc3RyaW5nIGNvbSBvIHTDrXR1bG8gcXVlIHNlcsOhIHBhc3NhZG8gcGFyYSBvIGNvbnRyb2xsZXJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbnRyb2xsZXIgUGFyw6JtZXRybyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSBTdHJpbmcgcXVlIHJlZmVyZW5jaWFyw6EgbyBub21lIGRvIGNvbnRyb2xsZXIgcXVlIHNlcsOhIGF0cmlidWlkbyBhbyBtb2RhbC5cblx0ICogKkVzdGUgY29udHJvbGxlciBuZWNlc3NpdGEgaW5qZXRhciBhbMOpbSBkbyAkc2NvcGUsIGFzIHByb3ByaWVkYWRlcyAqKmVudGl0eSoqIGUgKip0aXRsZSoqICpcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gb24tZGVsZXRlIFBhcsOibWV0cm8gbsOjbyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSB2YXJpw6F2ZWwgcXVlIGlyw6EgY29udGVyIHVtYSBmdW7Dp8OjbyBxdWUgc2Vyw6EgY2hhbWFkYSBxdWFuZG8gdW0gZWxlbWVudG8gZGEgbGlzdGEgZm9yIGRlbGV0YWRvLlxuXHQgKiBBIGZ1bsOnw6NvIHF1ZSBlc3TDoSBubyBvbi1kZWxldGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb24tdmFsdWUtdmlzdWFsaXphdGlvbi1vcGVuZWQgUGFyw6JtZXRybyBuw6NvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIHZhcmnDoXZlbCBxdWUgcG9zc3VpcsOhIHVtYSBmdW7Dp8OjbyBxdWUgaXLDoSBzZXIgZXhlY3V0YWRhIHF1YW5kbyBvIHVzdcOhcmlvIHRpdmVyIGFiZXJ0byBvIG1vZGFsXG4gICAqIHBhcmEgdmlzdWFsaXphw6fDo28gZGUgZGFkb3NcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb24tdmFsdWUtdmlzdWFsaXphdGlvbi1jbG9zZWQgUGFyw6JtZXRybyBuw6NvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIHZhcmnDoXZlbCBxdWUgcG9zc3VpcsOhIHVtYSBmdW7Dp8OjbyBxdWUgaXLDoSBzZXIgZXhlY3V0YWRhIHF1YW5kbyBvIHVzdcOhcmlvIHRpdmVyIGZlY2hhZG8gbyBtb2RhbFxuICAgKiBwYXJhIHZpc3VhbGl6YcOnw6NvIGRlIGRhZG9zXG5cdCAqXG5cdCAqL1xuXHRmdW5jdGlvbiBPbmVUb01hbnkoJG1vZGFsLCRwb3B1bGF0ZSl7XG5cdFx0dmFyIHRlbXBsYXRlID0gW1xuXHRcdCc8ZGl2IGNsYXNzPVwiY29sLW1kLTEyXCIgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6IDA7cGFkZGluZy1yaWdodDogMFwiPicsXG5cdFx0JyAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0XCIgbmctY2xpY2s9XCJuZXdNb2RhbCgpXCI+TmV3PC9idXR0b24+Jyxcblx0XHQnICAgPHVsIGNsYXNzPVwibGlzdC1ncm91cFwiPicsXG5cdFx0JyAgICAgICA8bGkgbmctcmVwZWF0PVwiY2hpbGQgaW4gY2hpbGRyZW5cIiBjbGFzcz1cImxpc3QtZ3JvdXAtaXRlbVwiPicsXG5cdFx0JyAgICAgICAgICAge3s6OmNoaWxkW3Byb3BlcnR5XX19Jyxcblx0XHQnICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdCBwdWxsLXJpZ2h0IGJ0bi1zbVwiIG5nLWNsaWNrPVwibmV3TW9kYWwoY2hpbGQpXCI+PGkgY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXBlbmNpbFwiPjwvaT48L2J1dHRvbj4nLFxuXHRcdCcgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1kYW5nZXIgcHVsbC1yaWdodCBidG4tc21cIiBuZy1jbGljaz1cInJlbW92ZUZyb21MaXN0KGNoaWxkKVwiPjxpIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZW1vdmVcIj48L2k+PC9idXR0b24+Jyxcblx0XHQnICAgICAgIDxkaXYgY2xhc3M9XCJjbGVhcmZpeFwiPjwvZGl2PjwvbGk+Jyxcblx0XHQnICAgPHVsPicsXG5cdFx0JzwvZGl2PicsXG5cdFx0JzxkaXYgY2xhc3M9XCJjbGVhcmZpeFwiPjwvZGl2Pidcblx0XHRdO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHJlc3RyaWN0OiAnRScsXG5cdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuam9pbignXFxuJyksXG5cdFx0XHRzY29wZToge1xuXHRcdFx0XHRjaGlsZHJlbjogJz0nLFxuXHRcdFx0XHR0ZW1wbGF0ZVVybDogJ0AnLFxuXHRcdFx0XHRwcm9wZXJ0eTogJ0BkaXNwbGF5YWJsZVByb3BlcnR5Jyxcblx0XHRcdFx0bmFtZTogJ0AnLFxuXHRcdFx0XHRjb250cm9sbGVyOiAnQCcsXG5cdFx0XHRcdG9uRGVsZXRlOiAnJj8nLFxuXHRcdFx0XHRvblZhbHVlVmlzdWFsaXphdGlvbk9wZW5lZDogJyY/Jyxcblx0XHRcdFx0b25WYWx1ZVZpc3VhbGl6YXRpb25DbG9zZWQ6ICcmPycsXG5cdFx0XHRcdG1vZGFsVGl0bGU6ICdAJ1xuXHRcdFx0fSxcblx0XHRcdGxpbms6IGZ1bmN0aW9uIChzY29wZSxlbG0sYXR0cnMpIHtcblx0XHRcdFx0dmFyIGV2ZW50SGFuZGxlciA9IHtcblx0XHRcdFx0XHR2YWx1ZVZpc3VhbGl6YXRpb25PcGVuZWQ6IChhdHRycy5vblZhbHVlVmlzdWFsaXphdGlvbk9wZW5lZCA/IHNjb3BlLm9uVmFsdWVWaXN1YWxpemF0aW9uT3BlbmVkIDphbmd1bGFyLm5vb3ApLFxuXHRcdFx0XHRcdHZhbHVlVmlzdWFsaXphdGlvbkNsb3NlZDogKGF0dHJzLm9uVmFsdWVWaXN1YWxpemF0aW9uQ2xvc2VkID8gc2NvcGUub25WYWx1ZVZpc3VhbGl6YXRpb25DbG9zZWQgOmFuZ3VsYXIubm9vcCksXG5cdFx0XHRcdFx0ZGVsZXRlOiAoYXR0cnMub25EZWxldGUgPyBzY29wZS5vbkRlbGV0ZSA6IGFuZ3VsYXIubm9vcClcblx0XHRcdFx0fTtcblx0XHRcdFx0c2NvcGUubmV3TW9kYWwgPSBuZXdNb2RhbDtcblx0XHRcdFx0c2NvcGUucmVtb3ZlRnJvbUxpc3QgPSByZW1vdmVGcm9tTGlzdDtcblx0XHRcdFx0c2NvcGUuZ2V0RnJvbU1vZGFsID0gZ2V0RnJvbU1vZGFsO1xuXHRcdFx0XHR2YXIgbmFtZSA9IGF0dHJzLm5hbWUgfHwgJ05ldyc7XG5cdFx0XHRcdGlmKCFzY29wZS5jaGlsZHJlbikgdGhyb3cgJ1lvdSBtdXN0IHByb3ZpZGUgYSBsaXN0IHRvIEd1bWdhT25lVG9NYW55Jztcblx0XHRcdFx0aWYoIXNjb3BlLnRlbXBsYXRlVXJsKSB0aHJvdyAnWW91IG11c3QgcHJvdmlkZSBhIHRlbXBsYXRlVXJsIGZvciB0aGUgbW9kYWwnO1xuXHRcdFx0XHRpZighc2NvcGUucHJvcGVydHkpIHRocm93ICdZb3UgbXVzdCBwcm92aWRlIGEgcHJvcGVydHkgdG8gZGlzcGxheSBpbiBHdW1nYU9uZVRvTWFueSc7XG5cdFx0XHRcdGlmKCFzY29wZS5jb250cm9sbGVyKSB0aHJvdyAnWW91IG11c3QgcHJvdmlkZSBhIGNvbnRyb2xsZXIgdG8gdGhlIG1vZGFsJztcblx0XHRcdFx0ZnVuY3Rpb24gZ2V0RnJvbU1vZGFsKHNlbGVjdGVkKXtcblx0XHRcdFx0XHRldmVudEhhbmRsZXIudmFsdWVWaXN1YWxpemF0aW9uQ2xvc2VkKCk7XG5cdFx0XHRcdFx0aWYoSlNPTi5zdHJpbmdpZnkoc2NvcGUuZXR0eSkgIT09ICd7fScpe1xuXHRcdFx0XHRcdFx0c2NvcGUuY2hpbGRyZW4uc3BsaWNlKHNjb3BlLmNoaWxkcmVuLmluZGV4T2Yoc2NvcGUuZXR0eSksMSxzZWxlY3RlZCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNjb3BlLmNoaWxkcmVuLnB1c2goc2VsZWN0ZWQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRmdW5jdGlvbiByZW1vdmVGcm9tTGlzdChvYmope1xuXHRcdFx0XHRcdGV2ZW50SGFuZGxlci5kZWxldGUoeyR2YWx1ZTogb2JqfSk7XG5cdFx0XHRcdFx0c2NvcGUuY2hpbGRyZW4uc3BsaWNlKHNjb3BlLmNoaWxkcmVuLmluZGV4T2Yob2JqKSwxKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmdW5jdGlvbiBuZXdNb2RhbChvYmope1xuXHRcdFx0XHRcdHNjb3BlLmV0dHkgPSB7fTtcblx0XHRcdFx0XHRpZihvYmope1xuXHRcdFx0XHRcdFx0c2NvcGUuZXR0eT0gb2JqO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRldmVudEhhbmRsZXIudmFsdWVWaXN1YWxpemF0aW9uT3BlbmVkKCk7XG5cdFx0XHRcdFx0dmFyIG1vZGFsSW5zdGFuY2UgPSAkbW9kYWwub3Blbih7XG5cdFx0XHRcdFx0XHR0ZW1wbGF0ZVVybDogc2NvcGUudGVtcGxhdGVVcmwsXG5cdFx0XHRcdFx0XHRjb250cm9sbGVyOiBzY29wZS5jb250cm9sbGVyLFxuXHRcdFx0XHRcdFx0cmVzb2x2ZToge1xuXHRcdFx0XHRcdFx0XHRlbnRpdHk6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHNjb3BlLmV0dHk7XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHRpdGxlOiBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBzY29wZS5uYW1lO1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRwb3B1bGF0ZVNjb3BlOiBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAkcG9wdWxhdGUucG9wdWxhdGVTY29wZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdG1vZGFsSW5zdGFuY2UucmVzdWx0LnRoZW4oZ2V0RnJvbU1vZGFsKTtcblx0XHRcdFx0fVxuXG5cblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0YW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMub25ldG9tYW55JyxbJ2d1bWdhLnNlcnZpY2VzLnBvcHVsYXRlJ10pXG5cdFx0LmRpcmVjdGl2ZSgnZ3VtZ2FPbmVUb01hbnknLE9uZVRvTWFueSlcblxuXG59KSgpO1xuIiwiKGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIFF1ZXJ5LiRpbmplY3Q9IFtdO1xuICAvKipcbiAgICogQG5nZG9jIGRpcmVjdGl2ZVxuICAgKiBAbmFtZSBndW1nYS5jb3JlOmd1bWdhUXVlcmllc1xuICAgKiBAcmVzdHJpY3QgRVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogXHRPIGNvbXBvbmVudGUgZ3VtZ2FRdWVyaWVzIHBvZGUgc2VyIHV0aWxpemFkbyBjb21vIHVtIGNvbXBsZW1lbnRvIHBhcmEgYSBkaXJlY3RpdmUgZ3VtZ2FTZWFyY2ggcGFyYSBxdWFuZG8gZWxhIGZvciB1bWEgYnVzY2EgYXZhbsOnYWRhLiBFbGUgdXRpbGl6YSBvIGFycmF5IHNlYXJjaFF1ZXJpZXMgcXVlIMOpXG4gICAqIFx0ZXhwb3N0byBwZWxvIGNvbXBvbmVudGUgZGUgQnVzY2EgQXZhbsOnYWRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzYXZlLXF1ZXJ5IEZ1bsOnw6NvIHF1ZSBzZXLDoSBleGVjdXRhZGEgcXVhbmRvIG8gYm90w6NvIGRlIHNhbHZhciBhIHBlc3F1aXNhIGZvciBjbGljYWRvLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGFiZWwgU3RyaW5nIHF1ZSBzZXLDoSBjb2xvY2FkYSBjb21vIHTDrXR1bG9cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBsYWNlaG9sZGVyIFN0cmluZyBxdWUgc2Vyw6EgY29sb2NhZGEgY29tbyBwbGFjZWhvbGRlciBvIGlucHV0LlxuICAgKi9cbiAgZnVuY3Rpb24gUXVlcnkoKXtcbiAgICB2YXIgX3RlbXBsYXRlID1cbiAgICAnPGRpdiBjbGFzcz1cImNvbC1tZC0xMlwiIG5nLXNob3c9XCJoYXNRdWVyaWVzICYmICRwYXJlbnQuc2VhcmNoUXVlcmllcy5sZW5ndGggPiAwXCI+JytcbiAgICAnICAgPGxhYmVsPjxzbWFsbD57ezo6bGFiZWx9fTwvc21hbGw+PC9sYWJlbD4nK1xuICAgICcgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTEyXCI+JytcbiAgICAnICAgPGRpdiBjbGFzcz1cImNvbC1tZC04XCIgIHN0eWxlPVwicGFkZGluZy1sZWZ0OiAwO3BhZGRpbmctcmlnaHQ6IDA7XCI+JytcbiAgICAnICAgPGd1bWdhLWFkdmFuY2VkLWxhYmVsICcrXG4gICAgJyAgICAgICAgIG5nLXJlcGVhdD1cInF1ZXJ5IGluICRwYXJlbnQuc2VhcmNoUXVlcmllc1wiJytcbiAgICAnICAgICAgICAgYXR0cj1cInt7cXVlcnkuYXR0cmlidXRlLm5hbWV9fVwiJytcbiAgICAnICAgICAgICAgaHFsPVwie3txdWVyeS5ocWwubGFiZWx9fVwiJytcbiAgICAnICAgICAgICAgdmFsdWU9XCJxdWVyeS52YWx1ZVwiJytcbiAgICAnICAgICAgICAgaW5kZXg9XCIkaW5kZXhcIicrXG4gICAgJyAgICAgICAgIGRpc2FibGVkPVwidHJ1ZVwiJytcbiAgICAnICAgICAgICAgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IC41JVwiPicrXG4gICAgJyAgIDwvZ3VtZ2EtYWR2YW5jZWQtbGFiZWw+JytcbiAgICAnPC9kaXY+JytcbiAgICAnIDxkaXYgY2xhc3M9XCJjb2wtbWQtNFwiIHN0eWxlPVwicGFkZGluZy1sZWZ0OiAwO3BhZGRpbmctcmlnaHQ6IDA7XCI+JytcbiAgICAnIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBpbnB1dC1ncm91cC1zbVwiIHN0eWxlPVwiXCI+JytcbiAgICAnICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJuYW1lXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBwbGFjZWhvbGRlcj1cInt7cGxhY2Vob2xkZXJ9fVwiIC8+JytcbiAgICAnICAgICA8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLWJ0blwiPicrXG4gICAgJyAgICAgICA8YnV0dG9uIG5nLWRpc2FibGVkPVwiKG5hbWUubGVuZ3RoIDwgMSlcIiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiIG5nLWNsaWNrPVwic2F2ZVF1ZXJ5KHtxdWVyeTogJHBhcmVudC5zZWFyY2hRdWVyaWVzLG5hbWU6IG5hbWV9KVwiID4nK1xuICAgICcgICAgICAgICA8aSBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tZmxvcHB5LXNhdmVcIj48L2k+JytcbiAgICAnICAgICAgIDwvYnV0dG9uPicrXG4gICAgJyAgICAgPC9zcGFuPicrXG4gICAgJyA8L2Rpdj4nK1xuICAgICcgPC9kaXY+JytcbiAgICAnPC9kaXY+JztcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgIHNjb3BlOntcbiAgICAgICAgc2F2ZVF1ZXJ5OiAnJicsXG4gICAgICAgIHBsYWNlaG9sZGVyOiAnQD8nXG4gICAgICB9LFxuICAgICAgdGVtcGxhdGU6IF90ZW1wbGF0ZSxcbiAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSxlbG0sYXR0cnMpIHtcbiAgICAgICAgc2NvcGUubGFiZWwgPSBhdHRycy5sYWJlbCB8fCAnQnVzY2EgYXRpdmE6JztcbiAgICAgICAgaWYoc2NvcGUuJHBhcmVudC5zZWFyY2hRdWVyaWVzKXtcbiAgICAgICAgICBzY29wZS5oYXNRdWVyaWVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFuZ3VsYXIubW9kdWxlKCdndW1nYS5kaXJlY3RpdmVzLnF1ZXJpZXMnLFsnZ3VtZ2EuZGlyZWN0aXZlcy5zZWFyY2guYWR2YW5jZWRsYWJlbCddKVxuICAuZGlyZWN0aXZlKCdndW1nYVF1ZXJpZXMnLFF1ZXJ5KTtcbn0pKCk7XG4iLCIiLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXHQvKipcblx0ICogQG5nZG9jIGRpcmVjdGl2ZVxuXHQgKiBAbmFtZSBndW1nYS5jb3JlOmd1bWdhU2VhcmNoXG5cdCAqIEByZXN0cmljdCBFXG5cdCAqIEBkZXNjcmlwdGlvbiBBIGRpcmVjdGl2ZSBndW1nYVNlYXJjaCBwb2RlIHNlciB1dGlsaXphZGEgcGFyYSBmYXplciBtb250YXIgcXVlcmllcyBkZSBidXNjYSwgc2VqYW0gZXNzYXMgYnVzY2FzIG5vcm1haXMgb3UgYXZhbsOnYWRhcy4gw4kgcG9zc8OtdmVsIGVzY29saGVyXG5cdCAqIHF1YWlzIGNhbXBvcyBubyBxdWFsIGEgYnVzY2Egc2Vyw6EgZmVpdGEsIGFzc2ltIGNvbW8gbmEgYnVzY2EgYXZhbsOnYWRhLlxuXHQgKiAjIyBFeGVtcGxvXG4gICAgICogVmVqYSB1bSBleGVtcGxvIGVtIGZ1bmNpb25hbWVudG8gW2FxdWldKGh0dHA6Ly9lbWJlZC5wbG5rci5jby9lelpJVGgzWmZtd1ZhbzBYejF3Ni9wcmV2aWV3KS4gICAgXG5cdCAqXG5cdCAqIE8gY29tcG9uZW50ZSB1dGlsaXphLXNlIGRlIHRhZ3MgcXVlIHPDsyBmdW5jaW9uYW0gZGVudHJvIGRhcyB0YWdzIGRvIGNvbXBvbmVudGUsIHF1ZSBzw6NvIGFzIHRhZ3MgYDxhZHZhbmNlZC1maWVsZD48L2FkdmFuY2VkLWZpZWxkPmAuIEEgdGFnIGRlIGFkdmFuY2VkLWZpZWxkIFxuXHQgKiBcdHJlY2ViZSBkb2lzIGF0cmlidXRvcyBjb21vIHBhcsOibWV0cm86IGBuYW1lYCBlIGB0eXBlYCBxdWUgcmVjZWJlbSAsIHJlc3BlY3RpdmFtZW50ZSwgbyBub21lIGRvIGF0cmlidXRvIGEgc2VyIHBlc3F1aXNhZG8gZSBxdWFsIHNldSB0aXBvLlxuXHQgKiBcdDxwcmU+XG5cdCAqICBcdFx0PGFkdmFuY2VkLWZpZWxkIG5hbWU9XCJub21lXCIgdHlwZT1cInN0cmluZ1wiPjwvYWR2YW5jZWQtZmllbGQ+XG5cdCAqICBcdFx0PGFkdmFuY2VkLWZpZWxkIG5hbWU9XCJpZGFkZVwiIHR5cGU9XCJudW1iZXJcIj48L2FkdmFuY2VkLWZpZWxkPlxuXHQgKiAgPC9wcmU+XG5cdCAqIFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhZHZhbmNlZC1tZXRob2QgUGFyw6JtZXRybyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSBmdW7Dp8OjbyBxdWUgc2Vyw6EgdXRpbGl6YWRhIHBhcmEgZmF6ZXIgYSBidXNjYSBhdmFuw6dhZGEuXG5cdCAqIFBhcmEgcmVjZWJlciBhIHF1ZXJ5IGF2YW7Dp2FkYSwgYmFzdGEgcGFzc2FyIHVtIHBhcsOibWV0cm8gYHBhcmFtYCBwYXJhIGEgZnVuw6fDo28uIGBhZHZhbmNlZC1tZXRob2Q9XCJmdW5jdGlvbihwYXJhbSlcImBcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gc2VhcmNoLW1ldGhvZCBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIGZ1bsOnw6NvIHF1ZSBzZXLDoSB1dGlsaXphZGEgcGFyYSBmYXplciBhIGJ1c2NhIHNpbXBsZXMuXG5cdCAqIFBhcmEgcmVjZWJlciBvIGNhbXBvIGUgYSBwZXNxdWlzYSBxdWUgZm9pIGZlaXRhLCBiYXN0YSBwYXNzYXIgb3MgcGFyw6JtZXRyb3MgYGZpZWxkYCBlIGBwYXJhbWAgcGFyYSBhIGZ1bsOnw6NvLiBgc2VhcmNoLW1ldGhvZD1cImZ1bmN0aW9uKGZpZWxkLHBhcmFtKVwiYC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkcyBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIHNlcXXDqm5jaWEgZGUgY2FtcG9zIGNvbSBvIHF1YWwgbyBjb21wb25lbnRlIGlyw6EgY3JpYXIgYSBsaXN0YSBkZSBhdHJpYnV0b3MgcXVlIHNlcsOjbyBwZXNxdWlzw6F2ZWlzLlxuXHQgKiBFeGVtcGxvOiBgZmllbGRzPVwiaWQsbmFtZSxjb21wYW55LGFnZVwiYFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGFkdmFuY2VkIFBhcsOibWV0cm8gbsOjbyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtIHZhbG9yIGJvb2xlYW5vIHBhcmEgY29udHJvbGFyIHNlIG8gY29tcG9uZW50ZSBpcsOhIG91IG7Do28gZmF6ZXIgYnVzY2EgYXZhbsOnYWRhXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9uLXNlYXJjaCBQYXLDom1ldHJvIG7Do28gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgZnVuw6fDo28gcXVlIHNlcsOhIGNoYW1hZGEgcXVhbmRvIHVtYSBidXNjYSBzaW1wbGVzIGZvciBmZWl0YS4gXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9uLWFkdmFuY2VkLXNlYXJjaCBQYXLDom1ldHJvIG7Do28gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgZnVuw6fDo28gcXVlIHNlcsOhIGNoYW1hZGEgcXVhbmRvIHVtYSBidXNjYSBhdmFuw6dhZGEgZm9yIGZlaXRhLiBcblx0ICpcblx0ICogXG5cdCAqL1xuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5zZWFyY2gnLFxuXHRcdFtcblx0XHQnZ3VtZ2EuZGlyZWN0aXZlcy5zZWFyY2guc2VhcmNoJyxcblx0XHQnZ3VtZ2EuZGlyZWN0aXZlcy5zZWFyY2gubm9ybWFsc2VhcmNoJyxcblx0XHQnZ3VtZ2EuZGlyZWN0aXZlcy5zZWFyY2guYWR2YW5jZWRzZWFyY2gnLFxuXHRcdCdndW1nYS5kaXJlY3RpdmVzLnNlYXJjaC5hZHZhbmNlZGxhYmVsJyxcblx0XHQnZ3VtZ2EuZGlyZWN0aXZlcy5zZWFyY2guc2VhcmNoaGVscGVyJyxcblx0XHRdKTtcblxufSkoKTtcbiIsIihmdW5jdGlvbigpe1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBAbmdkb2MgZGlyZWN0aXZlXG4gICAqIEBuYW1lIGd1bWdhLmNvcmU6Z3VtZ2FUYWJsZVxuICAgKiBAcmVzdHJpY3QgRVxuICAgKiBAZGVzY3JpcHRpb24gTyBjb21wb25lbnRlICoqR3VtZ2FUYWJsZSoqIHNlcnZlIHBhcmEgZXhwb3IgZGFkb3MgZW0gZm9ybWEgZGUgdGFiZWxhLlxuICAgKiBPIGNvbXBvbmVudGUgZXhww7VlIG5vICRzY29wZS5zZWxlY3RlZEVudGl0aWVzIHVtIGFycmF5IGNvbnRlbmRvIG9zIG9iamV0b3MgZGFzIGxpbmhhcyBzZWxlY2lvbmFkYXMgcGFyYSBxdWUgbyBkZXNlbnZvbHZlZG9yIHBvc3NhIHVzYS1sb3MgZW0gYcOnw7Vlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogVW0gZXhlbXBsbyBkYSBkaXJlY3RpdmUgZ3VtZ2FUYWJsZSBmdW5jaW9uYW5kbyBwb2RlIHNlciBlbmNvbnRyYWRvIFthcXVpXShodHRwOi8vZW1iZWQucGxua3IuY28vU0FMa3A1YktSWjFheXdzcnBtRVgpLlxuICAgKiAgPHByZT5cbiAgICogICAgPGd1bWdhLXRhYmxlIHZhbHVlcz1cImxpc3RcIiBjb2x1bW5zPVwibmFtZSxhZ2VcIj48L2d1bWdhLXRhYmxlPlxuICAgKiAgICA8c2NyaXB0PlxuICAgKiAgICAkc2NvcGUubGlzdCA9IFt7bmFtZTogJ0d1aWxoZXJtZScsIGFnZTogMjh9LHtuYW1lOiAnSWdvcicsIGFnZTogMTl9XTtcbiAgICogICAgPC9zY3JpcHQ+XG4gICAqICA8L3ByZT5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlcyBBdHJpYnV0byBvYnJpZ2F0w7NyaW8uIERldmUgc2VyIG8gbm9tZSBkbyBhcnJheSBleHBvc3RvIG5vICRzY29wZSBwYXJhIHBvcHVsYXIgYSB0YWJlbGEuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2x1bW5zIEF0cmlidXRvIG9icmlnYXTDs3Jpby4gQXMgcHJvcHJpZWRhZGVzIGRvIG9iamV0byBxdWUgc2Vyw6NvIGFwcmVzZW50YWRvcyBjb21vIGNvbHVuYXMgbmEgdGFiZWxhLFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2l6ZSBQb3NzdWVtIDMgb3DDp8O1ZXMgZGUgdGFtYW5ob3MsICoqbGFyZ2UqKiwgKiptZWRpdW0qKiBlICoqc21hbGwqKiwgcXVlIHJlc3BlY3RpdmFtZW50ZSBvY3VwYW0sIHRvZG8gbyBlc3Bhw6dvIGRhIHJvdywgZG9pcyB0ZXLDp29zIGVcbiAgICogdW0gdGVyw6dvLiBPIHZhbG9yIHBhZHLDo28gw6kgbGFyZ2UuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc2xhdGUtZW50aXR5IE5vbWUgZGEgZW50aWRhZGUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhZ2VzIERldmUgY29udGVyIG9zIHZhbG9yZXMgcGFyYSBhcHJlc2VudGFyIG9ww6fDtWVzIGRlIHJlZ2lzdHJvcyBwb3IgcMOhZ2luYS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHRhYmxlLWNsYXNzIFBvc3N1ZW0gMyBvcMOnw7VlcywgKipib3JkZXJlZCoqLCAqKnN0cmlwZWQqKiBlICoqY29uZGVuc2VkKiosIHF1ZSByZXNwZWN0aXZhbWVudGUsIGFkaWNpb25hIGJvcmRhcyBhIHRhYmVsYSxcbiAgICogYWx0ZXJuYSBjb3JlcyBkYXMgbGluaGFzIGUgZGltaW51aSBvIGVzcGHDp2FtZW50byBpbnRlcm5vIGRhcyBsaW5oYXMgZSBjb2x1bmFzLiBPIHZhbG9yIHBhZHLDo28gw6kgYm9yZGVyZWQuXG4gICAqIG8gY29tcG9uZW50ZSBzZWd1aXLDoSBhIG9yZGVtIGRlIGNvbHVuYXMgYWRpY2lvbmFkYSBhbyBhdHJpYnV0by5cbiAgICogQHBhcmFtIHtCb29sZWFufSBtdWx0aS1zZWxlY3Rpb24gw4kgdHJ1ZSBwb3IgcGFkcsOjbywgZGV0ZXJtaW5hIGEgcG9zc2liaWxpZGFkZSBkYSBzZWxlw6fDo28gZGUgdsOhcmlhcyBlbnRpZGFkZXMgb3UgYXBlbmFzXG4gICAqIHVtYSBwb3IgdmV6LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzb3J0LWZ1bmN0aW9uIE5vbWUgZGEgZnVuw6fDo28gYXRyaWJ1aWRhIGFvICRzY29wZSBwYXJhIG1hbmlwdWxhciBhIG9yZGVuYcOnw6NvLCBhIGZ1bsOnw6NvIHJlY2ViZSBkb2lzXG4gICAqIHBhcsOibWV0cm9zLCAqKmZpZWxkKiogZSAqKndheSoqIHF1ZSBzZXLDo28sIGEgY29sdW5hIGUgYSBkaXJlw6fDo28gZGEgb3JkZW5hw6fDo28gcmVzcGVjdGl2YW1lbnRlLCBleGlzdGVtIGR1YXMgZGlyZcOnw7VlcyxcbiAgICogKiphc2MqKiBvdSAqKmRlc2MqKi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHNvcnQtZGVmYXVsdCBEZXZlIGNvbnRlciBhICoqY29sdW5hKiogZSBhICoqZGlyZcOnw6NvKiogc2VwYXJhZG9zIHBvciB2aXJndWxhLCBzZXLDoSBhIG9yZGVuYcOnw6NvIHBhZHLDo28gbmEgcHJpbWVpcmEgZXhpYmnDp8OjbyBkYSB0YWJlbGEuXG4gICAqIEBwYXJhbSB7RXhwcmVzc2lvbn0gcm93LWNsYXNzIERldmUgY29udGVyIHVtYSBleHByZXNzw6NvIGNvbmRpY2lvbmFsIHBhcmEgbWFyY2FyIGRldGVybWluYWRhcyBsaW5oYXMgY29ycmVzcG9uZGVudGVzIGNvbW9cbiAgICogdmVyZGFkZWlyYXMgcGVyYW50ZSBhIGV4cHJlc3PDo28uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uU2VsZWN0IE5vbWUgZGEgZnVuw6fDo28gcXVlIHNlcsOhIGV4ZWN1dGFkYSBhbyBldmVudG8gY2xpY2suXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uU29ydCBOb21lIGRhIGZ1bsOnw6NvIHF1ZSBzZXLDoSBleGVjdXRhZGEgYW8gZXZlbnRvIGRlIHNvcnQuXG4gICAqL1xuICAgVGFibGUuJGluamVjdCA9IFtcIkd1bWdhVXRpbHNcIiwgXCIkY29tcGlsZVwiLCBcIiRyb290U2NvcGVcIiwgXCIkc3RhdGVcIiwgXCJHdW1nYUtleWJvYXJkXCIsIFwiJHRpbWVvdXRcIl07XG4gICBmdW5jdGlvbiBUYWJsZShHdW1nYVV0aWxzLCAkY29tcGlsZSwkcm9vdFNjb3BlLCRzdGF0ZSxHdW1nYUtleWJvYXJkLCR0aW1lb3V0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICBzY29wZToge1xuICAgICAgICBtdWx0aTogJz0/bXVsdGlTZWxlY3Rpb24nLFxuICAgICAgICBsaXN0OiAnPXZhbHVlcycsXG4gICAgICAgIHBhZ2VzOiAnPXBhZ2VzJyxcbiAgICAgICAgc29ydDogJyY/c29ydEZ1bmN0aW9uJyxcbiAgICAgICAgcm93Q2xhc3M6ICc9PycsXG4gICAgICAgIG9uU2VsZWN0OiAnJj8nLFxuICAgICAgICBvblNvcnQ6ICcmPydcbiAgICAgIH0sXG4gICAgICBsaW5rOiBMaW5rRm4sXG4gICAgICB0cmFuc2NsdWRlOiB0cnVlXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIExpbmtGbihzY29wZSwgZWxtLCBhdHRycywgY3RybCwgdHJhbnNjbHVkZUZuKSB7XG4gICAgICB2YXIgZXZlbnRIYW5kbGVyID0ge1xuICAgICAgICBzZWxlY3Q6IChhdHRycy5vblNlbGVjdCA/IHNjb3BlLm9uU2VsZWN0IDogYW5ndWxhci5ub29wKSxcbiAgICAgICAgc29ydDogKGF0dHJzLm9uU29ydCA/IHNjb3BlLm9uU29ydDogYW5ndWxhci5ub29wKVxuICAgICAgfTtcblxuICAgICAgc2NvcGUuJG9uKCdfY2xlYW4nLGZ1bmN0aW9uKCl7XG4gICAgICAgc2NvcGUuY2xlYW5TZWFyY2goKTtcbiAgICAgfSk7XG5cbiAgICAgIHZhciBDb2x1bW5PYmplY3QgPSB7fTtcbiAgICAgIHNjb3BlLmluZGV4ZXMgPSBbXTtcbiAgICAgIHNjb3BlLnRycyA9IFtdO1xuICAgICAgc2NvcGUuJHBhcmVudC5zZWxlY3RlZEVudGl0aWVzID0gW107XG4gICAgICBzY29wZS5vYmplY3RDb2x1bW4gPSBbXTtcbiAgICAgIHNjb3BlLmNvbmRpdGlvbmFsQ29sdW1ucyA9IFtdO1xuICAgICAgdmFyIHJhd1RhYmxlQ29uZmlnID0ge1xuICAgICAgICBtdWx0aTogc2NvcGUubXVsdGksXG4gICAgICAgIGxpc3Q6IFtdLFxuICAgICAgICBwYWdlczogc2NvcGUucGFnZXMgfHwgWzEwLCAyNSwgNTBdLFxuICAgICAgICBzb3J0Rm46IGF0dHJzLnNvcnQ/IHNjb3BlLnNvcnQgOiBhbmd1bGFyLm5vb3AsXG4gICAgICAgIHNvcnREZjogISFhdHRycy5zb3J0RGVmYXVsdD8gYXR0cnMuc29ydERlZmF1bHQuc3BsaXQoJywnKSA6IGZhbHNlLFxuICAgICAgICBzaXplOiBhdHRycy5zaXplIHx8ICdsYXJnZScsXG4gICAgICAgIGNsYXNzOiBhdHRycy50YWJsZUNsYXNzIHx8ICdib3JkZXJlZCcsXG4gICAgICAgIGNvbHVtbnM6IGF0dHJzLmNvbHVtbnMuc3BsaXQoJywnKSxcbiAgICAgICAgaGVhZGluZ3M6IFtdLFxuICAgICAgICB0cmFuc2xhdGU6IGF0dHJzLnRyYW5zbGF0ZUVudGl0eSxcbiAgICAgIH07XG4gICAgICB2YXIgaXRlbXNQZXJQYWdlID0gd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ2l0ZW1zUGVyUGFnZScpIHx8IHJhd1RhYmxlQ29uZmlnLnBhZ2VzWzBdO1xuICAgICAgc2NvcGUuaXRlbXNQZXJQYWdlID0gaXRlbXNQZXJQYWdlO1xuICAgICAgc2NvcGUuJHBhcmVudC5pdGVtc1BlclBhZ2UgPSBpdGVtc1BlclBhZ2U7XG5cbiAgICAgIHNjb3BlLiR3YXRjaCgnbGlzdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNjb3BlLmxpc3QpIHtcbiAgICAgICAgICBzY29wZS4kcGFyZW50LnNlbGVjdGVkRW50aXRpZXMgPSBbXTtcbiAgICAgICAgICBzY29wZS50YWJsZWNvbmZpZy5saXN0ID0gc2NvcGUubGlzdDtcbiAgICAgICAgICBzY29wZS5pbmRleGVzID0gW107XG5cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHNldENvbHVtbkNvbmZpZyhyYXdUYWJsZUNvbmZpZyk7XG5cbiAgICAgIGZ1bmN0aW9uIHNldENvbHVtbkNvbmZpZyhyYXdDb25maWcpIHtcbiAgICAgICAgcmF3Q29uZmlnLmNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoZWxtKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgICAgIGxhYmVsOiBHdW1nYVV0aWxzLmNhbWVsQ2FzZShlbG0pLFxuICAgICAgICAgICAgZmllbGQ6IGVsbVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmF3Q29uZmlnLmhlYWRpbmdzLnB1c2goe2xhYmVsOiBvYmoubGFiZWwsIHdheTogbnVsbH0pO1xuICAgICAgICAgIHJhd0NvbmZpZy5jb2x1bW5zLnNwbGljZShyYXdDb25maWcuY29sdW1ucy5pbmRleE9mKGVsbSksIDEsIG9iaik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRyYW5zY2x1ZGVGbihmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgICBhbmd1bGFyLmZvckVhY2goY2xvbmUsIGZ1bmN0aW9uIChjbG9uZUVsKSB7XG4gICAgICAgICAgICBpZiAoY2xvbmVFbC5ub2RlTmFtZSAhPSBcIiN0ZXh0XCIpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChjbG9uZUVsLm5vZGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnR1VNR0EtQk9PTEVBTi1NQVNLJzpcbiAgICAgICAgICAgICAgICByYXdDb25maWcuY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICAgIGlmIChvYmouZmllbGQgPT0gY2xvbmVFbC5nZXRBdHRyaWJ1dGUoJ2NvbHVtbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKG9iaiwge1xuICAgICAgICAgICAgICAgICAgICAgIHRydWVWYWx1ZTogY2xvbmVFbC5nZXRBdHRyaWJ1dGUoJ2Jvb2xlYW4tdHJ1ZScpLFxuICAgICAgICAgICAgICAgICAgICAgIGZhbHNlVmFsdWU6IGNsb25lRWwuZ2V0QXR0cmlidXRlKCdib29sZWFuLWZhbHNlJylcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnQlVUVE9OUy1DT0xVTU4nOlxuICAgICAgICAgICAgICAgIHNjb3BlLmJ1dHRvbkVsZW1lbnRzID0gY2xvbmVFbC5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICByYXdDb25maWcuaGVhZGluZ3MucHVzaCh7bGFiZWw6ICcgJywgd2F5OiBudWxsfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnRVhUUkEtQ09MVU1OJzpcbiAgICAgICAgICAgICAgICBzY29wZS5leHRyYUVsZW1lbnRzID0gY2xvbmVFbC5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICByYXdDb25maWcuaGVhZGluZ3MucHVzaCh7bGFiZWw6ICcgJywgd2F5OiBudWxsfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnT0JKRUNULUNPTFVNTic6XG4gICAgICAgICAgICAgICAgc2NvcGUub2JqZWN0Q29sdW1uLnB1c2goe2NvbHVtbjogY2xvbmVFbC5nZXRBdHRyaWJ1dGUoJ2NvbHVtbicpLHZhbHVlOiBjbG9uZUVsLmdldEF0dHJpYnV0ZSgncHJvcGVydHknKX0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0NPTFVNTi1DTEFTUyc6XG4gICAgICAgICAgICAgICAgc2NvcGUuY29uZGl0aW9uYWxDb2x1bW5zLnB1c2goe2NvbHVtbjogY2xvbmVFbC5nZXRBdHRyaWJ1dGUoJ2NvbHVtbicpLGNvbmRpdGlvbmFsOiBjbG9uZUVsLmdldEF0dHJpYnV0ZSgnY29uZGl0aW9uYWwtY2xhc3MnKX0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbn0pO1xuc2NvcGUudGFibGVjb25maWcgPSByYXdDb25maWc7XG5nZW5lcmF0ZVRhYmxlKHNjb3BlLnRhYmxlY29uZmlnKTtcbn1cbmZ1bmN0aW9uIGdldENvbmRpdGlvbnMoKXtcbiAgdmFyIGNvbmRpdGlvblRleHQgPSBhdHRycy5yb3dDbGFzcyB8fCAnJztcbiAgcmV0dXJuIGNvbmRpdGlvblRleHQucmVwbGFjZSgvey8sJycpLnJlcGxhY2UoL30vLCcnKS5zcGxpdCgnLCcpO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVUYWJsZShjb25maWcpIHtcbiAgdmFyIHRlbXBsYXRlID0gW107XG4gIGlmIChzY29wZS5wYWdlcykge1xuICAgIHZhciBwYWdpbmF0aW9uID1cbiAgICAnPHNlbGVjdCBuZy1tb2RlbD1cIml0ZW1zUGVyUGFnZVwiIG5nLWNoYW5nZT1cImNoYW5nZUl0ZW1zUGVyUGFnZShpdGVtc1BlclBhZ2UpXCI+JyArXG4gICAgJzxvcHRpb24gbmctcmVwZWF0PVwicCBpbiBwYWdlc1wiIHZhbHVlPVwie3sgcCB9fVwiIG5nLXNlbGVjdGVkPVwicCA9PSBpdGVtc1BlclBhZ2VcIj57eyBwIH19PC9vcHRpb24+JyArXG4gICAgJzwvc2VsZWN0Pic7XG4gICAgdGVtcGxhdGUucHVzaChwYWdpbmF0aW9uKTtcbiAgfVxuICBzd2l0Y2ggKGNvbmZpZy5zaXplKSB7XG4gICAgY2FzZSAnbGFyZ2UnOlxuICAgIHRlbXBsYXRlLnB1c2goXG4gICAgICAnPGRpdiBjbGFzcz1cImZ1bGwtd2lkdGgtd2l0aG91dC1wYWRkaW5nXCIgc3R5bGU9XCJtYXJnaW4tdG9wOiAxJVwiPicgK1xuICAgICAgJzxidXR0b24gY2xhc3M9XCJidG4gYnRuLWRlZmF1bHQgYnRuLXhzXCIgc3R5bGU9XCJtYXJnaW4tYm90dG9tOiAwLjI1JVwiIG5nLWNsaWNrPVwic2VsZWN0QWxsKClcIj5TZWxlY2lvbmFyIHRvZG9zPC9idXR0b24+JyArXG4gICAgICAnPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdCBidG4teHNcIiBzdHlsZT1cIm1hcmdpbi1ib3R0b206IDAuMjUlO21hcmdpbi1sZWZ0OjAuMjUlXCIgbmctY2xpY2s9XCJjbGVhblNlYXJjaCgpXCI+IExpbXBhciBwZXNxdWlzYTwvYnV0dG9uPicgK1xuICAgICAgJzx0YWJsZSBjbGFzcz1cInRhYmxlIHRhYmxlLScgKyBjb25maWcuY2xhc3MgKyAnIFwiPicpO1xuICAgIGJyZWFrO1xuICAgIGNhc2UgJ21lZGl1bSc6XG4gICAgdGVtcGxhdGUucHVzaChcbiAgICAgICc8ZGl2IGNsYXNzPVwiY29sLW1kLThcIiBzdHlsZT1cInBhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6IDA7XCI+JyArXG4gICAgICAnPHRhYmxlIGNsYXNzPVwidGFibGUgdGFibGUtJyArIGNvbmZpZy5jbGFzcyArICdcIj4nKTtcbiAgICBicmVhaztcbiAgICBjYXNlICdzbWFsbCc6XG4gICAgdGVtcGxhdGUucHVzaChcbiAgICAgICc8ZGl2IGNsYXNzPVwiY29sLW1kLTRcIiBzdHlsZT1cInBhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6IDA7XCI+JyArXG4gICAgICAnPHRhYmxlIGNsYXNzPVwidGFibGUgdGFibGUtJyArIGNvbmZpZy5jbGFzcyArICdcIj4nKTtcbiAgICBicmVhaztcbiAgfVxuICB0ZW1wbGF0ZS5wdXNoKCc8dGhlYWQ+Jyk7XG4gIHRlbXBsYXRlLnB1c2goJzx0cj4nKTtcbiAgaWYgKGF0dHJzLnNvcnRGdW5jdGlvbikge1xuICAgIHRlbXBsYXRlLnB1c2goJyA8dGQgbmctcmVwZWF0PVwiaGVhZCBpbiB0YWJsZWNvbmZpZy5oZWFkaW5ncyB0cmFjayBieSAkaW5kZXhcIiBuZy1jbGljaz1cImhlYWQubGFiZWwgIT09IFxcJyBcXCcgPyBzb3J0QXV4KGhlYWQpIDogXFwnXFwnXCInKTtcbiAgICB0ZW1wbGF0ZS5wdXNoKCcgICAgIG5nLWNsYXNzPVwiaGVhZC5sYWJlbCAhPSBcXCcgXFwnID8gXFwnY2xpY2thYmxlLXRkXFwnIDogXFwnIFxcJyBcIj4nKTtcbiAgICB0ZW1wbGF0ZS5wdXNoKCcgICAgICAgICA8c21hbGw+e3s6OmhlYWQubGFiZWx9fTxpIG5nLWNsYXNzPVwiKGhlYWQud2F5ICE9IG51bGwgJiYgaGVhZC5sYWJlbCAhPT0gXFwnIFxcJykgPyAoaGVhZC53YXkgPT09IHRydWUgPyBcXCdnbHlwaGljb24gZ2x5cGhpY29uLW1lbnUtdXBcXCcgOiBcXCdnbHlwaGljb24gZ2x5cGhpY29uLW1lbnUtZG93blxcJykgOiBcXCdcXCdcIj48L2k+PC9zbWFsbD48L3RkPicpO1xuICB9IGVsc2Uge1xuICAgIHRlbXBsYXRlLnB1c2goJzx0ZCBuZy1yZXBlYXQ9XCJoZWFkIGluIHRhYmxlY29uZmlnLmhlYWRpbmdzIHRyYWNrIGJ5ICRpbmRleFwiPnt7OjpoZWFkLmxhYmVsfX0nKTtcbiAgfVxuICB0ZW1wbGF0ZS5wdXNoKCcgPC90ZD4nKTtcbiAgdGVtcGxhdGUucHVzaCgnPC90cj4nKTtcbiAgdGVtcGxhdGUucHVzaCgnPC90aGVhZD4nKTtcbiAgdGVtcGxhdGUucHVzaCgnPHRib2R5PicpO1xuICBpZiAoY29uZmlnLm11bHRpID09PSBmYWxzZSkge1xuICAgIHRlbXBsYXRlLnB1c2goJzx0ciBzdHlsZT1cInt7OjpnZXRDbGFzc0Zyb21Db25kaXRpb25hbFJvdyhlbnRpdHkpfX1cIiBuZy1jbGFzcz1cInJldHVybkNsYXNzKCRpbmRleClcIiBuZy1yZXBlYXQ9XCJlbnRpdHkgaW4gdGFibGVjb25maWcubGlzdFwiIGNsYXNzPVwidXNlZFwiIG5nLWNsaWNrPVwiaGFuZGxlU2luZ2xlKGVudGl0eSwkaW5kZXgpXCIgbmctZGJsY2xpY2s9XCJnb1RvRWRpdChlbnRpdHkuaWQpXCI+JyArIGdlbmVyYXRlVGFibGVDZWxsKGNvbmZpZykgKyAnPC90cj4nKTtcbiAgfSBlbHNlIHtcbiAgICB0ZW1wbGF0ZS5wdXNoKCc8dHIgc3R5bGU9XCJ7ezo6Z2V0Q2xhc3NGcm9tQ29uZGl0aW9uYWxSb3coZW50aXR5KX19XCIgbmctY2xhc3M9XCJyZXR1cm5DbGFzcygkaW5kZXgpXCIgbmctcmVwZWF0PVwiZW50aXR5IGluIHRhYmxlY29uZmlnLmxpc3RcIiBjbGFzcz1cInVzZWRcIiBuZy1jbGljaz1cImhhbmRsZU11bHRpcGxlKGVudGl0eSwkaW5kZXgpXCIgbmctZGJsY2xpY2s9XCJnb1RvRWRpdChlbnRpdHkuaWQpXCIgPicgKyBnZW5lcmF0ZVRhYmxlQ2VsbChjb25maWcpICsgJzwvdHI+Jyk7XG4gIH1cbiAgdGVtcGxhdGUucHVzaCgnPC90Ym9keT4nKTtcbiAgdGVtcGxhdGUucHVzaCgnPC90YWJsZT48L2Rpdj4nKTtcbiAgZWxtLmFwcGVuZCgkY29tcGlsZSh0ZW1wbGF0ZS5qb2luKCdcXG4nKSkoc2NvcGUpKTtcblxufVxudmFyIHNlbGVjdGVkID0gZmFsc2U7XG5cbnNjb3BlLmdvVG9FZGl0ID0gZnVuY3Rpb24oaW5kZXgpe1xuICAkc3RhdGUuZ28oc2NvcGUudGFibGVjb25maWcudHJhbnNsYXRlICsgJy4nICsgJ2VkaXQnLHtpZDogaW5kZXh9KTtcbn07XG5zY29wZS5jaGFuZ2VJdGVtc1BlclBhZ2UgPSBmdW5jdGlvbihpdGVtc1BlclBhZ2Upe1xuICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnaXRlbXNQZXJQYWdlJywgaXRlbXNQZXJQYWdlKTtcbiAgc2NvcGUuJHBhcmVudC5pdGVtc1BlclBhZ2UgPSBpdGVtc1BlclBhZ2U7XG59O1xuc2NvcGUuc2VsZWN0QWxsID0gZnVuY3Rpb24oKXtcbiAgaWYoIXNlbGVjdGVkKXtcbiAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSBzY29wZS50YWJsZWNvbmZpZy5saXN0Lmxlbmd0aDtpIDwgbGVuO2krKyl7XG4gICAgICBzY29wZS5pbmRleGVzLnB1c2goaSk7XG4gICAgfVxuICAgIHNjb3BlLiRwYXJlbnQuc2VsZWN0ZWRFbnRpdGllcyA9IHNjb3BlLnRhYmxlY29uZmlnLmxpc3Q7XG4gIH0gZWxzZSB7XG4gICAgc2NvcGUuaW5kZXhlcyA9IFtdO1xuICAgIHNjb3BlLiRwYXJlbnQuc2VsZWN0ZWRFbnRpdGllcyA9IFtdO1xuICB9XG4gIHNlbGVjdGVkID0gIXNlbGVjdGVkO1xufTtcblxuXG5zY29wZS5jbGVhblNlYXJjaCA9IGZ1bmN0aW9uKCl7XG4gICRyb290U2NvcGUuJGJyb2FkY2FzdCgnbm9ybWFsJyx7ZmllbGQ6c2NvcGUudGFibGVjb25maWcuY29sdW1uc1sxXSxwYXJhbTogJyd9KTtcbiAgc2NvcGUudGFibGVjb25maWcuaGVhZGluZ3MuZm9yRWFjaChmdW5jdGlvbihlbG0pe1xuICAgIGVsbS53YXkgPSBudWxsO1xuICB9KVxufTtcblxuc2NvcGUuZ2V0Q2xhc3NGcm9tQ29uZGl0aW9uYWxSb3cgPSBmdW5jdGlvbiAoZW50aXR5KXtcbiAgdmFyIEhlbHBlck9iamVjdCA9IHt9O1xuICB2YXIgY29uZGl0aW9uc0Zyb21UYWcgPSBnZXRDb25kaXRpb25zKCk7XG4gIGNvbmRpdGlvbnNGcm9tVGFnLmZvckVhY2goZnVuY3Rpb24oZWxtKXtcbiAgICBIZWxwZXJPYmplY3RbZWxtLnNwbGl0KCc6JylbMF1dID0gZXZhbChlbG0uc3BsaXQoJzonKVsxXSk7XG4gIH0pO1xuICBmb3IodmFyIGtleSBpbiBIZWxwZXJPYmplY3QpIGlmKEhlbHBlck9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIEhlbHBlck9iamVjdFtrZXldID09PSB0cnVlKXtcbiAgICByZXR1cm4gJ2JvcmRlci1sZWZ0OiAzcHggc29saWQgJyArIGtleS50cmltKCk7XG4gIH1cbiAgcmV0dXJuICcnO1xufTtcblxuZnVuY3Rpb24gY2hlY2tPYmplY3QoZmllbGQpe1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2NvcGUub2JqZWN0Q29sdW1uLmxlbmd0aDtpKyspe1xuICAgIGlmKHNjb3BlLm9iamVjdENvbHVtbltpXS5jb2x1bW4gPT09IGZpZWxkKXtcbiAgICAgIHJldHVybiAne3s6OmVudGl0eS4nKyAgc2NvcGUub2JqZWN0Q29sdW1uW2ldLnZhbHVlICsnfX0nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGdldENsYXNzRnJvbUNvbmRpdGlvbmFsQ2VsbChjb2x1bW4sZW50aXR5KXtcbiAgc2NvcGUuY29uZGl0aW9uYWxDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24oZWxtKXtcbiAgICBpZihlbG0uY29sdW1uLnRvTG93ZXJDYXNlKCkudHJpbSgpID09PSBjb2x1bW4udG9Mb3dlckNhc2UoKS50cmltKCkpe1xuICAgICAgQ29sdW1uT2JqZWN0W2VsbS5jb2x1bW5dID0ge307XG4gICAgICBlbG0uY29uZGl0aW9uYWwucmVwbGFjZSgvey8sJycpLnJlcGxhY2UoL30vLCcnKS5zcGxpdCgnLCcpXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbihhcmcpe1xuICAgICAgICB2YXIgeCA9IGFyZy5zcGxpdCgnOicpO1xuICAgICAgICBDb2x1bW5PYmplY3RbZWxtLmNvbHVtbl1beFswXS50cmltKCkucmVwbGFjZSgvXCIvZywnJyldID0geFsxXS50cmltKCk7XG4gICAgICB9KVxuICAgIH1cbiAgfSk7XG59XG5cblxuc2NvcGUuZ2V0U3R5bGVGcm9tQ2VsbCA9IGZ1bmN0aW9uKGVudGl0eSxjb2x1bW4pe1xuICBpZihDb2x1bW5PYmplY3RbY29sdW1uLnRyaW0oKS50b0xvd2VyQ2FzZSgpXSl7XG4gICAgdmFyIGF1eE9iaiA9IENvbHVtbk9iamVjdFtjb2x1bW4udHJpbSgpLnRvTG93ZXJDYXNlKCldO1xuICAgIGZvcih2YXIga2V5IGluIGF1eE9iaikgaWYoYXV4T2JqLmhhc093blByb3BlcnR5KGtleSkgJiYgZXZhbChhdXhPYmpba2V5XSkgPT09IHRydWUpe1xuICAgICAgcmV0dXJuICdib3JkZXItbGVmdDogM3B4IHNvbGlkICcgKyBrZXkudHJpbSgpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVUYWJsZUNlbGwoY29uZmlnKSB7XG4gIHZhciB0ZW1wbGF0ZSA9IFtdO1xuICBjb25maWcuY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChlbG0pIHtcbiAgICBnZXRDbGFzc0Zyb21Db25kaXRpb25hbENlbGwoZWxtLmZpZWxkKTtcbiAgICBpZiAoZWxtLnRydWVWYWx1ZSkge1xuICAgICAgdGVtcGxhdGUucHVzaCgnPHRkIHN0eWxlPVwie3s6OmdldFN0eWxlRnJvbUNlbGwoZW50aXR5LFxcJyAnKyBlbG0uZmllbGQgKyAnIFxcJyl9fVwiPnt7OjplbnRpdHkuJyArIGVsbS5maWVsZCArICcgPT09IHRydWU/IFxcJycgKyBlbG0udHJ1ZVZhbHVlICsgJ1xcJyA6IFxcJycgKyBlbG0uZmFsc2VWYWx1ZSArICdcXCd9fTwvdGQ+Jyk7XG4gICAgfSBlbHNlIGlmKGNoZWNrT2JqZWN0KGVsbS5maWVsZCkgIT0gLTEpe1xuICAgICAgdGVtcGxhdGUucHVzaCgnPHRkIHN0eWxlPVwie3s6OmdldFN0eWxlRnJvbUNlbGwoZW50aXR5LFxcJyAnKyBlbG0uZmllbGQgKyAnIFxcJyl9fVwiPicgKyBjaGVja09iamVjdChlbG0uZmllbGQpICsnIDwvdGQ+Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXBsYXRlLnB1c2goJzx0ZCBzdHlsZT1cInt7OjpnZXRTdHlsZUZyb21DZWxsKGVudGl0eSxcXCcgJysgZWxtLmZpZWxkICsgJyBcXCcpfX1cIj57ezo6ZW50aXR5LicrIGVsbS5maWVsZCArICd9fSA8L3RkPicpO1xuICAgIH1cbiAgfSk7XG4gIGlmIChzY29wZS5idXR0b25FbGVtZW50cykge1xuICAgIHRlbXBsYXRlLnB1c2goJzx0ZCBzdHlsZT1cInt7OjpnZXRTdHlsZUZyb21DZWxsKGVudGl0eSxcXCcgJysgZWxtLmZpZWxkICsgJyBcXCcpfX1cIj4nICsgZ2V0U3BlY2lhbChzY29wZS5idXR0b25FbGVtZW50cykgKyAnPC90ZD4nKTtcbiAgfVxuICBpZiAoc2NvcGUuZXh0cmFFbGVtZW50cykge1xuICAgIHRlbXBsYXRlLnB1c2goJzx0ZCBzdHlsZT1cInt7OjpnZXRTdHlsZUZyb21DZWxsKGVudGl0eSxcXCcgJysgZWxtLmZpZWxkICsgJyBcXCcpfX1cIj4nICsgZ2V0U3BlY2lhbChzY29wZS5leHRyYUVsZW1lbnRzKSArICc8L3RkPicpO1xuICB9XG4gIHJldHVybiB0ZW1wbGF0ZS5qb2luKCcgJyk7XG59XG5cblxuZnVuY3Rpb24gZ2V0U3BlY2lhbChhcnJheSkge1xuICB2YXIgdHh0ID0gW107XG4gIGFuZ3VsYXIuZm9yRWFjaChhcnJheSwgZnVuY3Rpb24gKGVsbSkge1xuICAgIHR4dC5wdXNoKGVsbS5vdXRlckhUTUwpO1xuICB9KTtcbiAgcmV0dXJuIHR4dC5qb2luKCcgJyk7XG59XG5cbiAgICAgICAgICAgIC8vIE5lZ2HDp8OjbyBkdXBsYSB0cmFuc2Zvcm1hIGVtIGJvb2xlYW5cbiAgICAgICAgICAgIGlmICghIXJhd1RhYmxlQ29uZmlnLnNvcnREZikge1xuICAgICAgICAgICAgICAvLyBTZSBob3V2ZXIgbyBhdHJpYnV0byBzb3J0LWRlZmF1bHQgbW9udGEgbyBvYmpldG8gZSBkaXNwYXJhIG8gZXZlbnRvXG4gICAgICAgICAgICAgIHZhciBvYmpTb3J0RGVmYXVsdCA9IHtcbiAgICAgICAgICAgICAgICBmaWVsZDogcmF3VGFibGVDb25maWcuc29ydERmWzBdLFxuICAgICAgICAgICAgICAgIHdheTogcmF3VGFibGVDb25maWcuc29ydERmWzFdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGV2ZW50SGFuZGxlci5zb3J0KHtmaWVsZDogb2JqU29ydERlZmF1bHQuZmllbGR9KTtcbiAgICAgICAgICAgICAgc2NvcGUuc29ydChvYmpTb3J0RGVmYXVsdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjb3BlLnNvcnRBdXggPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgLy9RdWFuZG8gZWxlIGNsaWNhLCBlbGUgdmVyaWZpY2Egc2UgasOhIGV4aXN0ZSBhbGd1bWEgY29sdW5hIGNvbSBzb3J0LCBzZSBqw6EgZXhpc3RpciwgcmV0b3JuYSBlbGEgcGFyYSBudWxsXG4gICAgICAgICAgICAgICAgc2NvcGUudGFibGVjb25maWcuaGVhZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9IG9iaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LndheSA9PT0gdHJ1ZSB8fCBrZXkud2F5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGtleS53YXkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gUGVnYSBvIGluZGV4IGRvIG9iamV0b1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHNjb3BlLnRhYmxlY29uZmlnLmhlYWRpbmdzLmluZGV4T2Yob2JqKTtcbiAgICAgICAgICAgICAgICAvL1NldGEgbyBzb3J0IGRlbGUgcHJhIGZhbHNlIG91IHRydWVcbiAgICAgICAgICAgICAgICBvYmoud2F5ID0gIW9iai53YXk7XG4gICAgICAgICAgICAgICAgLy9SZW1vdmUgZGEgbGlzdGEgYW50ZXJpb3IgbyBhbnRpZ28gZSBjb2xvY2EgbyBub3ZvXG4gICAgICAgICAgICAgICAgc2NvcGUudGFibGVjb25maWcuaGVhZGluZ3Muc3BsaWNlKGluZGV4LCAxLCBvYmopO1xuICAgICAgICAgICAgICAgIHZhciBhdXg7XG4gICAgICAgICAgICAgICAgLy8gU2UgZm9yIHRydWUsIMOpIGFzY2VuZGVudGVcbiAgICAgICAgICAgICAgICBpZiAob2JqLndheSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgYXV4ID0gJ2FzYyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGF1eCA9ICdkZXNjJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRGlzcGFyYSBvIGV2ZW50b1xuICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlci5zb3J0KHtmaWVsZDogb2JqLmxhYmVsLnRvTG93ZXJDYXNlKCl9KTtcbiAgICAgICAgICAgICAgICBzY29wZS5zb3J0KHtmaWVsZDogb2JqLmxhYmVsLnRvTG93ZXJDYXNlKCksIHdheTogYXV4fSk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgc2NvcGUuaGFuZGxlTXVsdGlwbGUgPSBmdW5jdGlvbiAoZW50aXR5LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChHdW1nYVV0aWxzLmFyZU5vdEVxdWFsSW5BcnJheShzY29wZS5pbmRleGVzLCBpbmRleCkgfHwgc2NvcGUuaW5kZXhlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgICBzY29wZS5pbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgc2NvcGUuJHBhcmVudC5zZWxlY3RlZEVudGl0aWVzLnB1c2goZW50aXR5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc2NvcGUuaW5kZXhlcy5zcGxpY2Uoc2NvcGUuaW5kZXhlcy5pbmRleE9mKGluZGV4KSwgMSk7XG4gICAgICAgICAgICAgICAgICBzY29wZS4kcGFyZW50LnNlbGVjdGVkRW50aXRpZXMuc3BsaWNlKHNjb3BlLiRwYXJlbnQuc2VsZWN0ZWRFbnRpdGllcy5pbmRleE9mKGVudGl0eSksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIuc2VsZWN0KHtzZWxlY3RlZDogc2NvcGUuJHBhcmVudC5zZWxlY3RlZEVudGl0aWVzfSk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgc2NvcGUuaGFuZGxlU2luZ2xlID0gZnVuY3Rpb24gKGVudGl0eSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGUuaW5kZXhlcy5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgICAgICAgc2NvcGUuaW5kZXhlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgc2NvcGUuJHBhcmVudC5zZWxlY3RlZEVudGl0aWVzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNjb3BlLnNlbGVjdGVkSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICBzY29wZS5pbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgIHNjb3BlLiRwYXJlbnQuc2VsZWN0ZWRFbnRpdGllcy5wdXNoKGVudGl0eSk7XG4gICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyLnNlbGVjdCh7c2VsZWN0ZWQ6IHNjb3BlLiRwYXJlbnQuc2VsZWN0ZWRFbnRpdGllc30pO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHNjb3BlLnJldHVybkNsYXNzID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFHdW1nYVV0aWxzLmFyZU5vdEVxdWFsSW5BcnJheShzY29wZS5pbmRleGVzLCBpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnaW5mbyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy50YWJsZScsW10pXG4gICAgICAgICAgLmRpcmVjdGl2ZSgnZ3VtZ2FUYWJsZScsVGFibGUpO1xuICAgICAgICB9KSgpO1xuIiwiIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0Jztcblx0VHJhbnNsYXRlVGFnLiRpbmplY3QgPSBbXCJHdW1nYVRyYW5zbGF0ZUhlbHBlclwiLCBcIiRjb21waWxlXCJdO1xuXHRmdW5jdGlvbiBUcmFuc2xhdGVUYWcoR3VtZ2FUcmFuc2xhdGVIZWxwZXIsJGNvbXBpbGUpe1xuXHRcdHZhciBjaGlsZDtcblx0XHRyZXR1cm4ge1xuXHRcdFx0cmVzdHJpY3Q6ICdBJyxcblx0XHRcdGxpbms6IGZ1bmN0aW9uKHNjb3BlLGVsbSxhdHRycyl7XG5cdFx0XHRcdGlmKCFhdHRycy5ndW1nYVRyYW5zbGF0ZVRhZykgdGhyb3cgJ1lvdSBtdXN0IHBhc3MgYSB2YWxpZCB2YWx1ZSB0byBndW1nYVRyYW5zbGF0ZVRhZyc7XG5cdFx0XHRcdHNjb3BlLl9fdmFsdWVUb1RyYW5zbGF0ZSA9IGF0dHJzLmd1bWdhVHJhbnNsYXRlVGFnO1xuXHRcdFx0XHRpZihHdW1nYVRyYW5zbGF0ZUhlbHBlci5nZXRUcmFuc2xhdGUoc2NvcGUuX192YWx1ZVRvVHJhbnNsYXRlKSl7XG5cdFx0XHRcdFx0aWYoZWxtWzBdLmNoaWxkTm9kZXMubGVuZ3RoID4gMCl7XG5cdFx0XHRcdFx0XHRzY29wZS5jaGlsZCA9IGVsbVswXS5jaGlsZE5vZGVzWzBdO1xuXHRcdFx0XHRcdFx0ZWxtWzBdLmlubmVySFRNTCA9ICBHdW1nYVRyYW5zbGF0ZUhlbHBlci5nZXRUcmFuc2xhdGUoc2NvcGUuX192YWx1ZVRvVHJhbnNsYXRlKTtcblx0XHRcdFx0XHRcdGVsbS5hcHBlbmQoJGNvbXBpbGUoc2NvcGUuY2hpbGQpKHNjb3BlKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGVsbVswXS5pbm5lckhUTUwgPSBHdW1nYVRyYW5zbGF0ZUhlbHBlci5nZXRUcmFuc2xhdGUoc2NvcGUuX192YWx1ZVRvVHJhbnNsYXRlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH07XG5cdH1cblxuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy50cmFuc2xhdGV0YWcnLFsnZ3VtZ2Euc2VydmljZXMudHJhbnNsYXRlLmhlbHBlcicsJ2d1bWdhLnNlcnZpY2VzLnRyYW5zbGF0ZSddKVxuXHRcdC5kaXJlY3RpdmUoJ2d1bWdhVHJhbnNsYXRlVGFnJyxUcmFuc2xhdGVUYWcpO1xufSkoKTsiLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy50cmFuc2xhdGUnLFxuXHRcdFtcblx0XHRcdCdndW1nYS5kaXJlY3RpdmVzLnRyYW5zbGF0ZS50cmFuc2xhdGVoZWxwZXInLFxuXHRcdFx0J2d1bWdhLmRpcmVjdGl2ZXMudHJhbnNsYXRlLnRyYW5zbGF0ZScsXG5cdFx0XHQnZ3VtZ2EuZGlyZWN0aXZlcy50cmFuc2xhdGUudHJhbnNsYXRldGFnJ1xuXHRcdF0pXG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0Jztcblx0VXBsb2FkLiRpbmplY3QgPSBbXCIkaHR0cFwiLCBcIiRwYXJzZVwiLCBcIiR0aW1lb3V0XCJdO1xuXHQvKipcblx0ICogQG5nZG9jIGRpcmVjdGl2ZVxuXHQgKiBAbmFtZSBndW1nYS5jb3JlOmd1bWdhVXBsb2FkXG5cdCAqIEByZXN0cmljdFxuXHQgKiBAZGVzY3JpcHRpb25cblx0ICogXHRPIGNvbXBvbmVudGUgZ3VtZ2FVcGxvYWQgcG9kZSBzZXIgdXRpbGl6YWRvIHBhcmEgZmF6ZXIgdXBsb2FkIGRlIGltYWdlbnMuIE8gZnJhbWV3b3JrIEdVTUdBIHVzYSB1bSBtw6l0b2RvIGRlIHVwbG9hZFxuXHQgKiBcdGRlIGltYWdlbnMgcXVlIGZheiBvIHVwbG9hZCBkbyBhcnF1aXZvIHBhcmEgdW1hIHBhc3RhIHRlbXBvcsOhcmlhIGUgcmV0b3JuYSB1bSB0b2tlbi4gUXVhbmRvIG8gcmVnaXN0cm8gw6kgc2Fsdm8sIG8gZnJhbWV3b3JrIGd1bWdhXG5cdCAqIFx0ZmF6IG8gYmluZCBkYSBzdHJpbmcgcXVlIGVzdMOhIG5vIGF0cmlidXRvIGNvbSBvIGFycXVpdm8gdGVtcG9yw6FyaW8uXG5cdCAqIFx0QHBhcmFtIHtPYmpldH0gbW9kZWwgT2JqZXRvIHF1ZSBpcsOhIGNvbnRlciBhcyBpbmZvcm1hw6fDtWVzIGRhIGltYWdlbS5cblx0ICogXHRAcGFyYW0ge0Z1bmN0aW9ufSB1cGxvYWQtbWV0aG9kIEZ1bsOnw6NvIHF1ZSBzZXLDoSBleGVjdXRhZGEgcGFyYSBmYXplciBvIHVwbG9hZCBkYSBpbWFnZW0gcGFyYSBvIGFycXVpdm8gdGVtcG9yw6FyaW8uXG5cdCAqIFx0QHBhcmFtIHtGdW5jdGlvbn0gZGVsZXRlLW1ldGhvZCBGdW7Dp8OjbyBxdWUgc2Vyw6EgZXhlY3V0YWRhIHBhcmEgZGVsZXRhciBhIGltYWdlbSBkbyBlc3Bhw6dvIHRlbXBvcsOhcmlvLlxuXHQgKiBcdEBwYXJhbSB7U3RyaW5nfSB0b29sdGlwLXRleHQgTWVuc2FnZW0gcXVlIGlyw6EgYXBhcmVjZXIgbm8gdG9vbHRpcCBkYSBpbWFnZW0uXG5cdCAqL1xuXHRmdW5jdGlvbiBVcGxvYWQoJGh0dHAsJHBhcnNlLCR0aW1lb3V0KXtcblxuXHRcdHZhciBpbWcgPVxuXHRcdCc8ZGl2IG5nLWNsaWNrPVwiZmlyZUNsaWNrKClcIiBuZy1zaG93PVwiZmxhZ1wiIGNsYXNzPVwiY29sLW1kLTFcIiB0b29sdGlwPVwie3s6OnRvb2x0aXBUZXh0fX1cIiB0b29sdGlwLXBsYWNlbWVudD1cInJpZ2h0XCI+Jytcblx0XHQnXHQ8c3ZnIHZlcnNpb249XCIxLjFcIiBpZD1cIkxheWVyXzFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeD1cIjBweFwiIHk9XCIwcHhcIiB3aWR0aD1cIjEyOHB4XCIgaGVpZ2h0PVwiMTI4cHhcIiB2aWV3Qm94PVwiMCAwIDUxMiA1MTJcIiBlbmFibGUtYmFja2dyb3VuZD1cIm5ldyAwIDAgNTEyIDUxMlwiIHhtbDpzcGFjZT1cInByZXNlcnZlXCI+Jytcblx0XHQnXHRcdDxwYXRoIGlkPVwiYXZhdGFyXCIgZmlsbD1cIiNjY2NjY2NcIiBkPVwiTTQ5MC41NzksMzgzLjAyOWMtMTQuMTUyLTIyLjA4Ni02MS43NjMtMzUuODI0LTEwOC44MzUtNTUuNDUzYy00Ny4xMDMtMTkuNjMzLTU4LjI2OC0yNi40MzktNTguMjY4LTI2LjQzOScrXG5cdFx0J1x0XHRcdGwtMC40NDUtNDUuMTgyYzAsMCwxNy42NDYtMTMuNTU3LDIzLjEyNy01Ni4wNzRjMTEuMDEsMy4xOTgsMjIuNjE5LTE2LjQ2MSwyMy4yMzctMjYuODI0YzAuNjI1LTkuOTgtMS41MDgtMzcuNjYyLTE0Ljk4MS0zNC44NzcnICtcblx0XHQnXHRcdFx0YzIuNzU0LTIwLjg0NSw0Ljc0MS0zOS41ODYsMy43NjQtNDkuNTA1Yy0zLjQ5NS0zNi4yOTUtMzkuMjMtNzQuNTc4LTk0LjE4Mi03NC41NzhjLTU0Ljk1LDAtOTAuNywzOC4yODMtOTQuMTkzLDc0LjU3OCcgK1xuXHRcdCdcdFx0XHRjLTAuOTc4LDkuOTE5LDEuMDE5LDI4LjY2MSwzLjc1OCw0OS41MDVjLTEzLjQ1NS0yLjc4NS0xNS41ODcsMjQuODk3LTE0Ljk3OSwzNC44NzdjMC42MzUsMTAuMzYzLDEyLjE5NiwzMC4wMjEsMjMuMjU1LDI2LjgyNCcgK1xuXHRcdCdcdFx0XHRjNS40NjIsNDIuNTE3LDIzLjEyMiw1Ni4wNzQsMjMuMTIyLDU2LjA3NGwtMC40NDEsNDUuMTgyYzAsMC0xMS4xNzgsNi44MDctNTguMjY4LDI2LjQzOScgK1xuXHRcdCdcdFx0XHRjLTQ3LjEwNCwxOS42MjktOTQuNjgzLDMzLjM2Ny0xMDguODUxLDU1LjQ1M2MtMTIuNywxOS43NzctOC44ODIsMTE0Ljg3NS04Ljg4MiwxMTQuODc1aDQ3MC45NDYnICtcblx0XHQnXHRcdFx0QzQ5OS40NjIsNDk3LjkwNCw1MDMuMjgxLDQwMi44MDYsNDkwLjU3OSwzODMuMDI5elwiLz4nICtcblx0XHQnXHQ8L3N2Zz4nICtcblx0XHQnPC9kaXY+JztcblxuXHRcdHZhciB0ZW1wbGF0ZSA9XG5cdFx0JzxkaXYgY2xhc3M9XCJmdWxsLXdpZHRoLXdpdGhvdXQtcGFkZGluZ1wiPicgK1xuXHRcdGltZyArXG5cdFx0JyAgIDxpbWcgc3JjPVwiI1wiIGFsdD1cIlVwbG9hZGVkIEltYWdlXCIgbmctc2hvdz1cIiFmbGFnXCIgY2xhc3M9XCJpbWctcm91bmRlZFwiIHN0eWxlPVwib2JqZWN0LWZpdDogY292ZXJcIi8+JyArXG5cdFx0JyAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiIG5hbWU9XCJ1cGxvYWRcIiBpZD1cInVwbG9hZFwiIG5nLWhpZGU9XCJ0cnVlXCIvPicgK1xuXHRcdCcgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTEyXCIgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6IDBcIj4nICtcblx0XHQnICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWxpbmtcIiBuZy1oaWRlPVwiZmxhZ1wiIG5nLWNsaWNrPVwiZGVsZXRlSW1hZ2UoKVwiPiBEZWxldGUgSW1hZ2UgPHNwYW4gY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXRyYXNoXCI+PC9zcGFuPjwvYnV0dG9uPicgK1xuXHRcdCc8L2Rpdj4nICtcblx0XHQnPC9kaXY+Jztcblx0XHRyZXR1cm4ge1xuXHRcdFx0cmVzdHJpY3Q6ICdBRScsXG5cdFx0XHRzY29wZToge1xuXHRcdFx0XHRtb2RlbDogJz1hdHRyaWJ1dGUnLFxuXHRcdFx0XHR1cGxvYWRNZXRob2Q6ICcmJyxcblx0XHRcdFx0ZGVsZXRlTWV0aG9kOiAnJicsXG5cdFx0XHRcdHRvb2x0aXBUZXh0OiAnQCdcblx0XHRcdH0sXG5cdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG5cdFx0XHRsaW5rOmZ1bmN0aW9uKHNjb3BlLGVsbSxhdHRycyl7XG5cdFx0XHRcdHZhciBtb2RlbCA9ICRwYXJzZShhdHRycy5hdHRyaWJ1dGUpLFxuXHRcdFx0XHRtb2RlbFNldHRlciA9IG1vZGVsLmFzc2lnbixcblx0XHRcdFx0ZWxlbWVudCA9IGVsbS5maW5kKCdpbnB1dCcpLFxuXHRcdFx0XHRpbWFnZSA9IGVsbS5maW5kKCdpbWcnKVswXSxcblx0XHRcdFx0cmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuXG5cdFx0XHRcdHNjb3BlLmZpcmVDbGljayA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0JHRpbWVvdXQoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd1cGxvYWQnKVxuXHRcdFx0XHRcdFx0XHQuY2xpY2soKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLiR3YXRjaCgnbW9kZWwnLGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0aWYoc2NvcGUubW9kZWwpe1xuXHRcdFx0XHRcdFx0aWYoc2NvcGUubW9kZWwuYnl0ZXMpe1xuXHRcdFx0XHRcdFx0XHRzY29wZS5mbGFnID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGltYWdlLnNyYyA9ICdkYXRhOicgKyBzY29wZS5tb2RlbC5taW1lVHlwZSArICc7YmFzZTY0LCcgKyBzY29wZS5tb2RlbC5ieXRlcztcblx0XHRcdFx0XHRcdFx0aW1hZ2Uud2lkdGggPSAyMDA7XG5cdFx0XHRcdFx0XHRcdGltYWdlLmhlaWdodCA9IDIwMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2NvcGUubW9kZWwgPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmKCFhdHRycy5hdHRyaWJ1dGUpe1xuXHRcdFx0XHRcdHRocm93ICdZb3UgbXVzdCBwYXNzIGFuIGF0dHJpYnV0ZSB0byBHdW1nYVVwbG9hZCc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5mbGFnID0gdHJ1ZTtcblxuXHRcdFx0XHRmdW5jdGlvbiBzY2FsZVNpemUobWF4VywgbWF4SCwgY3VyclcsIGN1cnJIKXtcblx0XHRcdFx0XHR2YXIgcmF0aW8gPSBjdXJySCAvIGN1cnJXO1xuXHRcdFx0XHRcdGlmKGN1cnJXID49IG1heFcgJiYgcmF0aW8gPD0gMSl7XG5cdFx0XHRcdFx0XHRjdXJyVyA9IG1heFc7XG5cdFx0XHRcdFx0XHRjdXJySCA9IGN1cnJXICogcmF0aW87XG5cdFx0XHRcdFx0fSBlbHNlIGlmKGN1cnJIID49IG1heEgpe1xuXHRcdFx0XHRcdFx0Y3VyckggPSBtYXhIO1xuXHRcdFx0XHRcdFx0Y3VyclcgPSBjdXJySCAvIHJhdGlvO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gW2N1cnJXLCBjdXJySF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5kZWxldGVJbWFnZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0aW1hZ2Uuc3JjID0gJyc7XG5cdFx0XHRcdFx0c2NvcGUuZmxhZyA9IHRydWU7XG5cdFx0XHRcdFx0ZWxlbWVudFswXS5maWxlcyA9IFtdO1xuXHRcdFx0XHRcdHNjb3BlLmRlbGV0ZU1ldGhvZCgpO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGVsZW1lbnQuYmluZCgnY2hhbmdlJyxmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHNjb3BlLiRhcHBseShmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0dmFyIHg7XG5cdFx0XHRcdFx0XHRtb2RlbFNldHRlcihzY29wZSxlbGVtZW50WzBdLmZpbGVzWzBdKTtcblx0XHRcdFx0XHRcdHNjb3BlLmZsYWcgPSBmYWxzZTtcblx0XHRcdFx0XHRcdHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHRpbWFnZS5zcmMgPSByZWFkZXIucmVzdWx0O1xuXHRcdFx0XHRcdFx0XHRpbWFnZS53aWR0aCA9IDIwMDtcblx0XHRcdFx0XHRcdFx0aW1hZ2UuaGVpZ2h0ID0yMDA7XG5cdFx0XHRcdFx0XHRcdHZhciB4ID0gYXR0cnMuYXR0cmlidXRlLnNwbGl0KCcuJyk7XG5cdFx0XHRcdFx0XHRcdHNjb3BlLnVwbG9hZE1ldGhvZCh7aW1hZ2U6IHNjb3BlW3hbMF1dW3hbMV1dfSlcblx0XHRcdFx0XHRcdFx0LnRoZW4oZnVuY3Rpb24odmFsKXtcblx0XHRcdFx0XHRcdFx0XHRzY29wZS5tb2RlbC5uYW1lID0gdmFsLmRhdGE7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHJlYWRlci5yZWFkQXNEYXRhVVJMKGVsZW1lbnRbMF0uZmlsZXNbMF0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0YW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMudXBsb2FkJyxbXSlcblx0XHQuZGlyZWN0aXZlKCdndW1nYVVwbG9hZCcsVXBsb2FkKTtcblxufSkoKTtcbiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cdEFkZHJlc3NTZXJ2aWNlLiRpbmplY3QgPSBbXTtcblx0ZnVuY3Rpb24gQWRkcmVzc1NlcnZpY2UoKXtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXZlcnlVZjogWydBQycsICdBTCcsICdBTScsICdBUCcsICdCQScsICdDRScsICdERicsICdFUycsICdHTycsICdNQScsICdNRycsICdNUycsICdNVCcsICdQQScsICdQQicsICdQRScsICdQSScsICdQUicsXG5cdFx0XHQnUkonLCAnUk4nLCAnUlInLCAnUlMnLCAnU0MnLCAnU0UnLCAnU1AnLCAnVE8nXSxcblx0XHRcdGV2ZXJ5TG9ncmFkb3VybzogW1x0J091dHJvcycsICdBZXJvcG9ydG8nLCAnQWxhbWVkYScsICfDgXJlYScsICdBdmVuaWRhJywgJ0NhbXBvJywgJ0Now6FjYXJhJywgJ0NvbMO0bmlhJywgJ0NvbmRvbcOtbmlvJywgJ0Nvbmp1bnRvJywgJ0Rpc3RyaXRvJyxcblx0XHRcdCdFc3BsYW5hZGEnLCAnRXN0YcOnw6NvJywgJ0VzdHJhZGEnLCAnRmF2ZWxhJywgJ0ZhemVuZGEnLCAnRmVpcmEnLCAnSmFyZGltJywgJ0xhZGVpcmEnLCAnTGFyZ28nLCAnTGFnbycsICdMYWdvYScsICdMb3RlYW1lbnRvJyxcblx0XHRcdCdOw7pjbGVvJywgJ1BhcnF1ZScsICdQYXNzYXJlbGEnLCAnUMOhdGlvJywgJ1ByYcOnYScsICdRdWFkcmEnLCAnUmVjYW50bycsICdSZXNpZGVuY2lhbCcsICdSb2RvdmlhJywgJ1J1YScsICdTZXRvcicsICdTw610aW8nLFxuXHRcdFx0J1RyYXZlc3NhJywgJ1RyZXZvJywgJ1RyZWNobycsICdWYWxlJywgJ1ZlcmVkYScsICdWaWEnLCAnVmlhZHV0bycsICdWaWVsYScsICdWaWEnXSxcblx0XHRcdGF2YWlsYWJsZUNvdW50cmllczogWydCcmFzaWwnXSxcblx0XHRcdHJldHVybkZvcm1hdHRlZE9iamVjdDogZnVuY3Rpb24oKXtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR6aXBDb2RlIDogbnVsbCxcblx0XHRcdFx0XHRwcmVtaXNzZVR5cGU6IG51bGwsXG5cdFx0XHRcdFx0cHJlbWlzc2U6IG51bGwsXG5cdFx0XHRcdFx0bnVtYmVyOiBudWxsLFxuXHRcdFx0XHRcdGluZm9ybWF0aW9uOiBudWxsLFxuXHRcdFx0XHRcdG5laWdoYm91cmhvb2Q6IG51bGwsXG5cdFx0XHRcdFx0bG9jYWxpemF0aW9uOiBudWxsLFxuXHRcdFx0XHRcdHN0YXRlOiBudWxsLFxuXHRcdFx0XHRcdGNvdW50cnk6IG51bGxcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdFx0YW5ndWxhci5tb2R1bGUoJ2d1bWdhLnNlcnZpY2VzLmFkZHJlc3MnLFtdKVxuXHRcdC5mYWN0b3J5KCdHdW1nYUFkZHJlc3NTZXJ2aWNlJyxBZGRyZXNzU2VydmljZSk7XG5cblx0fSkoKTtcbiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cblx0QWxlcnQuJGluamVjdCA9IFtdXG5cdC8qKlxuXHQgKiBAbmdkb2Mgc2VydmljZVxuXHQgKiBAbmFtZSBndW1nYS5jb3JlOkd1bWdhQWxlcnRcblx0ICogQGRlc2NyaXB0aW9uIE8gc2VydmljZSBHdW1nYUFsZXJ0IMOpIHVtYSBub3ZhIHZlcnPDo28gZGEgZGlyZWN0aXZlIHtAbGluayBndW1nYS5jb3JlOmd1bWdhQWxlcnR9IGUgw6kgdXRpbGl6YWRvIHBhcmEgY3JpYXJcblx0ICogbm90aWZpY2HDp8O1ZXMgZ3Jvd2wtbGlrZS4gUGFyYSB1dGlsaXphciBvIHNlcnZpY2UsIGJhc3RhIGluY2x1aXIgR3VtZ2FBbGVydCBjb21vIGRlcGVuZMOqbmNpYS5cblx0ICogXG5cdCAqICpPYnNlcnZhw6fDo286IFBhcmEgdXRpbGl6YcOnw6NvIGRvIHNlcnZpY2Ugbm8gY29uZmlnIGRvIG3Ds2R1bG8sIHV0aWxpemFyIGBHdW1nYUFsZXJ0UHJvdmlkZXJgKlxuXHQgKlxuXHQgKlxuXHQgKiAjIyBNw6l0b2Rvc1xuXHQgKlxuXHQgKiBPIHNlcnZpY2UgR3VtZ2FBbGVydCBwb3NzdWkgcXVhdHJvIG3DqXRvZG9zIGRlIGNyaWHDp8OjbyBkZSBhbGVydGEsIHBvcsOpbSB0b2RvcyByZWNlYmVtIG8gbWVzbW8gcGFyw6JtZXRyby4gRm9pIG9wdGFkbyBwb3IgY3JpYXIgcXVhdHJvXG5cdCAqIG3DqXRvZG9zIGRpZmVyZW50ZXMgcGFyYSBhdW1lbnRhciBhIGxlZ2liaWxpZGFkZS5cblx0ICogLSBjcmVhdGVXYXJuaW5nTWVzc2FnZSh0aXRsZSxtZXNzYWdlLG9wdGlvbnMpXG5cdCAqIC0gY3JlYXRlRGFuZ2VyTWVzc2FnZSh0aXRsZSxtZXNzYWdlLG9wdGlvbnMpXG5cdCAqIC0gY3JlYXRlU3VjY2Vzc01lc3NhZ2UodGl0bGUsbWVzc2FnZSxvcHRpb25zKVxuXHQgKiAtIGNyZWF0ZUluZm9tZXNzYWdlKHRpdGxlLG1lc3NhZ2Usb3B0aW9ucylcblx0ICpcblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSBgdGl0bGVgOiBVbWEgc3RyaW5nIHF1ZSBpcsOhIGNvbnRlciBvIHTDrXR1bG8gZGEgbWVuc2FnZW0gcXVlIHNlcsOhIGNyaWFkYS5cblx0ICogIC0gYG1lc3NhZ2VgOiBVbWEgc3RyaW5nIHF1ZSBpcsOhIGNvbnRlciBvIGNvcnBvIGRhIG1lbnNhZ2VtIHF1ZSBzZXLDoSBjcmlhZGEuXG5cdCAqICAtIGBvcHRpb25zYDogVW0gb2JqZXRvIGNvbSBvcMOnw7VlcyBhZGljaW9uYWlzIHBhcmEgbyBhbGVydGEuIE9zIGF0cmlidXRvcyBxdWUgcG9kZW0gc2VyIHBhc3NhZG9zIHBhcmEgZXN0ZSBvYmpldG8gc8Ojbzpcblx0ICogIFx0PHByZT5cblx0ICogICBcdFx0dmFyIGNvbmZpZyA9IHtcblx0ICogICBcdFx0IG9mZnNldDogNTAsIC8vVGFtYW5obyBkYSBkaXN0w6JuY2lhIGVudHJlIG8gYWxlcnRhIGUgdGVsYS5cblx0ICogICBcdFx0IHRpbWVyOiAxMDAsIC8vVGVtcG8gcXVlIGlyw6EgZGVtb3JhciBwYXJhIGEgbWVuc2FnZW0gYXBhcmVjZXIgYXDDs3Ncblx0ICogICBcdFx0IGRlbGF5OiAzNTAwLFxuXHQgKiAgIFx0XHQgYWxvd0Rpc21pc3M6dHJ1ZSxcblx0ICogICBcdFx0IGFuaW1hdGlvbkVudGVyOiAnYW5pbWF0ZWQgYm91bmNlSW5SaWdodCcsXG5cdCAqICAgXHRcdCBhbmltYXRpb25FeGl0OiAnYW5pbWF0ZWQgYm91bmNlT3V0UmlnaHQnXG5cdCAqICAgXHRcdH1cblx0ICogXHRcdDwvcHJlPiAqT2JqZXRvIGNvbSBvcyB2YWxvcmVzIHBhZHLDtWVzIGRvIGFsZXJ0YSpcblx0ICogXHRcdFxuXHQgKi9cblx0ZnVuY3Rpb24gQWxlcnQoKXtcblx0XHRyZXR1cm4ge1xuXHRcdFx0JGdldDogZnVuY3Rpb24oKXtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0X19jb25maWc6IHtcblx0XHRcdFx0d2Fybjoge1xuXHRcdFx0XHRcdGljb246ICdnbHlwaGljb24gZ2x5cGhpY29uLXdhcm5pbmctc2lnbicsXG5cdFx0XHRcdFx0dHlwZTogJ3dhcm5pbmcnXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGRhbmdlcjoge1xuXHRcdFx0XHRcdGljb246ICdnbHlwaGljb24gZ2x5cGhpY29uLWV4Y2xhbWF0aW9uLXNpZ24nLFxuXHRcdFx0XHRcdHR5cGU6ICdkYW5nZXInIFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzdWNjZXNzOiB7XG5cdFx0XHRcdFx0aWNvbjonZ2x5cGhpY29uIGdseXBoaWNvbi1vaycsXG5cdFx0XHRcdFx0dHlwZTogJ3N1Y2Nlc3MnXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGluZm86IHtcblx0XHRcdFx0XHRpY29uOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1pbmZvLXNpZ24nLFxuXHRcdFx0XHRcdHR5cGU6ICdpbmZvJ1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X25vdGlmeTogZnVuY3Rpb24odHlwZSx0aXRsZSxtZXNzYWdlLG9wdGlvbnMpe1xuXHRcdFx0XHR2YXIgY29uZmlnID0gdGhpcy5fX2NvbmZpZ1t0eXBlXVxuXHRcdFx0XHQsXHRcdG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0IHx8IDUwXG5cdFx0XHRcdCxcdFx0dGltZXIgPSBvcHRpb25zLnRpbWVyIHx8IDEwMFxuXHRcdFx0XHQsXHRcdGRlbGF5ID0gb3B0aW9ucy5kZWxheSB8fCAzNTAwXG5cdFx0XHRcdCxcdFx0YWxvd0Rpc21pc3MgPSBvcHRpb25zLmFsb3dEaXNtaXNzIHx8IHRydWVcblx0XHRcdFx0LFx0XHRhbmltYXRpb25FbnRlciA9IG9wdGlvbnMuYW5pbWF0aW9uRW50ZXIgfHwgJ2FuaW1hdGVkIGJvdW5jZUluUmlnaHQnXG5cdFx0XHRcdCxcdFx0YW5pbWF0aW9uRXhpdCA9IG9wdGlvbnMuYW5pbWF0aW9uRXhpdCB8fCAnYW5pbWF0ZWQgYm91bmNlT3V0UmlnaHQnO1xuXHRcdFx0XHQkLm5vdGlmeSh7XG5cdFx0XHRcdFx0aWNvbjogY29uZmlnLmljb24sXG5cdFx0XHRcdFx0dGl0bGU6IHRpdGxlLFxuXHRcdFx0XHRcdG1lc3NhZ2U6IG1lc3NhZ2Vcblx0XHRcdFx0fSx7XG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRvZmZzZXQ6IG9mZnNldCxcblx0XHRcdFx0XHR0aW1lcjogdGltZXIsXG5cdFx0XHRcdFx0ZGVsYXk6IGRlbGF5LFxuXHRcdFx0XHRcdGFsb3dfZGlzbWlzczogYWxvd0Rpc21pc3MsXG5cdFx0XHRcdFx0YW5pbWF0ZToge1xuXHRcdFx0XHRcdFx0XHRlbnRlcjogYW5pbWF0aW9uRW50ZXIsXG5cdFx0XHRcdFx0XHRcdGV4aXQ6IGFuaW1hdGlvbkV4aXRcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0dGVtcGxhdGU6ICc8ZGl2IGRhdGEtbm90aWZ5PVwiY29udGFpbmVyXCIgY2xhc3M9XCJjb2wteHMtOSBjb2wtc20tMyBhbGVydCBhbGVydC17MH1cIiByb2xlPVwiYWxlcnRcIj4nICtcblx0XHRcdFx0XHRcdCc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzcz1cImNsb3NlXCIgZGF0YS1ub3RpZnk9XCJkaXNtaXNzXCI+w5c8L2J1dHRvbj4nICtcblx0XHRcdFx0XHRcdCc8c3BhbiBkYXRhLW5vdGlmeT1cImljb25cIj48L3NwYW4+ICcgK1xuXHRcdFx0XHRcdFx0JzxzcGFuIGRhdGEtbm90aWZ5PVwidGl0bGVcIj48Yj57MX08L2I+PC9zcGFuPjxicj4gJyArXG5cdFx0XHRcdFx0XHQnPHNwYW4gZGF0YS1ub3RpZnk9XCJtZXNzYWdlXCI+ezJ9PC9zcGFuPicgK1xuXHRcdFx0XHRcdFx0JzwvZGl2Pidcblx0XHRcdFx0fSlcblx0XHRcdH0sXG5cdFx0XHRjcmVhdGVXYXJuaW5nTWVzc2FnZTogZnVuY3Rpb24odGl0bGUsbWVzc2FnZSxvcHRpb25zKXtcblx0XHRcdFx0aWYoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcblx0XHRcdFx0dGhpcy5fbm90aWZ5KCd3YXJuaW5nJyx0aXRsZSxtZXNzYWdlLG9wdGlvbnMpO1xuXHRcdFx0fSxcblx0XHRcdGNyZWF0ZURhbmdlck1lc3NhZ2U6IGZ1bmN0aW9uKHRpdGxlLG1lc3NhZ2Usb3B0aW9ucyl7XG5cdFx0XHRcdGlmKCFvcHRpb25zKSBvcHRpb25zID0ge307XG5cdFx0XHRcdHRoaXMuX25vdGlmeSgnZGFuZ2VyJyx0aXRsZSxtZXNzYWdlLG9wdGlvbnMpO1xuXHRcdFx0fSxcblx0XHRcdGNyZWF0ZVN1Y2Nlc3NNZXNzYWdlOiBmdW5jdGlvbih0aXRsZSxtZXNzYWdlLG9wdGlvbnMpe1xuXHRcdFx0XHRpZighb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuXHRcdFx0XHR0aGlzLl9ub3RpZnkoJ3N1Y2Nlc3MnLHRpdGxlLG1lc3NhZ2Usb3B0aW9ucyk7XG5cdFx0XHR9LFxuXHRcdFx0Y3JlYXRlSW5mb01lc3NhZ2U6IGZ1bmN0aW9uKHRpdGxlLG1lc3NhZ2Usb3B0aW9ucyl7XG5cdFx0XHRcdGlmKCFvcHRpb25zKSBvcHRpb25zID0ge307XG5cdFx0XHRcdHRoaXMuX25vdGlmeSgnaW5mbycsdGl0bGUsbWVzc2FnZSxvcHRpb25zKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2Euc2VydmljZXMuYWxlcnQnLFtdKVxuXHRcdC5wcm92aWRlcignR3VtZ2FBbGVydCcsQWxlcnQpO1xufSkoKTsiLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdEJhc2UuJGluamVjdCA9IFtcIiRodHRwXCIsIFwiJHFcIl07XG5cdC8qKlxuXHQgKiBAbmdkb2Mgc2VydmljZVxuXHQgKiBAbmFtZSBndW1nYS5jb3JlOkd1bWdhQmFzZVxuXHQgKiBAZGVzY3JpcHRpb25cblx0ICogXHRPIHNlcnZpY2UgR3VtZ2FCYXNlIHBvZGUgc2VyIHV0aWxpemFkbyBjb21vIGhlbHBlciBwYXJhIGZhemVyIGNoYW1hZGFzIEhUVFAuIEVsZSBwZXJtaXRlIHF1ZSBvIHByb2dyYW1hZG9yIG7Do28gcHJlY2lzZSBpbmNsdWlyIG8gc2VydmljZSAkaHR0cFxuXHQgKiBcdGRvIEFuZ3VsYXJKUyBlIGrDoSB2ZW0gY29tIGFsZ3VtYXMgZnVuw6fDtWVzIGluY2x1w61kYXMuIFBhcmEgdXRpbGl6YXIgbyBHdW1nYUJhc2UsIGJhc3RhIMOtbmNsdcOtLWxvIGNvbW8gZGVwZW5kw6puY2lhLlxuXHQgKlxuXHQgKlxuXHQgKiAgIyBNw6l0b2Rvc1xuXHQgKiAgYEd1bWdhQmFzZS5nZXQodXJsLHBhcmFtcylgXG5cdCAqXG5cdCAqICBPIG3DqXRvZG8gZ2V0IGFjZWl0YSBkb2lzIHBhcsOibWV0cm9zIGB1cmxgIGUgYHBhcmFtc2AgZSByZXRvcm5hIHVtYSBwcm9taXNlIGRlIHVtYSBjaGFtYWRhIEhUVFAgZG8gdGlwbyBHRVQuXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPnVybDwvbGFiZWw+ICBFbmRlcmXDp28gbm8gcXVhbCBhIGNoYW1hZGEgaHR0cCBzZXLDoSBmZWl0YS5cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPk9iamVjdDwvbGFiZWw+IDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5wYXJhbXM8L2xhYmVsPiBQYXLDom1ldHJvcyBkYSBxdWVyeSBxdWUgc2Vyw6EgZmVpdGEuXG5cdCAqICAjIyMgUmV0b3Jub1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+SHR0cFByb21pc2U8L2xhYmVsPiBSZXRvbmEgdW1hIHByb21pc2UgZGEgY2hhbWFkYSBIVFRQIEdFVC5cblx0ICogIC0tLVxuIFx0ICogIGBHdW1nYUJhc2UuZ2V0QnlJZCh1cmwsaWQpYFxuXHQgKlxuXHQgKiAgTyBtw6l0b2RvIGdldEJ5SWQgYWNlaXRhIGRvaXMgcGFyw6JtZXRyb3MgYHVybGAgZSBgaWRgIGUgcmV0b3JuYSB1bWEgcHJvbWlzZSBkZSB1bWEgY2hhbWFkYSBIVFRQIGRvIHRpcG8gR0VULlxuXHQgKiAgIyMjIFBhcsOibWV0cm9zXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj51cmw8L2xhYmVsPiAgRW5kZXJlw6dvIG5vIHF1YWwgYSBjaGFtYWRhIGh0dHAgc2Vyw6EgZmVpdGEuXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5bU3RyaW5nfE51bWJlcl08L2xhYmVsPiA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+aWQ8L2xhYmVsPiBJZGVudGlmaWNhZG9yIGRvIHJlZ2lzdHJvIHF1ZSBzZXLDoSBidXNjYWRvLlxuXHQgKiAgIyMjIFJldG9ybm9cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPkh0dHBQcm9taXNlPC9sYWJlbD4gUmV0b25hIHVtYSBwcm9taXNlIGRhIGNoYW1hZGEgSFRUUCBHRVQuXG5cdCAqICAtLS1cblx0ICogIGBHdW1nYUJhc2UuZ2V0TmV3KHVybClgXG5cdCAqXG5cdCAqICBPIG3DqXRvZG8gZ2V0QnlJZCBhY2VpdGEgdW0gcGFyw6JtZXRybyBgdXJsYCBlIHJldG9ybmEgdW1hIHByb21pc2UgZGUgdW1hIGNoYW1hZGEgSFRUUCBkbyB0aXBvIEdFVC5cblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+dXJsPC9sYWJlbD4gIEVuZGVyZcOnbyBubyBxdWFsIGEgY2hhbWFkYSBodHRwIHNlcsOhIGZlaXRhIGUgbmEgcXVhbFxuXHQgKiAgIHNlcsOhIGZlaXRhIGEgY2hhbWFkYSBwYXJhIHVtIG5vdm8gcmVnaXN0cm8uXG5cdCAqICAjIyMgUmV0b3Jub1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+SHR0cFByb21pc2U8L2xhYmVsPiBSZXRvcm5hIHVtYSBwcm9taXNlIGRhIGNoYW1hZGEgSFRUUCBHRVQuXG5cdCAqICAtLS1cbiBcdCAqICBgR3VtZ2FCYXNlLmRlbGV0ZUFsbCh1cmwsYXJyYXkpYFxuXHQgKlxuXHQgKiAgTyBtw6l0b2RvIGRlbGV0ZUFsbCBhY2VpdGEgZG9pcyBwYXLDom1ldHJvcyBgdXJsYCBlIGBhcnJheWAgZSByZXRvcm5hIHVtYSBwcm9taXNlIGRlIHVtYSBzw6lyaWUgZGUgY2hhbWFkYXMgaHR0cCBkbyB0aXBvIERFTEVURSBxdWUgc2Vyw6NvIHJlc29sdmlkYXMgYW8gbWVzbW8gdGVtcG8uXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPnVybDwvbGFiZWw+ICBFbmRlcmXDp28gbm8gcXVhbCBhIGNoYW1hZGEgaHR0cCBzZXLDoSBmZWl0YS5cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPkFycmF5PC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+YXJyYXk8L2xhYmVsPiBBcnJheSBjb20gdG9kYXMgb3MgcmVnaXN0cm9zIHF1ZSBzZXLDo28gZGVsZXRhZG9zXG5cdCAqICAjIyMgUmV0b3Jub1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+SHR0cFByb21pc2U8L2xhYmVsPiBSZXRvcm5hIHVtYSBwcm9taXNlIGFww7NzIHRvZGFzIGFzIGNoYW1hZGFzIHRlcmVtIHNpZG8gcmVzb2x2aWRhcy5cblx0ICogIC0tLVxuXHQgKiAgYEd1bWdhQmFzZS5zYXZlKHVybCxkYXRhKWBcblx0ICpcblx0ICogIE8gbcOpdG9kbyBzYXZlIGFjZWl0YSBkb2lzIHBhcsOibWV0cm9zIGB1cmxgIGUgYGRhdGFgIGUgcmV0b3JuYSB1bWEgcHJvbWlzZSBkZSBkZSB1bWEgY2hhbWFkYSBIVFRQIFBPU1QuXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPnVybDwvbGFiZWw+ICBFbmRlcmXDp28gbm8gcXVhbCBhIGNoYW1hZGEgaHR0cCBzZXLDoSBmZWl0YS5cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPk9iamVjdDwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmRhdGE8L2xhYmVsPiBPYmpldG8gcXVlIGRlc2VqYSBzZXIgc2Fsdm8uXG5cdCAqICAjIyMgUmV0b3Jub1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+SHR0cFByb21pc2U8L2xhYmVsPiBSZXRvcm5hIHVtYSBwcm9taXNlIGRhIGNoYW1hZGEgSFRUUCBQT1NULlxuXHQgKiAgLS0tXG4gXHQgKiAgYEd1bWdhQmFzZS51cGRhdGUodXJsLGRhdGEpYFxuXHQgKlxuXHQgKiAgTyBtw6l0b2RvIGRlbGV0ZUFsbCBhY2VpdGEgZG9pcyBwYXLDom1ldHJvcyBgdXJsYCBlIGBkYXRhYCBlIHJldG9ybmEgdW1hIHByb21pc2UgZGUgZGUgdW1hIGNoYW1hZGEgSFRUUCBQVVQuXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPnVybDwvbGFiZWw+ICBFbmRlcmXDp28gbm8gcXVhbCBhIGNoYW1hZGEgaHR0cCBzZXLDoSBmZWl0YS5cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPk9iamVjdDwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmRhdGE8L2xhYmVsPiBPYmpldG8gcXVlIGRlc2VqYSBzZXIgYXR1YWxpemFkby5cblx0ICogICMjIyBSZXRvcm5vXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5IdHRwUHJvbWlzZTwvbGFiZWw+IFJldG9ybmEgdW1hIHByb21pc2UgZGEgY2hhbWFkYSBIVFRQIFBPU1QuXG5cdCAqICAtLS1cbiBcdCAqICBgR3VtZ2FCYXNlLmRlbCh1cmwsZGF0YSlgXG5cdCAqXG5cdCAqICBPIG3DqXRvZG8gZGVsIGFjZWl0YSBkb2lzIHBhcsOibWV0cm9zIGB1cmxgIGUgYGRhdGFgIGUgcmV0b3JuYSB1bWEgcHJvbWlzZSBkZSBkZSB1bWEgY2hhbWFkYSBIVFRQIERFTEVURS4gRXN0YSBmdW7Dp8OjbyDDqSBjaGFtYWRhIHBhcmEgY2FkYSByZWdpc3RybyBwYXNzYWRvIGRlbnRybyBkbyBBcnJheVxuXHQgKiAgbmEgZnVuw6fDo28gZGVsZXRlQWxsLlxuXHQgKiAgIyMjIFBhcsOibWV0cm9zXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj51cmw8L2xhYmVsPiAgRW5kZXJlw6dvIG5vIHF1YWwgYSBjaGFtYWRhIGh0dHAgc2Vyw6EgZmVpdGEuXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5PYmplY3Q8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5kYXRhPC9sYWJlbD4gT2JqZXRvIHF1ZSBkZXNlamEgc2VyIGRlbGV0YWRvLlxuXHQgKiAgIyMjIFJldG9ybm9cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPkh0dHBQcm9taXNlPC9sYWJlbD4gUmV0b3JuYSB1bWEgcHJvbWlzZSBkYSBjaGFtYWRhIEhUVFAgREVMRVRFLlxuXHQgKiAgLS0tXG5cdCAqICBgR3VtZ2FCYXNlLnBvc3RJbWFnZSh1cmwsYXR0cmlidXRlLGRhdGEpYFxuXHQgKlxuXHQgKiAgTyBtw6l0b2RvIHBvc3RJbWFnZSBhY2VpdGEgdHLDqnMgcGFyw6JtZXRyb3MgYHVybGAsYGF0dHJpYnV0ZWAgZSBgZGF0YWAgZSByZXRvcm5hIHVtYSBwcm9taXNlIGRlIGRlIHVtYSBjaGFtYWRhIEhUVFAgUE9TVCBGT1JNLURBVEEuXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPnVybDwvbGFiZWw+ICBFbmRlcmXDp28gbm8gcXVhbCBhIGNoYW1hZGEgaHR0cCBzZXLDoSBmZWl0YS5cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmF0dHJpYnV0ZTwvbGFiZWw+IEF0cmlidXRvIG5vIHF1YWwgYSBpbWFnZW0gc2Vyw6EgZmVpdG8gb1xuXHQgKiAgYmluZCBhcMOzcyBvIGZvcm0gdGVyIHNpZG8gZW52aWFkbyBjb21wbGV0by5cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPk9iamVjdDwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmRhdGE8L2xhYmVsPiBEYWRvcyBkYSBpbWFnZW0gcXVlIGZvaSBzZWxlY2lvbmFkYS4uXG5cdCAqICAjIyMgUmV0b3Jub1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+SHR0cFByb21pc2U8L2xhYmVsPiBSZXRvcm5hIHVtYSBwcm9taXNlIGRhIGNoYW1hZGEgSFRUUCBQT1NULiBOZXN0YSBwcm9taXNlLCBzZXLDoSByZXRvcm5hZG8gbyB2YWxvciBkZSB1bWEgU3RyaW5nIHF1ZSBkZXZlcsOhIHNlciBhdHJpYnXDrWRhIGFvIGF0cmlidXRvXG5cdCAqICBvbmRlIGVzdGF2YSBhIGltYWdlbS4gRXN0YSBzdHJpbmcgw6kgdW0gaWRlbnRpZmljYWRvciBwYXJhIHF1YW5kbyBvIHJlZ2lzdHJvIGZvciBlbnZpYWRvIGF0cmF2w6lzIGRlIHVtIHBvc3QuXG5cdCAqICAtLS1cbiBcdCAqICBgR3VtZ2FCYXNlLmRlbGV0ZUltYWdlKHVybCxhdHRyaWJ1dGUsZGF0YSlgXG5cdCAqXG5cdCAqICBPIG3DqXRvZG8gZGVsIGFjZWl0YSB0csOqcyBwYXLDom1ldHJvcyBgdXJsYCwgYGF0dHJpYnV0ZWAgZSBgZGF0YWAgZSByZXRvcm5hIHVtYSBwcm9taXNlIGRlIHVtYSBjaGFtYWRhIEhUVFAgREVMRVRFIEZPUk0tREFUQS5cblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+dXJsPC9sYWJlbD4gRW5kZXJlw6dvIG5vIHF1YWwgYSBjaGFtYWRhIGh0dHAgc2Vyw6EgZmVpdGEuXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5hdHRyaWJ1dGU8L2xhYmVsPiBBdHJpYnV0byBubyBxdWFsIGEgaW1hZ2VtIHNlcsOhIGZlaXRvIG9cblx0ICogIGJpbmQgYXDDs3MgbyBmb3JtIHRlciBzaWRvIGVudmlhZG8gY29tcGxldG8uXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5PYmplY3Q8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5kYXRhPC9sYWJlbD4gRGFkb3MgZGEgaW1hZ2VtIHF1ZSBmb2kgc2VsZWNpb25hZGEuXG5cdCAqICAjIyMgUmV0b3Jub1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+SHR0cFByb21pc2U8L2xhYmVsPiBSZXRvcm5hIHVtYSBwcm9taXNlIGRhIGNoYW1hZGEgSFRUUCBERUxFVEUuXG5cdCAqICAtLS1cblx0ICovXG5cdGZ1bmN0aW9uIEJhc2UoJGh0dHAsJHEpe1xuXHRcdHZhciBkZWZhdWx0UGFyYW1zID0ge307XG5cdFx0dGhpcy5nZXQgPSBnZXQ7XG5cdFx0dGhpcy5nZXRCeUlkID0gZ2V0QnlJZDtcblx0XHR0aGlzLmdldE5ldyA9IGdldE5ldztcblx0XHR0aGlzLmRlbGV0ZUFsbCA9IGRlbGV0ZUFsbDtcblx0XHR0aGlzLnNhdmUgPSBzYXZlO1xuXHRcdHRoaXMudXBkYXRlID0gdXBkYXRlO1xuXHRcdHRoaXMuZGVsID0gZGVsO1xuXHRcdHRoaXMucG9zdEltYWdlID0gcG9zdEltYWdlO1xuXHRcdHRoaXMuZGVsZXRlSW1hZ2UgPSBkZWxldGVJbWFnZTtcblxuXHRcdGZ1bmN0aW9uIGdldCh1cmwscGFyYW1zKSB7XG5cdFx0XHRpZiAoIXBhcmFtcykge1xuXHRcdFx0XHRwYXJhbXMgPSBkZWZhdWx0UGFyYW1zO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICRodHRwLmdldCh1cmwsIHBhcmFtcyk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0QnlJZCh1cmwsaWQpIHtcblx0XHRcdHJldHVybiAkaHR0cC5nZXQodXJsICsgJy8nICsgaWQpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldE5ldyh1cmwpe1xuXHRcdFx0cmV0dXJuICRodHRwLmdldCh1cmwrJy9uZXcnKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkZWxldGVBbGwodXJsLGVudGl0aWVzKSB7XG5cdFx0XHR2YXIgcHJvbWlzZXMgPSBlbnRpdGllcy5tYXAoZnVuY3Rpb24oZW50aXR5KXtcblx0XHRcdFx0cmV0dXJuIGRlbCh1cmwsZW50aXR5KTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuICRxLmFsbChwcm9taXNlcyk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2F2ZSh1cmwsZW50aXR5KSB7XG5cdFx0XHRyZXR1cm4gJGh0dHAucG9zdCh1cmwsIGVudGl0eSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlKHVybCxlbnRpdHkpIHtcblx0XHRcdHJldHVybiAkaHR0cC5wdXQodXJsICsgJy8nICsgZW50aXR5LmlkLCBlbnRpdHkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRlbCh1cmwsZW50aXR5KSB7XG5cdFx0XHRyZXR1cm4gJGh0dHAuZGVsZXRlKHVybCArICcvJyArIGVudGl0eS5pZCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcG9zdEltYWdlKHVybCwgYXR0cmlidXRlLCBtb2RlbCkge1xuXHRcdFx0dmFyIGZkID0gbmV3IEZvcm1EYXRhKCk7XG5cdFx0XHRmZC5hcHBlbmQoYXR0cmlidXRlLCBtb2RlbCk7XG5cdFx0XHRyZXR1cm4gJGh0dHAucG9zdCh1cmwgKyAnLycgKyBhdHRyaWJ1dGUgKyAnLycsIGZkLCB7XG5cdFx0XHRcdHRyYW5zZm9ybVJlcXVlc3Q6IGFuZ3VsYXIuaWRlbnRpdHksXG5cdFx0XHRcdGhlYWRlcnM6IHsnQ29udGVudC1UeXBlJzogdW5kZWZpbmVkfVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGVsZXRlSW1hZ2UodXJsLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gJGh0dHAuZGVsZXRlKHVybCArICcvJyArIGF0dHJpYnV0ZSArICcvJyArIHZhbHVlLCB7XG5cdFx0XHRcdHRyYW5zZm9ybVJlcXVlc3Q6IGFuZ3VsYXIuaWRlbnRpdHksXG5cdFx0XHRcdGhlYWRlcnM6IHsnQ29udGVudC1UeXBlJzogdW5kZWZpbmVkfVxuXHRcdFx0fSk7XG5cblx0XHR9XG5cdH1cblx0YW5ndWxhci5tb2R1bGUoJ2d1bWdhLnNlcnZpY2VzLmJhc2UnLFtdKVxuXHQuc2VydmljZSgnR3VtZ2FCYXNlJyxCYXNlKTtcbn0pKCk7XG4iLCIiLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXHREYXRlU2VydmljZS4kaW5qZWN0ID0gW107XG5cdGZ1bmN0aW9uIERhdGVTZXJ2aWNlKCl7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGZvcm1hdHM6IHtcblx0XHRcdFx0RE1ZOiAvXihcXGR7MSwyfSlcXC0oXFxkezEsMn0pXFwtKFxcZHs0fSkkLyxcblx0XHRcdFx0WU1EOiAvXihcXGR7NH0pXFwtKFxcZHsxLDJ9KVxcLShcXGR7MSwyfSkkL1xuXHRcdFx0fSxcblx0XHRcdHZhbGlkYXRlRm9ybWF0OiBmdW5jdGlvbihmb3JtYXQsIGRhdGUpIHtcblx0XHRcdFx0aWYgKCF0aGlzLmZvcm1hdHMuaGFzT3duUHJvcGVydHkoZm9ybWF0KSkge1xuXHRcdFx0XHRcdHRocm93ICdGb3JtYXRvIG7Do28gc3Vwb3J0YWRvJztcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgcmVnZXggPSBuZXcgUmVnRXhwKHRoaXMuZm9ybWF0c1tmb3JtYXRdKTtcblx0XHRcdFx0aWYgKCFyZWdleC50ZXN0KGRhdGUpKSB7XG5cdFx0XHRcdFx0dGhyb3cgJ0EgZGF0YSAnICsgZGF0ZSArICcgbsOjbyBjb25mZXJlIGNvbSBvIGZvcm1hdG8gJyArIGZvcm1hdCArICcuJztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVnZXgudGVzdChkYXRlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0YW5ndWxhci5tb2R1bGUoJ2d1bWdhLnNlcnZpY2VzLmRhdGUnLFtdKVxuXHQuZmFjdG9yeSgnR3VtZ2FEYXRlU2VydmljZScsRGF0ZVNlcnZpY2UpO1xufSkoKTtcbiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cblx0S2V5Ym9hcmQuJGluamVjdCA9IFtdO1xuXHQvKipcblx0ICogQG5nZG9jIHNlcnZpY2Vcblx0ICogQG5hbWUgZ3VtZ2EuY29yZTpHdW1nYUtleWJvYXJkXG5cdCAqIEBkZXNjcmlwdGlvbiBcblx0ICogXHRBIGRpcmVjdGl2ZSBHdW1nYUtleWJvYXJkIMOpIHVtIFdyYXBwZXIgZGUgdW1hIGJpYmxpb3RlY2EgY2hhbWFkYSBbTW91c2V0cmFwXShodHRwczovL2NyYWlnLmlzL2tpbGxpbmcvbWljZSkgXG5cdCAqIFx0cXVlIMOpIHV0aWxpemFkYSBwYXJhIGFkaWNpb25hciBmdW5jaW9uYWxpZGFkZXMgcXVhbmRvIGRldGVybWluYWRhcyB0ZWNsYXMgc8OjbyBwcmVzc2lvbmFkYXMuXG5cdCAqXG5cdCAqIFx0IyBNw6l0b2Rvc1xuXHQgKlxuXHQgKiAgYEd1bWdhS2V5Ym9hcmQuYWRkQmluZChrZXksZnVuY3Rpb24sZXZlbnQpYFxuXHQgKiAgXG5cdCAqIFx0TyBtw6l0b2RvIGBhZGRCaW5kYCBhZGljaW9uYSB1bWEgZnVuw6fDo28gYSBjb21iaW5hw6fDo28gZGUgdGVjbGFzIHBhc3NhZGEgY29tbyBwYXLDom1ldHJvLiBFbGUgcmVjZWJlIHRyw6pzIHBhcsOibWV0cm9zLCBga2V5YCBlIGBmdW5jdGlvbmAgZSBgZXZlbnRgLlxuXHQgKiAgIyMjIFBhcsOibWV0cm9zXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5rZXk8L2xhYmVsPiBRdWFpcyB0ZWNsYXMgc2Vyw6NvIGNsaWNhZGFzIHBhcmEgcXVlIGEgZnVuw6fDo28gc2VqYSBleGVjdXRhZGEuXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5PYmplY3Q8L2xhYmVsPiA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+ZnVuY3Rpb248L2xhYmVsPiBGdW7Dp8OjbyBxdWUgc2Vyw6EgZXhlY3V0YWRhIHF1YW5kbyBzZXF1w6puY2lhIGRlIHRlY2xhcyBlc3BlY2lmaWNhZGFzIGZvciBkaWdpdGFkYSBwZWxvIHVzdcOhcmlvLlxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+ZXZlbnQ8L2xhYmVsPiBFbSBxdWFsIGV2ZW50byBkZSB0ZWNsYWRvIHNlcsOhIGRpc3BhcmFkbywgY29tbyBwb3IgZXhlbXBsbyBga2V5cHJlc3NgIG91YGtleWRvd25gXG5cdCAqICAjIyMgUmV0b3Jub1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCI+Qm9vbGVhbjwvbGFiZWw+IFJldG9uYSB1bSBib29sZWFuLiBTZSBvIGJpbmQgZm9pIGZlaXRvLCByZXRvcm5hIHRydWUsIGNhc28gYW8gY29udHLDoXJpbyByZXRvcm5hIGZhbHNlLlxuXHQgKiAgLS0tXG4gXHQgKiAgYEd1bWdhS2V5Ym9hcmQucmVtb3ZlQmluZChrZXkpYFxuXHQgKiAgXG5cdCAqIFx0TyBtw6l0b2RvIGByZW1vdmVCaW5kYCByZW1vdmUgYXMgZnVuw6fDtWVzIHF1ZSBlc3TDo28gYXRyaWJ1w61kYXMgYSBga2V5YCBxdWUgZm9pIHBhc3NhZGEgLiBFbGUgcmVjZWJlIHVtIHBhcsOibWV0cm8gYGtleWAuXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmtleTwvbGFiZWw+IFF1YWlzIHRlY2xhcyBxdWUgbyBkZXNlbnZvbHZlZG9yIGRlc2VqYSByZW1vdmVyIG8gYmluZC5cblx0ICogIFxuXHQgKiAgLS0tXG5cdCAqICBcbiBcdCAqICBgR3VtZ2FLZXlib2FyZC50cmlnZ2VyQm91bmRlZEV2ZW50KGtleSlgXG5cdCAqICBcblx0ICogXHRPIG3DqXRvZG8gYHRyaWdnZXJCb3VuZGVkRXZlbnRgIGRpc3BhcmEgbyBldmVudG8gYXRyaWJ1w61kbyBhIGBrZXlgIHF1ZSBmb2kgcGFzc2FkYS5cblx0ICogXHRcblx0ICogICMjI1BhcsOibWV0cm9zXG5cdCAqICBcblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmtleTwvbGFiZWw+IFF1YWlzIHRlY2xhcyBxdWUgbyBkZXNlbnZvbHZlZG9yIGRlc2VqYSByZW1vdmVyIG8gYmluZC5cblx0ICogIFxuXHQgKiAgLS0tXG5cdCAqXG5cdCAqIFx0YEd1bWdhS2V5Ym9hcmQuYmluZFRvRWxlbWVudChlbGVtZW50LGtleSxmdW5jdGlvbixldmVudClgXG4gXHQgKiAgXG5cdCAqIFx0TyBtw6l0b2RvIGBiaW5kVG9FbGVtZW50YCBhZGljaW9uYSB1bWEgZnVuw6fDo28gYSBjb21iaW5hw6fDo28gZGUgdGVjbGFzIHBhc3NhZGEgY29tbyBwYXLDom1ldHJvIGVtIHVtIGVsZW1lbnRvIGVzcGVjw61maWNvLiBFbGUgcmVjZWJlIHF1YXRybyBwYXLDom1ldHJvcyxgZWxlbWVudGAsIGBrZXlgIGUgYGZ1bmN0aW9uYCBlIGBldmVudGAuXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPkVsZW1lbnQ8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5lbGVtZW50PC9sYWJlbD4gRWxlbWVudG8gbm8gcXVhbCBhIHNlcXXDqm5jaWEgZGUgdGVjbGFzIGRldmUgc2VyIGV4ZWN1dGFkYSBwYXJhIGRpc3BhcmFyIG8gZXZlbnRvLlxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+a2V5PC9sYWJlbD4gUXVhaXMgdGVjbGFzIHNlcsOjbyBjbGljYWRhcyBwYXJhIHF1ZSBhIGZ1bsOnw6NvIHNlamEgZXhlY3V0YWRhLlxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+T2JqZWN0PC9sYWJlbD4gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmZ1bmN0aW9uPC9sYWJlbD4gRnVuw6fDo28gcXVlIHNlcsOhIGV4ZWN1dGFkYSBxdWFuZG8gc2VxdcOqbmNpYSBkZSB0ZWNsYXMgZXNwZWNpZmljYWRhcyBmb3IgZGlnaXRhZGEgcGVsbyB1c3XDoXJpby5cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmV2ZW50PC9sYWJlbD4gRW0gcXVhbCBldmVudG8gZGUgdGVjbGFkbyBzZXLDoSBkaXNwYXJhZG8sIGNvbW8gcG9yIGV4ZW1wbG8gYGtleXByZXNzYCBvdWBrZXlkb3duYFxuXHQgKiAgIyMjIFJldG9ybm9cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiPkJvb2xlYW48L2xhYmVsPiBSZXRvbmEgdW0gYm9vbGVhbi4gU2UgbyBiaW5kIGZvaSBmZWl0bywgcmV0b3JuYSB0cnVlLCBjYXNvIGFvIGNvbnRyw6FyaW8gcmV0b3JuYSBmYWxzZS5cblx0ICogIC0tLVxuXHQgKlxuIFx0ICogXHRgR3VtZ2FLZXlib2FyZC51bmJpbmRGcm9tRWxlbWVudChlbGVtZW50LGtleSlgXG4gXHQgKiAgXG5cdCAqIFx0TyBtw6l0b2RvIGB1bmJpbmRGcm9tRWxlbWVudGAgcmVtb3ZlIGFzIHRlY2xhcyBkbyBlbGVtZW50byBwYXNzYWRvIGNvbW8gcGFyw6JtZXRyby4gRWxlIHJlY2ViZSBkb2lzIHBhcsOibWV0cm9zLGBlbGVtZW50YCBlIGBrZXlgLlxuXHQgKiAgIyMjIFBhcsOibWV0cm9zXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5FbGVtZW50PC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+ZWxlbWVudDwvbGFiZWw+IEVsZW1lbnRvIG5vIHF1YWwgYSBzZXF1w6puY2lhIGRlIHRlY2xhcyB2YWkgc2VyIHJldGlyYWRhLlxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+a2V5PC9sYWJlbD4gUXVhaXMgdGVjbGFzIHNlcsOjbyByZW1vdmlkYXMgZG8gZWxlbWVudC5cblx0ICogIC0tLVxuXHQgKiAgXG5cdCAqIFx0YEd1bWdhS2V5Ym9hcmQuYmluZFRvTXVsdGlwbGVFbGVtZW50KGFycmF5LGtleSxmdW5jdGlvbixldmVudClgXG4gXHQgKiAgXG5cdCAqIFx0TyBtw6l0b2RvIGBiaW5kVG9FbGVtZW50YCBhZGljaW9uYSB1bWEgZnVuw6fDo28gYSBjb21iaW5hw6fDo28gZGUgdGVjbGFzIHBhc3NhZGEgY29tbyBwYXLDom1ldHJvIGVtIHVtIGVsZW1lbnRvIGVzcGVjw61maWNvLiBFbGUgcmVjZWJlIHF1YXRybyBwYXLDom1ldHJvcyxgZWxlbWVudGAsIGBrZXlgIGUgYGZ1bmN0aW9uYCBlIGBldmVudGAuXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPkFycmF5PC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+YXJyYXk8L2xhYmVsPiBMaXN0YSBkb3MgZWxlbWVudG9zIHF1ZSBzZXLDo28gYWRpY2lvbmFkb3MgYSBzZXF1w6puY2lhIGRlIHRlY2xhcy5cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmtleTwvbGFiZWw+IFF1YWlzIHRlY2xhcyBzZXLDo28gY2xpY2FkYXMgcGFyYSBxdWUgYSBmdW7Dp8OjbyBzZWphIGV4ZWN1dGFkYS5cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPk9iamVjdDwvbGFiZWw+IDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5mdW5jdGlvbjwvbGFiZWw+IEZ1bsOnw6NvIHF1ZSBzZXLDoSBleGVjdXRhZGEgcXVhbmRvIHNlcXXDqm5jaWEgZGUgdGVjbGFzIGVzcGVjaWZpY2FkYXMgZm9yIGRpZ2l0YWRhIHBlbG8gdXN1w6FyaW8uXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5ldmVudDwvbGFiZWw+IEVtIHF1YWwgZXZlbnRvIGRlIHRlY2xhZG8gc2Vyw6EgZGlzcGFyYWRvLCBjb21vIHBvciBleGVtcGxvIGBrZXlwcmVzc2Agb3Vga2V5ZG93bmBcblx0ICogICMjIyBSZXRvcm5vXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIj5Cb29sZWFuPC9sYWJlbD4gUmV0b25hIHVtIGJvb2xlYW4uIFNlIG8gYmluZCBmb2kgZmVpdG8sIHJldG9ybmEgdHJ1ZSwgY2FzbyBhbyBjb250csOhcmlvIHJldG9ybmEgZmFsc2UuXG5cdCAqICAtLS1cblx0ICpcbiBcdCAqIFx0YEd1bWdhS2V5Ym9hcmQuZ2V0QmluZHMoKWBcbiBcdCAqICBcblx0ICogXHRPIG3DqXRvZG8gYGdldEJpbmRzYCByZXRvcm5hIHRvZG9zIG9zIGJpbmRzIHF1ZSBmb3JhbSBhZGljaW9uYWRvcy5cblx0ICpcblx0ICogXG5cdCAqICAjIyMgUmV0b3Jub1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCI+QXJyYXk8L2xhYmVsPiBSZXRvcm5hIHVtYSBsaXN0YSBkZSB0b2RvcyBvcyBiaW5kcyBqw6EgZmVpdG9zLlxuXHQgKiAgXG5cdCAqICAtLS1cblx0ICovXG5cdGZ1bmN0aW9uIEtleWJvYXJkKCl7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGFkZEJpbmQ6IGZ1bmN0aW9uKGtleSxmbixldmVudCl7XG5cdFx0XHRcdGlmKGtleSAmJiBmbil7XG5cdFx0XHRcdFx0TW91c2V0cmFwLmJpbmQoa2V5LGZuLGV2ZW50PyBldmVudCA6ICcnKTtcblx0XHRcdFx0XHR0aGlzLl9fYmluZHMucHVzaChrZXkpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0scmVtb3ZlQmluZDogZnVuY3Rpb24oa2V5KXtcblx0XHRcdFx0aWYoa2V5KXtcblx0XHRcdFx0XHRNb3VzZXRyYXAudW5iaW5kKGtleSk7XG5cdFx0XHRcdFx0dGhpcy5fX2JpbmRzLnNwbGljZSh0aGlzLl9fYmluZHMuaW5kZXhPZihrZXkpLDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dHJpZ2dlckJvdW5kZWRFdmVudDogZnVuY3Rpb24oa2V5KXtcblx0XHRcdFx0aWYoa2V5KXtcblx0XHRcdFx0XHRNb3VzZXRyYXAudHJpZ2dlcihrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0YmluZFRvRWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCxrZXksZm4sZXZlbnQpe1xuXHRcdFx0XHRpZihlbGVtZW50ICYmIGtleSAmJiBmbil7XG5cdFx0XHRcdFx0TW91c2V0cmFwKGVsZW1lbnQpLmJpbmQoa2V5LGZuLGV2ZW50ID8gZXZlbnQ6ICcnKTtcblx0XHRcdFx0XHR0aGlzLl9fYmluZHMucHVzaChrZXkpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmRGcm9tRWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCxrZXkpe1xuXHRcdFx0XHRpZihlbGVtZW50ICYmIGtleSkge1xuXHRcdFx0XHRcdE1vdXNldHJhcChlbGVtZW50KS51bmJpbmQoa2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGJpbmRUb011bHRpcGxlRWxlbWVudHM6IGZ1bmN0aW9uKGFycmF5T2ZFbGVtZW50cyxrZXksZm4sZXZlbnQpe1xuXHRcdFx0XHRmb3IodmFyIGkgPSAwLCBsZW4gPSBhcnJheU9mRWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIGlmKGtleSAmJiBmbil7XG5cdFx0XHRcdFx0TW91c2V0cmFwKGFycmF5T2ZFbGVtZW50c1tpXSkuYmluZChrZXksZm4sZXZlbnQ/IGV2ZW50OiAnJyk7XG5cdFx0XHRcdFx0dGhpcy5fX2JpbmRzLnB1c2goa2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGdldEJpbmRzOiBmdW5jdGlvbigpe1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fX2JpbmRzO1xuXHRcdFx0fSxcblx0XHRcdF9fYmluZHM6IFtdXG5cdFx0fVxuXHR9XG5cdGFuZ3VsYXIubW9kdWxlKCdndW1nYS5zZXJ2aWNlcy5rZXlib2FyZCcsW10pXG5cdFx0LmZhY3RvcnkoJ0d1bWdhS2V5Ym9hcmQnLEtleWJvYXJkKTtcbn0pKCk7IiwiKGZ1bmN0aW9uKCl7XG5cbiAgZnVuY3Rpb24gTGlzdEhlbHBlcigpe1xuICAgIHJldHVybiB7XG4gICAgICAnYXV4JzogW10sXG4gICAgICAncmV0dXJuQ29sdW1uQ29uZmlnJzogZnVuY3Rpb24oaXRlbSxjb25maWcpe1xuICAgICAgICB2YXIgaXRlbUNvbmZpZyA9IGNvbmZpZy5maWx0ZXIoZnVuY3Rpb24odmFsKXsgcmV0dXJuIHZhbC5uYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpID09IGl0ZW0udG9Mb3dlckNhc2UoKS50cmltKCl9KVswXSB8fCB7fTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0aXRsZTogaXRlbUNvbmZpZy50aXRsZSB8fCBpdGVtLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgc2l6ZTogaXRlbUNvbmZpZy5zaXplIHx8ICcnLFxuICAgICAgICAgIG5hbWU6IGl0ZW1Db25maWcubmFtZSB8fCBpdGVtLFxuICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudFdpdGhvdXRQYXJlbnQoaXRlbUNvbmZpZy5jb250ZW50LGl0ZW0pLFxuICAgICAgICAgIHNvcnRGaWVsZDogaXRlbUNvbmZpZy5zb3J0RmllbGQgfHwgbnVsbCxcbiAgICAgICAgICBjb25kaXRpb25hbDogaXRlbUNvbmZpZy5jb25kaXRpb25hbCB8fCBhbmd1bGFyLm5vb3BcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICdjb250ZW50V2l0aG91dFBhcmVudCc6ZnVuY3Rpb24oY29udGVudCxpdGVtKXtcbiAgICAgICAgaWYoY29udGVudCAmJiBjb250ZW50LmluZGV4T2YoJ3R5cGU9XCJidXR0b25cIicpICE9IC0xICYmIGNvbnRlbnQuaW5kZXhPZignbmctY2xpY2s9XCInKSAhPSAtMSl7XG4gICAgICAgICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZSgvbmctY2xpY2s9XCIvZ2ksJ25nLWNsaWNrPVwiJHBhcmVudC4kcGFyZW50LicpOztcbiAgICAgICAgfVxuICAgICAgICBpZihjb250ZW50KXtcbiAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ3t7JHZhbHVlLicraXRlbSsnfX0nO1xuICAgICAgfSxcbiAgICAgICdlbnN1cmVEZWZhdWx0VmFsdWVzJzogZnVuY3Rpb24oYXJyLGNvbmZpZyl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24oaXRlbSwkaW5kZXgpe1xuICAgICAgICAgIHJldHVybiBzZWxmLnJldHVybkNvbHVtbkNvbmZpZyhpdGVtLGNvbmZpZyk7XG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgJ2xvYWREZWZhdWx0Q29sdW1ucyc6IGZ1bmN0aW9uKGZpcnN0T2JqZWN0KXtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGZpcnN0T2JqZWN0KS5tYXAoZnVuY3Rpb24oa2V5LCRpbmRleCl7XG4gICAgICAgICAgaWYoa2V5ICE9ICdfX2NoZWNrZWQnKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHRpdGxlOiBrZXkudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgc2l6ZTogJycsXG4gICAgICAgICAgICAgIG5hbWU6ICdrZXknLFxuICAgICAgICAgICAgICBjb250ZW50OiAne3skdmFsdWUuJyArIGtleSArICd9fScsXG4gICAgICAgICAgICAgIHNvcnRGaWVsZDogbnVsbCxcbiAgICAgICAgICAgICAgY29uZGl0aW9uYWw6IGFuZ3VsYXIubm9vcFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICAnc29ydENvbHVtbnMnOiBmdW5jdGlvbihhdXgsY29sdW1ucyl7XG4gICAgICAgIHJldHVybiBjb2x1bW5zLnNvcnQoZnVuY3Rpb24odmFsdWUxLHZhbHVlMil7XG4gICAgICAgICAgKGF1eC5pbmRleE9mKHZhbHVlMS5uYW1lKSAtIGF1eC5pbmRleE9mKHZhbHVlMi5uYW1lKSlcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICAnYWRkQ2hlY2tib3gnOiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRpdGxlOiAnPGxhYmVsPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cInZtLmNoZWNrQWxsXCIgbmctY2hhbmdlPVwidm0uc2VsZWN0QWxsKHZtLmNoZWNrQWxsKVwiLz48c3Ryb25nID48c21hbGw+U2VsZWNpb25hciBUb2Rvczwvc21hbGw+PC9zdHJvbmc+PC9sYWJlbD4nLFxuICAgICAgICAgIHNpemU6ICdjb2wtbWQtMScsXG4gICAgICAgICAgbmFtZTonX19jaGVja2JveCcsXG4gICAgICAgICAgY29udGVudDogJzxpbnB1dCBuYW1lPVwiX19jaGVja2JveFwiIHR5cGU9XCJjaGVja2JveFwiIG5nLW1vZGVsPVwiJHZhbHVlLl9fY2hlY2tlZFwiLz4nLFxuICAgICAgICAgIHNvcnRGaWVsZDogbnVsbCxcbiAgICAgICAgICBjb25kaXRpb25hbDogYW5ndWxhci5ub29wXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgJ21vdW50VGFibGUnOmZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGZ1bmN0aW9uIHJldHVybkZvcm1hdHRhYmxlR2x5cGhpY29uKHN0cmluZyl7XG4gICAgICAgICAgcmV0dXJuICc8aSBuZy1jbGFzcz1cInZtLnNlbGVjdGVkSXRlbSA9PSBcXCcnICsgc3RyaW5nICsnXFwnID8gKHZtLnNlbGVjdGVkSXRlbURpciA9PSBcXCdhc2NcXCcgPyBcXCdnbHlwaGljb24gZ2x5cGhpY29uLW1lbnUtdXBcXCcgOiBcXCdnbHlwaGljb24gZ2x5cGhpY29uLW1lbnUtZG93blxcJyApOiBcXCdcXCdcIj48L2k+JztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXR1cm5Gb3JtYXR0YWJsZVRhYmxlSGVhZGVyKGJvb2wsc3RyaW5nLHNmKXtcbiAgICAgICAgICBpZihib29sKXtcbiAgICAgICAgICAgIHJldHVybiAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCIgYnRuIGJ0bi1saW5rIGJ0bi1zbVwiIG5nLWNsaWNrPVwidm0uc29ydFByb3h5KFxcJycrIHNmICsnXFwnLCcgKyAnXFwnJy5jb25jYXQoc2YpLmNvbmNhdCgnXFwnJykgKycpXCI+JyArIHN0cmluZyArIHJldHVybkZvcm1hdHRhYmxlR2x5cGhpY29uKHNmKSArICc8L2J1dHRvbj4nO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1vdW50SGVhZGVyKHByZXYsIG5leHQpe1xuICAgICAgICAgIHJldHVybiBwcmV2Kz0gJ1xcdFxcdDx0ZCBjbGFzcz1cIicrIG5leHQuc2l6ZSArJ1wiID4nICsgcmV0dXJuRm9ybWF0dGFibGVUYWJsZUhlYWRlcighIW5leHQuc29ydEZpZWxkLG5leHQudGl0bGUsbmV4dC5zb3J0RmllbGQpICsgJzwvdGQ+XFxuJztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtb3VudEFsbFRhYmxlQ2VsbChwcmV2LG5leHQpe1xuICAgICAgICAgIHJldHVybiBwcmV2ICs9ICc8dGQgbmctc3R5bGU9XCJ7Ym9yZGVyTGVmdDoge3s6OnZtLmNvbmRpdGlvbmFsVGFibGVDZWxsKCR2YWx1ZSxcXCcnKyBuZXh0Lm5hbWUgKydcXCcpfX0gfVwiPicgKyBuZXh0LmNvbnRlbnQgKyc8L3RkPic7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWd1cmF0aW9uLmNvbHVtbnMudW5zaGlmdCh0aGlzLmFkZENoZWNrYm94KCkpO1xuICAgICAgICBjb25maWd1cmF0aW9uLmNvbHVtbnMgPSB0aGlzLnNvcnRDb2x1bW5zKGNvbmZpZ3VyYXRpb24uYXV4Q29sdW1uc1RvU29ydCwgY29uZmlndXJhdGlvbi5jb2x1bW5zKTtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAnPHNlbGVjdCBuZy1vcHRpb25zPVwiaXRlbSBmb3IgaXRlbSBpbiB2bS5jb25maWcuaXRlbXNQZXJQYWdlXCIgbmctbW9kZWw9XCJ2bS4kcGFyZW50Lml0ZW1zUGVyUGFnZVwiPjwvc2VsZWN0Pic7XG4gICAgICAgIG1lc3NhZ2UgKz0gJzx0YWJsZSBjbGFzcz1cIicrIGNvbmZpZ3VyYXRpb24uY2xhc3MgKydcIj5cXG4nO1xuICAgICAgICBtZXNzYWdlICs9ICc8dGhlYWQ+JztcbiAgICAgICAgbWVzc2FnZSArPSAnXFx0PHRyPlxcbic7XG4gICAgICAgIG1lc3NhZ2UgPSBjb25maWd1cmF0aW9uLmNvbHVtbnMucmVkdWNlKG1vdW50SGVhZGVyLmJpbmQodGhpcyksbWVzc2FnZSk7XG4gICAgICAgIG1lc3NhZ2UgKz0gJ1xcdDwvdHI+XFxuJztcbiAgICAgICAgbWVzc2FnZSArPSAnPC90aGVhZD4nO1xuICAgICAgICBtZXNzYWdlICs9ICc8dGJvZHk+JztcbiAgICAgICAgbWVzc2FnZSArPSAnPHRyIG5nLXN0eWxlPVwie2JvcmRlckxlZnQ6IHt7Ojp2bS5jb25kaXRpb25hbCgkdmFsdWUpfX0gfVwiICBuZy1kYmxjbGljaz1cInZtLmRvdWJsZSgkdmFsdWUpXCIgbmctY2xhc3M9XCIkdmFsdWUuX19jaGVja2VkID8gXFwnYWN0aXZlXFwnIDogXFwnXFwnXCIgbmctcmVwZWF0PVwiJHZhbHVlIGluIHZtLmRhdGEgdHJhY2sgYnkgJGluZGV4XCIgbmctY2xpY2s9XCJ2bS5zZWxlY3RSb3coJGluZGV4LCR2YWx1ZSwkZXZlbnQpXCIgPic7XG4gICAgICAgIG1lc3NhZ2UgKz0gY29uZmlndXJhdGlvbi5jb2x1bW5zLnJlZHVjZShtb3VudEFsbFRhYmxlQ2VsbCwnJyk7XG4gICAgICAgIG1lc3NhZ2UgKz0gJzwvdHI+JztcbiAgICAgICAgbWVzc2FnZSArPSAnPC90Ym9keT4nO1xuICAgICAgICBtZXNzYWdlICs9ICc8L3RhYmxlPlxcbic7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFuZ3VsYXIubW9kdWxlKCdndW1nYS5zZXJ2aWNlcy5saXN0aGVscGVyJyxbXSlcbiAgLmZhY3RvcnkoJ0d1bWdhTGlzdEhlbHBlcicsTGlzdEhlbHBlcik7XG5cbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdE5vdGlmaWNhdGlvbi4kaW5qZWN0ID0gW1wiJGh0dHBcIiwgXCIkcVwiXTtcblx0LyoqXG5cdCAqIEBuZ2RvYyBzZXJ2aWNlXG5cdCAqIEBuYW1lIGd1bWdhLmNvcmU6R3VtZ2FOb3RpZmljYXRpb25cblx0ICogQGRlc2NyaXB0aW9uXG5cdCAqL1xuXHRmdW5jdGlvbiBOb3RpZmljYXRpb24oJGh0dHAsJHEpe1xuXHRcdHZhciB0b2tlbiA9IHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpO1xuXHRcdHZhciB1cmwgPSAnaHR0cDovLzE5Mi4xNjguMjUuMjAxOjgwODQvc2VjdXJpdHktYXBpL25vdGlmaWNhdGlvbnMnO1xuXHRcdHZhciBldmVudFNvdXJjZTtcblxuXHRcdHRoaXMuZ2V0U291cmNlID0gZ2V0U291cmNlO1xuXHRcdHRoaXMubmV3TWVzc2FnZXMgPSBuZXdNZXNzYWdlcztcblx0XHR0aGlzLm5ld01lc3NhZ2VzQ291bnQgPSBuZXdNZXNzYWdlc0NvdW50O1xuXHRcdHRoaXMuaXNWaWV3ZWRNZXNzYWdlID0gaXNWaWV3ZWRNZXNzYWdlO1xuXG5cdFx0ZnVuY3Rpb24gc2V0VXJsKHVybCkge1xuXHRcdFx0dXJsID0gdXJsO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBzZXRUb2tlbih0b2tlbikge1xuXHRcdFx0dG9rZW4gPSB0b2tlbjtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gZ2V0U291cmNlKCkge1xuXHRcdFx0aWYgKCF0b2tlbikgdGhyb3cgXCJJbmZvcm1lIHVtIHRva2VuLlwiO1xuXHRcdFx0cmV0dXJuIG5ldyBFdmVudFNvdXJjZSh1cmwuY29uY2F0KCcvc291cmNlP2d1bWdhVG9rZW49JyArIHRva2VuKSk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIG5ld01lc3NhZ2VzKCkge1xuXHRcdFx0Z2V0U291cmNlKCkuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdHZhciBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcblx0XHRcdFx0Y29uc29sZS5sb2coZGF0YS5uZXdNZXNzYWdlcyk7XG5cdFx0XHRcdHJldHVybiBkYXRhLm5ld01lc3NhZ2VzO1xuXHRcdFx0fSwgZmFsc2UpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBuZXdNZXNzYWdlc0NvdW50KCkge1xuXHRcdFx0Z2V0U291cmNlKCkuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdHZhciBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcblx0XHRcdFx0Y29uc29sZS5sb2coZGF0YS5uZXdNZXNzYWdlc0NvdW50KTtcblx0XHRcdFx0cmV0dXJuIGRhdGEubmV3TWVzc2FnZXNDb3VudDtcblx0XHRcdH0sIGZhbHNlKTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gaXNWaWV3ZWRNZXNzYWdlKGlkKSB7XG5cdFx0XHRpZiAoIXRva2VuKSB0aHJvdyBcIkluZm9ybWUgdW0gdG9rZW4uXCI7XG5cdFx0XHRyZXR1cm4gJGh0dHAuZ2V0KHVybC5jb25jYXQoJy92aWV3ZWQvP2lkPScgKyBpZCArICcmZ3VtZ2FUb2tlbj0nICsgdG9rZW4pKTtcblx0XHR9XG5cdH1cblx0YW5ndWxhci5tb2R1bGUoJ2d1bWdhLnNlcnZpY2VzLm5vdGlmaWNhdGlvbicsW10pXG5cdC5zZXJ2aWNlKCdHdW1nYU5vdGlmaWNhdGlvbicsTm90aWZpY2F0aW9uKTtcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdFBvcHVsYXRlLiRpbmplY3QgPSBbXTtcblx0LyoqXG5cdCAqIEBuZ2RvYyBzZXJ2aWNlXG5cdCAqIEBuYW1lIGd1bWdhLmNvcmU6JHBvcHVsYXRlUHJvdmlkZXJcblx0ICogQGRlc2NyaXB0aW9uIE8gc2VydmljZSAqKiRwb3B1bGF0ZSoqIMOpIHV0aWxpemFkbyBwYXJhIGFkaWNpb25hciBmdW7Dp8O1ZXMgYsOhc2ljYXMgZGUgQ1JVRCwgcXVlIGrDoSBmYXplbSBhIGNvbmV4w6NvIGNvbSBvIFNlcnZpY2Vcblx0ICogICgqTWVsaG9yIHV0aWxpemFkbyBjb20gbyBzZXJ2aWNlIEd1bWdhUmVzdCopLCBwb3NzaWJpbGl0YW5kbyBhc3NpbSBxdWUgbyAkc2NvcGUgZmlxdWUgbGltcG8uIMOJIHBvc3PDrXZlbCB0YW1iw6ltIGNyaWFyIHVtYSBjb25maWd1cmHDp8Ojb1xuXHQgKiAgbm92YSBwYXJhIHNlciB1dGlsaXphZGEsIGV4dGVuZGVyIGFzIGrDoSBjcmlhZGFzIGUgcmVjdXBlcmFyIG8gb2JqZXRvIGRlIGNvbnRyb2xlIGRhIGNvbmZpZ3VyYcOnw6NvLlxuXHQgKlxuXHQgKiBcdEFzIGZ1bsOnw7VlcyBjcmlhbSB1bSBvYmpldG8gY29tIG8gbm9tZSBkbyBJRCBwYXNzYWRvIHBhcmEgYXJtYXplbmFyIG9zIGRhZG9zLiBBbMOpbSBkaXNzbywgbyBpZGVudGlmaWNhZG9yIMOpIHV0aWxpemFkbyBwYXJhIG5vbWVhciBhcyBmdW7Dp8O1ZXMuIENhc28gbyBJZGVudGlmaWNhZG9yXG5cdCAqIFx0cGFzc2FkbyBzZWphIGBVc2VyYCBlIGEgZnVuw6fDo28gc2VqYSBgZ2V0YCwgbyBub21lIGRhIGZ1bsOnw6NvIHNlcsOhIGB1c2VyR2V0YCwgcGFyYSBldml0YXIgY29saXPDo28gZGUgbm9tZXMuXG5cdCAqIFx0VG9kYXMgYXMgZnVuw6fDtWVzIHBvc3N1ZW0gZXZlbnRvcyBxdWUgc8OjbyBkaXNwYXJhZG9zIGFudGVzIGUgZGVwb2lzIGRhIGV4ZWN1w6fDo28gZGEgZnVuw6fDo28sIHBhcmEgYWp1ZGFyIG8gZGVzZW52b2x2ZWRvciBhIGV4dGVuZGVyIGFzIGZ1bmNpb25hbGlkYWRlc1xuXHQgKiBcdGRhcyBmdW7Dp8O1ZXMgc2VtIHByZWNpc2FyIHNvYnJlc2NyZXZlci1sYXMuIFBhcmEgdXRpbGl6YXIgZXN0ZXMgZXZlbnRvcywgYmFzdGEgYWRpY2lvbmFyIHVtIGxpc3RlbmVyIG5vICRzY29wZSwgY29tbyBwb3IgZXhlbXBsbzpcblx0ICogIDxwcmU+XG5cdCAqICBcdCRzY29wZS4kb24oJ2JlZm9yZUdldCcsZnVuY3Rpb24oKXtcblx0ICogICAgYWxlcnQoJ0FudGVzIGRvIEdldCEnKTtcblx0ICogIFx0fSlcblx0ICpcblx0ICogXHRcdCRzY29wZS4kb24oJ2FmdGVyR2V0JyxmdW5jdGlvbih2YWx1ZXMpe1xuXHQgKlx0XHQgIC8vIHZhbHVlcyDDqSByZXRvcm5vIGRhIGZ1bsOnw6NvIGFzw61uY3JvbmEuXG5cdCAqIFx0XHR9KVxuXHQgKiBcdDwvcHJlPlxuXHQgKlxuXHQgKlxuXHQgKiAjIENvbW8gdXRpbGl6YXI6XG5cdCAqXG5cdCAqIFx0UGFyYSB1dGlsaXphciBvIGFzc2lzdGVudGUsIMOpIG5lY2Vzc8OhcmlvIGluamV0YXIgY29tbyBkZXBlbmTDqm5jaWEgbm8gYmxvY28gZGUgY29uZmlndXJhw6fDo28gZG8gbcOzZHVsbzpcblx0ICogXHQ8cHJlPlxuXHQgKiAgXHRhbmd1bGFyLm1vZHVsZSgnc2FtcGxlJyxbJ2d1bWdhLmNvcmUnXSlcblx0ICogIFx0LmNvbmZpZyhmdW5jdGlvbigkcG9wdWxhdGVQcm92aWRlcil7XG5cdCAqICAgICAkc3RhdGVQcm92aWRlclxuICAgKiAgIFx0IC5zdGF0ZSgnY3J1ZC5saXN0Jywge1xuICAgKiAgICAgIHVybDogJy9saXN0Jyxcblx0ICogICAgICB0ZW1wbGF0ZVVybDogJ2FwcC9tb2R1bGVzL2NydWQvdmlld3MvbGlzdC5odG1sJyxcblx0ICogICAgICBjb250cm9sbGVyOiAnQ3J1ZENvbnRyb2xsZXInLFxuICAgKiAgICAgIHJlc29sdmU6ICB7XG4gICAqICAgICAgIHBvcHVsYXRlU2NvcGU6IGZ1bmN0aW9uKCl7XG4gICAqICAgICAgICByZXR1cm4gJHBvcHVsYXRlUHJvdmlkZXIucG9wdWxhdGVTY29wZTtcbiAgICogICAgICAgfVxuICAgKiAgICAgfVxuICAgKiAgIH0pXG5cdCAqICAgfSlcblx0ICogIDwvcHJlPlxuXHQgKlxuXHQgKiBcdEUgZGVwb2lzIG5vIGNvbnRyb2xsZXIsIHV0aWxpemFyIGVsZSBleGVjdXRhbmRvIGEgZnVuw6fDo28gcG9wdWxhdGVTY29wZSBxdWUgZm9pIHBhc3NhZGEgYXRyYXbDqXMgZG8gcmVzb2x2ZTpcblx0ICogXHQ8cHJlPlxuXHQgKiBcdFx0YW5ndWxhci5tb2R1bGUoJ3NhbXBsZScpXG5cdCAqIFx0XHQuY29udHJvbGxlcignU2FtcGxlQ29udHJvbGxlcicsXG5cdCAqIFx0ICAgWyckc2NvcGUnLCdwb3B1bGF0ZVNjb3BlJywnVXNlclNlcnZpY2UnLGZ1bmN0aW9uKCRzY29wZSxwb3B1bGF0ZVNjb3BlLFVzZXJTZXJ2aWNlKXtcblx0ICogXHRcdCAgIHBvcHVsYXRlU2NvcGUoJHNjb3BlLFVzZXJTZXJ2aWNlLCdVc2VyJywnYmFzZS1saXN0Jyk7XG5cdCAqIFx0ICAgfV0pXG5cdCAqIFx0PC9wcmU+XG5cdCAqXG5cdCAqIFx0UG9kZS1zZSBvcHRhciB0YW1iw6ltIHBvciBuw6NvIGluY2x1aXIgbm8gbcOzZHVsbyBkZSBjb25maWd1cmHDp8OjbywgbWFzIGRpcmV0byBubyBjb250cm9sbGVyOlxuXHQgKiBcdDxwcmU+XG5cdCAqIFx0XHRhbmd1bGFyLm1vZHVsZSgnc2FtcGxlJylcblx0ICogXHRcdC5jb250cm9sbGVyKCdTYW1wbGVDb250cm9sbGVyJyxcblx0ICogXHQgICBbJyRzY29wZScsJyRwb3B1bGF0ZScsJ1VzZXJTZXJ2aWNlJyxmdW5jdGlvbigkc2NvcGUsJHBvcHVsYXRlLFVzZXJTZXJ2aWNlKXtcblx0ICogXHRcdCAgICRwb3B1bGF0ZS5wb3B1bGF0ZVNjb3BlKCRzY29wZSxVc2VyU2VydmljZSwnVXNlcicsJ2Jhc2UtbGlzdCcpO1xuXHQgKiBcdCAgIH1dKVxuXHQgKiBcdDwvcHJlPlxuXHQgKlxuXHQgKiAjIENvbmZpZ3VyYcOnw7Vlczpcblx0ICpcblx0ICogXHQtIGBiYXNlLWxpc3RgOiBBIGNvbmZpZ3VyYcOnw6NvIGBiYXNlLWxpc3RgIHNlcnZlIHBhcmEgaW5jbHVpciBmdW7Dp8O1ZXMgZ2VyYWlzIHF1ZSBzw6NvIG5lY2Vzc8OhcmlhcyBlbSBww6FnaW5hcyBkZSBsaXN0YWdlbSwgcXVlIHPDo286XG5cdCAqIFx0XHQtIGBnZXRgXG5cdCAqIFx0XHQtIGByZXNldEFuZEdldGBcblx0ICogXHRcdC0gYGdldEJ5SWRgXG5cdCAqIFx0XHQtIGB1cGRhdGVgXG5cdCAqIFx0XHQtIGBzYXZlUXVlcnlgXG5cdCAqIFx0XHQtIGBnZXRRdWVyeWBcblx0ICogXHRcdC0gYGRlbGV0ZWBcblx0ICpcblx0ICogICAgLSBgc29ydGBcblx0ICogICAgLSBgc2VhcmNoYFxuXHQgKiAgICAtIGBhZHZhbmNlZFNlYXJjaGBcblx0ICpcblx0ICpcblx0ICogXHQtIGBiYXNlLWZvcm1gOiBBIGNvbmZpZ3VyYcOnw6NvIGBiYXNlLWZvcm1gIHNlcnZlIHBhcmEgaW5jbHVpciBmdW7Dp8O1ZXMgZ2VyYWlzIHF1ZSBzw6NvIG5lY2Vzc8OhcmlhcyBlbSBww6FnaW5hcyBkZSBmb3JtdWzDoXJpbywgcXVlIHPDo286XG5cdCAqIFx0XHQtIGBnZXROZXdgXG5cdCAqIFx0XHQtIGBnZXRCeUlkYFxuXHQgKiBcdFx0LSBgc2F2ZWBcblx0ICogXHRcdC0gYHVwZGF0ZWBcblx0ICogXHRcdC0gYHNhdmVJbWFnZWBcblx0ICpcblx0ICogICAgLSBgZGVsZXRlSW1hZ2VgXG5cdCAqXG5cdCAqXG5cdCAqIFx0LSBgbWFueS10by1tYW55YDogQSBjb25maWd1cmHDp8OjbyBgbWFueS10by1tYW55YCBzZXJ2ZSBwYXJhIGluY2x1aXIgZnVuw6fDtWVzIHF1ZSBjb211bWVudGUgc8OjbyB1dGlsaXphZGFzIGVtIHJlbGHDp8O1ZXMgbXVpdG9zIHBhcmEgbXVpdG9zLCBxdWUgc8Ojbzpcblx0ICogXHRcdC0gYHNlYXJjaGBcblx0ICogXHRcdC0gYHNhdmVgXG5cdCAqIFx0XHQtIGBzZWFyY2hBc3luY2Bcblx0ICogXHRcdC0gYHNhdmVBc3luY2Bcblx0ICpcblx0ICogXHQtIGBtYW55LXRvLW9uZWA6IEEgY29uZmlndXJhw6fDo28gYG1hbnktdG8tb25lYCBzZXJ2ZSBwYXJhIGluY2x1aXIgZnVuw6fDtWVzIHF1ZSBjb211bWVudGUgc8OjbyB1dGlsaXphZGFzIGVtIHJlbGHDp8O1ZXMgbXVpdG9zIHBhcmEgdW0sIHF1ZSBzw6NvOlxuXHQgKiBcdFx0LSBgc2VhcmNoYFxuXHQgKiBcdFx0LSBgc2F2ZWBcblx0ICogXHRcdC0gYHNhdmVBc3luY2Bcblx0ICpcblx0ICpcdCMjIEltcGxlbWVudGHDp8O1ZXM6XG5cdCAqXHRcdFBhcmEgdmVyIGFzIGltcGxlbWVudGHDp8O1ZXMgZGFzIGZ1bsOnw7VlcyBhY2ltYSwgY2xpcXVlIFthcXVpXSgpLlxuXHQgKlxuXHQgKlx0IyBNw6l0b2Rvc1xuXHQgKiAgYCRwb3B1bGF0ZS5zZXRDb25maWcobmFtZSx2YWx1ZSlgXG5cdCAqXG5cdCAqICBPIG3DqXRvZG8gc2V0Q29uZmlnIGFjZWl0YSBkb2lzIHBhcsOibWV0cm9zIGBuYW1lYCBlIGB2YWx1ZWAsIG8gbm9tZSBkYSBjb25maWd1cmHDp8OjbyBlIG8gb2JqZXRvIHF1ZSBpcsOhIGZhemVyIGEgY29uZmlndXJhw6fDo28uXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPm5hbWU8L2xhYmVsPiBTdHJpbmcgcXVlIHNlcsOhIHVzYWRhIHBhcmEgaWRlbnRpZmljYXIgbyBvYmpldG8gcXVlIHNlcsOhIGNyaWFkby5cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPk9iamVjdDwvbGFiZWw+IDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj52YWx1ZTwvbGFiZWw+IE9iamV0byBkZSBjb25maWd1cmHDp8OjbyBxdWUgc2Vyw6EgdXNhZG8uXG5cdCAqICAgUGFyYSBhZGljaW9uYXIgYSBmdW7Dp8OjbywgY29sb3F1ZSBvIG5vbWUgZGEgZnVuw6fDo28gZSBvIHZhbG9yIGRlbGUgY29tbyBgdHJ1ZWBcblx0ICpcblx0ICogIC0tLVxuXHQgKlxuXHQgKiAgYCRwb3B1bGF0ZS5nZXRDb25maWcobmFtZSlgXG5cdCAqXG5cdCAqICBPIG3DqXRvZG8gZ2V0Q29uZmlnIGFjZWl0YSB1bSBwYXLDom1ldHJvIGBuYW1lYCwgcXVlIMOpIG8gbm9tZSBkYSBjb25maWd1cmHDp8OjbyBkZXNlamFkYS5cblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+bmFtZTwvbGFiZWw+IFN0cmluZyBxdWUgc2Vyw6EgdXNhZGEgcGFyYSBpZGVudGlmaWNhciBvIG9iamV0byBxdWUgc2Vyw6EgcmVjdXBlcmFkby5cblx0ICogICBQYXJhIGFkaWNpb25hciBhIGZ1bsOnw6NvLCBjb2xvcXVlIG8gbm9tZSBkYSBmdW7Dp8OjbyBlIG8gdmFsb3IgZGVsZSBjb21vIGB0cnVlYFxuXHQgKlxuXHQgKiBcdCMjIyBSZXRvcm5vXG5cdCAqXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5PYmplY3Q8L2xhYmVsPiBDb25maWd1cmHDp8OjbyBxdWUgc2Vyw6EgcmVjdXBlcmFkYSBkYSBmdW7Dp8Ojby5cblx0ICpcblx0ICpcblx0ICogIC0tLVxuXHQgKlxuXHQgKiAgYCRwb3B1bGF0ZS5zZXRNZXRob2QobmFtZSxjb25maWcsZnVuY3Rpb24pYFxuXHQgKlxuXHQgKiAgTyBtw6l0b2RvIHNldE1ldGhvZCBhY2VpdGEgdHLDqnMgcGFyw6JtZXRyb3M6IGBuYW1lYCxgY29uZmlnYCwgYGZ1bmN0aW9uYC4gRXN0ZSBtw6l0b2RvIMOpIHV0aWxpemFkbyBwYXJhIGV4dGVuZGVyIGFzIGZ1bmNpb25hbGlkYWRlcyBkZSB1bWEgY29uZmlndXJhw6fDo28uXG5cdCAqXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPm5hbWU8L2xhYmVsPiBTdHJpbmcgcXVlIHNlcsOhIHVzYWRhIHBhcmEgaWRlbnRpZmljYXIgY29tbyBzZXLDoSBvIG5vbWUgZGEgZnVuw6fDo28gYSBzZXIgYWRpY2lvbmFkYS5cblx0ICogICBQYXJhIGFkaWNpb25hciBhIGZ1bsOnw6NvLCBjb2xvcXVlIG8gbm9tZSBkYSBmdW7Dp8OjbyBlIG8gdmFsb3IgZGVsZSBjb21vIGB0cnVlYFxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+Y29uZmlnPC9sYWJlbD4gU3RyaW5nIHF1ZSBzZXLDoSB1c2FkYSBwYXJhIGlkZW50aWZpY2FyIHF1YWwgb2JqZXRvIGRlIGNvbmZpZ3VyYcOnw6NvIGVzdGEgZnVuw6fDo28gc2Vyw6EgYWRpY2lvbmFkYS5cblx0ICogICBQYXJhIGFkaWNpb25hciBhIGZ1bsOnw6NvLCBjb2xvcXVlIG8gbm9tZSBkYSBmdW7Dp8OjbyBlIG8gdmFsb3IgZGVsZSBjb21vIGB0cnVlYFxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+RnVuY3Rpb248L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5mdW5jdGlvbjwvbGFiZWw+IEZ1bsOnw6NvIHF1ZSBzZXLDoSBhZGljaW9uYWRhIGFvICRzY29wZS4gKkFvIHBhc3NhciBhIGZ1bsOnw6NvLCBvIGRlc2Vudm9sdmVkb3Jcblx0ICogIHRlbSBhY2Vzc28gYSA0IHBhcsOibWV0cm9zIHF1ZSBzZXLDo28gdXRpbGl6YWRvcyBwYXJhIGRlZmluaXIgYSBmdW7Dp8OjbyBubyBzY29wZTogYFNjb3BlYCwgYFNlcnZpY2VgLGBJZGAqLlxuXHQgKlxuXHQgKiAgLS0tXG5cdCAqXG4gXHQgKlxuXHQgKiAgYCRwb3B1bGF0ZS5wb3B1bGF0ZVNjb3BlKHNjb3BlLHNlcnZpY2UsaWQsY29uZmlnKWBcblx0ICpcblx0ICogIE8gbcOpdG9kbyBwb3B1bGF0ZVNjb3BlIGFjZWl0YSBxdWF0cm8gcGFyw6JtZXRyb3M6IGBzY29wZWAsYHNlcnZpY2VgLCBgaWRgIGUgYGNvbmZpZ2AuIEVzdGUgbcOpdG9kbyDDqSB1dGlsaXphZG8gcGFyYSBwb3B1bGFyIG8gJHNjb3BlIGRvIGNvbnRyb2xhZG9yIGNvbSBhcyBmdW7Dp8O1ZXMgZGEgY29uZmlndXJhw6fDo28uXG5cdCAqXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPk9iamVjdDwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPnNjb3BlPC9sYWJlbD4gT2JqZXRvIG9uZGUgYXMgZnVuw6fDtWVzIHPDo28gY29sb2NhZGFzLCBjYXNvIHNlamFtIG51bSBjb250cm9sYWRvciwgbm8gKiRzY29wZSouXG5cdCAqICAgUGFyYSBhZGljaW9uYXIgYSBmdW7Dp8OjbywgY29sb3F1ZSBvIG5vbWUgZGEgZnVuw6fDo28gZSBvIHZhbG9yIGRlbGUgY29tbyBgdHJ1ZWBcblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmlkPC9sYWJlbD4gSWRlbnRpZmljYWRvciBxdWUgc2Vyw6EgdXRpbGl6YWRvIHBhcmEgYXJtYXplbmFyIG9zIGRhZG9zIG5vICRzY29wZSwgYWzDqW0gZGUgbm9tZWFyXG5cdCAqICBhcyBmdW7Dp8O1ZXMuXG4gXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+Y29uZmlnPC9sYWJlbD4gU3RyaW5nIHF1ZSBzZXLDoSB1dGlsaXphZGEgcGFyYSBkZWZpbmlyIHF1YWwgY29uZmlndXJhw6fDo28gc2Vyw6EgdXRpbGl6YWRhLlxuXHQgKiAgLS0tXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFBvcHVsYXRlKCl7XG5cdFx0dmFyIGhlbHBlcnMgPSB7fSwgY29uZmlncyA9IHt9LCBtZXRob2RzID0ge307XG5cdFx0aGVscGVycy5ndWFyYW50ZWVTdHJpbmcgPSBmdW5jdGlvbihzKXsgcmV0dXJuIChzICYmIGFuZ3VsYXIuaXNTdHJpbmcocykpfTtcblx0XHRoZWxwZXJzLmd1YXJhbnRlZUFycmF5ID0gZnVuY3Rpb24oYSl7IHJldHVybiAoYSAmJiBhbmd1bGFyLmlzQXJyYXkoYSkpfTtcblx0XHRoZWxwZXJzLmd1YXJhbnRlZUlzRGVmaW5lZCA9IGZ1bmN0aW9uKGQpeyByZXR1cm4gYW5ndWxhci5pc0RlZmluZWQoZCl9O1xuXHRcdGhlbHBlcnMuZ3VhcmFudGVlQmFzaWNMaXN0ID0gZnVuY3Rpb24ocyl7IHJldHVybiAocyAmJiB0aGlzLmd1YXJhbnRlZVN0cmluZyhzKSAmJiBzID09ICdiYXNpYy1saXN0Jyl9O1xuXHRcdGNvbmZpZ3NbJ2Jhc2UtbGlzdCddPSB7XG5cdFx0XHRnZXQ6IHRydWUsXG5cdFx0XHRyZXNldEFuZEdldDogdHJ1ZSxcblx0XHRcdGdldEJ5SWQ6IHRydWUsXG5cdFx0XHR1cGRhdGU6IHRydWUsXG5cdFx0XHRkZWxldGU6IHRydWUsXG5cdFx0XHRzb3J0OiB0cnVlLFxuXHRcdFx0c2VhcmNoOiB0cnVlLFxuXHRcdFx0YWR2YW5jZWRTZWFyY2g6IHRydWUsXG5cdFx0XHRzYXZlUXVlcnk6IHRydWUsXG5cdFx0XHRnZXRRdWVyeTogdHJ1ZSxcblx0XHRcdHJlc2V0UXVlcnk6IHRydWVcblx0XHR9O1xuXHRcdGNvbmZpZ3NbJ2Jhc2UtZm9ybSddID0ge1xuXHRcdFx0Z2V0TmV3OiB0cnVlLFxuXHRcdFx0Z2V0QnlJZDogdHJ1ZSxcblx0XHRcdHNhdmU6IHRydWUsXG5cdFx0XHR1cGRhdGU6IHRydWUsXG5cdFx0XHRzYXZlSW1hZ2U6IHRydWUsXG5cdFx0XHRkZWxldGVJbWFnZTogdHJ1ZVxuXHRcdH07XG5cblx0XHRjb25maWdzWydtYW55LXRvLW1hbnknXSA9IHtcblx0XHRcdHNlYXJjaDogdHJ1ZSxcblx0XHRcdHNhdmU6IHRydWUsXG5cdFx0XHRzZWFyY2hBc3luYzogdHJ1ZSxcblx0XHRcdHNhdmVBc3luYzogdHJ1ZVxuXHRcdH1cblxuXHRcdGNvbmZpZ3NbJ21hbnktdG8tb25lJ109e1xuXHRcdFx0c2F2ZTogdHJ1ZSxcblx0XHRcdHNlYXJjaEFzeW5jOiB0cnVlLFxuXHRcdFx0c2F2ZUFzeW5jOiB0cnVlXG5cdFx0fVxuXG5cblx0XHRtZXRob2RzLnNlYXJjaEFzeW5jID0gZnVuY3Rpb24oU2NvcGUsU2VydmljZSxJZCl7XG5cdFx0XHRTY29wZVtJZC50b0xvd2VyQ2FzZSgpICsgJ0FzeW5jU2VhcmNoJ10gPSBmdW5jdGlvbihmaWVsZCx2YWx1ZSl7XG5cdFx0XHRcdHJldHVybiBTZXJ2aWNlLmdldFNlYXJjaChmaWVsZCwgdmFsdWUpXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGEuZGF0YS52YWx1ZXM7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1ldGhvZHMuZ2V0UXVlcnkgPSBmdW5jdGlvbihTY29wZSxTZXJ2aWNlLElkKXtcblx0XHRcdFNjb3BlW0lkLnRvTG93ZXJDYXNlKCkgKyAnR2V0UXVlcnknXSA9IGZ1bmN0aW9uKHBhZ2Upe1xuXHRcdFx0XHRyZXR1cm4gU2VydmljZS5nZXRRdWVyeShwYWdlKVxuXHRcdFx0XHQudGhlbihmdW5jdGlvbihkYXRhKXtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YS5kYXRhLnZhbHVlcztcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtZXRob2RzLnNhdmVRdWVyeSA9IGZ1bmN0aW9uKFNjb3BlLFNlcnZpY2UsSWQpe1xuXHRcdFx0XHRTY29wZVtJZC50b0xvd2VyQ2FzZSgpICsgJ1NhdmVRdWVyeSddID0gZnVuY3Rpb24ocXVlcnksbmFtZSl7XG5cdFx0XHRcdFx0U2NvcGUuJGJyb2FkY2FzdCgnYmVmb3JlU2F2ZVF1ZXJ5Jyx7cXVlcnk6IHF1ZXJ5LCBuYW1lOiBuYW1lfSk7XG5cdFx0XHRcdFx0U2VydmljZS5zYXZlUXVlcnkoe3F1ZXJ5OiBxdWVyeSwgbmFtZTogbmFtZX0pXG5cdFx0XHRcdFx0LnRoZW4oZnVuY3Rpb24oZGF0YSl7XG5cdFx0XHRcdFx0XHRTY29wZS4kYnJvYWRjYXN0KCdhZnRlclNhdmVRdWVyeScsZGF0YSk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fVxuXHRcdH1cblxuXHRcdG1ldGhvZHMuc2F2ZUFzeW5jID0gZnVuY3Rpb24oU2NvcGUsU2VydmljZSxJZCl7XG5cdFx0XHRTY29wZVtJZC50b0xvd2VyQ2FzZSgpICsgJ0FzeW5jU2F2ZSddID0gZnVuY3Rpb24odmFsdWUscGFyYW0pe1xuXHRcdFx0XHR2YXIgb2JqID0ge307XG5cdFx0XHRcdG9ialtwYXJhbV0gPSB2YWx1ZTtcblx0XHRcdFx0cmV0dXJuIFNlcnZpY2UudXBkYXRlKG9iaik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdG1ldGhvZHMuZ2V0ID0gZnVuY3Rpb24oU2NvcGUsU2VydmljZSxJZCl7XG5cdFx0XHRTY29wZVtJZF09IHt9O1xuXHRcdFx0U2NvcGUucGFnZSA9IDA7XG5cdFx0XHRTY29wZVtJZC50b0xvd2VyQ2FzZSgpICsgJ0dldCddPSBmdW5jdGlvbihwYWdlKSB7XG5cdFx0XHRcdFNjb3BlLiRicm9hZGNhc3QoJ2JlZm9yZUdldCcpO1xuXHRcdFx0XHRTZXJ2aWNlLmdldChwYWdlKVxuXHRcdFx0XHQudGhlbihmdW5jdGlvbiAodmFsdWVzKSB7XG5cdFx0XHRcdFx0U2NvcGVbSWRdLmNvbnRlbnQgPSB2YWx1ZXM7XG5cdFx0XHRcdFx0U2NvcGUuJGJyb2FkY2FzdCgnYWZ0ZXJHZXQnLHZhbHVlcyk7XG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0XHRTY29wZVtJZC50b0xvd2VyQ2FzZSgpICsgJ0dldCddKCk7XG5cdFx0fTtcblx0XHRtZXRob2RzLnJlc2V0QW5kR2V0ID0gZnVuY3Rpb24oU2NvcGUsU2VydmljZSxJZCl7XG5cdFx0XHRTY29wZVtJZC50b0xvd2VyQ2FzZSgpICsgJ1Jlc2V0QW5kR2V0J10gPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRTY29wZS5wYWdlID0gMDtcblx0XHRcdFx0U2NvcGUuJGJyb2FkY2FzdCgnYmVmb3JlUmVzZXRBbmRHZXQnKTtcblx0XHRcdFx0U2VydmljZS5yZXNldEFuZEdldCgpXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG5cdFx0XHRcdFx0U2NvcGVbSWRdLmNvbnRlbnQgPSB2YWx1ZXM7XG5cdFx0XHRcdFx0U2NvcGUuJGJyb2FkY2FzdCgnYWZ0ZXJSZXNldEFuZEdldCcsdmFsdWVzKTtcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHR9O1xuXHRcdG1ldGhvZHMuZ2V0TmV3ID0gZnVuY3Rpb24oU2NvcGUsU2VydmljZSxJZCl7XG5cdFx0XHRTY29wZVtJZF0gPSBTY29wZVtJZF0gfHwge307XG5cdFx0XHRTY29wZVtJZC50b0xvd2VyQ2FzZSgpICsgJ0dldE5ldyddID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0U2NvcGUuJGJyb2FkY2FzdCgnYmVmb3JlR2V0TmV3Jyk7XG5cdFx0XHRcdFNlcnZpY2UuZ2V0TmV3KClcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcblx0XHRcdFx0XHRTY29wZS4kYnJvYWRjYXN0KCdhZnRlckdldE5ldycsdmFsdWVzKTtcblx0XHRcdFx0XHRTY29wZVtJZF1bJ25ldycgKyBJZF0gPSB2YWx1ZXM7XG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0fTtcblx0XHRtZXRob2RzLmdldEJ5SWQgPSBmdW5jdGlvbihTY29wZSxTZXJ2aWNlLElkKXtcblx0XHRcdFNjb3BlW0lkLnRvTG93ZXJDYXNlKCkgKyAnR2V0QnlJZCddID0gZnVuY3Rpb24oaWQpe1xuXHRcdFx0XHRTY29wZS4kYnJvYWRjYXN0KCdiZWZvcmVHZXRCeUlkJyk7XG5cdFx0XHRcdFNlcnZpY2UuZ2V0QnlJZChpZClcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcblx0XHRcdFx0XHRTY29wZVtJZF1bJ2lkJyArIGlkXSA9IHZhbHVlcztcblx0XHRcdFx0XHRTY29wZS4kYnJvYWRjYXN0KCdhZnRlckdldEJ5SWQnLHZhbHVlcyk7XG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0fTtcblx0XHRtZXRob2RzLnNhdmUgPSBmdW5jdGlvbihTY29wZSxTZXJ2aWNlLElkKXtcblx0XHRcdFNjb3BlW0lkLnRvTG93ZXJDYXNlKCkgKyAnU2F2ZSddID0gZnVuY3Rpb24odmFsdWUscGFyYW0pe1xuXHRcdFx0XHRTY29wZS4kYnJvYWRjYXN0KCdiZWZvcmVTYXZlJyx2YWx1ZSk7XG5cdFx0XHRcdHZhciBvYmogPSB7fTtcblx0XHRcdFx0b2JqW3BhcmFtXSA9IHZhbHVlO1xuXHRcdFx0XHRTZXJ2aWNlLnVwZGF0ZShvYmopXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG5cdFx0XHRcdFx0U2NvcGUuJGJyb2FkY2FzdCgnYWZ0ZXJTYXZlJyx2YWx1ZXMpO1xuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0bWV0aG9kcy51cGRhdGUgPSBmdW5jdGlvbihTY29wZSxTZXJ2aWNlLElkKXtcblx0XHRcdFNjb3BlW0lkLnRvTG93ZXJDYXNlKCkrJ1VwZGF0ZSddID0gZnVuY3Rpb24odmFsdWUpe1xuXHRcdFx0XHRTY29wZS4kYnJvYWRjYXN0KCdiZWZvcmVVcGRhdGUnLHZhbHVlKTtcblx0XHRcdFx0U2VydmljZS51cGRhdGUodmFsdWUpXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG5cdFx0XHRcdFx0U2NvcGUuJGJyb2FkY2FzdCgnYWZ0ZXJVcGRhdGUnLHZhbHVlcyk7XG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0fTtcblx0XHRtZXRob2RzLmRlbGV0ZSA9IGZ1bmN0aW9uKFNjb3BlLFNlcnZpY2UsSWQpe1xuXHRcdFx0U2NvcGVbSWQudG9Mb3dlckNhc2UoKSArICdEZWxldGUnXSA9IGZ1bmN0aW9uKHZhbHVlKXtcblx0XHRcdFx0U2NvcGUuJGJyb2FkY2FzdCgnYmVmb3JlRGVsZXRlJyk7XG5cdFx0XHRcdFNlcnZpY2UuZGVsZXRlQ29sbGVjdGlvbih2YWx1ZSlcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcblx0XHRcdFx0XHRTY29wZS4kYnJvYWRjYXN0KCdhZnRlckRlbGV0ZScsdmFsdWVzKTtcblx0XHRcdFx0XHRTY29wZVtJZC50b0xvd2VyQ2FzZSgpICsgJ0dldCddKCk7XG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0fTtcblx0XHRtZXRob2RzLnNvcnQgPSBmdW5jdGlvbihTY29wZSxTZXJ2aWNlLElkKXtcblx0XHRcdFNjb3BlW0lkLnRvTG93ZXJDYXNlKCkrJ1NvcnQnXSA9IGZ1bmN0aW9uKGZpZWxkLHdheSl7XG5cdFx0XHRcdFNjb3BlLiRicm9hZGNhc3QoJ2JlZm9yZVNvcnQnKTtcblx0XHRcdFx0U2VydmljZS5zb3J0KGZpZWxkLHdheSlcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcblx0XHRcdFx0XHRTY29wZVtJZF0uY29udGVudCA9IHZhbHVlcztcblx0XHRcdFx0XHRTY29wZS4kYnJvYWRjYXN0KCdhZnRlclNvcnQnLHZhbHVlcyk7XG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0fTtcblx0XHRtZXRob2RzLnNhdmVJbWFnZSA9IGZ1bmN0aW9uKFNjb3BlLFNlcnZpY2UsSWQpe1xuXHRcdFx0U2NvcGVbSWQudG9Mb3dlckNhc2UoKSArICdTYXZlSW1hZ2UnXSA9IGZ1bmN0aW9uKGF0dHJpYnV0ZSxtb2RlbCl7XG5cdFx0XHRcdFNjb3BlLiRicm9hZGNhc3QoJ2JlZm9yZVNhdmVJbWFnZScpO1xuXHRcdFx0XHRyZXR1cm4gU2VydmljZS5zYXZlSW1hZ2UoYXR0cmlidXRlLG1vZGVsKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdG1ldGhvZHMuZGVsZXRlSW1hZ2UgPSBmdW5jdGlvbihTY29wZSxTZXJ2aWNlLElkKXtcblx0XHRcdFNjb3BlW0lkLnRvTG93ZXJDYXNlKCkgKyAnRGVsZXRlSW1hZ2UnXSA9IGZ1bmN0aW9uKGF0dHJpYnV0ZSxtb2RlbCl7XG5cdFx0XHRcdFNjb3BlLiRicm9hZGNhc3QoJ2JlZm9yZURlbGV0ZUltYWdlJyk7XG5cdFx0XHRcdFNlcnZpY2UuZGVsZXRlSW1hZ2UoYXR0cmlidXRlLG1vZGVsKVxuXHRcdFx0XHQudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuXHRcdFx0XHRcdFNjb3BlLiRicm9hZGNhc3QoJ2FmdGVyRGVsZXRlSW1hZ2UnLHZhbHVlcyk7XG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0fTtcblx0XHRtZXRob2RzLnNlYXJjaCA9IGZ1bmN0aW9uKFNjb3BlLFNlcnZpY2UsSWQpe1xuXHRcdFx0U2NvcGVbSWQudG9Mb3dlckNhc2UoKSArICdTZWFyY2gnXSA9IGZ1bmN0aW9uKGZpZWxkLHBhcmFtKXtcblx0XHRcdFx0U2NvcGUuJGJyb2FkY2FzdCgnYmVmb3JlU2VhcmNoJyk7XG5cdFx0XHRcdFNlcnZpY2UuZ2V0U2VhcmNoKGZpZWxkLHBhcmFtKVxuXHRcdFx0XHQudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuXHRcdFx0XHRcdFNjb3BlW0lkXS5jb250ZW50ID0gdmFsdWVzO1xuXHRcdFx0XHRcdFNjb3BlLiRicm9hZGNhc3QoJ2FmdGVyU2VhcmNoJyx2YWx1ZXMpO1xuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdH1cblx0XHRtZXRob2RzLmFkdmFuY2VkU2VhcmNoID0gZnVuY3Rpb24oU2NvcGUsU2VydmljZSxJZCl7XG5cdFx0XHRTY29wZVtJZC50b0xvd2VyQ2FzZSgpICsgJ0FkdmFuY2VkU2VhcmNoJ10gPSBmdW5jdGlvbihwYXJhbSl7XG5cdFx0XHRcdFNjb3BlLiRicm9hZGNhc3QoJ2JlZm9yZUFkdmFuY2VkU2VhcmNoJyxwYXJhbSlcblx0XHRcdFx0U2VydmljZS5nZXRBZHZhbmNlZFNlYXJjaChwYXJhbSlcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcblx0XHRcdFx0XHRTY29wZVtJZF0uY29udGVudCA9IHZhbHVlcztcblx0XHRcdFx0XHRTY29wZS4kYnJvYWRjYXN0KCdhZnRlckFkdmFuY2VkU2VhcmNoJyx2YWx1ZXMpXG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdG1ldGhvZHMucmVzZXRRdWVyeSA9IGZ1bmN0aW9uKFNjb3BlLFNlcnZpY2UsaWQpe1xuXHRcdFx0U2NvcGVbaWQudG9Mb3dlckNhc2UoKSArICdSZXNldFF1ZXJ5J10gPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRTY29wZS5wYWdlID0gMDtcblx0XHRcdFx0U2VydmljZS5yZXNldFF1ZXJ5KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdG1ldGhvZHNcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2V0Q29uZmlnOiBmdW5jdGlvbihuLHYpe1xuXHRcdFx0XHRoZWxwZXJzLmd1YXJhbnRlZVN0cmluZyhuKSAmJiBoZWxwZXJzLmd1YXJhbnRlZUlzRGVmaW5lZCh2KSA/IChjb25maWdzW25dID0gdikgOiBhbmd1bGFyLm5vb3A7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0Q29uZmlnOiBmdW5jdGlvbihzdHJpbmcpe1xuXHRcdFx0XHRyZXR1cm4gY29uZmlnc1tzdHJpbmddO1xuXHRcdFx0fSxcblx0XHRcdHNldE1ldGhvZDogZnVuY3Rpb24obmFtZSxjb25maWcsZm4pe1xuXHRcdFx0XHRpZighKGhlbHBlcnMuZ3VhcmFudGVlU3RyaW5nKG5hbWUpICYmIGhlbHBlcnMuZ3VhcmFudGVlU3RyaW5nKGNvbmZpZykpKVxuXHRcdFx0XHRcdHRocm93ICdPbmUgb2YgJHBvcHVsYXRlUHJvdmlkZXIuc2V0TWV0aG9kIGFyZ3VtZW50cyBpcyB3cm9uZy4nO1xuXHRcdFx0XHRjb25maWdzW2NvbmZpZ11bbmFtZV0gPSB0cnVlO1xuXHRcdFx0XHRtZXRob2RzW25hbWVdID0gZm47XG5cdFx0XHR9LFxuXHRcdFx0cG9wdWxhdGVTY29wZTogZnVuY3Rpb24oc2NwLHN2YyxpZCxjb25maWcpe1xuXHRcdFx0XHRpZighaGVscGVycy5ndWFyYW50ZWVJc0RlZmluZWQoc2NwKSkgdGhyb3cgJ1RoZSAkc2NvcGUgcGFzc2VkIGZvciBwb3B1bGF0ZVNjb3BlIHdhc25cXCd0IGRlZmluZWQnO1xuXHRcdFx0XHRpZighaGVscGVycy5ndWFyYW50ZWVJc0RlZmluZWQoaWQpKSB0aHJvdyAnVGhlIGlkZW50aWZpZXIgZm9yIHBvcHVsYXRlU2NvcGUgbXVzdCBiZSBwYXNzZWQnO1xuXHRcdFx0XHRpZighaGVscGVycy5ndWFyYW50ZWVJc0RlZmluZWQoY29uZmlnKSkgdGhyb3cgJ1RoZSBjb25maWd1cmF0aW9uIGZvciBwb3B1bGF0ZVNjb3BlIG11c3QgYmUgcGFzc2VkJztcblx0XHRcdFx0aWYoIWhlbHBlcnMuZ3VhcmFudGVlSXNEZWZpbmVkKHN2YykpIHRocm93ICdUaGUgc2VydmljZSBmb3IgcG9wdWxhdGVTY29wZSBtdXN0IGJlIHBhc3NlZCc7XG5cdFx0XHRcdGlmKGNvbmZpZ3NbY29uZmlnXSl7XG5cdFx0XHRcdFx0c2NwW2lkXSA9IHt9O1xuXHRcdFx0XHRcdHNjcFtpZF0uY29udGVudCA9IHt9O1xuXHRcdFx0XHRcdHZhciBjb25maWd1cmF0aW9uID0gY29uZmlnc1tjb25maWddO1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBjb25maWd1cmF0aW9uKSBpZihjb25maWd1cmF0aW9uLmhhc093blByb3BlcnR5KGtleSkpe1xuXHRcdFx0XHRcdFx0bWV0aG9kc1trZXldKHNjcCxzdmMsaWQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdCRnZXQ6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2Euc2VydmljZXMucG9wdWxhdGUnLFtdKVxuXHQucHJvdmlkZXIoJyRwb3B1bGF0ZScsUG9wdWxhdGUpXG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRCYXNlLiRpbmplY3QgPSBbXCIkaHR0cFwiLCBcIiRxXCJdO1xuXHQvKipcblx0ICogQG5nZG9jIHNlcnZpY2Vcblx0ICogQG5hbWUgZ3VtZ2EuY29yZTpHdW1nYVJlc3Rcblx0ICogQGRlc2NyaXB0aW9uXG5cdCAqIFx0TyBzZXJ2aWNlIEd1bWdhUmVzdCDDqSB1bWEgZXZvbHXDp8OjbyBkbyBzZXJ2aWNlIHtAbGluayBndW1nYS5jb3JlOkd1bWdhQmFzZX0sIHBvaXMgc3VhIGNvbmZpZ3VyYcOnw6NvIG7Do28gbmVjZXNzaXRhXG5cdCAqIFx0ZGUgbmVuaHVtYSBvdXRyYSBjb25maWd1cmHDp8OjbyBhZGljaW9uYWwgbm8gc2VydmljZSBxdWUgaXLDoSBjaGFtw6EtbG8uXG5cdCAqXG5cdCAqICMjIEV4ZW1wbG9cblx0ICogPHByZT5cblx0ICogYW5ndWxhci5tb2R1bGUoJ3NhbXBsZScsWydndW1nYS5jb3JlJ10pXG5cdCAqIC5zZXJ2aWNlKCdHdW1nYVJlc3QnLGZ1bmN0aW9uKEd1bWdhUmVzdCl7XG5cdCAqIFx0ICAgLy9FeGVtcGxvIGRlIHV0aWxpemHDp8Ojby5cblx0ICogXHQgICB2YXIgc2VydmljZSA9IG5ldyBHdW1nYVJlc3QoJ2h0dHA6Ly93d3cuZ3VtZ2EuY29tLmJyL2FwaScpO1xuXHQgKiAgICAgLy8gT3UsIGNhc28gbsOjbyBxdWVpcmEgYWRpY2lvbmFyIG5lbmh1bSBtw6l0b2RvLCB1dGlsaXphcjpcblx0ICogICAgIC8vIHJldHVybiBuZXcgR3VtZ2FSZXN0KCdodHRwOi8vd3d3Lmd1bWdhLmNvbS5ici9hcGknKTtcblx0ICpcblx0ICpcdCAgIHNlcnZpY2UuZ2V0ID0gZnVuY3Rpb24ocGFnZSl7XG5cdCAqXHQgICAgICAgYWxlcnQoJ01vZGlmaXF1ZWkgdW0gbcOpdG9kbyBkYSBzZXJ2aWNlIGUgY2hhbWVpIG8gcGFkcsOjbyEnKTtcblx0ICpcdFx0ICAgICByZXR1cm4gR3VtZ2FSZXN0LnByb3RvdHlwZS5nZXQuY2FsbCh0aGlzLHBhZ2UpO1xuXHQgKlx0ICAgfVxuXHQgKiBcdCAgIHJldHVybiBzZXJ2aWNlO1xuXHQgKiB9KVxuXHQgKiA8L3ByZT5cblx0ICpcblx0ICogIyBNw6l0b2Rvc1xuXHQgKlxuXHQgKiAgYEd1bWdhUmVzdC5nZXQocGFyYW1zKWBcblx0ICpcblx0ICogIE8gbcOpdG9kbyBnZXQgYWNlaXRhIHVtIHBhcsOibWV0cm8gYHVybGAgZSByZXRvcm5hIHVtYSBwcm9taXNlIGRlIHVtYSBjaGFtYWRhIEhUVFAgZG8gdGlwbyBHRVQuXG5cdCAqXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPk9iamVjdDwvbGFiZWw+IDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5wYXJhbXM8L2xhYmVsPiBQYXLDom1ldHJvcyBkYSBxdWVyeSBxdWUgc2Vyw6EgZmVpdGEuXG5cdCAqICAjIyMgUmV0b3Jub1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+SHR0cFByb21pc2U8L2xhYmVsPiBSZXRvbmEgdW1hIHByb21pc2UgZGEgY2hhbWFkYSBIVFRQIEdFVC5cblx0ICogIC0tLVxuXHQgKiAgYEd1bWdhUmVzdC5yZXNldEFuZEdldCgpYFxuXHQgKlxuXHQgKiAgTyBtw6l0b2RvIHJlc2V0QW5kR2V0IHJlc2V0YSBhIHF1ZXJ5IGF0dWFsIGUgcGVyZm9ybWEgdW1hIGNoYW1hZGEgSFRUUCBkbyB0aXBvIEdFVC5cblx0ICpcblx0ICogICMjIyBSZXRvcm5vXG5cdCAqXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5IdHRwUHJvbWlzZTwvbGFiZWw+IFJldG9ybmEgdW1hIHByb21pc2UgZGEgY2hhbWFkYSBIVFRQIEdFVC5cblx0ICpcblx0ICogXHQtLS1cblx0ICpcbiBcdCAqICBgR3VtZ2FSZXN0LmdldEJ5SWQoaWQpYFxuXHQgKlxuXHQgKiAgTyBtw6l0b2RvIGdldEJ5SWQgYWNlaXRhIHVtIHBhcsOibWV0cm8gYGlkYCBlIHJldG9ybmEgdW1hIHByb21pc2UgZGUgdW1hIGNoYW1hZGEgSFRUUCBkbyB0aXBvIEdFVC5cblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+W1N0cmluZ3xOdW1iZXJdPC9sYWJlbD4gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmlkPC9sYWJlbD4gSWRlbnRpZmljYWRvciBkbyByZWdpc3RybyBxdWUgc2Vyw6EgYnVzY2Fkby5cblx0ICogICMjIyBSZXRvcm5vXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5IdHRwUHJvbWlzZTwvbGFiZWw+IFJldG9uYSB1bWEgcHJvbWlzZSBkYSBjaGFtYWRhIEhUVFAgR0VULlxuXHQgKiAgLS0tXG5cdCAqICBgR3VtZ2FSZXN0LmdldE5ldygpYFxuXHQgKlxuXHQgKiAgTyBtw6l0b2RvIGdldEJ5SWQgIHJldG9ybmEgdW1hIHByb21pc2UgZGUgdW1hIGNoYW1hZGEgSFRUUCBkbyB0aXBvIEdFVC5cblx0ICogICMjIyBSZXRvcm5vXG5cdCAqXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5IdHRwUHJvbWlzZTwvbGFiZWw+IFJldG9ybmEgdW1hIHByb21pc2UgZGEgY2hhbWFkYSBIVFRQIEdFVC5cblx0ICpcblx0ICogIC0tLVxuIFx0ICogIGBHdW1nYVJlc3QuZGVsZXRlKGRhdGEpYFxuXHQgKlxuXHQgKiAgTyBtw6l0b2RvIGRlbGV0ZSByZWNlYmUgY29tbyBwYXLDom1ldHJvIHVtIG9iamV0byBxdWUgc2Vyw6EgZGVsZXRhZG8uIE8gb2JqZXRvIGRldmUgdGVyIHVtIHBhcsOibWV0cm8gSUQsXG5cdCAqICBxdWUgc2Vyw6EgcGFzc2FkbyBwYXJhIGEgdXJsIGRhIGNoYW1hZGEuXG5cdCAqXG4gXHQgKiAgIyMjIFBhcsOibWV0cm9zXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5PYmplY3Q8L2xhYmVsPiA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+ZGF0YTwvbGFiZWw+IFJlZ2lzdHJvIHF1ZSBzZXLDoSBkZWxldGFkby5cblx0ICpcblx0ICogICMjIyBSZXRvcm5vXG5cdCAqXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5IdHRwUHJvbWlzZTwvbGFiZWw+IFJldG9ybmEgdW1hIHByb21pc2UgZGEgY2hhbWFkYSBIVFRQIERFTEVURS5cblx0ICpcblx0ICogIC0tLVxuXHQgKlxuIFx0ICogIGBHdW1nYVJlc3Quc29ydChmaWVsZCx3YXkpYFxuXHQgKlxuXHQgKiBPIG3DqXRvZG8gc29ydCByZWNlYmUgZG9pcyBwYXLDom1ldHJvcyBwYXJhIGZhemVyIGEgb3JkZW5hw6fDo286IGBmaWVsZGAgZSBgd2F5YCwgcXVlIGRldGVybWluYXLDo28gcXVhbCBjYW1wbyBzZXLDoSBvcmRlbmFkb1xuXHQgKiBlIHNlIHNlcsOhICdhc2MnIG91ICdkZXNjJy5cblx0ICpcbiBcdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+IDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5maWVsZDwvbGFiZWw+IFF1YWwgY2FtcG8gc2Vyw6EgZmVpdGEgYSBvcmRlbmHDp8Ojb1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD4gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPndheTwvbGFiZWw+IEVtIHF1ZSBzZW50aWRvIGEgb3JkZW5hw6fDo28gc2Vyw6EgZmVpdGEsIHNlIHNlcsOhIGFzY2VuZGVudGUgYGFzY2Agb3UgZGVzY2VuZGVudGUgYGRlc2NgLlxuXHQgKiAgIyMjIFJldG9ybm9cblx0ICpcblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPkh0dHBQcm9taXNlPC9sYWJlbD4gUmV0b3JuYSB1bWEgcHJvbWlzZSBkYSBjaGFtYWRhIEhUVFAgR0VULlxuXHQgKlxuXHQgKiAgLS0tXG5cdCAqXG5cdCAqICBgR3VtZ2FSZXN0LmRlbGV0ZUNvbGxlY3Rpb24oYXJyYXkpYFxuXHQgKlxuXHQgKiAgTyBtw6l0b2RvIGRlbGV0ZUFsbCBhY2VpdGEgdW0gcGFyw6JtZXRybyBgdXJsYCAgZSByZXRvcm5hIHVtYSBwcm9taXNlIGRlIHVtYSBzw6lyaWUgZGUgY2hhbWFkYXMgaHR0cCBkbyB0aXBvIERFTEVURSBxdWUgc2Vyw6NvIHJlc29sdmlkYXMgYW8gbWVzbW8gdGVtcG8uXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPkFycmF5PC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+YXJyYXk8L2xhYmVsPiBBcnJheSBjb20gdG9kYXMgb3MgcmVnaXN0cm9zIHF1ZSBzZXLDo28gZGVsZXRhZG9zXG5cdCAqICAjIyMgUmV0b3Jub1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+SHR0cFByb21pc2U8L2xhYmVsPiBSZXRvcm5hIHVtYSBwcm9taXNlIGFww7NzIHRvZGFzIGFzIGNoYW1hZGFzIHRlcmVtIHNpZG8gcmVzb2x2aWRhcy5cblx0ICogIC0tLVxuXHQgKlxuIFx0ICogIGBHdW1nYVJlc3Quc2F2ZUltYWdlKGF0dHJpYnV0ZSxkYXRhKWBcblx0ICpcblx0ICogIE8gbcOpdG9kbyBzYXZlSW1hZ2UgYWNlaXRhIGRvaXMgcGFyw6JtZXRyb3MgYGF0dHJpYnV0ZWAgZSBgZGF0YWAgZSByZXRvcm5hIHVtYSBwcm9taXNlIGRlIGRlIHVtYSBjaGFtYWRhIEhUVFAgUE9TVCBGT1JNLURBVEEuXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmF0dHJpYnV0ZTwvbGFiZWw+IEF0cmlidXRvIG5vIHF1YWwgYSBpbWFnZW0gc2Vyw6EgZmVpdG8gb1xuXHQgKiAgYmluZCBhcMOzcyBvIGZvcm0gdGVyIHNpZG8gZW52aWFkbyBjb21wbGV0by5cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPk9iamVjdDwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmRhdGE8L2xhYmVsPiBEYWRvcyBkYSBpbWFnZW0gcXVlIGZvaSBzZWxlY2lvbmFkYS4uXG5cdCAqICAjIyMgUmV0b3Jub1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+SHR0cFByb21pc2U8L2xhYmVsPiBSZXRvcm5hIHVtYSBwcm9taXNlIGRhIGNoYW1hZGEgSFRUUCBQT1NULiBOZXN0YSBwcm9taXNlLCBzZXLDoSByZXRvcm5hZG8gbyB2YWxvciBkZSB1bWEgU3RyaW5nIHF1ZSBkZXZlcsOhIHNlciBhdHJpYnXDrWRhIGFvIGF0cmlidXRvXG5cdCAqICBvbmRlIGVzdGF2YSBhIGltYWdlbS4gRXN0YSBzdHJpbmcgw6kgdW0gaWRlbnRpZmljYWRvciBwYXJhIHF1YW5kbyBvIHJlZ2lzdHJvIGZvciBlbnZpYWRvIGF0cmF2w6lzIGRlIHVtIHBvc3QuXG5cdCAqICAtLS1cbiBcdCAqICBgR3VtZ2FSZXN0LmRlbGV0ZUltYWdlKGF0dHJpYnV0ZSxkYXRhKWBcblx0ICpcblx0ICogIE8gbcOpdG9kbyBkZWxldGVJbWFnZSBhY2VpdGEgZG9pcyBwYXLDom1ldHJvcyBgdXJsYCBlIGBkYXRhYCBlIHJldG9ybmEgdW1hIHByb21pc2UgZGUgZGUgdW1hIGNoYW1hZGEgSFRUUCBERUxFVEUgRk9STS1EQVRBLlxuXHQgKiAgIyMjIFBhcsOibWV0cm9zXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5hdHRyaWJ1dGU8L2xhYmVsPiBBdHJpYnV0byBubyBxdWFsIGEgaW1hZ2VtIHNlcsOhIGZlaXRvIG9cblx0ICogIGJpbmQgYXDDs3MgbyBmb3JtIHRlciBzaWRvIGVudmlhZG8gY29tcGxldG8uXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5PYmplY3Q8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5kYXRhPC9sYWJlbD4gRGFkb3MgZGEgaW1hZ2VtIHF1ZSBmb2kgc2VsZWNpb25hZGEuXG5cdCAqICAjIyMgUmV0b3Jub1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+SHR0cFByb21pc2U8L2xhYmVsPiBSZXRvcm5hIHVtYSBwcm9taXNlIGRhIGNoYW1hZGEgSFRUUCBERUxFVEUuXG5cdCAqICAtLS1cbiBcdCAqXG4gXHQgKiAgYEd1bWdhUmVzdC5nZXRTZWFyY2goZmllbGQscGFyYW0pYFxuXHQgKlxuXHQgKiAgTyBtw6l0b2RvIGdldFNlYXJjaCBhY2VpdGEgZG9pcyBwYXLDom1ldHJvcyBgZmllbGRgIGUgYHBhcmFtYCBlIHJldG9ybmEgdW1hIHByb21pc2UgZGUgdW1hIGNoYW1hZGEgSFRUUCBkbyB0aXBvIEdFVC5cblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+W1N0cmluZ108L2xhYmVsPiA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+ZmllbGQ8L2xhYmVsPiBRdWFsIGNhbXBvIGEgYnVzY2Egc2Vyw6EgZmVpdGEuIENhc29cblx0ICogIHF1ZWlyYSBmYXplciBhIGJ1c2NhIGVtIG1haXMgZGUgdW0gY2FtcG8sIHBhc3NhciB1bWEgc3RyaW5nIGNvbSBvcyBub21lcyBzZXBhcmFkb3MgcG9yIHbDrXJndWxhLlxuIFx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPltPYmplY3RdPC9sYWJlbD4gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPnBhcmFtPC9sYWJlbD4gT2JqZXRvIHF1ZSBpcsOhIGNvbnRlciBvcyBwYXLDom1ldHJvc1xuIFx0ICogIGRhIGJ1c2NhLlxuXHQgKiAgIyMjIFJldG9ybm9cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPkh0dHBQcm9taXNlPC9sYWJlbD4gUmV0b25hIHVtYSBwcm9taXNlIGRhIGNoYW1hZGEgSFRUUCBHRVQuXG5cdCAqICAtLS1cblx0ICpcbiBcdCAqICBgR3VtZ2FSZXN0LmdldEFkdmFuY2VkU2VhcmNoKHBhcmFtKWBcblx0ICpcblx0ICogIE8gbcOpdG9kbyBnZXRBZHZhbmNlZFNlYXJjaCBhY2VpdGEgdW0gcGFyw6JtZXRybyBgcGFyYW1gIGUgcmV0b3JuYSB1bWEgcHJvbWlzZSBkZSB1bWEgY2hhbWFkYSBIVFRQIGRvIHRpcG8gR0VULlxuXHQgKiAgIyMjIFBhcsOibWV0cm9zXG4gXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+W09iamVjdF08L2xhYmVsPiA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+cGFyYW08L2xhYmVsPiBPYmpldG8gcXVlIGlyw6EgY29udGVyIG9zIHBhcsOibWV0cm9zXG4gXHQgKiAgZGEgYnVzY2EuXG5cdCAqICAjIyMgUmV0b3Jub1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+SHR0cFByb21pc2U8L2xhYmVsPiBSZXRvbmEgdW1hIHByb21pc2UgZGEgY2hhbWFkYSBIVFRQIEdFVC5cblx0ICogIC0tLVxuICAgKlxuIFx0ICogIGBHdW1nYVJlc3QucmVzZXREZWZhdWx0U3RhdGUoKWBcblx0ICpcblx0ICogIE8gbcOpdG9kbyByZXNldERlZmF1bHRTdGF0ZSByZXRvcm5hIG8gb2JqZXRvIGRlIHF1ZXJ5IGFvIHNldSBlc3RhZG8gcGFkcsOjby5cblx0ICpcblx0ICogIC0tLVxuXHQgKlxuXHQgKiAgYEd1bWdhUmVzdC5zYXZlUXVlcnkocXVlcnkpYFxuXHQgKlxuXHQgKiAgTyBtw6l0b2RvIHNhdmVRdWVyeSBhY2VpdGEgdW0gcGFyw6JtZXRybyBgcXVlcnlgIGUgcmV0b3JuYSB1bWEgcHJvbWlzZSBkZSB1bWEgY2hhbWFkYSBIVFRQIGRvIHRpcG8gUE9TVC5cblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+W09iamVjdF08L2xhYmVsPiA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+cXVlcnk8L2xhYmVsPiBPYmpldG8gcXVlIGlyw6EgY29udGVyIHRyw6pzIGF0cmlidXRvcyBuZWNlc3PDoXJpb3Ncblx0ICogIHBhcmEgc2FsdmFyIGEgcXVlcnkuIE9zIGF0cmlidXRvcyBzw6NvOiBgcGFnZWAsIGBkYXRhYCBlIGBuYW1lYC4gT25kZSBgcGFnZWAgw6kgbyBub21lIGRhIHDDoWdpbmEgYXR1YWwsIGBkYXRhYCDDqSBhIGJ1c2NhIGUgYG5hbWVgIMOpIG8gbm9tZSBkYSBxdWVyeSBhIHNlciBzYWx2YS5cblx0ICogICMjIyBSZXRvcm5vXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5IdHRwUHJvbWlzZTwvbGFiZWw+IFJldG9uYSB1bWEgcHJvbWlzZSBkYSBjaGFtYWRhIEhUVFAgUE9TVC5cblx0ICogIC0tLVxuXHQgKlxuXHQgKiAgYEd1bWdhUmVzdC5nZXRRdWVyeShwYWdlKWBcblx0ICpcblx0ICogIE8gbcOpdG9kbyBnZXRRdWVyeSBhY2VpdGEgdW0gcGFyw6JtZXRybyBgcGFnZWAgZSByZXRvcm5hIHVtYSBwcm9taXNlIGRlIHVtYSBjaGFtYWRhIEhUVFAgZG8gdGlwbyBHRVQuIEVzdGUgUGFyw6JtZXRybyBgcGFnZWAgw6kgbyB2YWxvciBkZSByZXRvcm5vIGRvIG9iamV0byBgbG9jYXRpb24uaGFzaGAgZGlzcG9uw612ZWxcblx0ICogIGF0cmF2w6lzIGRvIGJyb3dzZXIuIEV4ZW1wbG86IGBHdW1nYVJlc3QuZ2V0UXVlcnkobG9jYXRpb24uaGFzaCk7YC4gw4kgbmVjZXNzw6FyaW8gZXN0ZSBhdHJpYnV0byBwYXJhIHBlZ2FyIGFwZW5hcyBhcyBxdWVyaWVzIHJlbGFjaW9uYWRhcyBhIHDDoWdpbmEuIEFzIGluZm9ybWHDp8O1ZXMgZG8gdXN1w6FyaW8gasOhIHPDo29cblx0ICogIHBhc3NhZGFzIGF0cmF2w6lzIGRvIHRva2VuLlxuXHQgKiAgIyMjIFBhcsOibWV0cm9zXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5bU3RyaW5nXTwvbGFiZWw+IDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5wYWdlPC9sYWJlbD4gU3RyaW5nIHF1ZSBzZXLDoSB1dGlsaXphZGEgcGFyYSBmYXplciBhIHBlc3F1aXNhIGRhc1xuXHQgKiAgcXVlcmllcyByZWxhY2lvbmFkYXMgY29tIGEgcMOhZ2luYS5cblx0ICogICMjIyBSZXRvcm5vXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5IdHRwUHJvbWlzZTwvbGFiZWw+IFJldG9uYSB1bWEgcHJvbWlzZSBkYSBjaGFtYWRhIEhUVFAgR0VULlxuXHQgKiAgLS0tXG5cdCAqL1xuXHRmdW5jdGlvbiBCYXNlKCRodHRwLCRxKXtcblx0XHRmdW5jdGlvbiBSZXN0UHJvdG90eXBlKHVybCl7XG5cdFx0XHR0aGlzLl91cmwgPSB1cmw7XG5cdFx0XHR0aGlzLl9xdWVyeSA9IHtwYXJhbXM6IHtzdGFydDogMCxwYWdlU2l6ZTogMTB9fTtcblx0XHR9XG5cdFx0UmVzdFByb3RvdHlwZS5wcm90b3R5cGUuZ2V0ID0gX2dldDtcblx0XHRSZXN0UHJvdG90eXBlLnByb3RvdHlwZS5yZXNldEFuZEdldCA9IF9yZXNldEFuZEdldDtcblx0XHRSZXN0UHJvdG90eXBlLnByb3RvdHlwZS5nZXROZXcgPSBfZ2V0TmV3O1xuXHRcdFJlc3RQcm90b3R5cGUucHJvdG90eXBlLmdldEJ5SWQgPSBfZ2V0QnlJZDtcblx0XHRSZXN0UHJvdG90eXBlLnByb3RvdHlwZS5zYXZlID0gX3NhdmU7XG5cdFx0UmVzdFByb3RvdHlwZS5wcm90b3R5cGUudXBkYXRlPSBfdXBkYXRlO1xuXHRcdFJlc3RQcm90b3R5cGUucHJvdG90eXBlLmRlbGV0ZSA9IF9kZWxldGU7XG5cdFx0UmVzdFByb3RvdHlwZS5wcm90b3R5cGUuc29ydCA9IF9zb3J0O1xuXHRcdFJlc3RQcm90b3R5cGUucHJvdG90eXBlLmRlbGV0ZUNvbGxlY3Rpb24gPSBfZGVsZXRlQ29sbGVjdGlvbjtcblx0XHRSZXN0UHJvdG90eXBlLnByb3RvdHlwZS5zYXZlSW1hZ2UgPSBfc2F2ZUltYWdlO1xuXHRcdFJlc3RQcm90b3R5cGUucHJvdG90eXBlLmRlbGV0ZUltYWdlID0gX2RlbGV0ZUltYWdlO1xuXHRcdFJlc3RQcm90b3R5cGUucHJvdG90eXBlLmdldFNlYXJjaCA9IF9nZXRTZWFyY2g7XG5cdFx0UmVzdFByb3RvdHlwZS5wcm90b3R5cGUuZ2V0QWR2YW5jZWRTZWFyY2ggPSBfZ2V0QWR2YW5jZWRTZWFyY2g7XG5cdFx0UmVzdFByb3RvdHlwZS5wcm90b3R5cGUucmVzZXREZWZhdWx0U3RhdGUgPSBfcmVzZXRRdWVyeTtcblx0XHRSZXN0UHJvdG90eXBlLnByb3RvdHlwZS5zYXZlUXVlcnkgPSBfc2F2ZVF1ZXJ5O1xuXHRcdFJlc3RQcm90b3R5cGUucHJvdG90eXBlLmdldFF1ZXJ5ID0gX2dldFF1ZXJ5O1xuXHRcdGZ1bmN0aW9uIF9nZXQocGFnZSl7XG5cdFx0XHRpZiAocGFnZSkge1xuXHRcdFx0XHR0aGlzLl9xdWVyeS5wYXJhbXMuc3RhcnQgPSAocGFnZSAtIDEpICogdGhpcy5fcXVlcnkucGFyYW1zLnBhZ2VTaXplO1xuXHRcdFx0XHRpZiAocGFnZSA8IDEpIHRocm93ICdJbnZhbGlkIHBhZ2UnO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICRodHRwLmdldCh0aGlzLl91cmwsdGhpcy5fcXVlcnkpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBfZ2V0TmV3ICgpIHtyZXR1cm4gJGh0dHAuZ2V0KHRoaXMuX3VybCArICcvbmV3Jyl9XG5cdFx0ZnVuY3Rpb24gX2dldEJ5SWQoaWQpe3JldHVybiAkaHR0cC5nZXQodGhpcy5fdXJsICsgJy8nICsgaWQpO31cblx0XHRmdW5jdGlvbiBfc2F2ZSAodil7cmV0dXJuICRodHRwLnBvc3QodGhpcy5fdXJsLHYpO31cblx0XHRmdW5jdGlvbiBfdXBkYXRlICh2KXtcblx0XHRcdGlmKHYuaWQpe1xuXHRcdFx0XHRyZXR1cm4gJGh0dHAucHV0KHRoaXMuX3VybCArICcvJyArIHYuaWQgLHYpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuc2F2ZSh2KTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gX2RlbGV0ZSh2KXtyZXR1cm4gJGh0dHAuZGVsZXRlKHRoaXMuX3VybCArICcvJyArIHYuaWQpO31cblx0XHRmdW5jdGlvbiBfcmVzZXRRdWVyeSgpe3RoaXMuX3F1ZXJ5ID0ge3BhcmFtczoge3N0YXJ0OiAwLHBhZ2VTaXplOiAxMH19O31cblxuXHRcdGZ1bmN0aW9uIF9yZXNldEFuZEdldCgpe1xuXHRcdFx0dGhpcy5yZXNldERlZmF1bHRTdGF0ZSgpO1xuXHRcdFx0cmV0dXJuICRodHRwLmdldCh0aGlzLl91cmwsdGhpcy5fcXVlcnkpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBfc29ydChmLHcpe1xuXHRcdFx0dGhpcy5yZXNldERlZmF1bHRTdGF0ZSgpO1xuXHRcdFx0dGhpcy5fcXVlcnkucGFyYW1zLnNvcnRGaWVsZCA9IGY7XG5cdFx0XHR0aGlzLl9xdWVyeS5wYXJhbXMuc29ydERpciA9IHc7XG5cdFx0XHRyZXR1cm4gJGh0dHAuZ2V0KHRoaXMuX3VybCx0aGlzLl9xdWVyeSk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIF9kZWxldGVDb2xsZWN0aW9uKGFycil7XG5cdFx0XHR2YXIgdXJsID0gdGhpcy5fdXJsO1xuXHRcdFx0cmV0dXJuICRxLmFsbChhcnIubWFwKGZ1bmN0aW9uKHYpe1xuXHRcdFx0XHRyZXR1cm4gJGh0dHAuZGVsZXRlKHVybCArICcvJyArIHYuaWQpO1xuXHRcdFx0fSkpXG5cdFx0fVxuXHRcdGZ1bmN0aW9uIF9zYXZlSW1hZ2UoYSxtKXtcblx0XHRcdHZhciBmZCA9IG5ldyBGb3JtRGF0YSgpO1xuXHRcdFx0ZmQuYXBwZW5kKGEsbSk7XG5cdFx0XHRyZXR1cm4gJGh0dHAucG9zdCh0aGlzLl91cmwgKyAnLycgK2EgKyAnLycsZmQse1xuXHRcdFx0XHR0cmFuc2Zvcm1SZXF1ZXN0OiBhbmd1bGFyLmlkZW50aXR5LFxuXHRcdFx0XHRoZWFkZXJzOiB7J0NvbnRlbnQtVHlwZSc6IHVuZGVmaW5lZH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBfZGVsZXRlSW1hZ2UoYSl7XG5cdFx0XHR2YXIgZmQgPSBuZXcgRm9ybURhdGEoKTtcblx0XHRcdGZkLmFwcGVuZChhLHt9KTtcblx0XHRcdHJldHVybiAkaHR0cC5kZWxldGUodGhpcy5fdXJsICsgJy8nICthLGZkLHtcblx0XHRcdFx0dHJhbnNmb3JtUmVxdWVzdDogYW5ndWxhci5pZGVudGl0eSxcblx0XHRcdFx0aGVhZGVyczogeydDb250ZW50LVR5cGUnOiB1bmRlZmluZWR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gX2dldFNlYXJjaChmLHApe1xuXHRcdFx0dGhpcy5yZXNldERlZmF1bHRTdGF0ZSgpO1xuXHRcdFx0KCFwKSA/ICBwID0gJycgOiBhbmd1bGFyLm5vb3A7XG5cdFx0XHR0aGlzLl9xdWVyeS5wYXJhbXMucSA9IHA7XG5cdFx0XHR0aGlzLl9xdWVyeS5wYXJhbXMuc2VhcmNoRmllbGRzID0gZjtcblx0XHRcdHJldHVybiB0aGlzLmdldCgpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBfZ2V0QWR2YW5jZWRTZWFyY2gocCl7XG5cdFx0XHRpZih0eXBlb2YgcCA9PT0gJ3N0cmluZycpe1xuXHRcdFx0XHR0aGlzLl9xdWVyeS5wYXJhbXMgPSB7fVxuXHRcdFx0XHR0aGlzLl9xdWVyeS5wYXJhbXMuYXEgPSBwO1xuXHRcdFx0XHRyZXR1cm4gJGh0dHAuZ2V0KHRoaXMuX3VybCx0aGlzLl9xdWVyeSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9xdWVyeS5wYXJhbXMgPSB7fTtcblx0XHRcdHRoaXMuX3F1ZXJ5LnBhcmFtcy5hcSA9IHAuaHFsO1xuXHRcdFx0dGhpcy5fcXVlcnkucGFyYW1zLmFxbyA9IEpTT04uc3RyaW5naWZ5KHAuc291cmNlKTtcblx0XHRcdHJldHVybiAkaHR0cC5nZXQodGhpcy5fdXJsLHRoaXMuX3F1ZXJ5KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBfc2F2ZVF1ZXJ5KHEpe1xuXHRcdFx0dmFyIF9hdXggPSB7XG5cdFx0XHRcdHBhZ2U6IGxvY2F0aW9uLmhhc2gucmVwbGFjZSgnIycsJycpLnJlcGxhY2UoL1xcLy9naSwnXycpLFxuXHRcdFx0XHRkYXRhOiBKU09OLnN0cmluZ2lmeShxLnF1ZXJ5KSxcblx0XHRcdFx0bmFtZTogcS5uYW1lXG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuICRodHRwLnBvc3QodGhpcy5fdXJsICsgJy9zYXEnLF9hdXgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIF9nZXRRdWVyeShwYWdlKXtcblx0XHRcdFx0cmV0dXJuICRodHRwLmdldCh0aGlzLl91cmwgKyAnL2d1bWdhdXNlcmRhdGEvYXE7JyArIHBhZ2UucmVwbGFjZSgnIycsJycpLnJlcGxhY2UoL1xcLy9naSwnXycpKTtcblx0XHR9XG5cdFx0cmV0dXJuIFJlc3RQcm90b3R5cGU7XG5cdH1cblxuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2Euc2VydmljZXMucmVzdCcsW10pXG5cdC5zZXJ2aWNlKCdHdW1nYVJlc3QnLEJhc2UpO1xuXG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0JztcblxuXG5cdFx0VHJhbnNsYXRlLiRpbmplY3Q9IFtdO1xuXHRcdGZ1bmN0aW9uIFRyYW5zbGF0ZSgpe1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0JGdldDogW1wiJGh0dHBcIiwgZnVuY3Rpb24oJGh0dHApe1xuXHRcdFx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdFx0XHQkaHR0cC5nZXQoJy9pMThuLycrc2VsZi5fbGFuZ3VhZ2UgKyAnLmpzb24nKVxuXHRcdFx0XHRcdFx0LnN1Y2Nlc3MoZnVuY3Rpb24gU3VjY2Vzc0dldCh2YWx1ZXMpe1xuXHRcdFx0XHRcdFx0XHRsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnR1VNR0EnKyBzZWxmLl9sYW5ndWFnZSxKU09OLnN0cmluZ2lmeSh2YWx1ZXMpKTtcblx0XHRcdFx0XHRcdFx0bG9jYWxTdG9yYWdlLnNldEl0ZW0oJ0dVTUdBQ3VycmVudCcsc2VsZi5fbGFuZ3VhZ2UpO1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRyZXR1cm4gc2VsZjtcblx0XHRcdFx0fV0sXG5cdFx0XHRcdHNldExhbmd1YWdlOiBmdW5jdGlvbihsYW5ndWFnZSl7XG5cdFx0XHRcdFx0aWYoIWxhbmd1YWdlKSB0aHJvdyAnWW91IG11c3QgcGFzcyBhIGxhbmd1YWdlIHRvIEd1bWdhVHJhbnNsYXRlJztcblx0XHRcdFx0XHR0aGlzLl9sYW5ndWFnZS50b0xvd2VyQ2FzZSgpICE9PSBsYW5ndWFnZS50b0xvd2VyQ2FzZSgpID8gdGhpcy5fbGFuZ3VhZ2UgPSBsYW5ndWFnZSA6IGZ1bmN0aW9uKCl7fTtcblx0XHRcdFx0fSxcblx0XHRcdFx0X2xhbmd1YWdlOiAncHQtYnInXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YW5ndWxhci5tb2R1bGUoJ2d1bWdhLnNlcnZpY2VzLnRyYW5zbGF0ZScsWydndW1nYS5zZXJ2aWNlcy50cmFuc2xhdGUuaGVscGVyJ10pXG5cdFx0LnByb3ZpZGVyKCckZ3VtZ2FUcmFuc2xhdGUnLFRyYW5zbGF0ZSlcbn0pKCk7IiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRUcmFuc2xhdGVIZWxwZXIuJGluamVjdCA9IFtdO1xuXG5cdGZ1bmN0aW9uIFRyYW5zbGF0ZUhlbHBlcigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0X3RyYW5zbGF0aW9uOiB7fSxcblx0XHRcdF9fZ2V0RnJvbUxvY2FsU3RvcmFnZTogZnVuY3Rpb24oKXtcblx0XHRcdFx0dmFyIGxhbmd1YWdlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ0dVTUdBQ3VycmVudCcpXG5cdFx0XHRcdCxcdFx0c2VsZiA9IHRoaXM7XG5cdFx0XHRcdGZ1bmN0aW9uIGl0ZXJhdGUob2JqLHN0cmluZyl7XG5cdFx0XHRcdFx0Zm9yKHZhciBrZXkgaW4gb2JqKSBpZihvYmouaGFzT3duUHJvcGVydHkoa2V5KSl7XG5cdFx0XHRcdFx0XHQodHlwZW9mIG9ialtrZXldID09ICdvYmplY3QnKSA/IFxuXHRcdFx0XHRcdFx0XHRpdGVyYXRlKG9ialtrZXldLCBzdHJpbmcgKyAnLicgKyBrZXkpIDogc2VsZi5fdHJhbnNsYXRpb25bKHN0cmluZyArICcuJyArIGtleSkuc3Vic3RyaW5nKDEpXSA9IG9ialtrZXldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZihsYW5ndWFnZSAmJiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnR1VNR0EnICsgbGFuZ3VhZ2UpKXtcblx0XHRcdFx0XHRpdGVyYXRlKEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ0dVTUdBJyArIGxhbmd1YWdlKSksJycpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0fSxcblx0XHRcdGdldFRyYW5zbGF0ZTogZnVuY3Rpb24odG9UcmFuc2xhdGUpe1xuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzZWxmLl90cmFuc2xhdGlvbikubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdHNlbGYuX19nZXRGcm9tTG9jYWxTdG9yYWdlKCk7XG5cdFx0XHRcdGlmKCF0b1RyYW5zbGF0ZSB8fCB0eXBlb2YgdG9UcmFuc2xhdGUgIT0gJ3N0cmluZycpICBcblx0XHRcdFx0XHR0aHJvdyAnVGhlIHZhbHVlIHBhc3NlZCB0byBHdW1nYVRyYW5zbGF0ZSBpcyBXcm9uZyEnO1xuXHRcdFx0XHRpZihzZWxmLl90cmFuc2xhdGlvblt0b1RyYW5zbGF0ZV0pXG5cdFx0XHRcdFx0cmV0dXJuIHNlbGYuX3RyYW5zbGF0aW9uW3RvVHJhbnNsYXRlXTtcblx0XHRcdFx0cmV0dXJuIHRvVHJhbnNsYXRlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGFuZ3VsYXIubW9kdWxlKCdndW1nYS5zZXJ2aWNlcy50cmFuc2xhdGUuaGVscGVyJyxbXSlcblx0LmZhY3RvcnkoJ0d1bWdhVHJhbnNsYXRlSGVscGVyJyxUcmFuc2xhdGVIZWxwZXIpXG5cbn0pKCk7IiwiKGZ1bmN0aW9uKCl7XG4gICd1c2Ugc3RyaWN0JztcblxuICBVdGlscy4kaW5qZWN0ID0gW107XG5cbiAgZnVuY3Rpb24gVXRpbHMoKXtcbiAgICByZXR1cm4ge1xuICAgICAgYXJlTm90RXF1YWxJbkFycmF5OiBmdW5jdGlvbiAoYXJyYXksIGluZGV4KSB7XG4gICAgICAgIHZhciBhdXggPSBhcnJheS5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudCA9PSBpbmRleDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoYXV4Lmxlbmd0aCA8IDEpO1xuICAgICAgfSxcbiAgICAgIGNhbWVsQ2FzZTogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSwgc3RyaW5nLmxlbmd0aCk7XG4gICAgICB9LFxuICAgICAgb2JqSW5BcnJheTogZnVuY3Rpb24gKGFycmF5LCBmaWVsZCkge1xuICAgICAgICB2YXIgYXJyYXlBdXggPSBhcnJheS5maWx0ZXIoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHJldHVybiBvYmouZmllbGQgPT0gZmllbGQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXJyYXlBdXgubGVuZ3RoID4gMDtcbiAgICAgIH0sXG4gICAgICBjaGVja0luZGV4OiBmdW5jdGlvbiAoYXJyYXksIHR4dCkge1xuICAgICAgICB2YXIgZmxhZyA9IC0xO1xuICAgICAgICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChvYmosIGluZGV4KSB7XG4gICAgICAgICAgaWYgKG9iai5maWVsZCA9PSB0eHQpIHtcbiAgICAgICAgICAgIGZsYWcgPSBpbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmxhZztcbiAgICAgIH0sXG4gICAgICBlcnJvck1lc3NhZ2VzOiB7XG4gICAgICAgIG1heDogXCJZb3UndmUgdHlwZWQgbW9yZSB0aGFuIHRoZSBtYXhpbXVtIVwiLFxuICAgICAgICBtaW46IFwiWW91J3ZlIHR5cGVkIGxlc3MgdGhhbiB0aGUgbWluaW11bSFcIixcbiAgICAgICAgcmVxOiBcIlRoaXMgZmllbGQgaXMgcmVxdWlyZWRcIlxuICAgICAgfVxuICAgIH1cbiAgfVxuICBhbmd1bGFyLm1vZHVsZSgnZ3VtZ2Euc2VydmljZXMudXRpbHMnLFtdKVxuICAuZmFjdG9yeSgnR3VtZ2FVdGlscycsVXRpbHMpO1xufSkoKTtcbiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cblx0V2ViU3RvcmFnZS4kaW5qZWN0ID0gW107XG5cdC8qKlxuXHQgKiBAbmdkb2Mgc2VydmljZVxuXHQgKiBAbmFtZSBndW1nYS5jb3JlOkd1bWdhV2ViU3RvcmFnZVxuXHQgKiBAZGVzY3JpcHRpb24gXG5cdCAqIFxuXHQgKiBcdE8gc2VydmljZSBHdW1nYVdlYlN0b3JhZ2Ugw6kgdXRpbGl6YWRvIHBhcmEgYWp1ZGFyIG8gZGVzZW52b2x2ZWRvciBhIHRyYWJhbGhhciBjb20gbyBzdG9yYWdlIGRvIEJyb3dzZXIuXG5cdCAqXG5cdCAqIFx0I03DqXRvZG9zXG5cdCAqXG5cdCAqXHQtLS1cblx0ICogXG5cdCAqICBgR3VtZ2FXZWJTdG9yYWdlLnNldFNlc3Npb25TdG9yYWdlSXRlbShrZXksdmFsdWUpYFxuXHQgKiAgXG5cdCAqICBPIG3DqXRvZG8gc2V0U2Vzc2lvblN0b3JhZ2VJdGVtIGFjZWl0YSBkb2lzIHBhcsOibWV0cm9zIGBrZXlgIGUgYHZhbHVlYC5cbiBcdCAqICBcblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD4gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmtleTwvbGFiZWw+IFF1YWwgbyBpZGVudGlmaWNhZG9yIGRvIHZhbG9yIHF1ZSBzZXLDoSBzYWx2by5cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPltTdHJpbmd8TnVtYmVyfE9iamVjdF08L2xhYmVsPiA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+dmFsdWU8L2xhYmVsPiBWYWxvciBxdWUgc2Vyw6Egc2Fsdm8gbm8gc2Vzc2lvblN0b3JhZ2UuXG5cdCAqICAtLS1cbiBcdCAqIFxuXHQgKiAgYEd1bWdhV2ViU3RvcmFnZS5nZXRTZXNzaW9uU3RvcmFnZUl0ZW0oa2V5KWBcblx0ICogIFxuXHQgKiAgTyBtw6l0b2RvIHNldFNlc3Npb25TdG9yYWdlSXRlbSBhY2VpdGEgdW0gcGFyw6JtZXRybyBga2V5YC5cbiBcdCAqICBcblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD4gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmtleTwvbGFiZWw+IFF1YWwgbyBpZGVudGlmaWNhZG9yIGRvIHZhbG9yIHF1ZSBzZXLDoSBzYWx2by5cblx0ICpcblx0ICogICMjIyBSZXRvcm5vXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5bU3RyaW5nfE51bWJlcnxPYmplY3RdPC9sYWJlbD4gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmtleTwvbGFiZWw+IFJldG9ybmEgbyB2YWxvciBxdWUgZXN0aXZlciBuYSBzZXNzaW9uU3RvcmFnZSBkYXF1ZWxhIGtleSBlc3BlY8OtZmljYS4gQ2FzbyBuw6NvIGVuY29udHJlLFxuXHQgKiAgbyB2YWxvciByZXRvcm5hZG8gw6kgbnVsbC5cblx0ICogIC0tLVxuXHQgKlxuIFx0ICogIGBHdW1nYVdlYlN0b3JhZ2UucmVtb3ZlU2Vzc2lvblN0b3JhZ2VJdGVtKGtleSlgXG5cdCAqICBcblx0ICogIE8gbcOpdG9kbyByZW1vdmVTZXNzaW9uU3RvcmFnZUl0ZW0gYWNlaXRhIHVtIHBhcsOibWV0cm8gYGtleWAuXG4gXHQgKiAgXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+IDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5rZXk8L2xhYmVsPiBRdWFsIG8gaWRlbnRpZmljYWRvciBkbyB2YWxvciBxdWUgc2Vyw6EgcmVtb3ZpZG8gZGEgc2Vzc2lvblN0b3JhZ2UuXG5cdCAqXG5cdCAqICAtLS0gXG5cdCAqXG5cdCAqICBgR3VtZ2FXZWJTdG9yYWdlLmNsZWFyU2Vzc2lvblN0b3JhZ2UoKWBcblx0ICogIFxuXHQgKiAgTyBtw6l0b2RvIGNsZWFyU2Vzc2lvblN0b3JhZ2UgbsOjbyBhY2VpdGEgbmVuaHVtIHBhcsOibWV0cm8gZSBsaW1wYSBhIHNlc3Npb25TdG9yYWdlLlxuIFx0ICogIFxuXHQgKiAgLS0tIFxuXHQgKlxuIFx0ICpcblx0ICogIGBHdW1nYVdlYlN0b3JhZ2UuZ2V0TnVtYmVyT2ZJdGVtc0luU2Vzc2lvblN0b3JhZ2UoKWBcblx0ICogIFxuXHQgKiAgTyBtw6l0b2RvIGdldE51bWJlck9mSXRlbXNJblNlc3Npb25TdG9yYWdlIG7Do28gYWNlaXRhIG5lbmh1bSBwYXLDom1ldHJvLCBlIHJldG9ybmEgbyBuw7ptZXJvIGRlIGl0ZW5zIG5vIGxvY2FsU3RvcmFnZS5cbiBcdCAqICBcblx0ICogIC0tLSBcblx0ICpcbiBcdCAqIFxuXHQgKiAgYEd1bWdhV2ViU3RvcmFnZS5zZXRMb2NhbFN0b3JhZ2VJdGVtKGtleSx2YWx1ZSlgXG5cdCAqICBcblx0ICogIE8gbcOpdG9kbyBzZXRMb2NhbFN0b3JhZ2VJdGVtIGFjZWl0YSBkb2lzIHBhcsOibWV0cm9zIGBrZXlgIGUgYHZhbHVlYC5cbiBcdCAqICBcblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD4gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmtleTwvbGFiZWw+IFF1YWwgbyBpZGVudGlmaWNhZG9yIGRvIHZhbG9yIHF1ZSBzZXLDoSBzYWx2by5cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPltTdHJpbmd8TnVtYmVyfE9iamVjdF08L2xhYmVsPiA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+dmFsdWU8L2xhYmVsPiBWYWxvciBxdWUgc2Vyw6Egc2Fsdm8gbm8gTG9jYWxTdG9yYWdlLlxuXHQgKiAgLS0tXG4gXHQgKiBcblx0ICogIGBHdW1nYVdlYlN0b3JhZ2UuZ2V0TG9jYWxTdG9yYWdlSXRlbShrZXkpYFxuXHQgKiAgXG5cdCAqICBPIG3DqXRvZG8gc2V0TG9jYWxTdG9yYWdlSXRlbSBhY2VpdGEgdW0gcGFyw6JtZXRybyBga2V5YC5cbiBcdCAqICBcblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD4gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmtleTwvbGFiZWw+IFF1YWwgbyBpZGVudGlmaWNhZG9yIGRvIHZhbG9yIHF1ZSBzZXLDoSBzYWx2by5cblx0ICpcblx0ICogICMjIyBSZXRvcm5vXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5bU3RyaW5nfE51bWJlcnxPYmplY3RdPC9sYWJlbD4gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmtleTwvbGFiZWw+IFJldG9ybmEgbyB2YWxvciBxdWUgZXN0aXZlciBuYSBMb2NhbFN0b3JhZ2UgZGFxdWVsYSBrZXkgZXNwZWPDrWZpY2EuIENhc28gbsOjbyBlbmNvbnRyZSxcblx0ICogIG8gdmFsb3IgcmV0b3JuYWRvIMOpIG51bGwuXG5cdCAqICAtLS1cblx0ICpcbiBcdCAqICBgR3VtZ2FXZWJTdG9yYWdlLnJlbW92ZUxvY2FsU3RvcmFnZUl0ZW0oa2V5KWBcblx0ICogIFxuXHQgKiAgTyBtw6l0b2RvIHJlbW92ZUxvY2FsU3RvcmFnZUl0ZW0gYWNlaXRhIHVtIHBhcsOibWV0cm8gYGtleWAuXG4gXHQgKiAgXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+IDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5rZXk8L2xhYmVsPiBRdWFsIG8gaWRlbnRpZmljYWRvciBkbyB2YWxvciBxdWUgc2Vyw6EgcmVtb3ZpZG8gZGEgTG9jYWxTdG9yYWdlLlxuXHQgKlxuXHQgKiAgLS0tIFxuXHQgKlxuXHQgKiAgYEd1bWdhV2ViU3RvcmFnZS5jbGVhckxvY2FsU3RvcmFnZSgpYFxuXHQgKiAgXG5cdCAqICBPIG3DqXRvZG8gY2xlYXJMb2NhbFN0b3JhZ2UgbsOjbyBhY2VpdGEgbmVuaHVtIHBhcsOibWV0cm8gZSBsaW1wYSBvIGxvY2FsU3RvcmFnZS5cbiBcdCAqICBcblx0ICogIC0tLSBcbiBcdCAqXG5cdCAqICBgR3VtZ2FXZWJTdG9yYWdlLmdldE51bWJlck9mSXRlbXNJbkxvY2FsU3RvcmFnZSgpYFxuXHQgKiAgXG5cdCAqICBPIG3DqXRvZG8gZ2V0TnVtYmVyT2ZJdGVtc0luTG9jYWxTdG9yYWdlIG7Do28gYWNlaXRhIG5lbmh1bSBwYXLDom1ldHJvLCBlIHJldG9ybmEgbyBuw7ptZXJvIGRlIGl0ZW5zIG5vIGxvY2FsU3RvcmFnZS5cbiBcdCAqICBcblx0ICogIC0tLSBcblx0ICovXG5cdGZ1bmN0aW9uIFdlYlN0b3JhZ2UoKXtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2V0U2Vzc2lvblN0b3JhZ2VJdGVtOiBmdW5jdGlvbihrZXksdmFsdWUpe1xuXHRcdFx0XHR2YXIgX3ZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdGlmKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jyl7XG5cdFx0XHRcdFx0X3ZhbHVlID0gYW5ndWxhci50b0pzb24odmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKGtleSxfdmFsdWUpO1xuXHRcdFx0fSxcblx0XHRcdGdldFNlc3Npb25TdG9yYWdlSXRlbTogZnVuY3Rpb24oa2V5KXtcblx0XHRcdFx0dmFyIGcgPSB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuXHRcdFx0XHRpZighZyl7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRhbmd1bGFyLmZyb21Kc29uKGcpO1xuXHRcdFx0XHR9Y2F0Y2goZSl7XG5cdFx0XHRcdFx0cmV0dXJuIGc7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGFuZ3VsYXIuZnJvbUpzb24oZyk7XG5cdFx0XHR9LFxuXHRcdFx0cmVtb3ZlU2Vzc2lvblN0b3JhZ2VJdGVtOiBmdW5jdGlvbihrZXkpe1xuXHRcdFx0XHR3aW5kb3cuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuXHRcdFx0fSxcblx0XHRcdGNsZWFyU2Vzc2lvblN0b3JhZ2U6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5jbGVhcigpO1xuXHRcdFx0fSxcblx0XHRcdGdldE51bWJlck9mSXRlbXNJblNlc3Npb25TdG9yYWdlOiBmdW5jdGlvbigpe1xuXHRcdFx0XHRyZXR1cm4gd2luZG93LnNlc3Npb25TdG9yYWdlLmxlbmd0aDtcblx0XHRcdH0sXG5cdFx0XHRzZXRMb2NhbFN0b3JhZ2VJdGVtOiBmdW5jdGlvbihrZXksdmFsdWUpe1xuXHRcdFx0XHR3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LGFuZ3VsYXIudG9Kc29uKHZhbHVlKSk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0TG9jYWxTdG9yYWdlSXRlbTogZnVuY3Rpb24oa2V5KXtcblx0XHRcdFx0dmFyIGcgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRhbmd1bGFyLmZyb21Kc29uKGcpO1xuXHRcdFx0XHR9Y2F0Y2goZSl7XG5cdFx0XHRcdFx0cmV0dXJuIGc7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGFuZ3VsYXIuZnJvbUpzb24oZyk7XG5cdFx0XHR9LFxuXHRcdFx0cmVtb3ZlTG9jYWxTdG9yYWdlSXRlbTogZnVuY3Rpb24oa2V5KXtcblx0XHRcdFx0d2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG5cdFx0XHR9LFxuXHRcdFx0Y2xlYXJMb2NhbFN0b3JhZ2U6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHdpbmRvdy5sb2NhbFN0b3JhZ2UuY2xlYXIoKTtcblx0XHRcdH0sXG5cdFx0XHRnZXROdW1iZXJPZkl0ZW1zSW5Mb2NhbFN0b3JhZ2U6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLmxlbmd0aDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2Euc2VydmljZXMud2Vic3RvcmFnZScsW10pXG5cdC5mYWN0b3J5KCdHdW1nYVdlYlN0b3JhZ2UnLFdlYlN0b3JhZ2UpXG59KSgpOyIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG4gICAvKipcbiAgICAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAgICAqIEBuYW1lIGd1bWdhLmNvcmU6Z3VtZ2FFcnJvclxuICAgICogQGVsZW1lbnQgaW5wdXRcbiAgICAqIEByZXN0cmljdCBBXG4gICAgKiBAZGVzY3JpcHRpb24gTyBjb21wb25lbnRlIGd1bWdhRXJyb3Igc2VydmUgcGFyYSBtb3N0cmFyIG1lbnNhZ2VucyBkZSB2YWxpZGHDp8O1ZXMgYWJhaXhvIGRvIGlucHV0IHJlc3BvbnPDoXZlbCBwZWxvIGVycm8uXG4gICAgKlxuICAgICogQGV4YW1wbGVcbiAgICAqICBVbSBleGVtcGxvIGRhIGRpcmVjdGl2ZSBndW1nYUVycm9yIGZ1bmNpb25hbmRvIHBvZGUgc2VyIGVuY29udHJhZG8gW2FxdWldKGh0dHA6Ly9lbWJlZC5wbG5rci5jby9BY2pxY2d2Z0doZEpxRGg3MmVIQSkuXG4gICAgKiAgPHByZT5cbiAgICAqICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIj5cbiAgICAqICAgICAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiBuYW1lPVwibWluTnVtYmVyXCIgbmctbW9kZWw9XCJtaW5OdW1iZXJcIiBndW1nYS1lcnJvciBndW1nYS1taW4tbnVtYmVyPVwiMjBcIj5cbiAgICAqICAgIDwvZm9ybT5cbiAgICAqICA8L3ByZT5cbiAgICovXG4gIEVycm9yLiRpbmplY3QgPSBbXCIkY29tcGlsZVwiXTtcbiAgZnVuY3Rpb24gRXJyb3IoJGNvbXBpbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdBJyxcblx0XHRcdHNjb3BlOiB7fSxcbiAgICAgIHJlcXVpcmU6ICdeZm9ybScsXG4gICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsbSwgYXR0cnMsIGN0cmwpIHtcblx0XHRcdFx0c2NvcGUuZXJyb3JzID0gW107XG5cblx0XHRcdFx0c2NvcGUuZXJyb3JzQ29udGFpbnMgPSBmdW5jdGlvbihlcnJvcnMsIGVycm9yKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgayBpbiBlcnJvcnMpIHtcblx0XHRcdFx0XHRcdGlmIChhbmd1bGFyLmVxdWFscyhlcnJvcnNba10sIGVycm9yKSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUuYWRkRXJyb3IgPSBmdW5jdGlvbihlcnJvcikge1xuXHRcdFx0XHRcdGlmICghc2NvcGUuZXJyb3JzQ29udGFpbnMoc2NvcGUuZXJyb3JzLCBlcnJvcikpIHtcblx0XHRcdFx0XHRcdHNjb3BlLmVycm9ycy5wdXNoKGVycm9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5yZW1vdmVFcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7XG5cdFx0XHRcdFx0dmFyIGVycm9yQ29weSA9IGFuZ3VsYXIuY29weShlcnJvcik7XG5cdFx0XHRcdFx0ZXJyb3JDb3B5LnZhbGlkID0gIWVycm9yQ29weS52YWxpZDtcblx0XHRcdFx0XHR2YXIgZXhpc3QgPSBzY29wZS5lcnJvcnNDb250YWlucyhzY29wZS5lcnJvcnMsIGVycm9yQ29weSk7XG5cdFx0XHRcdFx0aWYgKGV4aXN0KSB7XG5cdFx0XHRcdFx0XHRzY29wZS5lcnJvcnMuc3BsaWNlKGV4aXN0LCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c2NvcGUuJG9uKCckZXJyb3JNZXNzYWdlJywgZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgICBpZiAoZWxtWzBdLm5hbWUgPT0gZGF0YS5uYW1lKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS52YWxpZCA9PSBmYWxzZSkge1xuICBcdFx0XHRcdFx0XHRzY29wZS5hZGRFcnJvcihkYXRhKTtcbiAgXHRcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRcdHNjb3BlLnJlbW92ZUVycm9yKGRhdGEpO1xuICBcdFx0XHRcdFx0fVxuICAgICAgICAgIH1cblx0XHRcdFx0fSk7XG5cbiAgICAgICAgdmFyIHRlbXBsYXRlID0gJzxvbCBjbGFzcz1cImxpc3QtZXJyb3JzIHRleHQtZGFuZ2VyXCI+PGxpIG5nLXJlcGVhdD1cImVycm9yIGluIGVycm9yc1wiID57eyBlcnJvci5maWVsZE1lc3NhZ2UgfX08L2xpPjwvb2w+JztcbiAgICAgICAgZWxtLmFmdGVyKCRjb21waWxlKHRlbXBsYXRlKShzY29wZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtLmVycm9yJyxbXSlcblx0LmRpcmVjdGl2ZSgnZ3VtZ2FFcnJvcicsRXJyb3IpO1xufSkoKTtcbiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cdC8qKlxuXHQgKiBAbmdkb2MgZGlyZWN0aXZlXG5cdCAqIEBuYW1lIGd1bWdhLmNvcmU6Z3VtZ2FFcnJvcnNcblx0ICogQHJlc3RyaWN0IEVcblx0ICogQGRlc2NyaXB0aW9uIE8gY29tcG9uZW50ZSBndW1nYUVycm9ycyBzZXJ2ZSBwYXJhIG1vc3RyYXIgdG9kYXMgbWVuc2FnZW5zIGRlIHZhbGlkYcOnw7VlcyBkbyBmb3JtdWzDoXJpbyBkZSBmb3JtYSBhZ3J1cGFkYS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHBsYWNlbWVudCBPbmRlIGlyw6EgYXBhcmVjZXIsIG8gcGFkcsOjbyDDqSB0b3AsIG1hcyB0YW1iw6ltIGFjZWl0YSByaWdodCwgYm90dG9tIGUgbGVmdC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IGljb24gw41jb25lIGRvIGJvdMOjbywgcG9yIHBhZHLDo28gw6kgZ2x5cGhpY29uIGdseXBoaWNvbi1pbmZvLXNpZ25cblx0ICogQHBhcmFtIHtTdHJpbmd9IGxhYmVsIFRleHRvIGRvIGJvdMOjb1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGl0bGUgVMOtdHVsbyBkbyBwb3BvdmVyIGRlIGVycm9zXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqICBVbSBleGVtcGxvIGRhIGRpcmVjdGl2ZSBndW1nYUVycm9ycyBmdW5jaW9uYW5kbyBwb2RlIHNlciBlbmNvbnRyYWRvIFthcXVpXShodHRwOi8vZW1iZWQucGxua3IuY28vQWNqcWNndmdHaGRKcURoNzJlSEEpLlxuXHQgKiAgPHByZT5cblx0ICogICAgPGZvcm0gbmFtZT1cIm15Rm9ybVwiPlxuXHQgKiAgICAgIDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbmFtZT1cIm1pbk51bWJlclwiIG5nLW1vZGVsPVwibWluTnVtYmVyXCIgZ3VtZ2EtbWluLW51bWJlcj1cIjIwXCI+XG5cdCAqICAgICAgPGd1bWdhLWVycm9ycyBwbGFjZW1lbnQ9XCJyaWdodFwiIGljb249XCJnbHlwaGljb24gZ2x5cGhpY29uLWluZm8tc2lnblwiIGxhYmVsPVwiQ2FtcG9zIGludsOhbGlkb3NcIiB0aXRsZT1cIkNhbXBvcyBpbnbDoWxpZG9zXCI+PC9ndW1nYS1lcnJvcnM+XG5cdCAqICAgIDwvZm9ybT5cblx0ICogIDwvcHJlPlxuXHQqL1xuXHRFcnJvcnMuJGluamVjdCA9IFtcIiRjb21waWxlXCJdO1xuICBmdW5jdGlvbiBFcnJvcnMoJGNvbXBpbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdFJyxcblx0XHRcdHNjb3BlOiB7XG5cdFx0XHRcdGVycm9yczogJz0nXG5cdFx0XHR9LFxuICAgICAgcmVxdWlyZTogJ15mb3JtJyxcbiAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxtLCBhdHRycywgY3RybCkge1xuXHRcdFx0XHRzY29wZS5lcnJvcnMgPSBbXTtcblxuXHRcdFx0XHRzY29wZS5lcnJvcnNDb250YWlucyA9IGZ1bmN0aW9uKGVycm9ycywgZXJyb3IpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBrIGluIGVycm9ycykge1xuXHRcdFx0XHRcdFx0aWYgKGFuZ3VsYXIuZXF1YWxzKGVycm9yc1trXSwgZXJyb3IpKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5hZGRFcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7XG5cdFx0XHRcdFx0aWYgKCFzY29wZS5lcnJvcnNDb250YWlucyhzY29wZS5lcnJvcnMsIGVycm9yKSkge1xuXHRcdFx0XHRcdFx0c2NvcGUuZXJyb3JzLnB1c2goZXJyb3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLnJlbW92ZUVycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcblx0XHRcdFx0XHQvLyBlcnJvci52YWxpZCA9ICFlcnJvci52YWxpZDtcblx0XHRcdFx0XHR2YXIgZXJyb3JDb3B5ID0gYW5ndWxhci5jb3B5KGVycm9yKTtcblx0XHRcdFx0XHRlcnJvckNvcHkudmFsaWQgPSAhZXJyb3JDb3B5LnZhbGlkO1xuXHRcdFx0XHRcdHZhciBleGlzdCA9IHNjb3BlLmVycm9yc0NvbnRhaW5zKHNjb3BlLmVycm9ycywgZXJyb3JDb3B5KTtcblx0XHRcdFx0XHRpZiAoZXhpc3QpIHtcblx0XHRcdFx0XHRcdHNjb3BlLmVycm9ycy5zcGxpY2UoZXhpc3QsIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzY29wZS4kb24oJyRlcnJvck1lc3NhZ2UnLCBmdW5jdGlvbihldmVudCwgZGF0YSkge1xuXHRcdFx0XHRcdGlmIChkYXRhLnZhbGlkID09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRzY29wZS5hZGRFcnJvcihkYXRhKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2NvcGUucmVtb3ZlRXJyb3IoZGF0YSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR2YXIgdGl0bGUgPSBhdHRycy50aXRsZSB8fCAnRXJyb3MnO1xuXHRcdFx0XHR2YXIgcGxhY2VtZW50ID0gYXR0cnMucGxhY2VtZW50IHx8ICd0b3AnO1xuXHRcdFx0XHR2YXIgaWNvbiA9IGF0dHJzLmljb24gfHwgJ2dseXBoaWNvbiBnbHlwaGljb24taW5mby1zaWduJztcblxuXHRcdFx0XHR2YXIgdGVtcGxhdGUgPSBbXG5cdFx0XHRcdFx0JzxidXR0b24gcG9wb3Zlci1wbGFjZW1lbnQ9XCInK3BsYWNlbWVudCsnXCIgcG9wb3Zlci10ZW1wbGF0ZT1cIlxcJ3RlbXBsYXRlLmh0bWxcXCdcIiBwb3BvdmVyLXRpdGxlPVwiJyt0aXRsZSsnXCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1zbSBidG4tZGFuZ2VyXCI+J1xuXHRcdFx0XHQsXHQnPGkgY2xhc3M9XCInK2ljb24rJ1wiPjwvaT4nXG5cdFx0XHRcdCwgYXR0cnMubGFiZWxcblx0XHRcdFx0LFx0JzwvYnV0dG9uPidcblx0XHRcdFx0LFx0JzxzY3JpcHQgaWQ9XCJ0ZW1wbGF0ZS5odG1sXCIgdHlwZT1cInRleHQvbmctdGVtcGxhdGVcIj4nXG5cdFx0XHRcdCxcdCc8b2wgY2xhc3M9XCJsaXN0LWVycm9ycyB0ZXh0LWRhbmdlclwiPjxsaSBuZy1yZXBlYXQ9XCJlcnJvciBpbiBlcnJvcnNcIiA+e3sgZXJyb3IubWVzc2FnZSB9fTwvbGk+PC9vbD4nXG5cdFx0XHRcdCxcdCc8L3NjcmlwdD4nXG5cdFx0XHRcdF0uam9pbihcIlxcblwiKTtcblx0XHRcdFx0ZWxtLmFwcGVuZCgkY29tcGlsZSh0ZW1wbGF0ZSkoc2NvcGUpKTtcblxuICAgICAgfVxuICAgIH1cbiAgfVxuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtLmVycm9ycycsWyd1aS5ib290c3RyYXAnXSlcblx0LmRpcmVjdGl2ZSgnZ3VtZ2FFcnJvcnMnLEVycm9ycyk7XG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0Jztcblx0Rm9ybS4kaW5qZWN0ID0gW1wiJHRpbWVvdXRcIiwgXCIkcm9vdFNjb3BlXCJdO1xuXHQvKipcblx0KiBAbmdkb2MgZGlyZWN0aXZlXG5cdCogQG5hbWUgZ3VtZ2EuY29yZTpndW1nYUZvcm1cblx0KiBAcmVzdHJpY3QgQVxuXHQqIEBlbGVtZW50IGZvcm1cblx0KiBAZGVzY3JpcHRpb24gQSBkaXJlY3RpdmUgZ3VtZ2FGb3JtIMOpIHV0aWxpemFkYSBlbSBjb25qdW50byBjb20gYXMgZGlyZWN0aXZlcyBkZSB2YWxpZGHDp8OjbyBkZSBpbnB1dC4gRWxhIGNvbnTDqW0gZnVuw6fDtWVzIHF1ZSBzZXLDo29cblx0KiB1c2FkYXMgcGFyYSBtYW5pcHVsYXIgbyBmb3JtdWzDoXJpby4gRWxhIGV4cMO1ZSBubyAkc2NvcGUgdW0gb2JqZXRvIEd1bWdhRm9ybSBwYXJhIGFncnVwYXIgYXMgZnVuw6fDtWVzIGVtIHVtIGx1Z2FyIHPDsy5cblx0KlxuXHQqXHQjIENvbW8gdXRpbGl6YXJcblx0KlxuXHQqIE8gY29tcG9uZW50ZSBHdW1nYUZvcm0gZGV2ZSBzZXIgaW5jbHXDrWRvIG5vIGVsZW1lbnRvIGBmb3JtYCwgcXVlIG5lY2Vzc2l0YSB0ZXIgdW0gYXRyaWJ1dG8gbmFtZS4gw4kgbmVjZXNzw6FyaW8gdGFtYsOpbSBxdWUgb3MgaW5wdXRzIHF1ZSBzZXLDo28gdXRpbGl6YWRvcyB0ZW5oYW0gdW0gYXRyaWJ1dG8gbmFtZSxcblx0KiBwb2lzIG8gY29udHJvbGUgZGVsZXMgw6kgZmVpdG8gYSBwYXJ0aXIgZGVzdGUgYXRyaWJ1dG8uXG5cdCpcblx0Klx0PHByZT5cblx0KiAgPGZvcm0gbmFtZT1cIlVzZXJGb3JtXCIgZ3VtZ2EtZm9ybT5cblx0Klx0ICAgLi4uXG5cdCogIDwvZm9ybT5cblx0KiA8L3ByZT5cblx0KlxuXHQqXHQjIE3DqXRvZG9zXG5cdCpcblx0KmAkc2NvcGUuR3VtZ2FGb3JtLmdldE1lc3NhZ2VzKG5hbWUsZXJyb3IpYFxuICAqXG4gICogIE8gbcOpdG9kbyBgZ2V0TWVzc2FnZXNgIGFjZWl0YSBkb2lzIHBhcsOibWV0cm9zIGBuYW1lYCBlIGBlcnJvcmAsIG9uZGUgbmFtZSDDqSBvIG5vbWUgZG8gaW5wdXQgcXVlIGRlc2VqYWRhXG4gICogIHJlY3VwZXJhciBhIG1lbnNhZ2VtIGUgbyBlcnJvLiBDYXNvIG8gcGFyw6JtZXRybyBlcnJvciBuw6NvIHNlamEgcGFzc2Fkbywgw6kgcmV0b3JuYWRvIG8gb2JqZXRvIGNvbSB0b2RhcyBhcyBtZW5zYWdlbnMgZG8gY2FtcG8uXG4gICogICMjIyBQYXLDom1ldHJvc1xuICAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5uYW1lPC9sYWJlbD4gU3RyaW5nIHF1ZSB0ZXLDoSBvIG5vbWUgZG8gaW4gcHV0IHBhcmEgcmV0b3JuYXIgb3MgZXJyb3JzLlxuICAqICAgUGFyYSBhZGljaW9uYXIgYSBmdW7Dp8OjbywgY29sb3F1ZSBvIG5vbWUgZGEgZnVuw6fDo28gZSBvIHZhbG9yIGRlbGUgY29tbyBgdHJ1ZWBcblx0KiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+ZXJyb3I8L2xhYmVsPiBTdHJpbmcgcXVlIHNlcsOhIHRlcsOhIG8gbm9tZSBkbyBlcnJvIHF1ZSBzZXLDoSByZXRvcm5hZG8uIENhc29cblx0KiAgbsOjbyBzZWphIHBhc3NhZG8gZXN0ZSBwYXLDom1ldHJvLCBzZXLDoSByZXRvcm5hZG8gdW0gb2JqZXRvIGNvbSB0b2RvcyBvcyBlcnJvcy5cbiAgKiBcdCMjIyBSZXRvcm5vXG4gICpcbiAgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+W09iamVjdHxTdHJpbmddPC9sYWJlbD4gU3RyaW5nIHF1ZSBjb250ZXLDoSBhIG1lbnNhZ2VtIGRlIGVycm8gb3UgbyBvYmpldG8gY29tIHRvZGFzIGFzIG1lbnNhZ2VucyBkZSBlcnJvLlxuXHQqXG5cdCogLS0tLVxuXHQqXG5cdCpgJHNjb3BlLkd1bWdhRm9ybS5jaGFuZ2VNZXNzYWdlKG5hbWUsZXJyb3IsbWVzc2FnZSlgXG5cdCpcblx0KiAgTyBtw6l0b2RvIGBjaGFuZ2VNZXNzYWdlYCBhY2VpdGEgdHLDqnMgcGFyw6JtZXRyb3MsIGBuYW1lYCxgZXJyb3JgIGUgYG1lc3NhZ2VgLCBvbmRlIGBuYW1lYCDDqSBvIG5vbWUgZG8gaW5wdXQgcXVlIGRlc2VqYWRhXG5cdCogIHJlY3VwZXJhciBhIG1lbnNhZ2VtLCBgZXJyb3JgIMOpIHF1YWwgZXJybyBxdWUgYSBtZW5zYWdlbSBzZXLDoSBhbHRlcmFkYSBlIGBtZXNzYWdlYCBxdWFsIHNlcsOhIGEgbm92YSBtZW5zYWdlbSAuXG5cdCogICMjIyBQYXLDom1ldHJvc1xuXHQqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5uYW1lPC9sYWJlbD4gU3RyaW5nIHF1ZSB0ZXLDoSBvIG5vbWUgZG8gaW5wdXQgcGFyYSByZXRvcm5hciBvcyBlcnJvcnMuXG5cdCogICBQYXJhIGFkaWNpb25hciBhIGZ1bsOnw6NvLCBjb2xvcXVlIG8gbm9tZSBkYSBmdW7Dp8OjbyBlIG8gdmFsb3IgZGVsZSBjb21vIGB0cnVlYFxuXHQqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5lcnJvcjwvbGFiZWw+IFN0cmluZyBxdWUgc2Vyw6EgdGVyw6EgbyBub21lIGRvIGVycm8gcXVlIHNlcsOhIHJldG9ybmFkby4gQ2Fzb1xuXHQqICBuw6NvIHNlamEgcGFzc2FkbyBlc3RlIHBhcsOibWV0cm8sIHNlcsOhIHJldG9ybmFkbyB1bSBvYmpldG8gY29tIHRvZG9zIG9zIGVycm9zLlxuXHQqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5tZXNzYWdlPC9sYWJlbD4gU3RyaW5nIHF1ZSBzZXLDoSB1c2FkYSBjb21vIG1lbnNhZ2VtIGRlIGVycm8gcGFyYSBhIGRpcmVjdGl2ZS5cblx0KiBcdCMjIyBSZXRvcm5vXG5cdCpcblx0KiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+Qm9vbGVhbjwvbGFiZWw+IFRydWUgY2FzbyBhIG1lbnNhZ2VtIHRlbmhhIHNpZG8gYWx0ZXJhZGEsIEZhbHNlIGNhc28gbsOjby5cblx0KlxuXHQqIC0tLS1cblx0KlxuXHQqYCRzY29wZS5HdW1nYUZvcm0uc2V0Rm9ybVZhbGlkKClgXG5cdCpcblx0KiAgTyBtw6l0b2RvIGBzZXRGb3JtVmFsaWRgIMOpIHV0aWxpemFkbyBwYXJhIGxpbXBhciB0b2RvcyBvcyBlcnJvcyBxdWUgZXN0aXZlcmVtIGF0aXZvcyBubyBmb3JtdWzDoXJpby4gRWxlIHBlcmNvcnJlIG8gb2JqZXRvIGRlIGVycm8gcXVlIG8gQW5ndWxhci5qcyBjcmlhIGF1dG9tYXRpY2FtZW50ZSBlIHZhbGlkYSB0b2RvcyBvcyBjYW1wb3Ncblx0KiAgcXVlIGVzdGl2ZXJlbSBjb20gZXJyby5cblx0KlxuXHQqIC0tLS1cbiAgKlxuXHQqYCRzY29wZS5HdW1nYUZvcm0uc2V0Rm9ybVByaXN0aW5lKClgXG5cdCpcblx0KiAgTyBtw6l0b2RvIGBzZXRGb3JtUHJpc3RpbmVgIMOpIHV0aWxpemFkbyBwYXJhIGNvbG9jYXIgdG9kb3Mgb3MgY2FtcG9zIGVtIHVtIGVzdGFkbyBkZSAkcHJpc3RpbmUsIG91IHNlamEsIHF1YW5kbyBhaW5kYSBuw6NvIGZvcmFtIGF0dWFsaXphZG9zIHBlbG8gdXN1w6FyaW8uXG5cdCpcblx0KiAtLS0tXG5cdCpcblx0KmAkc2NvcGUuR3VtZ2FGb3JtLmNsZWFyRm9ybSgpYFxuXHQqXG5cdCogIE8gbcOpdG9kbyBgY2xlYXJGb3JtYCDDqSB1dGlsaXphZG8gcGFyYSBsaW1wYXIgdG9kb3Mgb3MgY2FtcG9zIGRvIGZvcm11bMOhcmlvIGUsIGFsw6ltIGRpc3NvLCBjb2xvY2FyIGVsZXMgZW0gdW0gZXN0YWRvIGRlICRwcmlzdGluZS5cblx0KlxuXHQqIC0tLS1cblx0KlxuXHQqYCRzY29wZS5HdW1nYUZvcm0uZ2V0Rm9ybUVycm9ycygpYFxuXHQqXG5cdCogIE8gbcOpdG9kbyBgZ2V0Rm9ybUVycm9yc2Agw6kgdXRpbGl6YWRvIHBhcmEgcXVhbmRvIGRlc2VqYS1zZSBvYnRlciB0b2RvcyBvcyBlcnJvcyBxdWUgZXN0w6NvIHByZXNlbnRlcyBubyBmb3JtdWzDoXJpby5cblx0KlxuXHQqICMjIyBSZXRvcm5vXG5cdCpcblx0KiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+W0FycmF5XTwvbGFiZWw+IExpc3RhIHF1ZSBpcsOhIGNvbnRlciB0b2RvcyBvcyBlcnJvcyBxdWUgZXN0w6NvIG5vIGZvcm11bMOhcmlvLlxuXHQqXG5cdCogLS0tLVxuXHQqL1xuXHRmdW5jdGlvbiBGb3JtKCR0aW1lb3V0LCRyb290U2NvcGUpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0cmVzdHJpY3Q6ICdBJyxcblx0XHRcdHJlcXVpcmU6ICdeZm9ybScsXG5cdFx0XHRzY29wZTogZmFsc2UsXG5cdFx0XHRsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxtLCBhdHRycywgY3RybCkge1xuXHRcdFx0XHRpZighYXR0cnMubmFtZSkgdGhyb3cgJ8OJIG5lY2Vzc8OhcmlvIHBhc3NhciB1bSB2YWxvciBwYXJhIG8gYXRyaWJ1dG8gXCJuYW1lXCIgZG8gZWxlbWVudCA8Zm9ybT4nO1xuXHRcdFx0XHRzY29wZS5HdW1nYUZvcm0gPSB7fTtcblx0XHRcdFx0dmFyIF9mb3JtID0gc2NvcGVbYXR0cnMubmFtZV07XG5cdFx0XHRcdHZhciBfZm9ybUNvbnRyb2xsZXJzID0gW107XG5cdFx0XHRcdChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRhbmd1bGFyLmZvckVhY2goZWxtLmZpbmQoJ2lucHV0JyksZnVuY3Rpb24oaW5wdXQpe1xuXHRcdFx0XHRcdFx0X2Zvcm1Db250cm9sbGVycy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0bmFtZTogYW5ndWxhci5lbGVtZW50KGlucHV0KS5jb250cm9sbGVyKCduZ01vZGVsJykuJG5hbWUsXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2xsZXI6IGFuZ3VsYXIuZWxlbWVudChpbnB1dCkuY29udHJvbGxlcignbmdNb2RlbCcpLFxuXHRcdFx0XHRcdFx0XHRlcnJvck1lc3NhZ2VzOiB7XG5cdFx0XHRcdFx0XHRcdFx0bWF4ZGF0ZTogJ0EgZGF0YSBlc3BlY2lmaWNhZGEgbm8gY2FtcG8gezB9IG7Do28gZGV2ZSB1bHRyYXBhc3NhciBvIGxpbWl0ZSBkZTogezF9LicsXG5cdFx0XHRcdFx0XHRcdFx0bWF4bGVuZ3RoOiAnTyB0ZXh0byBlc3BlY2lmaWNhZG8gbm8gY2FtcG8gezB9IG7Do28gZGV2ZSB1bHRyYXBhc3NhciBvIGxpbWl0ZSBkZTogezF9LicsXG5cdFx0XHRcdFx0XHRcdFx0bWF4bnVtYmVyOiAnTyBuw7ptZXJvIGVzcGVjaWZpY2FkbyBubyBjYW1wbyB7MH0gbsOjbyBkZXZlIHVsdHJhcGFzc2FyIG8gbGltaXRlIGRlOiB7MX0uJyxcblx0XHRcdFx0XHRcdFx0XHRtaW5kYXRlOiAnQSBkYXRhIGVzcGVjaWZpY2FkYSBubyBjYW1wbyB7MH0gbsOjbyBkZXZlIHNlciBtZW5vciBxdWUgbyBsaW1pdGUgbcOtbmltbyBkZTogezF9LicsXG5cdFx0XHRcdFx0XHRcdFx0bWlubGVuZ3RoOiAnTyB0ZXh0byBlc3BlY2lmaWNhZG8gbm8gY2FtcG8gezB9IG7Do28gZGV2ZSBzZXIgbWVub3IgcXVlIG8gbGltaXRlIG3DrW5pbW8gZGU6IHsxfS4nLFxuXHRcdFx0XHRcdFx0XHRcdG1pbm51bWJlcjogJ08gbsO6bWVybyBlc3BlY2lmaWNhZG8gbm8gY2FtcG8gezB9IG7Do28gZGV2ZSBzZXIgbWVub3IgcXVlIG8gbGltaXRlIG3DrW5pbW8gZGU6IHsxfS4nLFxuXHRcdFx0XHRcdFx0XHRcdHBhdHRlcm46ICdPIHRleHRvIGVzcGVjaWZpY2FkbyBubyBjYW1wbyB7MH0gZGV2ZSBlc3RhciBkZW50cm8gZG8gcGFkcsOjbzogezF9LicsXG5cdFx0XHRcdFx0XHRcdFx0cmFuZ2VkYXRlOidBIGRhdGEgZXNwZWNpZmljYWRhIG5vIGNhbXBvIHswfSBkZXZlIGVzdGFyIGRlbnRybyBkbyBpbnRlcnZhbG86IHsxfS4nLFxuXHRcdFx0XHRcdFx0XHRcdHJhbmdlbnVtYmVyOiAnTyBuw7ptZXJvIGVzcGVjaWZpY2FkbyBubyBjYW1wbyB7MH0gZGV2ZSBlc3RhciBkZW50cm8gZG8gaW50ZXJ2YWxvOiB7MX0uJyxcblx0XHRcdFx0XHRcdFx0XHRyZXF1aXJlZDogJ08gY2FtcG8gezB9IMOpIG9icmlnYXTDs3Jpby4nXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fSkoKTtcblxuXHRcdFx0XHRmdW5jdGlvbiByZXR1cm5PYmplY3QobmFtZSl7XG5cdFx0XHRcdFx0cmV0dXJuIF9mb3JtQ29udHJvbGxlcnMuZmlsdGVyKGZ1bmN0aW9uKCR2KXtcblx0XHRcdFx0XHRcdHJldHVybiAkdi5uYW1lLnRyaW0oKS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdH0pWzBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUuJG9uKCckZXJyb3InLGZ1bmN0aW9uKGV2LGRhdGEpe1xuXHRcdFx0XHRcdCR0aW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRpZiAoZGF0YS5lcnJvci5zdWJzdHJpbmcoMCw1KSA9PSAncmFuZ2UnKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBhdXhWYWx1ZSA9IHNjb3BlLiRldmFsKGRhdGEudmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRkYXRhLnZhbHVlID0gJ23DrW5pbW8gZGUgJyArIGF1eFZhbHVlLm1pbiArICcgZSBtw6F4aW1vIGRlICcgKyBhdXhWYWx1ZS5tYXg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YXIgX2F1eCA9IHJldHVybk9iamVjdChkYXRhLm5hbWUpXG5cdFx0XHRcdFx0XHQsXHRcdG1lc3NhZ2UgPSBfYXV4LmVycm9yTWVzc2FnZXNbZGF0YS5lcnJvcl0ucmVwbGFjZSgnezF9JyxkYXRhLnZhbHVlKVxuXHRcdFx0XHRcdFx0LFx0XHRhdXhNZXNzYWdlID0gbWVzc2FnZTtcblx0XHRcdFx0XHRcdGlmIChkYXRhLmVycm9yICE9ICdyZXF1aXJlZCcpIHtcblx0XHRcdFx0XHRcdFx0YXV4TWVzc2FnZSA9IGF1eE1lc3NhZ2UucmVwbGFjZSgnbm8gY2FtcG8gezB9JywnJyk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRhdXhNZXNzYWdlID0gYXV4TWVzc2FnZS5yZXBsYWNlKCd7MH0nLCcnKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoJ3swfScsZGF0YS5sYWJlbCk7XG5cdFx0XHRcdFx0XHQkcm9vdFNjb3BlLiRicm9hZGNhc3QoJyRlcnJvck1lc3NhZ2UnLHtcblx0XHRcdFx0XHRcdFx0bmFtZTogZGF0YS5uYW1lLFxuXHRcdFx0XHRcdFx0XHRtZXNzYWdlOiBtZXNzYWdlLFxuXHRcdFx0XHRcdFx0XHRmaWVsZE1lc3NhZ2U6IGF1eE1lc3NhZ2UsXG5cdFx0XHRcdFx0XHRcdHZhbGlkOiBkYXRhLnZhbGlkLFxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRzY29wZS5HdW1nYUZvcm0uZ2V0TWVzc2FnZXMgPSBmdW5jdGlvbihuYW1lLGVycm9yKXtcblx0XHRcdFx0XHRpZighZXJyb3Ipe1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJldHVybk9iamVjdChuYW1lKS5lcnJvck1lc3NhZ2VzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihyZXR1cm5PYmplY3QobmFtZSkuZXJyb3JNZXNzYWdlcyl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmV0dXJuT2JqZWN0KG5hbWUpLmVycm9yTWVzc2FnZXNbZXJyb3JdIHx8IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNjb3BlLkd1bWdhRm9ybS5jaGFuZ2VNZXNzYWdlID0gZnVuY3Rpb24oaW5wdXQsd2hpY2gsbWVzc2FnZSl7XG5cdFx0XHRcdFx0aWYoIWlucHV0IHx8ICF3aGljaCB8fCAhbWVzc2FnZSkgdGhyb3cgJ1ZhbG9yZXMgcGFzc2Fkb3MgZXJyYWRvcyBwYXJhIGEgZnVuw6fDo28gR3VtZ2FGb3JtLmNoYW5nZU1lc3NhZ2UoaW5wdXQsbWVzc2FnZSknXG5cdFx0XHRcdFx0dmFyIGF1eCA9IF9mb3JtQ29udHJvbGxlcnMuZmlsdGVyKGZ1bmN0aW9uKHZhbHVlKXtcblx0XHRcdFx0XHRcdHJldHVybiBpbnB1dCA9PSB2YWx1ZS5uYW1lO1xuXHRcdFx0XHRcdH0pWzBdO1xuXHRcdFx0XHRcdGlmKGF1eC5lcnJvck1lc3NhZ2VzICYmIGF1eC5lcnJvck1lc3NhZ2VzW3doaWNoXSl7XG5cdFx0XHRcdFx0XHRhdXguZXJyb3JNZXNzYWdlc1t3aGljaF0gPSBtZXNzYWdlO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzY29wZS5HdW1nYUZvcm0uc2V0Rm9ybVZhbGlkID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGZvcih2YXIga2V5IGluIF9mb3JtLiRlcnJvcikgaWYoX2Zvcm0uJGVycm9yLmhhc093blByb3BlcnR5KGtleSkpe1xuXHRcdFx0XHRcdFx0X2Zvcm0uJGVycm9yW2tleV0uZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0dmFsdWUuJHNldFZhbGlkaXR5KGtleSx0cnVlKTtcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNjb3BlLiRhcHBseSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNjb3BlLkd1bWdhRm9ybS5jbGVhckZvcm0gPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdF9mb3JtQ29udHJvbGxlcnMuZm9yRWFjaChmdW5jdGlvbihjb250cm9sbGVyKXtcblx0XHRcdFx0XHRcdGNvbnRyb2xsZXIuY29udHJvbGxlci4kc2V0Vmlld1ZhbHVlKCcnKTtcblx0XHRcdFx0XHRcdGNvbnRyb2xsZXIuY29udHJvbGxlci4kc2V0UHJpc3RpbmUoKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdHNjb3BlLiRhcHBseSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUuR3VtZ2FGb3JtLnNldEZvcm1QcmlzdGluZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRfZm9ybUNvbnRyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24oY29udHJvbGxlcil7XG5cdFx0XHRcdFx0XHRjb250cm9sbGVyLmNvbnRyb2xsZXIuJHNldFByaXN0aW5lKCk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRzY29wZS4kYXBwbHkoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLkd1bWdhRm9ybS5nZXRGb3JtRXJyb3JzID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHR2YXIgX2FyciA9IFtdXG5cdFx0XHRcdFx0LFx0XHRuYW1lXG5cdFx0XHRcdFx0LFx0XHRhdXggPSBbXTtcblx0XHRcdFx0XHRmb3IodmFyIGtleSBpbiBfZm9ybS4kZXJyb3IpIGlmKF9mb3JtLiRlcnJvci5oYXNPd25Qcm9wZXJ0eShrZXkpKXtcblx0XHRcdFx0XHRcdF9mb3JtLiRlcnJvcltrZXldLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdGF1eC5wdXNoKHZhbHVlLiRuYW1lKTtcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRfYXJyLnB1c2goe3R5cGU6IGtleSxmaWVsZHM6IGF1eH0pO1xuXHRcdFx0XHRcdFx0YXV4ID0gW107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBfYXJyO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0YW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMuZm9ybS5mb3JtJyxbXSlcblx0LmRpcmVjdGl2ZSgnZ3VtZ2FGb3JtJyxGb3JtKTtcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogQG5nZG9jIGRpcmVjdGl2ZVxuICAgKiBAbmFtZSBndW1nYS5jb3JlOmd1bWdhTWF4RGF0ZVxuICAgKiBAZWxlbWVudCBpbnB1dFxuICAgKiBAcmVzdHJpY3QgQVxuICAgKiBAc2NvcGUgZmFsc2VcbiAgICogQGRlc2NyaXB0aW9uIE8gY29tcG9uZW50ZSBHdW1nYU1heERhdGUgc2VydmUgcGFyYSB2YWxpZGFyIGRhdGFzIG3DoXhpbWFzIGVtIGVudHJhZGFzIGRlIGZvcm11bMOhcmlvcy5cbiAgICpcbiAgICogIyMgTm90YVxuICAgKiBFc3RhIGRpcmV0aXZhIHN1cG9ydGEgYXBlbmFzICoqaW5wdXRzKiogZG8gdGlwbyAqKmRhdGUqKi4gTyB2YWxvciBkbyBhdHJpYnV0by9kaXJldGl2YSDDqSAqKm9icmlnYXTDs3JpbyoqIGUgZGV2ZSBzZXIgdW1hICoqZGF0YSoqLlxuICAgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbGFiZWwgVXNhZG8gbmEgaW50ZWdyYcOnw6NvIGNvbSB7QGxpbmsgZ3VtZ2EuY29yZTpndW1nYUVycm9yc30gcGFyYSBpbmRpY2FyIGVtIHF1YWwgY2FtcG8gc2UgZW5jb250cmEgbyBlcnJvLlxuXHQgKiBTZSBvIGF0cmlidXRvIGZvciBvbWl0aWRvLCBhIGRpcmV0aXZhIHVzYXLDoSBvIGF0cmlidXRvIG5hbWUgZG8gaW5wdXQuXG5cdCAqXG4gICAqIEBleGFtcGxlXG4gICAqICBVbSBleGVtcGxvIGRhIGRpcmVjdGl2ZSBndW1nYU1heERhdGUgZnVuY2lvbmFuZG8gcG9kZSBzZXIgZW5jb250cmFkbyBbYXF1aV0oaHR0cDovL2VtYmVkLnBsbmtyLmNvL0FjanFjZ3ZnR2hkSnFEaDcyZUhBKS5cbiAgICogIDxwcmU+XG4gICAqICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIj5cbiAgICogICAgICA8aW5wdXQgdHlwZT1cImRhdGVcIiBuYW1lPVwibWF4RGF0ZVwiIG5nLW1vZGVsPVwibWF4RGF0ZVwiIGd1bWdhLW1heC1kYXRlPVwiMjAxNS0wNy0yMFwiPlxuICAgKiAgICAgIDxwIG5nLXNob3c9XCJteUZvcm0ubWF4RGF0ZS4kZXJyb3IubWF4ZGF0ZVwiIGNsYXNzPVwidGV4dC1kYW5nZXJcIj5EYXRhIHN1cGVyaW9yIGEgZXNwZXJhZGE8L3A+XG4gICAqICAgIDwvZm9ybT5cbiAgICogIDwvcHJlPlxuICAgKi9cbiAgIE1heERhdGUuJGluamVjdCA9IFtcIiRmaWx0ZXJcIl07XG4gICBmdW5jdGlvbiBNYXhEYXRlKCRmaWx0ZXIpIHtcbiAgICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICByZXF1aXJlOiAnbmdNb2RlbCcsXG4gICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsbSwgYXR0cnMsIGN0cmwpIHtcblx0ICAgICAgaWYgKGF0dHJzLnR5cGUgIT0gJ2RhdGUnKSB7XG5cdCAgICAgICAgdGhyb3cgJ0VzdGEgZGlyZXRpdmEgc3Vwb3J0YSBhcGVuYXMgaW5wdXRzIGRvIHRpcG8gZGF0ZSc7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKCFhdHRycy5ndW1nYU1heERhdGUpIHtcblx0ICAgICAgICB0aHJvdyBcIk8gdmFsb3IgZGEgZGlyZXRpdmEgZ3VtZ2EtbWF4LWRhdGUgbsOjbyBmb2kgaW5mb3JtYWRvLlwiO1xuXHQgICAgICB9XG4gICAgICAgIHZhciB2YWxpZGF0ZU1heERhdGUgPSBmdW5jdGlvbiAoaW5wdXRWYWx1ZSkge1xuXHRcdFx0XHRcdHZhciBlcnJvciA9ICdtYXhkYXRlJztcbiAgICAgICAgXHR2YXIgZm9ybWF0ID0gJ3l5eXktTU0tZGQnO1xuICAgICAgICBcdHZhciBpbnB1dCA9ICRmaWx0ZXIoJ2RhdGUnKShpbnB1dFZhbHVlLCBmb3JtYXQpO1xuICAgICAgICBcdHZhciBtYXggPSAkZmlsdGVyKCdkYXRlJykoYXR0cnMuZ3VtZ2FNYXhEYXRlLCBmb3JtYXQpO1xuICAgICAgICBcdHZhciBpc1ZhbGlkID0gaW5wdXQgPD0gbWF4O1xuICAgICAgICBcdGN0cmwuJHNldFZhbGlkaXR5KGVycm9yLCBpc1ZhbGlkKTtcblx0XHRcdFx0XHRzY29wZS4kYnJvYWRjYXN0KCckZXJyb3InLCB7XG5cdFx0XHRcdFx0XHRuYW1lOiBhdHRycy5uYW1lLFxuXHRcdFx0XHRcdFx0bGFiZWw6IGF0dHJzLmxhYmVsIHx8IGF0dHJzLm5hbWUsXG5cdFx0XHRcdFx0XHR2YWxpZDogaXNWYWxpZCxcblx0XHRcdFx0XHRcdGVycm9yOiBlcnJvcixcblx0XHRcdFx0XHRcdHZhbHVlOiBhdHRycy5ndW1nYU1heERhdGVcblx0XHRcdFx0XHR9KTtcbiAgICAgICAgXHRyZXR1cm4gaW5wdXRWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgY3RybC4kcGFyc2Vycy51bnNoaWZ0KHZhbGlkYXRlTWF4RGF0ZSk7XG4gICAgICAgIGN0cmwuJGZvcm1hdHRlcnMucHVzaCh2YWxpZGF0ZU1heERhdGUpO1xuICAgICAgICBhdHRycy4kb2JzZXJ2ZSgnZ3VtZ2FNYXhEYXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBcdHZhbGlkYXRlTWF4RGF0ZShjdHJsLiR2aWV3VmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMuZm9ybS5tYXguZGF0ZScsW10pXG4gIC5kaXJlY3RpdmUoJ2d1bWdhTWF4RGF0ZScsTWF4RGF0ZSk7XG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAgICogQG5hbWUgZ3VtZ2EuY29yZTpndW1nYU1heExlbmd0aFxuICAgKiBAZWxlbWVudCBpbnB1dFxuICAgKiBAcmVzdHJpY3QgQVxuICAgKiBAc2NvcGUgZmFsc2VcbiAgICogQGRlc2NyaXB0aW9uIE8gY29tcG9uZW50ZSBHdW1nYU1heExlbmd0aCBzZXJ2ZSBwYXJhIHZhbGlkYXIgcXVhbnRpZGFkZXMgbcOheGltYXMgZGUgY2FyYWN0ZXJlcyBlbSBlbnRyYWRhcyBkZSBmb3JtdWzDoXJpb3MuXG4gICAqXG4gICAqICMjIE5vdGFcbiAgICogTyB2YWxvciBkbyBhdHJpYnV0by9kaXJldGl2YSDDqSAqKm9icmlnYXTDs3JpbyoqIGUgZGV2ZSBzZXIgdW0gKipuw7ptZXJvKiouXG4gICAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBVc2FkbyBuYSBpbnRlZ3Jhw6fDo28gY29tIHtAbGluayBndW1nYS5jb3JlOmd1bWdhRXJyb3JzfSBwYXJhIGluZGljYXIgZW0gcXVhbCBjYW1wbyBzZSBlbmNvbnRyYSBvIGVycm8uXG5cdCAqIFNlIG8gYXRyaWJ1dG8gZm9yIG9taXRpZG8sIGEgZGlyZXRpdmEgdXNhcsOhIG8gYXRyaWJ1dG8gbmFtZSBkbyBpbnB1dC5cblx0ICpcbiAgICogQGV4YW1wbGVcbiAgICogIFVtIGV4ZW1wbG8gZGEgZGlyZWN0aXZlIEd1bWdhTWF4TGVuZ3RoIGZ1bmNpb25hbmRvIHBvZGUgc2VyIGVuY29udHJhZG8gW2FxdWldKGh0dHA6Ly9lbWJlZC5wbG5rci5jby9BY2pxY2d2Z0doZEpxRGg3MmVIQSkuXG4gICAqICA8cHJlPlxuICAgKiAgICA8Zm9ybSBuYW1lPVwibXlGb3JtXCI+XG4gICAqICAgICAgPGlucHV0IHR5cGU9XCJkYXRlXCIgbmFtZT1cIm1heExlbmd0aFwiIG5nLW1vZGVsPVwibWF4TGVuZ3RoXCIgZ3VtZ2EtbWF4LWxlbmd0aD1cIjIwXCIgaWQ9XCJtYXhMZW5ndGhcIj5cbiAgICogICAgICA8cCBuZy1zaG93PVwibXlGb3JtLm1heExlbmd0aC4kZXJyb3IubWF4bGVuZ3RoXCIgY2xhc3M9XCJ0ZXh0LWRhbmdlclwiPlRhbWFuaG8gc3VwZXJpb3IgYW8gZXNwZXJhZG88L3A+XG4gICAqICAgIDwvZm9ybT5cbiAgICogIDwvcHJlPlxuICAgKi9cbiAgIE1heExlbmd0aC4kaW5qZWN0ID0gW107XG4gICBmdW5jdGlvbiBNYXhMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICByZXF1aXJlOiAnbmdNb2RlbCcsXG4gICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsbSwgYXR0cnMsIGN0cmwpIHtcbiAgICAgICAgaWYgKCFhdHRycy5ndW1nYU1heExlbmd0aCkge1xuICAgICAgICAgIHRocm93IFwiTyB2YWxvciBkYSBkaXJldGl2YSBndW1nYS1tYXgtbGVuZ3RoIG7Do28gZm9pIGluZm9ybWFkby5cIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsaWRhdGVNYXhMZW5ndGggPSBmdW5jdGlvbiAoaW5wdXRWYWx1ZSkge1xuXHRcdFx0XHRcdHZhciBlcnJvciA9ICdtYXhsZW5ndGgnO1xuICAgICAgICAgIHZhciBpbnB1dCA9IChpbnB1dFZhbHVlID09IHVuZGVmaW5lZCkgPyAtMSA6IGlucHV0VmFsdWUubGVuZ3RoO1xuICAgICAgICAgIHZhciBtYXggPSBhdHRycy5ndW1nYU1heExlbmd0aDtcbiAgICAgICAgICB2YXIgaXNWYWxpZCA9IGlucHV0IDw9IG1heCAmJiBpbnB1dCAhPSAtMTtcbiAgICAgICAgICBjdHJsLiRzZXRWYWxpZGl0eShlcnJvciwgaXNWYWxpZCk7XG5cdFx0XHRcdFx0c2NvcGUuJGJyb2FkY2FzdCgnJGVycm9yJywge1xuXHRcdFx0XHRcdFx0bmFtZTogYXR0cnMubmFtZSxcblx0XHRcdFx0XHRcdGxhYmVsOiBhdHRycy5sYWJlbCB8fCBhdHRycy5uYW1lLFxuXHRcdFx0XHRcdFx0dmFsaWQ6IGlzVmFsaWQsXG5cdFx0XHRcdFx0XHRlcnJvcjogZXJyb3IsXG5cdFx0XHRcdFx0XHR2YWx1ZTogYXR0cnMuZ3VtZ2FNYXhMZW5ndGhcblx0XHRcdFx0XHR9KTtcbiAgICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgY3RybC4kcGFyc2Vycy51bnNoaWZ0KHZhbGlkYXRlTWF4TGVuZ3RoKTtcbiAgICAgICAgY3RybC4kZm9ybWF0dGVycy5wdXNoKHZhbGlkYXRlTWF4TGVuZ3RoKTtcbiAgICAgICAgYXR0cnMuJG9ic2VydmUoJ2d1bWdhTWF4TGVuZ3RoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhbGlkYXRlTWF4TGVuZ3RoKGN0cmwuJHZpZXdWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtLm1heC5sZW5ndGgnLFtdKVxuICAuZGlyZWN0aXZlKCdndW1nYU1heExlbmd0aCcsTWF4TGVuZ3RoKTtcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogQG5nZG9jIGRpcmVjdGl2ZVxuICAgKiBAbmFtZSBndW1nYS5jb3JlOmd1bWdhTWF4TnVtYmVyXG4gICAqIEBlbGVtZW50IGlucHV0XG4gICAqIEByZXN0cmljdCBBXG4gICAqIEBzY29wZSBmYWxzZVxuICAgKiBAZGVzY3JpcHRpb24gTyBjb21wb25lbnRlIEd1bWdhTWF4TnVtYmVyIHNlcnZlIHBhcmEgdmFsaWRhciBuw7ptZXJvcyBtw6F4aW1vcyBlbSBlbnRyYWRhcyBkZSBmb3JtdWzDoXJpb3MuXG4gICAqXG4gICAqICMjIE5vdGFcbiAgICogRXN0YSBkaXJldGl2YSBzdXBvcnRhIGFwZW5hcyAqKmlucHV0cyoqIGRvIHRpcG8gKipudW1iZXIqKi4gTyB2YWxvciBkbyBhdHJpYnV0by9kaXJldGl2YSDDqSAqKm9icmlnYXTDs3JpbyoqIGUgZGV2ZSBzZXIgdW0gKipuw7ptZXJvKiouXG4gICAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBVc2FkbyBuYSBpbnRlZ3Jhw6fDo28gY29tIHtAbGluayBndW1nYS5jb3JlOmd1bWdhRXJyb3JzfSBwYXJhIGluZGljYXIgZW0gcXVhbCBjYW1wbyBzZSBlbmNvbnRyYSBvIGVycm8uXG5cdCAqIFNlIG8gYXRyaWJ1dG8gZm9yIG9taXRpZG8sIGEgZGlyZXRpdmEgdXNhcsOhIG8gYXRyaWJ1dG8gbmFtZSBkbyBpbnB1dC5cblx0ICpcbiAgICogQGV4YW1wbGVcbiAgICogIFVtIGV4ZW1wbG8gZGEgZGlyZWN0aXZlIEd1bWdhTWF4TnVtYmVyIGZ1bmNpb25hbmRvIHBvZGUgc2VyIGVuY29udHJhZG8gW2FxdWldKGh0dHA6Ly9lbWJlZC5wbG5rci5jby9BY2pxY2d2Z0doZEpxRGg3MmVIQSkuXG4gICAqICA8cHJlPlxuICAgKiAgICA8Zm9ybSBuYW1lPVwibXlGb3JtXCI+XG4gICAqICAgICAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiBuYW1lPVwibWF4TnVtYmVyXCIgbmctbW9kZWw9XCJtYXhOdW1iZXJcIiBndW1nYS1tYXgtbnVtYmVyPVwiMjBcIj5cbiAgICogICAgICA8cCBuZy1zaG93PVwibXlGb3JtLm1heE51bWJlci4kZXJyb3IubWF4bnVtYmVyXCIgY2xhc3M9XCJ0ZXh0LWRhbmdlclwiPk7Dum1lcm8gc3VwZXJpb3IgYW8gZXNwZXJhZG88L3A+XG4gICAqICAgIDwvZm9ybT5cbiAgICogIDwvcHJlPlxuICAgKi9cbiAgIE1heE51bWJlci4kaW5qZWN0ID0gW107XG4gICBmdW5jdGlvbiBNYXhOdW1iZXIoKSB7XG4gICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgcmVxdWlyZTogJ25nTW9kZWwnLFxuICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbG0sIGF0dHJzLCBjdHJsKSB7XG4gICAgICAgaWYgKGF0dHJzLnR5cGUgIT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgJ0VzdGEgZGlyZXRpdmEgc3Vwb3J0YSBhcGVuYXMgaW5wdXRzIGRvIHRpcG8gbnVtYmVyJztcbiAgICAgIH1cbiAgICAgIGlmICghYXR0cnMuZ3VtZ2FNYXhOdW1iZXIpIHtcbiAgICAgICAgdGhyb3cgXCJPIHZhbG9yIGRhIGRpcmV0aXZhIGd1bWdhLW1heC1udW1iZXIgbsOjbyBmb2kgaW5mb3JtYWRvLlwiO1xuICAgICAgfVxuICAgICAgdmFyIHZhbGlkYXRlTWF4TnVtYmVyID0gZnVuY3Rpb24gKGlucHV0VmFsdWUpIHtcblx0XHRcdFx0dmFyIGVycm9yID0gJ21heG51bWJlcic7XG4gICAgICAgIHZhciBpbnB1dCA9IHBhcnNlSW50KGlucHV0VmFsdWUpO1xuICAgICAgICB2YXIgbWF4ID0gcGFyc2VJbnQoYXR0cnMuZ3VtZ2FNYXhOdW1iZXIpO1xuICAgICAgICB2YXIgaXNWYWxpZCA9IGlucHV0IDw9IG1heDtcbiAgICAgICAgY3RybC4kc2V0VmFsaWRpdHkoZXJyb3IsIGlzVmFsaWQpO1xuXHRcdFx0XHRzY29wZS4kYnJvYWRjYXN0KCckZXJyb3InLCB7XG5cdFx0XHRcdFx0bmFtZTogYXR0cnMubmFtZSxcblx0XHRcdFx0XHRsYWJlbDogYXR0cnMubGFiZWwgfHwgYXR0cnMubmFtZSxcblx0XHRcdFx0XHR2YWxpZDogaXNWYWxpZCxcblx0XHRcdFx0XHRlcnJvcjogZXJyb3IsXG5cdFx0XHRcdFx0dmFsdWU6IGF0dHJzLmd1bWdhTWF4TnVtYmVyXG5cdFx0XHRcdH0pO1xuICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZTtcbiAgICAgIH07XG4gICAgICBjdHJsLiRwYXJzZXJzLnVuc2hpZnQodmFsaWRhdGVNYXhOdW1iZXIpO1xuICAgICAgY3RybC4kZm9ybWF0dGVycy5wdXNoKHZhbGlkYXRlTWF4TnVtYmVyKTtcbiAgICAgIGF0dHJzLiRvYnNlcnZlKCdndW1nYU1heE51bWJlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFsaWRhdGVNYXhOdW1iZXIoY3RybC4kdmlld1ZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBzY29wZS4kb24oJ2NsZWFyRmllbGRzJyxmdW5jdGlvbihldmVudCwgZGF0YSkge1xuICAgICAgIGN0cmwuJG1vZGVsVmFsdWUgPSBudWxsO1xuICAgICAgIGNvbnNvbGUubG9nKCdkaXJlY3RpdmUgZGF0ZSBjbGVhcicpO1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKGVsbSk7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coKTtcblx0XHRcdFx0fSk7XG4gICAgfVxuICB9XG59XG5hbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtLm1heC5udW1iZXInLFtdKVxuLmRpcmVjdGl2ZSgnZ3VtZ2FNYXhOdW1iZXInLE1heE51bWJlcik7XG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAgICogQG5hbWUgZ3VtZ2EuY29yZTpndW1nYU1pbkRhdGVcbiAgICogQGVsZW1lbnQgaW5wdXRcbiAgICogQHJlc3RyaWN0IEFcbiAgICogQGRlc2NyaXB0aW9uIE8gY29tcG9uZW50ZSBHdW1nYU1pbkRhdGUgc2VydmUgcGFyYSB2YWxpZGFyIGRhdGFzIG3DrW5pbWFzIGVtIGVudHJhZGFzIGRlIGZvcm11bMOhcmlvcy5cbiAgICpcbiAgICogIyMgTm90YVxuICAgKiBFc3RhIGRpcmV0aXZhIHN1cG9ydGEgYXBlbmFzICoqaW5wdXRzKiogZG8gdGlwbyAqKmRhdGUqKi4gTyB2YWxvciBkbyBhdHJpYnV0by9kaXJldGl2YSDDqSAqKm9icmlnYXTDs3JpbyoqIGUgZGV2ZSBzZXIgdW1hICoqZGF0YSoqLlxuICAgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbGFiZWwgVXNhZG8gbmEgaW50ZWdyYcOnw6NvIGNvbSB7QGxpbmsgZ3VtZ2EuY29yZTpndW1nYUVycm9yc30gcGFyYSBpbmRpY2FyIGVtIHF1YWwgY2FtcG8gc2UgZW5jb250cmEgbyBlcnJvLlxuXHQgKiBTZSBvIGF0cmlidXRvIGZvciBvbWl0aWRvLCBhIGRpcmV0aXZhIHVzYXLDoSBvIGF0cmlidXRvIG5hbWUgZG8gaW5wdXQuXG5cdCAqXG4gICAqIEBleGFtcGxlXG4gICAqICBVbSBleGVtcGxvIGRhIGRpcmVjdGl2ZSBHdW1nYU1pbkRhdGUgZnVuY2lvbmFuZG8gcG9kZSBzZXIgZW5jb250cmFkbyBbYXF1aV0oaHR0cDovL2VtYmVkLnBsbmtyLmNvL0FjanFjZ3ZnR2hkSnFEaDcyZUhBKS5cbiAgICogIDxwcmU+XG4gICAqICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIj5cbiAgICogICAgICA8aW5wdXQgdHlwZT1cImRhdGVcIiBuYW1lPVwibWluRGF0ZVwiIG5nLW1vZGVsPVwibWluRGF0ZVwiIGd1bWdhLW1pbi1kYXRlPVwiMjAxNS0wNy0yMFwiPlxuICAgKiAgICAgIDxwIG5nLXNob3c9XCJteUZvcm0ubWluRGF0ZS4kZXJyb3IubWluZGF0ZVwiIGNsYXNzPVwidGV4dC1kYW5nZXJcIj5EYXRhIGluZmVyaW9yIGEgZXNwZXJhZGE8L3A+XG4gICAqICAgIDwvZm9ybT5cbiAgICogIDwvcHJlPlxuICAqL1xuXHQgTWluRGF0ZS4kaW5qZWN0ID0gW1wiJGZpbHRlclwiXTtcblx0IGZ1bmN0aW9uIE1pbkRhdGUoJGZpbHRlcikge1xuXHQgXHRyZXR1cm4ge1xuXHQgXHRcdHJlc3RyaWN0OiAnQScsXG5cdCBcdFx0cmVxdWlyZTogJ25nTW9kZWwnLFxuXHQgXHRcdGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxtLCBhdHRycywgY3RybCkge1xuXHQgXHRcdFx0aWYgKGF0dHJzLnR5cGUgIT0gJ2RhdGUnKSB7XG5cdCBcdFx0XHRcdHRocm93ICdFc3RhIGRpcmV0aXZhIHN1cG9ydGEgYXBlbmFzIGlucHV0cyBkbyB0aXBvIGRhdGUnO1xuXHQgXHRcdFx0fVxuXHQgXHRcdFx0aWYgKCFhdHRycy5ndW1nYU1pbkRhdGUpIHtcblx0IFx0XHRcdFx0dGhyb3cgXCJPIHZhbG9yIGRhIGRpcmV0aXZhIGd1bWdhLW1pbi1kYXRlIG7Do28gZm9pIGluZm9ybWFkby5cIjtcblx0IFx0XHRcdH1cbiAgICAgICAgLy8gaWYgKCFHdW1nYURhdGVTZXJ2aWNlLnZhbGlkYXRlRm9ybWF0KCdZTUQnLCBhdHRycy5ndW1nYU1pbkRhdGUpKSB7XG4gICAgICAgIC8vICAgdGhyb3cgJ08gdmFsb3IgZGEgZGlyZXRpdmEgbsOjbyBjb3JyZXNwb25kZSBhbyBmb3JtYXRvIHl5eXktbW0tZGQnO1xuICAgICAgICAvLyB9XG4gICAgICAgIHZhciB2YWxpZGF0ZU1pbkRhdGUgPSBmdW5jdGlvbiAoaW5wdXRWYWx1ZSkge1xuXHRcdFx0XHRcdHZhciBlcnJvciA9ICdtaW5kYXRlJztcblx0XHRcdFx0XHR2YXIgZm9ybWF0ID0gJ3l5eXktTU0tZGQnO1xuXHRcdFx0XHRcdHZhciBpbnB1dCA9ICRmaWx0ZXIoJ2RhdGUnKShpbnB1dFZhbHVlLCBmb3JtYXQpO1xuXHRcdFx0XHRcdHZhciBtaW4gPSAkZmlsdGVyKCdkYXRlJykoYXR0cnMuZ3VtZ2FNaW5EYXRlLCBmb3JtYXQpO1xuXHRcdFx0XHRcdHZhciBpc1ZhbGlkID0gaW5wdXQgPj0gbWluO1xuXHRcdFx0XHRcdGN0cmwuJHNldFZhbGlkaXR5KGVycm9yLCBpc1ZhbGlkKTtcblx0XHRcdFx0XHRzY29wZS4kYnJvYWRjYXN0KCckZXJyb3InLCB7XG5cdFx0XHRcdFx0XHRuYW1lOiBhdHRycy5uYW1lLFxuXHRcdFx0XHRcdFx0bGFiZWw6IGF0dHJzLmxhYmVsIHx8IGF0dHJzLm5hbWUsXG5cdFx0XHRcdFx0XHR2YWxpZDogaXNWYWxpZCxcblx0XHRcdFx0XHRcdGVycm9yOiBlcnJvcixcblx0XHRcdFx0XHRcdHZhbHVlOiBhdHRycy5ndW1nYU1pbkRhdGVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZXR1cm4gaW5wdXRWYWx1ZTtcblx0XHRcdFx0fTtcblx0XHRcdFx0Y3RybC4kcGFyc2Vycy51bnNoaWZ0KHZhbGlkYXRlTWluRGF0ZSk7XG5cdFx0XHRcdGN0cmwuJGZvcm1hdHRlcnMucHVzaCh2YWxpZGF0ZU1pbkRhdGUpO1xuXHRcdFx0XHRhdHRycy4kb2JzZXJ2ZSgnZ3VtZ2FNaW5EYXRlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHZhbGlkYXRlTWluRGF0ZShjdHJsLiR2aWV3VmFsdWUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0YW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMuZm9ybS5taW4uZGF0ZScsW10pXG5cdC5kaXJlY3RpdmUoJ2d1bWdhTWluRGF0ZScsTWluRGF0ZSk7XG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAgICogQG5hbWUgZ3VtZ2EuY29yZTpndW1nYU1pbkxlbmd0aFxuICAgKiBAZWxlbWVudCBpbnB1dFxuICAgKiBAcmVzdHJpY3QgQVxuICAgKiBAZGVzY3JpcHRpb24gTyBjb21wb25lbnRlIEd1bWdhTWluTGVuZ3RoIHNlcnZlIHBhcmEgdmFsaWRhciBxdWFudGlkYWRlcyBtw61uaW1hcyBkZSBjYXJhY3RlcmVzIGVtIGVudHJhZGFzIGRlIGZvcm11bMOhcmlvcy5cbiAgICpcbiAgICogIyMgTm90YVxuICAgKiBPIHZhbG9yIGRvIGF0cmlidXRvL2RpcmV0aXZhIMOpICoqb2JyaWdhdMOzcmlvKiogZSBkZXZlIHNlciB1bSAqKm7Dum1lcm8qKi5cbiAgICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGxhYmVsIFVzYWRvIG5hIGludGVncmHDp8OjbyBjb20ge0BsaW5rIGd1bWdhLmNvcmU6Z3VtZ2FFcnJvcnN9IHBhcmEgaW5kaWNhciBlbSBxdWFsIGNhbXBvIHNlIGVuY29udHJhIG8gZXJyby5cblx0ICogU2UgbyBhdHJpYnV0byBmb3Igb21pdGlkbywgYSBkaXJldGl2YSB1c2Fyw6EgbyBhdHJpYnV0byBuYW1lIGRvIGlucHV0LlxuXHQgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgVW0gZXhlbXBsbyBkYSBkaXJlY3RpdmUgR3VtZ2FNaW5MZW5ndGggZnVuY2lvbmFuZG8gcG9kZSBzZXIgZW5jb250cmFkbyBbYXF1aV0oaHR0cDovL2VtYmVkLnBsbmtyLmNvL0FjanFjZ3ZnR2hkSnFEaDcyZUhBKS5cbiAgICogIDxwcmU+XG4gICAqICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIj5cbiAgICogICAgICA8aW5wdXQgdHlwZT1cImRhdGVcIiBuYW1lPVwibWluTGVuZ3RoXCIgbmctbW9kZWw9XCJtaW5MZW5ndGhcIiBndW1nYS1taW4tbGVuZ3RoPVwiMjBcIiBpZD1cIm1pbkxlbmd0aFwiPlxuICAgKiAgICAgIDxwIG5nLXNob3c9XCJteUZvcm0ubWluTGVuZ3RoLiRlcnJvci5taW5sZW5ndGhcIiBjbGFzcz1cInRleHQtZGFuZ2VyXCI+VGFtYW5obyBpbmZlcmlvciBhbyBlc3BlcmFkbzwvcD5cbiAgICogICAgPC9mb3JtPlxuICAgKiAgPC9wcmU+XG4gICovXG5cdE1pbkxlbmd0aC4kaW5qZWN0ID0gW107XG5cdGZ1bmN0aW9uIE1pbkxlbmd0aCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcbiAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxtLCBhdHRycywgY3RybCkge1xuICAgICAgICBpZiAoIWF0dHJzLmd1bWdhTWluTGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgXCJPIHZhbG9yIGRhIGRpcmV0aXZhIGd1bWdhLW1pbi1sZW5ndGggbsOjbyBmb2kgaW5mb3JtYWRvLlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWxpZGF0ZU1pbkxlbmd0aCA9IGZ1bmN0aW9uIChpbnB1dFZhbHVlKSB7XG5cdFx0XHRcdFx0dmFyIGVycm9yID0gJ21pbmxlbmd0aCc7XG4gICAgICAgICAgdmFyIGlucHV0ID0gKGlucHV0VmFsdWUgPT0gdW5kZWZpbmVkKSA/IC0xIDogaW5wdXRWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgdmFyIG1pbiA9IGF0dHJzLmd1bWdhTWluTGVuZ3RoO1xuICAgICAgICAgIHZhciBpc1ZhbGlkID0gaW5wdXQgPj0gbWluO1xuICAgICAgICAgIGN0cmwuJHNldFZhbGlkaXR5KGVycm9yLCBpc1ZhbGlkKTtcblx0XHRcdFx0XHRzY29wZS4kYnJvYWRjYXN0KCckZXJyb3InLCB7XG5cdFx0XHRcdFx0XHRuYW1lOiBhdHRycy5uYW1lLFxuXHRcdFx0XHRcdFx0bGFiZWw6IGF0dHJzLmxhYmVsIHx8IGF0dHJzLm5hbWUsXG5cdFx0XHRcdFx0XHR2YWxpZDogaXNWYWxpZCxcblx0XHRcdFx0XHRcdGVycm9yOiBlcnJvcixcblx0XHRcdFx0XHRcdHZhbHVlOiBhdHRycy5ndW1nYU1pbkxlbmd0aFxuXHRcdFx0XHRcdH0pO1xuICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xuICAgICAgICB9O1xuXHQgXHRcdFx0Y3RybC4kcGFyc2Vycy51bnNoaWZ0KHZhbGlkYXRlTWluTGVuZ3RoKTtcblx0IFx0XHRcdGN0cmwuJGZvcm1hdHRlcnMucHVzaCh2YWxpZGF0ZU1pbkxlbmd0aCk7XG5cdCBcdFx0XHRhdHRycy4kb2JzZXJ2ZSgnZ3VtZ2FNaW5MZW5ndGgnLCBmdW5jdGlvbiAoKSB7XG5cdCBcdFx0XHRcdHZhbGlkYXRlTWluTGVuZ3RoKGN0cmwuJHZpZXdWYWx1ZSk7XG5cdCBcdFx0XHR9KTtcblx0IFx0XHR9XG5cdCBcdH1cblx0IH1cblx0IGFuZ3VsYXIubW9kdWxlKCdndW1nYS5kaXJlY3RpdmVzLmZvcm0ubWluLmxlbmd0aCcsW10pXG5cdCAuZGlyZWN0aXZlKCdndW1nYU1pbkxlbmd0aCcsTWluTGVuZ3RoKTtcblx0fSkoKTtcbiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBAbmdkb2MgZGlyZWN0aXZlXG4gICAqIEBuYW1lIGd1bWdhLmNvcmU6Z3VtZ2FNaW5OdW1iZXJcbiAgICogQGVsZW1lbnQgaW5wdXRcbiAgICogQHJlc3RyaWN0IEFcbiAgICogQGRlc2NyaXB0aW9uIE8gY29tcG9uZW50ZSBHdW1nYU1pbk51bWJlciBzZXJ2ZSBwYXJhIHZhbGlkYXIgbsO6bWVyb3MgbcOtbmltb3MgcGFyYSBlbnRyYWRhcyBlbSBmb3JtdWzDoXJpb3MuXG4gICAqXG4gICAqICMjIE5vdGFcbiAgICogRXN0YSBkaXJldGl2YSBzdXBvcnRhIGFwZW5hcyAqKmlucHV0cyoqIGRvIHRpcG8gKipudW1iZXIqKi4gTyB2YWxvciBkbyBhdHJpYnV0by9kaXJldGl2YSDDqSAqKm9icmlnYXTDs3JpbyoqIGUgZGV2ZSBzZXIgdW0gKipuw7ptZXJvKiouXG4gICAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBVc2FkbyBuYSBpbnRlZ3Jhw6fDo28gY29tIHtAbGluayBndW1nYS5jb3JlOmd1bWdhRXJyb3JzfSBwYXJhIGluZGljYXIgZW0gcXVhbCBjYW1wbyBzZSBlbmNvbnRyYSBvIGVycm8uXG5cdCAqIFNlIG8gYXRyaWJ1dG8gZm9yIG9taXRpZG8sIGEgZGlyZXRpdmEgdXNhcsOhIG8gYXRyaWJ1dG8gbmFtZSBkbyBpbnB1dC5cblx0ICpcbiAgICogQGV4YW1wbGVcbiAgICogIFVtIGV4ZW1wbG8gZGEgZGlyZWN0aXZlIEd1bWdhTWluTnVtYmVyIGZ1bmNpb25hbmRvIHBvZGUgc2VyIGVuY29udHJhZG8gW2FxdWldKGh0dHA6Ly9lbWJlZC5wbG5rci5jby9BY2pxY2d2Z0doZEpxRGg3MmVIQSkuXG4gICAqICA8cHJlPlxuICAgKiAgICA8Zm9ybSBuYW1lPVwibXlGb3JtXCI+XG4gICAqICAgICAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiBuYW1lPVwibWluTnVtYmVyXCIgbmctbW9kZWw9XCJtaW5OdW1iZXJcIiBndW1nYS1taW4tbnVtYmVyPVwiMjBcIj5cbiAgICogICAgICA8cCBuZy1zaG93PVwibXlGb3JtLm1pbk51bWJlci4kZXJyb3IubWlubnVtYmVyXCIgY2xhc3M9XCJ0ZXh0LWRhbmdlclwiPk7Dum1lcm8gaW5mZXJpb3IgYW8gZXNwZXJhZG88L3A+XG4gICAqICAgIDwvZm9ybT5cbiAgICogIDwvcHJlPlxuICAqL1xuXHQgTWluTnVtYmVyLiRpbmplY3QgPSBbXTtcblx0IGZ1bmN0aW9uIE1pbk51bWJlcigpIHtcblx0IFx0cmV0dXJuIHtcblx0IFx0XHRyZXN0cmljdDogJ0EnLFxuXHQgXHRcdHJlcXVpcmU6ICduZ01vZGVsJyxcblx0IFx0XHRsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsbSwgYXR0cnMsIGN0cmwpIHtcblx0IFx0XHRcdGlmIChhdHRycy50eXBlICE9ICdudW1iZXInKSB7XG5cdCBcdFx0XHRcdHRocm93ICdFc3RhIGRpcmV0aXZhIHN1cG9ydGEgYXBlbmFzIGlucHV0cyBkbyB0aXBvIG51bWJlcic7XG5cdCBcdFx0XHR9XG5cdCBcdFx0XHRpZiAoIWF0dHJzLmd1bWdhTWluTnVtYmVyKSB7XG5cdCBcdFx0XHRcdHRocm93IFwiTyB2YWxvciBkYSBkaXJldGl2YSBndW1nYS1taW4tbnVtYmVyIG7Do28gZm9pIGluZm9ybWFkby5cIjtcblx0IFx0XHRcdH1cblx0IFx0XHRcdHZhciB2YWxpZGF0ZU1pbk51bWJlciA9IGZ1bmN0aW9uIChpbnB1dFZhbHVlKSB7XG5cdFx0XHRcdFx0dmFyIGVycm9yID0gJ21pbm51bWJlcic7XG5cdCBcdFx0XHRcdHZhciBpbnB1dCA9IHBhcnNlSW50KGlucHV0VmFsdWUpO1xuXHQgXHRcdFx0XHR2YXIgbWluID0gcGFyc2VJbnQoYXR0cnMuZ3VtZ2FNaW5OdW1iZXIpO1xuXHQgXHRcdFx0XHR2YXIgaXNWYWxpZCA9IGlucHV0ID49IG1pbjtcblx0IFx0XHRcdFx0Y3RybC4kc2V0VmFsaWRpdHkoZXJyb3IsIGlzVmFsaWQpO1xuXHRcdFx0XHRcdHNjb3BlLiRicm9hZGNhc3QoJyRlcnJvcicsIHtcblx0XHRcdFx0XHRcdG5hbWU6IGF0dHJzLm5hbWUsXG5cdFx0XHRcdFx0XHRsYWJlbDogYXR0cnMubGFiZWwgfHwgYXR0cnMubmFtZSxcblx0XHRcdFx0XHRcdHZhbGlkOiBpc1ZhbGlkLFxuXHRcdFx0XHRcdFx0ZXJyb3I6IGVycm9yLFxuXHRcdFx0XHRcdFx0dmFsdWU6IGF0dHJzLmd1bWdhTWluTnVtYmVyXG5cdFx0XHRcdFx0fSk7XG5cdCBcdFx0XHRcdHJldHVybiBpbnB1dFZhbHVlO1xuXHQgXHRcdFx0fTtcblx0IFx0XHRcdGN0cmwuJHBhcnNlcnMudW5zaGlmdCh2YWxpZGF0ZU1pbk51bWJlcik7XG5cdCBcdFx0XHRjdHJsLiRmb3JtYXR0ZXJzLnB1c2godmFsaWRhdGVNaW5OdW1iZXIpO1xuXHQgXHRcdFx0YXR0cnMuJG9ic2VydmUoJ2d1bWdhTWluTnVtYmVyJywgZnVuY3Rpb24gKCkge1xuXHQgXHRcdFx0XHR2YWxpZGF0ZU1pbk51bWJlcihjdHJsLiR2aWV3VmFsdWUpO1xuXHQgXHRcdFx0fSk7XG5cdCBcdFx0fVxuXHQgXHR9XG5cdCB9XG5cdCBhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtLm1pbi5udW1iZXInLFtdKVxuXHQgLmRpcmVjdGl2ZSgnZ3VtZ2FNaW5OdW1iZXInLE1pbk51bWJlcik7XG5cdH0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogQG5nZG9jIGRpcmVjdGl2ZVxuICAgKiBAbmFtZSBndW1nYS5jb3JlOmd1bWdhUGF0dGVyblxuICAgKiBAZWxlbWVudCBpbnB1dFxuICAgKiBAcmVzdHJpY3QgQVxuICAgKiBAZGVzY3JpcHRpb24gTyBjb21wb25lbnRlIEd1bWdhUGF0dGVybiBzZXJ2ZSBwYXJhIHZhbGlkYXIgZXhwcmVzc8O1ZXMgcmVndWxhcmVzIGRlIGZvcm11bMOhcmlvcy5cbiAgICpcbiAgICogIyMgTm90YVxuICAgKiBPIHZhbG9yIGRvIGF0cmlidXRvL2RpcmV0aXZhIMOpICoqb2JyaWdhdMOzcmlvKiogZSBkZXZlIHNlciB1bWEgKipleHByZXNzw6NvIHJlZ3VsYXIqKi5cbiAgICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGxhYmVsIFVzYWRvIG5hIGludGVncmHDp8OjbyBjb20ge0BsaW5rIGd1bWdhLmNvcmU6Z3VtZ2FFcnJvcnN9IHBhcmEgaW5kaWNhciBlbSBxdWFsIGNhbXBvIHNlIGVuY29udHJhIG8gZXJyby5cblx0ICogU2UgbyBhdHJpYnV0byBmb3Igb21pdGlkbywgYSBkaXJldGl2YSB1c2Fyw6EgbyBhdHJpYnV0byBuYW1lIGRvIGlucHV0LlxuXHQgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgVW0gZXhlbXBsbyBkYSBkaXJlY3RpdmUgR3VtZ2FQYXR0ZXJuIGZ1bmNpb25hbmRvIHBvZGUgc2VyIGVuY29udHJhZG8gW2FxdWldKGh0dHA6Ly9lbWJlZC5wbG5rci5jby9BY2pxY2d2Z0doZEpxRGg3MmVIQSkuXG4gICAqICA8cHJlPlxuICAgKiAgICA8Zm9ybSBuYW1lPVwibXlGb3JtXCI+XG4gICAqICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImNlcFwiIG5nLW1vZGVsPVwiY2VwXCIgZ3VtZ2EtcGF0dGVybj1cIihcXGR7NX0pXFwtKFxcZHszfSlcIiBpZD1cImNlcFwiIHBsYWNlaG9sZGVyPVwiOTk5OTktOTk5XCI+XG4gICAqICAgICAgPHAgbmctc2hvdz1cIm15Rm9ybS5jZXAuJGVycm9yLnBhdHRlcm5cIiBjbGFzcz1cInRleHQtZGFuZ2VyXCI+RXhwcmVzc8OjbyBuw6NvIGNvcnJlc3BvbmRlIGNvbSBvIGZvcm1hdG8gZXNwZXJhZG88L3A+XG4gICAqICAgIDwvZm9ybT5cbiAgICogIDwvcHJlPlxuICAqL1xuXHRQYXR0ZXJuLiRpbmplY3QgPSBbXTtcbiAgZnVuY3Rpb24gUGF0dGVybigpIHtcbiAgICByZXR1cm4ge1xuXHRcdFx0cmVzdHJpY3Q6ICdBJyxcblx0IFx0XHRyZXF1aXJlOiAnbmdNb2RlbCcsXG4gICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsbSwgYXR0cnMsIGN0cmwpIHtcblx0XHRcdFx0aWYgKCFhdHRycy5ndW1nYVBhdHRlcm4pIHtcblx0XHRcdFx0XHR0aHJvdyBcIk8gdmFsb3IgZGEgZGlyZXRpdmEgZ3VtZ2EtcGF0dGVybiBuw6NvIGZvaSBpbmZvcm1hZG8uXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHZhbGlkYXRlUGF0dGVybiA9IGZ1bmN0aW9uIChpbnB1dFZhbHVlKSB7XG5cdFx0XHRcdFx0dmFyIGVycm9yID0gJ3BhdHRlcm4nO1xuXHRcdFx0XHRcdHZhciByZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgYXR0cnMuZ3VtZ2FQYXR0ZXJuICsgJyQnKTtcblx0XHRcdFx0XHR2YXIgaXNWYWxpZCA9IHJlZ2V4LnRlc3QoaW5wdXRWYWx1ZSk7XG5cdFx0XHRcdFx0Y3RybC4kc2V0VmFsaWRpdHkoZXJyb3IsIGlzVmFsaWQpO1xuXHRcdFx0XHRcdHNjb3BlLiRicm9hZGNhc3QoJyRlcnJvcicsIHtcblx0XHRcdFx0XHRcdG5hbWU6IGF0dHJzLm5hbWUsXG5cdFx0XHRcdFx0XHRsYWJlbDogYXR0cnMubGFiZWwgfHwgYXR0cnMubmFtZSxcblx0XHRcdFx0XHRcdHZhbGlkOiBpc1ZhbGlkLFxuXHRcdFx0XHRcdFx0ZXJyb3I6IGVycm9yLFxuXHRcdFx0XHRcdFx0dmFsdWU6IGF0dHJzLnBhdHRlcm5BbGlhcyB8fCBhdHRycy5ndW1nYVBhdHRlcm5cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZXR1cm4gaW5wdXRWYWx1ZTtcblx0XHRcdFx0fTtcblx0XHRcdFx0Y3RybC4kcGFyc2Vycy51bnNoaWZ0KHZhbGlkYXRlUGF0dGVybik7XG5cdFx0XHRcdGN0cmwuJGZvcm1hdHRlcnMucHVzaCh2YWxpZGF0ZVBhdHRlcm4pO1xuXHRcdFx0XHRhdHRycy4kb2JzZXJ2ZSgnZ3VtZ2FQYXR0ZXJuJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHZhbGlkYXRlUGF0dGVybihjdHJsLiR2aWV3VmFsdWUpO1xuXHRcdFx0XHR9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMuZm9ybS5wYXR0ZXJuJyxbXSlcbiAgLmRpcmVjdGl2ZSgnZ3VtZ2FQYXR0ZXJuJyxQYXR0ZXJuKTtcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogQG5nZG9jIGRpcmVjdGl2ZVxuICAgKiBAbmFtZSBndW1nYS5jb3JlOmd1bWdhUmFuZ2VEYXRlXG4gICAqIEByZXN0cmljdCBBXG4gICAqIEBlbGVtZW50IGlucHV0XG4gICAqIEBkZXNjcmlwdGlvblxuXHQgKiBPIGNvbXBvbmVudGUgR3VtZ2FSYW5nZURhdGUgc2VydmUgcGFyYSB2YWxpZGFyIGRhdGFzIG3DrW5pbWFzIGUgbcOheGltYXMgcGFyYSBlbnRyYWRhcyBlbSBmb3JtdWzDoXJpb3MgY29tIGNhbXBvcyBkbyB0aXBvIGRhdGUuXG4gICAqXG4gICAqICMjIE5vdGFcbiAgICogTyB2YWxvciBkbyBhdHJpYnV0by9kaXJldGl2YSDDqSAqKm9icmlnYXTDs3JpbyoqIGUgZGV2ZSBzZXIgdW0gKipvYmpldG8qKiBjb250ZW5kbyBkdWFzIHByb3ByaWVkYWRlcywgKiptaW4qKiBlICoqbWF4KipcbiAgICogY29tIG9zIHZhbG9yZXMgZGUgc3VhcyByZXNwZWN0aXZhcyBkYXRhcyBwYXJhIGV4ZWN1w6fDo28gZGEgdmFsaWRhw6fDo28gcmFuZ2UuXG4gICAqXG4gICAqICMjIEV4ZW1wbG9cbiAgICogVW0gZXhlbXBsbyBkYSBkaXJlY3RpdmUgR3VtZ2FSYW5nZURhdGUgZnVuY2lvbmFuZG8gcG9kZSBzZXIgZW5jb250cmFkbyBbYXF1aV0oaHR0cDovL2VtYmVkLnBsbmtyLmNvL0FjanFjZ3ZnR2hkSnFEaDcyZUhBKS5cbiAgICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGxhYmVsIFVzYWRvIG5hIGludGVncmHDp8OjbyBjb20ge0BsaW5rIGd1bWdhLmNvcmU6Z3VtZ2FFcnJvcnN9IHBhcmEgaW5kaWNhciBlbSBxdWFsIGNhbXBvIHNlIGVuY29udHJhIG8gZXJyby5cblx0ICogU2UgbyBhdHJpYnV0byBmb3Igb21pdGlkbywgYSBkaXJldGl2YSB1c2Fyw6EgbyBhdHJpYnV0byBuYW1lIGRvIGlucHV0LlxuXHQgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgPHByZT5cbiAgICogICAgPGZvcm0gbmFtZT1cIm15Rm9ybVwiPlxuICAgKiAgICAgIDxpbnB1dCB0eXBlPVwiZGF0ZVwiIG5hbWU9XCJyYW5nZURhdGVcIiBuZy1tb2RlbD1cInJhbmdlRGF0ZVwiIGd1bWdhLXJhbmdlLWRhdGU9XCJ7bWluOiAnMTk4Ni0xMi0yOScsIG1heDogJzIwMTUtMDctMjAnfVwiIGlkPVwicmFuZ2VkYXRlXCI+XG4gICAqICAgICAgPHAgbmctc2hvdz1cIm15Rm9ybS5jZXAuJGVycm9yLnJhbmdlZGF0ZVwiIGNsYXNzPVwidGV4dC1kYW5nZXJcIj5BIGRhdGEgaW5mb3JtYWRhIG7Do28gZXN0w6EgZW50cmUgb3MgdmFsb3JlcyBlc3BlcmFkb3M8L3A+XG4gICAqICAgIDwvZm9ybT5cbiAgICogIDwvcHJlPlxuXHQgKi9cblx0IFJhbmdlRGF0ZS4kaW5qZWN0ID0gW1wiJGZpbHRlclwiXTtcblx0IGZ1bmN0aW9uIFJhbmdlRGF0ZSgkZmlsdGVyKSB7XG5cdCBcdHJldHVybiB7XG5cdCBcdFx0cmVzdHJpY3Q6ICdBJyxcblx0IFx0XHRyZXF1aXJlOiAnbmdNb2RlbCcsXG5cdCBcdFx0bGluazogZnVuY3Rpb24gKHNjb3BlLCBlbG0sIGF0dHJzLCBjdHJsKSB7XG5cdCBcdFx0XHRpZiAoYXR0cnMudHlwZSAhPSAnZGF0ZScpIHtcblx0IFx0XHRcdFx0dGhyb3cgJ0VzdGEgZGlyZXRpdmEgc3Vwb3J0YSBhcGVuYXMgaW5wdXRzIGRvIHRpcG8gZGF0ZSc7XG5cdCBcdFx0XHR9XG5cdCBcdFx0XHRpZiAoIWF0dHJzLmd1bWdhUmFuZ2VEYXRlKSB7XG5cdCBcdFx0XHRcdHRocm93IFwiTyB2YWxvciBkYSBkaXJldGl2YSBndW1nYS1yYW5nZS1kYXRlIG7Do28gZm9pIGluZm9ybWFkby5cIjtcblx0IFx0XHRcdH1cbiAgICAgICAgdmFyIHZhbGlkYXRlUmFuZ2VEYXRlID0gZnVuY3Rpb24gKGlucHV0VmFsdWUpIHtcblx0XHRcdFx0XHR2YXIgZXJyb3IgPSAncmFuZ2VkYXRlJztcbiAgICAgICAgICB2YXIgZm9ybWF0ID0gJ3l5eXktTU0tZGQnO1xuICAgICAgICAgIHZhciByYW5nZSA9IHNjb3BlLiRldmFsKGF0dHJzLmd1bWdhUmFuZ2VEYXRlKTtcbiAgICAgICAgXHR2YXIgaW5wdXQgPSAkZmlsdGVyKCdkYXRlJykoaW5wdXRWYWx1ZSwgZm9ybWF0KTtcbiAgICAgICAgICB2YXIgbWluID0gJGZpbHRlcignZGF0ZScpKHJhbmdlLm1pbiwgZm9ybWF0KTtcbiAgICAgICAgXHR2YXIgbWF4ID0gJGZpbHRlcignZGF0ZScpKHJhbmdlLm1heCwgZm9ybWF0KTtcbiAgICAgICAgXHR2YXIgaXNWYWxpZCA9IGlucHV0ID49IG1pbiAmJiBpbnB1dCA8PSBtYXg7XG4gICAgICAgIFx0Y3RybC4kc2V0VmFsaWRpdHkoZXJyb3IsIGlzVmFsaWQpO1xuXHRcdFx0XHRcdHNjb3BlLiRicm9hZGNhc3QoJyRlcnJvcicsIHtcblx0XHRcdFx0XHRcdG5hbWU6IGF0dHJzLm5hbWUsXG5cdFx0XHRcdFx0XHRsYWJlbDogYXR0cnMubGFiZWwgfHwgYXR0cnMubmFtZSxcblx0XHRcdFx0XHRcdHZhbGlkOiBpc1ZhbGlkLFxuXHRcdFx0XHRcdFx0ZXJyb3I6IGVycm9yLFxuXHRcdFx0XHRcdFx0dmFsdWU6IGF0dHJzLmd1bWdhUmFuZ2VEYXRlXG5cdFx0XHRcdFx0fSk7XG4gICAgICAgIFx0cmV0dXJuIGlucHV0VmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIGN0cmwuJHBhcnNlcnMudW5zaGlmdCh2YWxpZGF0ZVJhbmdlRGF0ZSk7XG4gICAgICAgIGN0cmwuJGZvcm1hdHRlcnMucHVzaCh2YWxpZGF0ZVJhbmdlRGF0ZSk7XG4gICAgICAgIGF0dHJzLiRvYnNlcnZlKCdndW1nYVJhbmdlRGF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgXHR2YWxpZGF0ZVJhbmdlRGF0ZShjdHJsLiR2aWV3VmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMuZm9ybS5yYW5nZS5kYXRlJyxbXSlcbiAgLmRpcmVjdGl2ZSgnZ3VtZ2FSYW5nZURhdGUnLFJhbmdlRGF0ZSk7XG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAgICogQG5hbWUgZ3VtZ2EuY29yZTpndW1nYVJhbmdlTnVtYmVyXG4gICAqIEByZXN0cmljdCBBXG4gICAqIEBlbGVtZW50IGlucHV0XG4gICAqIEBkZXNjcmlwdGlvblxuXHQgKiBPIGNvbXBvbmVudGUgR3VtZ2FSYW5nZU51bWJlciBzZXJ2ZSBwYXJhIHZhbGlkYXIgbsO6bWVyb3MgbcOtbmltb3MgZSBtw6F4aW1vcyBlbSBlbnRyYWRhcyBkZSBmb3JtdWzDoXJpb3MgY29tIGNhbXBvcyBkbyB0aXBvIG51bWJlci5cbiAgICpcbiAgICogIyMgTm90YVxuICAgKiBPIHZhbG9yIGRvIGF0cmlidXRvL2RpcmV0aXZhIMOpICoqb2JyaWdhdMOzcmlvKiogZSBkZXZlIHNlciB1bSAqKm9iamV0byoqIGNvbnRlbmRvIGR1YXMgcHJvcHJpZWRhZGVzLCAqKm1pbioqIGUgKiptYXgqKlxuICAgKiBjb20gb3MgdmFsb3JlcyBkZSBzdWFzIHJlc3BlY3RpdmFzIGRhdGFzIHBhcmEgZXhlY3XDp8OjbyBkYSB2YWxpZGHDp8OjbyByYW5nZS5cbiAgICpcbiAgICogIyMgRXhlbXBsb1xuICAgKiBVbSBleGVtcGxvIGRhIGRpcmVjdGl2ZSBHdW1nYVJhbmdlTnVtYmVyIGZ1bmNpb25hbmRvIHBvZGUgc2VyIGVuY29udHJhZG8gW2FxdWldKGh0dHA6Ly9lbWJlZC5wbG5rci5jby9BY2pxY2d2Z0doZEpxRGg3MmVIQSkuXG4gICAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBVc2FkbyBuYSBpbnRlZ3Jhw6fDo28gY29tIHtAbGluayBndW1nYS5jb3JlOmd1bWdhRXJyb3JzfSBwYXJhIGluZGljYXIgZW0gcXVhbCBjYW1wbyBzZSBlbmNvbnRyYSBvIGVycm8uXG5cdCAqIFNlIG8gYXRyaWJ1dG8gZm9yIG9taXRpZG8sIGEgZGlyZXRpdmEgdXNhcsOhIG8gYXRyaWJ1dG8gbmFtZSBkbyBpbnB1dC5cblx0ICpcbiAgICogQGV4YW1wbGVcbiAgICogIDxwcmU+XG4gICAqICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIj5cbiAgICogICAgICA8aW5wdXQgdHlwZT1cImRhdGVcIiBuYW1lPVwicmFuZ2VOdW1iZXJcIiBuZy1tb2RlbD1cInJhbmdlTnVtYmVyXCIgZ3VtZ2EtbnVtYmVyLWRhdGU9XCJ7bWluOiAwLCBtYXg6IDIwfVwiPlxuICAgKiAgICAgIDxwIG5nLXNob3c9XCJteUZvcm0ucmFuZ2VOdW1iZXIuJGVycm9yLnJhbmdlbnVtYmVyXCIgY2xhc3M9XCJ0ZXh0LWRhbmdlclwiPk8gbsO6bWVybyBpbmZvcm1hZG8gbsOjbyBlc3TDoSBlbnRyZSBvcyB2YWxvcmVzIGVzcGVyYWRvczwvcD5cbiAgICogICAgPC9mb3JtPlxuICAgKiAgPC9wcmU+XG5cdCAqL1xuXHQgUmFuZ2VOdW1iZXIuJGluamVjdCA9IFtdO1xuXHQgZnVuY3Rpb24gUmFuZ2VOdW1iZXIoKSB7XG5cdCBcdHJldHVybiB7XG5cdCBcdFx0cmVzdHJpY3Q6ICdBJyxcblx0IFx0XHRyZXF1aXJlOiAnbmdNb2RlbCcsXG5cdCBcdFx0bGluazogZnVuY3Rpb24gKHNjb3BlLCBlbG0sIGF0dHJzLCBjdHJsKSB7XG5cdCBcdFx0XHRpZiAoYXR0cnMudHlwZSAhPSAnbnVtYmVyJykge1xuXHQgXHRcdFx0XHR0aHJvdyAnRXN0YSBkaXJldGl2YSBzdXBvcnRhIGFwZW5hcyBpbnB1dHMgZG8gdGlwbyBudW1iZXInO1xuXHQgXHRcdFx0fVxuXHQgXHRcdFx0aWYgKCFhdHRycy5ndW1nYVJhbmdlTnVtYmVyKSB7XG5cdCBcdFx0XHRcdHRocm93IFwiTyB2YWxvciBkYSBkaXJldGl2YSBndW1nYS1yYW5nZS1udW1iZXIgbsOjbyBmb2kgaW5mb3JtYWRvLlwiO1xuXHQgXHRcdFx0fVxuXHQgXHRcdFx0dmFyIHZhbGlkYXRlUmFuZ2VOdW1iZXIgPSBmdW5jdGlvbiAoaW5wdXRWYWx1ZSkge1xuXHRcdFx0XHRcdHZhciBlcnJvciA9ICdyYW5nZW51bWJlcic7XG4gICAgICAgICAgdmFyIHJhbmdlID0gc2NvcGUuJGV2YWwoYXR0cnMuZ3VtZ2FSYW5nZU51bWJlcik7XG4gICAgICAgICAgdmFyIGlucHV0ID0gcGFyc2VJbnQoaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgdmFyIGlzVmFsaWQgPSBpbnB1dCA+PSByYW5nZS5taW4gJiYgaW5wdXQgPD0gcmFuZ2UubWF4O1xuICAgICAgICAgIGN0cmwuJHNldFZhbGlkaXR5KGVycm9yLCBpc1ZhbGlkKTtcblx0XHRcdFx0XHRzY29wZS4kYnJvYWRjYXN0KCckZXJyb3InLCB7XG5cdFx0XHRcdFx0XHRuYW1lOiBhdHRycy5uYW1lLFxuXHRcdFx0XHRcdFx0bGFiZWw6IGF0dHJzLmxhYmVsIHx8IGF0dHJzLm5hbWUsXG5cdFx0XHRcdFx0XHR2YWxpZDogaXNWYWxpZCxcblx0XHRcdFx0XHRcdGVycm9yOiBlcnJvcixcblx0XHRcdFx0XHRcdHZhbHVlOiBhdHRycy5ndW1nYVJhbmdlTnVtYmVyXG5cdFx0XHRcdFx0fSk7XG5cdCBcdFx0XHRcdHJldHVybiBpbnB1dFZhbHVlO1xuXHQgXHRcdFx0fTtcblx0IFx0XHRcdGN0cmwuJHBhcnNlcnMudW5zaGlmdCh2YWxpZGF0ZVJhbmdlTnVtYmVyKTtcblx0IFx0XHRcdGN0cmwuJGZvcm1hdHRlcnMucHVzaCh2YWxpZGF0ZVJhbmdlTnVtYmVyKTtcblx0IFx0XHRcdGF0dHJzLiRvYnNlcnZlKCdndW1nYVJhbmdlTnVtYmVyJywgZnVuY3Rpb24gKCkge1xuXHQgXHRcdFx0XHR2YWxpZGF0ZVJhbmdlTnVtYmVyKGN0cmwuJHZpZXdWYWx1ZSk7XG5cdCBcdFx0XHR9KTtcblx0IFx0XHR9XG5cdCBcdH1cblx0IH1cblx0IGFuZ3VsYXIubW9kdWxlKCdndW1nYS5kaXJlY3RpdmVzLmZvcm0ucmFuZ2UubnVtYmVyJyxbXSlcblx0IC5kaXJlY3RpdmUoJ2d1bWdhUmFuZ2VOdW1iZXInLFJhbmdlTnVtYmVyKTtcblx0fSkoKTtcbiIsIihmdW5jdGlvbigpe1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBAbmdkb2MgZGlyZWN0aXZlXG4gICAqIEBuYW1lIGd1bWdhLmNvcmU6Z3VtZ2FSZXF1aXJlZFxuICAgKiBAcmVzdHJpY3QgQVxuICAgKiBAZWxlbWVudCBBTllcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIE8gY29tcG9uZW50ZSBHdW1nYVJlcXVpcmVkIHNlcnZlIHBhcmEgdmFsaWRhciBjYW1wb3Mgb2JyaWdhdMOzcmlvcy5cbiAgICpcbiAgICogIyMgRXhlbXBsb1xuICAgKiBVbSBleGVtcGxvIGRhIGRpcmVjdGl2ZSBHdW1nYVJlcXVpcmVkIGZ1bmNpb25hbmRvIHBvZGUgc2VyIGVuY29udHJhZG8gW2FxdWldKGh0dHA6Ly9lbWJlZC5wbG5rci5jby9BY2pxY2d2Z0doZEpxRGg3MmVIQSkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBVc2FkbyBuYSBpbnRlZ3Jhw6fDo28gY29tIHtAbGluayBndW1nYS5jb3JlOmd1bWdhRXJyb3JzfSBwYXJhIGluZGljYXIgZW0gcXVhbCBjYW1wbyBzZSBlbmNvbnRyYSBvIGVycm8uXG4gICAqIFNlIG8gYXRyaWJ1dG8gZm9yIG9taXRpZG8sIGEgZGlyZXRpdmEgdXNhcsOhIG8gYXRyaWJ1dG8gbmFtZSBkbyBpbnB1dC5cblx0ICpcbiAgICogQGV4YW1wbGVcbiAgICogIDxwcmU+XG4gICAqICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIj5cbiAgICogICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwicmVxdWlyZWRcIiBuZy1tb2RlbD1cInJlcXVpcmVkXCIgZ3VtZ2EtcmVxdWlyZWQ+XG4gICAqICAgICAgPHAgbmctc2hvdz1cIm15Rm9ybS5yZXF1aXJlZC4kZXJyb3IucmVxdWlyZWRcIiBjbGFzcz1cInRleHQtZGFuZ2VyXCI+Q2FtcG8gb2JyaWdhdMOzcmlvPC9wPlxuICAgKiAgICA8L2Zvcm0+XG4gICAqICA8L3ByZT5cbiAgICovXG4gIFJlcXVpcmVkLiRpbmplY3QgPSBbXTtcbiAgZnVuY3Rpb24gUmVxdWlyZWQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICByZXF1aXJlOiAnbmdNb2RlbCcsXG4gICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsbSwgYXR0cnMsIGN0cmwpIHtcbiAgICAgICAgYXR0cnMucmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICB2YXIgdmFsaWRhdGVSZXF1aXJlZCA9IGZ1bmN0aW9uIChpbnB1dFZhbHVlKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gJ3JlcXVpcmVkJztcbiAgICAgICAgICB2YXIgaXNWYWxpZCA9ICFhdHRycy5yZXF1aXJlZCB8fCAhY3RybC4kaXNFbXB0eShpbnB1dFZhbHVlKTtcbiAgICAgICAgICBjdHJsLiRzZXRWYWxpZGl0eShlcnJvciwgaXNWYWxpZCk7XG4gICAgICAgICAgc2NvcGUuJGJyb2FkY2FzdCgnJGVycm9yJywge1xuICAgICAgICAgICAgbmFtZTogYXR0cnMubmFtZSxcbiAgICAgICAgICAgIGxhYmVsOiBhdHRycy5sYWJlbCB8fCBhdHRycy5uYW1lLFxuICAgICAgICAgICAgdmFsaWQ6IGlzVmFsaWQsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICB2YWx1ZTogYXR0cnMuZ3VtZ2FSZXF1aXJlZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBjdHJsLiRwYXJzZXJzLnVuc2hpZnQodmFsaWRhdGVSZXF1aXJlZCk7XG4gICAgICAgIGN0cmwuJGZvcm1hdHRlcnMucHVzaCh2YWxpZGF0ZVJlcXVpcmVkKTtcbiAgICAgICAgYXR0cnMuJG9ic2VydmUoJ2d1bWdhUmVxdWlyZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFsaWRhdGVSZXF1aXJlZChjdHJsLiR2aWV3VmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMuZm9ybS5yZXF1aXJlZCcsW10pXG4gIC5kaXJlY3RpdmUoJ2d1bWdhUmVxdWlyZWQnLFJlcXVpcmVkKTtcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdEFkdmFuY2VkTGFiZWwuJGluamVjdCA9IFtdO1xuXHRmdW5jdGlvbiBBZHZhbmNlZExhYmVsKCl7XG5cdFx0dmFyIHRlbXBsYXRlID1cblx0XHQnPGRpdiBjbGFzcz1cImJ0bi1ncm91cFwiPicgK1xuXHRcdCcgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi14c1wiIG5nLWRpc2FibGVkPVwiZGlzYWJsZWRcIiBpZD1cImJ0bnt7YXR0cn19XCIgbmctY2xpY2s9XCJvck9yQW5kKHZhbHVlKVwiPjxzdHJvbmc+e3thdHRyfX08L3N0cm9uZz4ge3tocWx9fSA8c3Ryb25nPnt7dmFsdWV9fTwvc3Ryb25nPjwvYnV0dG9uPicgK1xuXHRcdCcgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi14c1wiIG5nLWRpc2FibGVkPVwiZGlzYWJsZWRcIiBuZy1jbGljaz1cImVtaXREZWxldGUoKVwiIG5nLWlmPVwiZ2V0VmlzaWJpbGl0eSh2YWx1ZSlcIj48c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPjwvYnV0dG9uPicgK1xuXHRcdCc8L2Rpdj4nO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHJlc3RyaWN0OiAnRScsXG5cdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG5cdFx0XHRzY29wZToge1xuXHRcdFx0XHRhdHRyOiAnQCcsXG5cdFx0XHRcdGhxbDogJ0AnLFxuXHRcdFx0XHR2YWx1ZTogJz0nLFxuXHRcdFx0XHRpbmRleDogJz0nLFxuXHRcdFx0XHRkaXNhYmxlZDogJz0nXG5cdFx0XHR9LFxuXHRcdFx0bGluazogZnVuY3Rpb24oc2NvcGUsJGVsbSwkYXR0cnMpe1xuXHRcdFx0XHRpZighJGF0dHJzLmRpc2FibGVkKSBzY29wZS5kaXNhYmxlZCA9IGZhbHNlO1xuXHRcdFx0XHRzY29wZS5ib2wgPSBmYWxzZTtcblxuXHRcdFx0XHRzY29wZS5vck9yQW5kID0gZnVuY3Rpb24oKXtcblxuXHRcdFx0XHRcdGlmKHR5cGVvZiBzY29wZS52YWx1ZSA9PT0gJ3N0cmluZycgJiYgc2NvcGUudmFsdWUudG9VcHBlckNhc2UoKSA9PT0gJ09SJyAmJiAhc2NvcGUuaHFsKXtcblx0XHRcdFx0XHRcdHNjb3BlLnZhbHVlID0gJ0FORCc7XG5cdFx0XHRcdFx0fSAgIGVsc2UgIGlmKHNjb3BlLnZhbHVlLnRvVXBwZXJDYXNlKCkgPT09ICdBTkQnICYmICFzY29wZS5ocWwpe1xuXHRcdFx0XHRcdFx0c2NvcGUudmFsdWUgPSAnT1InO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRzY29wZS5lbWl0RGVsZXRlID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRzY29wZS4kZW1pdCgnZGVsZXRlcGxzJyxzY29wZS5pbmRleCk7XG5cdFx0XHRcdH07XG5cblxuXHRcdFx0XHRzY29wZS5nZXRWaXNpYmlsaXR5ID0gZnVuY3Rpb24odmFsKXtcblx0XHRcdFx0XHRyZXR1cm4gISh2YWwgPT0gJ0FORCcgfHwgdmFsID09ICdPUicpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5zZWFyY2guYWR2YW5jZWRsYWJlbCcsW10pXG5cdC5kaXJlY3RpdmUoJ2d1bWdhQWR2YW5jZWRMYWJlbCcsQWR2YW5jZWRMYWJlbClcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdEFkdmFuY2VkU2VhcmNoLiRpbmplY3QgPSBbXCJHdW1nYVNlYXJjaEhlbHBlclwiXTtcblx0ZnVuY3Rpb24gQWR2YW5jZWRTZWFyY2goR3VtZ2FTZWFyY2hIZWxwZXIpe1xuXHRcdHZhciB0ZW1wbGF0ZSA9XG5cdFx0JyAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cFwiPicgK1xuXHRcdCcgICAgICAgXHQ8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLWJ0blwiIGRyb3Bkb3duIGlzLW9wZW49XCJzdGF0dXMuaXNvcGVuXCI+Jytcblx0XHQnXHRcdFx0XHRcdFx0PHNwYW4gZHJvcGRvd24gb24tdG9nZ2xlPVwidG9nZ2xlZChvcGVuKVwiPicrXG5cdFx0J1x0XHRcdFx0XHRcdFx0PGEgaHJlZiBpZD1cInNpbXBsZS1kcm9wZG93blwiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0XCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6LTNweDtcIiBkcm9wZG93bi10b2dnbGU+Jytcblx0XHQnXHRcdFx0XHRcdFx0XHRcdDxpIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1ob3VyZ2xhc3NcIj48L2k+XHQnK1xuXHRcdCdcdFx0XHRcdFx0XHRcdDwvYT4nK1xuXHRcdCdcdFx0XHRcdFx0XHRcdDx1bCBjbGFzcz1cImRyb3Bkb3duLW1lbnVcIiBhcmlhLWxhYmVsbGVkYnk9XCJzaW1wbGUtZHJvcGRvd25cIiBzdHlsZT1cIndpZHRoOiBhdXRvO1wiPicrXG5cdFx0J1x0XHRcdFx0XHRcdFx0XHQ8bGkgbmctcmVwZWF0PVwiY2hvaWNlIGluICRwYXJlbnQuYXZhaWxhYmxlUXVlcmllc1wiPicrXG5cdFx0J1x0XHRcdFx0XHRcdFx0XHRcdDxhIGhyZWYgbmctY2xpY2s9XCJkb1F1ZXJ5KGNob2ljZSlcIj57e2Nob2ljZS5kZXNjcmlwdGlvbn19PC9hPicrXG5cdFx0J1x0XHRcdFx0XHRcdFx0XHQ8L2xpPicrXG5cdFx0J1x0XHRcdFx0XHRcdFx0PC91bD4nK1xuXHRcdCdcdFx0XHRcdFx0XHQ8L3NwYW4+Jytcblx0XHQnICAgICAgIFx0PC9zcGFuPicgK1xuXHRcdCcgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJzZWFyY2hJbnB1dFRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIG5nLWRpc2FibGVkPVwiaXNQYW5lbE9wZW5cIiBpZD1cInRleHRNYWluXCIvPiAnICtcblx0XHQnICAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYnRuXCI+JyArXG5cdFx0JyAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cIm15LWJ1dHRvbiBidG4tZGVmYXVsdFwiIG5nLWNsaWNrPVwic2hvd0xpdHRsZVBhbmVsID0gIXNob3dMaXR0bGVQYW5lbFwiPjxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWRvd25cIj48L3NwYW4+PC9idXR0b24+JyArXG5cdFx0JyAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cIm15LWJ1dHRvbiBidG4tZGVmYXVsdFwiIHR5cGU9XCJidXR0b25cIiBuZy1jbGljaz1cImlzUGFuZWxPcGVuID0gIWlzUGFuZWxPcGVuXCI+PHNwYW4gY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLWZpbHRlclwiPjwvc3Bhbj4nICtcblx0XHQnICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwibXktYnV0dG9uIGJ0bi1wcmltYXJ5IGxhc3RcIiB0eXBlPVwiYnV0dG9uXCIgbmctZGlzYWJsZWQ9XCJpc1BhbmVsT3BlblwiIG5nLWNsaWNrPVwiZG9TZWFyY2goc2VhcmNoSW5wdXRUZXh0KVwiPlNlYXJjaCA8c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tc2VhcmNoXCI+PC9zcGFuPicgK1xuXHRcdCcgICAgICAgPC9zcGFuPicgK1xuXHRcdCcgICA8L2Rpdj4nICtcblx0XHQnICAgPGRpdiBjbGFzcz1cInBhbmVsLWFkdmFuY2VkXCIgbmctc2hvdz1cImlzUGFuZWxPcGVuXCI+JyArXG5cdFx0JyAgICAgICA8ZGl2IGNsYXNzPVwicGFuZWwtYm9keVwiPicgK1xuXHRcdCcgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtM1wiPicgK1xuXHRcdCcgICAgICAgICAgIDxoMyBzdHlsZT1cIm1hcmdpbi10b3A6IDA7bWFyZ2luLWJvdHRvbTogMFwiPjxzbWFsbD5BZHZhbmNlZCBTZWFyY2g8L3NtYWxsPjwvaDM+JyArXG5cdFx0JyAgICAgICAgICAgPC9kaXY+JyArXG5cdFx0JyAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0taW5saW5lIGNvbC1tZC05XCI+JyArXG5cdFx0JyAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+JyArXG5cdFx0JyAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibGlzdC1ob2xkZXJcIj4nICtcblx0XHQnICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzPVwibGlzdC1zZWxlY3RhYmxlXCIgbmctc2hvdz1cInNlbGVjdEF0dHJpYnV0ZVwiPlxcbicgK1xuXHRcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIG5nLXJlcGVhdD1cImF0dHIgaW4gYXR0cmlidXRlc1wiIG5nLWNsaWNrPVwiYXR0cmlidXRlSGFzQ2hhbmdlZChhdHRyKVwiIGNsYXNzPVwiaG92ZXItbGlzdFwiPjxidXR0b24gY2xhc3M9XCJidG4gYnRuLWxpbmtcIj57e2F0dHIubmFtZX19PC9idXR0b24+PC9saT5cXG4nICtcblx0XHQnICAgICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cXG4nICtcblx0XHQnICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4nICtcblx0XHQnICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0XCIgbmctY2xpY2s9XCJzZWxlY3RBdHRyaWJ1dGUgPSAhc2VsZWN0QXR0cmlidXRlXCIgPnt7cXVlcnkuYXR0cmlidXRlLm5hbWUgfHwgXFwnQXR0cmlidXRlXFwnfX08c3BhbiBjbGFzcz1cImNhcmV0XCI+PC9zcGFuPjwvYnV0dG9uPicgK1xuXHRcdCcgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxpc3QtaG9sZGVyXCI+JyArXG5cdFx0JyAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cImxpc3Qtc2VsZWN0YWJsZVwiIG5nLXNob3c9XCJzZWxlY3RIUUxcIj5cXG4nICtcblx0XHQnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBuZy1yZXBlYXQ9XCJvcHQgaW4gaHFsT3B0c1wiIGNsYXNzPVwiaG92ZXItbGlzdFwiIG5nLWNsaWNrPVwiaGFuZGxlSHFsT3B0aW9uKG9wdClcIj48YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1saW5rXCIgPnt7b3B0LmxhYmVsfX08L2J1dHRvbj48L2xpPlxcbicgK1xuXHRcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxcbicgK1xuXHRcdCcgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PicgK1xuXHRcdCcgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0XCIgbmctY2xpY2s9XCJzZWxlY3RIUUwgPSAhc2VsZWN0SFFMXCI+IHt7IHF1ZXJ5LmhxbC5sYWJlbCB8fCBcXCdIUUxcXCcgIH19IDxzcGFuIGNsYXNzPVwiY2FyZXRcIj48L3NwYW4+PC9idXR0b24+ICAnK1xuXHRcdCcgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ7e3R5cGVJbnB1dH19XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2wgY29sLXgtM1wiIG5nLW1vZGVsPVwicXVlcnkudmFsdWVcIiBpZD1cInNlbGVjdGFibGVBZHZhbmNlZFZhbHVlXCIgbmctaW5pdD1cImlucHV0ID0gdGhpc1wiLz4nICtcblx0XHQnICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0XCIgbmctY2xpY2s9XCJhZGRRdWVyeShxdWVyeSlcIiBuZy1kaXNhYmxlZD1cInF1ZXJ5LnZhbHVlLmxlbmd0aCA+IDAgPyBmYWxzZSA6IHRydWVcIj48c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tcGx1c1wiPjwvc3Bhbj48L2J1dHRvbj4nICtcblx0XHQnICAgICAgICAgICAgICAgPC9kaXY+JyArXG5cdFx0JyAgICAgICAgICAgPC9kaXY+JyArXG5cdFx0JyAgICAgICA8L2Rpdj4nK1xuXHRcdCcgICAgICAgICAgIDxoci8+JyArXG5cdFx0JyAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTEyXCIgc3R5bGU9XCJwYWRkaW5nLWJvdHRvbTogMiVcIj4nICtcblx0XHQnICAgICAgIDxndW1nYS1hZHZhbmNlZC1sYWJlbCBuZy1yZXBlYXQ9XCJxdWVyeSBpbiBxdWVyaWVzXCIgYXR0cj1cInt7cXVlcnkuYXR0cmlidXRlLm5hbWV9fVwiIGhxbD1cInt7cXVlcnkuaHFsLmxhYmVsfX1cIiB2YWx1ZT1cInF1ZXJ5LnZhbHVlXCIgaW5kZXg9XCIkaW5kZXhcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj48L2d1bWdhLWFkdmFuY2VkLWxhYmVsPicgK1xuXHRcdCcgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC0xMlwiIHN0eWxlPVwibWFyZ2luLXRvcDogMSU7XCI+JyArXG5cdFx0JyAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5IHB1bGwtcmlnaHRcIiB0eXBlPVwiYnV0dG9uXCIgbmctZGlzYWJsZWQ9XCJxdWVyaWVzLmxlbmd0aCA9PSAwXCIgbmctY2xpY2s9XCJzaG93QXJyYXkocXVlcmllcylcIj5BZHZhbmNlZCBTZWFyY2g8c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tc2VhcmNoXCI+PC9zcGFuPicgK1xuXHRcdCcgICAgICAgPC9kaXY+JyArXG5cdFx0JyAgICAgICA8L2Rpdj4nICtcblx0XHQnICAgICAgIDxkaXYgY2xhc3M9XCJjbGVhcmZpeFwiIHN0eWxlPVwibWFyZ2luLWJvdHRvbTogMiVcIj48L2Rpdj4nICtcblx0XHQnICAgPC9kaXY+JyArXG5cdFx0JzxkaXYgY2xhc3M9XCJsaXR0bGUtcGFuZWxcIiBuZy1zaG93PVwic2hvd0xpdHRsZVBhbmVsXCI+JyArXG5cdFx0JyAgIDxkaXYgY2xhc3M9XCJwYW5lbC1ib2R5XCI+JyArXG5cdFx0JyAgICAgICA8bGFiZWwgbmctcmVwZWF0PVwiZmllbGQgaW4gbm9ybWFsRmllbGRzXCIgc3R5bGU9XCJkaXNwbGF5OiBibG9ja1wiID48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmctbW9kZWw9XCJtb2RlbHNbZmllbGQudmFsdWVdXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCIgPjxzcGFuPnt7ZmllbGQudmFsdWV9fTwvc3Bhbj48L2xhYmVsPicgK1xuXHRcdCcgICA8L2Rpdj4nICtcblx0XHQnPC9kaXY+Jztcblx0XHRyZXR1cm4ge1xuXHRcdFx0cmVzdHJpY3Q6ICdFJyxcblx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcblx0XHRcdHNjb3BlOiBmYWxzZSxcblx0XHRcdHJlcXVpcmU6ICdeP2d1bWdhU2VhcmNoJyxcblx0XHRcdGxpbms6IGZ1bmN0aW9uKHNjb3BlLGVsbSxhdHRycyxjdHJsKXtcblx0XHRcdFx0c2NvcGUuaXNQYW5lbE9wZW4gPSBmYWxzZTtcblx0XHRcdFx0c2NvcGUuc2VsZWN0SFFMID0gZmFsc2U7XG5cdFx0XHRcdHNjb3BlLm1vZGVscyA9IHt9O1xuXHRcdFx0XHRzY29wZS5zZWFyY2hGaWVsZCA9ICcnO1xuXHRcdFx0XHRzY29wZS50cmFuc2xhdGUgPSBzY29wZS4kcGFyZW50LmVudGl0eVRvVHJhbnNsYXRlO1xuXG5cdFx0XHRcdHNjb3BlLmRvUXVlcnkgPSBmdW5jdGlvbiAoY2hvaWNlKSB7XG5cdFx0XHRcdFx0dmFyIHF1ZXJ5ID0gSlNPTi5wYXJzZShjaG9pY2UudmFsdWUpO1xuXHRcdFx0XHRcdHNjb3BlLiRlbWl0KCdhZHZhbmNlZCcsIHtocWw6IEd1bWdhU2VhcmNoSGVscGVyLnRyYW5zbGF0ZUFycmF5VG9IUUwocXVlcnkpLCBzb3VyY2U6IHF1ZXJ5fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS4kb24oJ19kb1NlYXJjaCcsZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRpZihzY29wZS5xdWVyaWVzLmxlbmd0aCAhPSAwKXtcblx0XHRcdFx0XHRcdHNjb3BlLnNob3dBcnJheShzY29wZS5xdWVyaWVzKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYoc2NvcGUuc2VhcmNoSW5wdXRUZXh0KXtcblx0XHRcdFx0XHRcdFx0c2NvcGUuZG9TZWFyY2goc2NvcGUuc2VhcmNoSW5wdXRUZXh0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHNjb3BlLiRvbignX2ZvY3VzJyxmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGlmKHNjb3BlLmlzUGFuZWxPcGVuKXtcblx0XHRcdFx0XHRcdGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWxlY3RhYmxlQWR2YW5jZWRWYWx1ZScpLmZvY3VzKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0ZXh0TWFpbicpLmZvY3VzKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZighc2NvcGUuJHBhcmVudC5ub3JtYWxGaWVsZHMubGVuZ3RoID4gMCB8fCAhc2NvcGUuJHBhcmVudC5lbnRpdHlUb1RyYW5zbGF0ZSl7XG5cdFx0XHRcdFx0dGhyb3cgJ01pc3Npbmcgc29tZSBwYXJhbWV0ZXJzIGluIEd1bWdhU2VhcmNoJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLm5vcm1hbEZpZWxkcyA9IHNjb3BlLiRwYXJlbnQubm9ybWFsRmllbGRzLm1hcChmdW5jdGlvbihlbG0sJGluZGV4KXtcblx0XHRcdFx0XHRzY29wZS5tb2RlbHNbZWxtXSA9IGZhbHNlO1xuXHRcdFx0XHRcdCRpbmRleCA9PSAwICYmIChzY29wZS5tb2RlbHNbZWxtXSA9IHRydWUpO1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRuYW1lOiBlbG0uc2xpY2UoMCwxKS50b1VwcGVyQ2FzZSgpICsgZWxtLnNsaWNlKDEsZWxtLmxlbmd0aCkudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHZhbHVlOiBlbG1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9KTtcblxuXG5cdFx0XHRcdHNjb3BlLiRvbignc2hvd1BhbmVsJyxmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHNjb3BlLmlzUGFuZWxPcGVuID0gIXNjb3BlLmlzUGFuZWxPcGVuO1xuXHRcdFx0XHRcdHNjb3BlLiRhcHBseSgpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRzY29wZS5tb2RlbHMucmV0dXJuU3RyaW5nID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHR2YXIgdHh0ID0gJyc7XG5cdFx0XHRcdFx0Zm9yKHZhciBrZXkgaW4gdGhpcykgaWYodGhpcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGtleSAhPSAncmV0dXJuU3RyaW5nJyAmJiB0aGlzW2tleV0pe1xuXHRcdFx0XHRcdFx0dHh0ICs9IGtleSArICcsJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYodHh0Lmxlbmd0aCA9PSAwKXtcblx0XHRcdFx0XHRcdHJldHVybiBzY29wZS5ub3JtYWxGaWVsZHNbMF0udmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0eHQuc2xpY2UoMCwtMSk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0c2NvcGUuJHdhdGNoKCdpc1BhbmVsT3BlbicsZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRpZihzY29wZS5pc1BhbmVsT3BlbiA9PT0gdHJ1ZSl7XG5cdFx0XHRcdFx0XHRzY29wZS5zZWxlY3RBdHRyaWJ1dGUgPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzY29wZS5xdWVyaWVzID0gW107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNjb3BlLnF1ZXJ5ID0ge307XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzY29wZS5hdHRyaWJ1dGVzID0gc2NvcGUuJHBhcmVudC5hdHRyaWJ1dGVzO1xuXHRcdFx0XHRzY29wZS5ocWxPcHRzID0gW107XG5cdFx0XHRcdHNjb3BlLnF1ZXJpZXMgPSBbXTtcblxuXHRcdFx0XHRzY29wZS5hdHRyaWJ1dGVIYXNDaGFuZ2VkID0gZnVuY3Rpb24oYXR0cmlidXRlKSB7XG5cdFx0XHRcdFx0c2NvcGUucXVlcnkuYXR0cmlidXRlID0gYXR0cmlidXRlO1xuXHRcdFx0XHRcdGlmKGF0dHJpYnV0ZS50eXBlID09PSAnZGF0ZScpe1xuXHRcdFx0XHRcdFx0c2NvcGUudHlwZUlucHV0ID0gJ2RhdGUnO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzY29wZS50eXBlSW5wdXQgPSAndGV4dCc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNjb3BlLmhxbE9wdHMgPSBHdW1nYVNlYXJjaEhlbHBlci5nZXRUeXBlTGlzdE9mSFFMUG9zc2liaWxpdGllcyhhdHRyaWJ1dGUudHlwZSk7XG5cdFx0XHRcdFx0c2NvcGUuc2VsZWN0SFFMID0gdHJ1ZSA7XG5cdFx0XHRcdFx0c2NvcGUuc2VsZWN0QXR0cmlidXRlID0gZmFsc2U7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0c2NvcGUuaGFuZGxlSHFsT3B0aW9uID0gZnVuY3Rpb24oaHEpe1xuXHRcdFx0XHRcdHNjb3BlLnF1ZXJ5LmhxbCA9IGhxO1xuXHRcdFx0XHRcdHNjb3BlLnNlbGVjdEhRTCA9IGZhbHNlO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGFuZ3VsYXIuZWxlbWVudChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VsZWN0YWJsZUFkdmFuY2VkVmFsdWUnKSlcblx0XHRcdFx0Lm9uKCdrZXlkb3duJyxmdW5jdGlvbihldil7XG5cdFx0XHRcdFx0aWYoZXYua2V5Q29kZSA9PSAxMyAmJiBldi50YXJnZXQudmFsdWUubGVuZ3RoID4gMCl7XG5cdFx0XHRcdFx0XHRzY29wZS5hZGRRdWVyeShzY29wZS5xdWVyeSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNjb3BlLiRhcHBseSgpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRhbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RleHRNYWluJykpXG5cdFx0XHRcdC5vbigna2V5ZG93bicsZnVuY3Rpb24oZXYpe1xuXHRcdFx0XHRcdGlmKGV2LmtleUNvZGUgPT0gMTMgJiYgZXYudGFyZ2V0LnZhbHVlLmxlbmd0aCA+IDApe1xuXHRcdFx0XHRcdFx0c2NvcGUuJGVtaXQoJ25vcm1hbCcse2ZpZWxkOiBzY29wZS5tb2RlbHMucmV0dXJuU3RyaW5nKCkscGFyYW06c2NvcGUuc2VhcmNoSW5wdXRUZXh0IHx8ICcnfSk7XG5cdFx0XHRcdFx0XHRpZihzY29wZS5zaG93TGl0dGxlUGFuZWwpe1xuXHRcdFx0XHRcdFx0XHRzY29wZS5zaG93TGl0dGxlUGFuZWwgPSAhc2NvcGUuc2hvd0xpdHRsZVBhbmVsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0c2NvcGUuYWRkUXVlcnkgPSBmdW5jdGlvbihxdWVyeSl7XG5cdFx0XHRcdFx0aWYoc2NvcGUucXVlcmllcy5sZW5ndGggPT09IDApe1xuXHRcdFx0XHRcdFx0c2NvcGUucXVlcmllcy5wdXNoKHF1ZXJ5KTtcblx0XHRcdFx0XHR9IGVsc2UgaWYoc2NvcGUucXVlcmllcy5sZW5ndGggPj0gMSl7XG5cdFx0XHRcdFx0XHRzY29wZS5xdWVyaWVzLnNwbGljZShzY29wZS5xdWVyaWVzLmxlbmd0aCwxLHt2YWx1ZTogJ0FORCd9LHF1ZXJ5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2NvcGUucXVlcnkgPSB7fTtcblx0XHRcdFx0XHRzY29wZS50eXBlSW5wdXQgPSAndGV4dCc7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0c2NvcGUuJG9uKCdkZWxldGVwbHMnLGZ1bmN0aW9uKGV2LGRhdGEpe1xuXHRcdFx0XHRcdHNjb3BlLnF1ZXJpZXMuc3BsaWNlKGRhdGEsMSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHNjb3BlLnNob3dBcnJheSA9IGZ1bmN0aW9uKGFycmF5KXtcblx0XHRcdFx0XHRzY29wZS5pc1BhbmVsT3BlbiA9IGZhbHNlO1xuXHRcdFx0XHRcdHNjb3BlLiRlbWl0KCdhZHZhbmNlZCcse2hxbDogR3VtZ2FTZWFyY2hIZWxwZXIudHJhbnNsYXRlQXJyYXlUb0hRTChhcnJheSksc291cmNlOiBhcnJheX0pO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHNjb3BlLmRvU2VhcmNoID0gZnVuY3Rpb24odHh0KXtcblx0XHRcdFx0XHRzY29wZS4kZW1pdCgnbm9ybWFsJyx7ZmllbGQ6IHNjb3BlLm1vZGVscy5yZXR1cm5TdHJpbmcoKSxwYXJhbTp0eHQgfHwgJyd9KTtcblx0XHRcdFx0XHRzY29wZS5zZWFyY2hJbnB1dFRleHQgPSAnJztcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cdGFuZ3VsYXIubW9kdWxlKCdndW1nYS5kaXJlY3RpdmVzLnNlYXJjaC5hZHZhbmNlZHNlYXJjaCcsWydndW1nYS5kaXJlY3RpdmVzLnNlYXJjaC5zZWFyY2hoZWxwZXInXSlcblx0LmRpcmVjdGl2ZSgnZ3VtZ2FBZHZhbmNlZFNlYXJjaCcsQWR2YW5jZWRTZWFyY2gpXG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE5vcm1hbFNlYXJjaC4kaW5qZWN0ID0gW107XG5cdGZ1bmN0aW9uIE5vcm1hbFNlYXJjaCgpe1xuXHRcdHZhciB0ZW1wbGF0ZSA9XG5cdFx0JzxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cFwiPicgK1xuXHRcdCcgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIG5nLW1vZGVsPVwic2VhcmNoRmllbGRcIiBwbGFjZWhvbGRlcj1cIlNlYXJjaFwiLz4nICtcblx0XHQnICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1idG5cIj4nICtcblx0XHQnICAgICAgIDxidXR0b24gY2xhc3M9XCJteS1idXR0b24gYnRuLWRlZmF1bHRcIiBuZy1jbGljaz1cInNob3dMaXR0bGVQYW5lbCA9ICFzaG93TGl0dGxlUGFuZWxcIj48c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1kb3duXCI+PC9zcGFuPjwvYnV0dG9uPicgK1xuXHRcdCcgICAgICAgPGJ1dHRvbiBjbGFzcz1cIm15LWJ1dHRvbiBidG4tcHJpbWFyeSBsYXN0XCIgdHlwZT1cImJ1dHRvblwiIG5nLWRpc2FibGVkPVwiIXNlYXJjaEZpZWxkXCIgbmctY2xpY2s9XCJkb1NlYXJjaChzZWFyY2hGaWVsZClcIiA+U2VhcmNoIDxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1zZWFyY2hcIj48L3NwYW4+PC9idXR0b24+JyArXG5cdFx0JyAgIDwvc3Bhbj4nICtcblx0XHQnPC9kaXY+JyArXG5cdFx0JzxkaXYgY2xhc3M9XCJsaXR0bGUtcGFuZWxcIiBuZy1zaG93PVwic2hvd0xpdHRsZVBhbmVsXCI+JyArXG5cdFx0JyAgIDxkaXYgY2xhc3M9XCJwYW5lbC1ib2R5XCI+JyArXG5cdFx0JyAgICAgICA8bGFiZWwgbmctcmVwZWF0PVwiZmllbGQgaW4gbm9ybWFsRmllbGRzXCIgc3R5bGU9XCJkaXNwbGF5OiBibG9ja1wiID48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmctbW9kZWw9XCJtb2RlbHNbZmllbGQudmFsdWVdXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCIgPjxzcGFuPnt7ZmllbGQudmFsdWV9fTwvc3Bhbj48L2xhYmVsPicgK1xuXHRcdCcgICA8L2Rpdj4nICtcblx0XHQnPC9kaXY+Jztcblx0XHRyZXR1cm4ge1xuXHRcdFx0cmVzdHJpY3Q6ICdFJyxcblx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcblx0XHRcdGxpbms6IGZ1bmN0aW9uKHNjb3BlLGVsbSxhdHRycyl7XG5cdFx0XHRcdGlmKCFzY29wZS4kcGFyZW50Lm5vcm1hbEZpZWxkcy5sZW5ndGggPiAwIHx8ICFzY29wZS4kcGFyZW50LmVudGl0eVRvVHJhbnNsYXRlKXtcblx0XHRcdFx0XHR0aHJvdyAnTWlzc2luZyBzb21lIHBhcmFtZXRlcnMgaW4gR3VtZ2FTZWFyY2gnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNjb3BlLm1vZGVscyA9IHt9O1xuXHRcdFx0XHRzY29wZS5zZWFyY2hGaWVsZCA9ICcnO1xuXHRcdFx0XHRzY29wZS50cmFuc2xhdGUgPSBzY29wZS4kcGFyZW50LmVudGl0eVRvVHJhbnNsYXRlO1xuXHRcdFx0XHRzY29wZS5ub3JtYWxGaWVsZHMgPSBzY29wZS4kcGFyZW50Lm5vcm1hbEZpZWxkcy5tYXAoZnVuY3Rpb24oZWxtLCRpbmRleCl7XG5cdFx0XHRcdFx0c2NvcGUubW9kZWxzW2VsbV0gPSBmYWxzZTtcblx0XHRcdFx0XHQkaW5kZXggPT0gMCAmJiAoc2NvcGUubW9kZWxzW2VsbV0gPSB0cnVlKTtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0bmFtZTogZWxtLnNsaWNlKDAsMSkudG9VcHBlckNhc2UoKSArIGVsbS5zbGljZSgxLGVsbS5sZW5ndGgpLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR2YWx1ZTogZWxtXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0c2NvcGUubW9kZWxzLnJldHVyblN0cmluZyA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0dmFyIHR4dCA9ICcnO1xuXHRcdFx0XHRcdGZvcih2YXIga2V5IGluIHRoaXMpIGlmKHRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBrZXkgIT0gJ3JldHVyblN0cmluZycgJiYgdGhpc1trZXldKXtcblx0XHRcdFx0XHRcdHR4dCArPSBrZXkgKyAnLCc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHR4dC5sZW5ndGggPT0gMCl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc2NvcGUubm9ybWFsRmllbGRzWzBdLnZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdHh0LnNsaWNlKDAsLTEpO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGVsbS5maW5kKCdpbnB1dCcpXG5cdFx0XHRcdC5iaW5kKCdrZXlwcmVzcycsZnVuY3Rpb24oZXYpe1xuXHRcdFx0XHRcdGlmKGV2LmtleUNvZGUgPT0gMTMgJiYgc2NvcGUuc2VhcmNoRmllbGQubGVuZ3RoID4gMCl7XG5cdFx0XHRcdFx0XHRzY29wZS4kZW1pdCgnbm9ybWFsJyx7ZmllbGQ6IHNjb3BlLm1vZGVscy5yZXR1cm5TdHJpbmcoKSxwYXJhbTpzY29wZS5zZWFyY2hGaWVsZH0pO1xuXHRcdFx0XHRcdFx0aWYoc2NvcGUuc2hvd0xpdHRsZVBhbmVsKXtcblx0XHRcdFx0XHRcdFx0c2NvcGUuc2hvd0xpdHRsZVBhbmVsID0gIXNjb3BlLnNob3dMaXR0bGVQYW5lbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHNjb3BlLmRvU2VhcmNoID0gZnVuY3Rpb24odHh0KXtcblx0XHRcdFx0XHRzY29wZS4kZW1pdCgnbm9ybWFsJyx7ZmllbGQ6IHNjb3BlLm1vZGVscy5yZXR1cm5TdHJpbmcoKSxwYXJhbTp0eHQgfHwgJyd9KTtcblx0XHRcdFx0XHRzY29wZS5zaG93TGl0dGxlUGFuZWwgPSAhc2NvcGUuc2hvd0xpdHRsZVBhbmVsO1xuXHRcdFx0XHRcdHNjb3BlLnNlYXJjaEZpZWxkID0gJyc7XG5cdFx0XHRcdH07XG5cblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cdGFuZ3VsYXIubW9kdWxlKCdndW1nYS5kaXJlY3RpdmVzLnNlYXJjaC5ub3JtYWxzZWFyY2gnLFtdKVxuXHQuZGlyZWN0aXZlKCdndW1nYU5vcm1hbFNlYXJjaCcsTm9ybWFsU2VhcmNoKVxufSkoKTsiLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdFNlYXJjaC4kaW5qZWN0ID0gW107XG5cdGZ1bmN0aW9uIFNlYXJjaCgpe1xuXHRcdHZhciB0ZW1wbGF0ZSA9XG5cdFx0JzxkaXYgY2xhc3M9XCJmdWxsLXdpZHRoLXdpdGhvdXQtcGFkZGluZ1wiPicgK1xuXHRcdCcgICAgIDxkaXYgbmctaWY9XCIhYWR2XCI+JyArXG5cdFx0JyAgICAgICAgIDxndW1nYS1ub3JtYWwtc2VhcmNoPjwvZ3VtZ2Etbm9ybWFsLXNlYXJjaD4nICtcblx0XHQnICAgICA8L2Rpdj4nICtcblx0XHQnICAgICA8ZGl2IG5nLWlmPVwiYWR2XCI+JyArXG5cdFx0JyAgICAgICAgIDxndW1nYS1hZHZhbmNlZC1zZWFyY2g+PC9ndW1nYS1hZHZhbmNlZC1zZWFyY2g+JyArXG5cdFx0JyAgICAgPC9kaXY+JyArXG5cdFx0JzwvZGl2Pic7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHJlc3RyaWN0OiAnRScsXG5cdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG5cdFx0XHR0cmFuc2NsdWRlOiB0cnVlLFxuXHRcdFx0c2NvcGUgOiB7XG5cdFx0XHRcdGFkdmFuY2VkOiAnJmFkdmFuY2VkTWV0aG9kJyxcblx0XHRcdFx0bm9ybWFsOiAnJnNlYXJjaE1ldGhvZCcsXG5cdFx0XHRcdG9uU2VhcmNoOiAnJicsXG5cdFx0XHRcdG9uQWR2YW5jZWRTZWFyY2g6ICcmJyxcblx0XHRcdFx0Z2V0UXVlcmllczogJyY/J1xuXHRcdFx0fSxcblx0XHRcdGxpbms6IGZ1bmN0aW9uKHNjb3BlLGVsbSxhdHRycyxjb250cm9sbGVyLHRyYW5zY2x1ZGVGbil7XG5cdFx0XHRcdHNjb3BlLmFkdiA9IGZhbHNlO1xuXHRcdFx0XHRzY29wZS5hdHRyaWJ1dGVzID0gW107XG5cdFx0XHRcdHNjb3BlLm5vcm1hbEZpZWxkcyA9IGF0dHJzLmZpZWxkcy5zcGxpdCgnLCcpO1xuXHRcdFx0XHRzY29wZS5lbnRpdHlUb1RyYW5zbGF0ZSA9IGF0dHJzLnRyYW5zbGF0ZUVudGl0eTtcblx0XHRcdFx0c2NvcGUuJHBhcmVudC5zZWFyY2hRdWVyaWVzID0gW107XG5cdFx0XHRcdHNjb3BlLmF2YWlsYWJsZVF1ZXJpZXMgPSBbXTtcblx0XHRcdFx0c2NvcGUuc2F2ZVF1ZXJ5ID0gZmFsc2U7XG5cdFx0XHRcdGlmKGF0dHJzLmdldFF1ZXJpZXMpe1xuXHRcdFx0XHRcdHNjb3BlLnNhdmVRdWVyeSA9IHRydWU7XG5cdFx0XHRcdFx0c2NvcGUuZ2V0UXVlcmllcyh7cGFnZTogbG9jYXRpb24uaGFzaH0pXG5cdFx0XHRcdFx0LnRoZW4oZnVuY3Rpb24oZGF0YSl7XG5cdFx0XHRcdFx0XHRzY29wZS5hdmFpbGFibGVRdWVyaWVzID0gZGF0YTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGV2ZW50SGFuZGxlciA9IHtcblx0XHRcdFx0XHRzZWFyY2g6IGF0dHJzLm9uU2VhcmNoID8gc2NvcGUub25TZWFyY2ggOiBhbmd1bGFyLm5vb3AsXG5cdFx0XHRcdFx0YWR2YW5jZWQ6IGF0dHJzLm9uQWR2YW5jZWRTZWFyY2ggPyBzY29wZS5vbkFkdmFuY2VkU2VhcmNoIDogYW5ndWxhci5ub29wXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoYXR0cnMuYWR2YW5jZWQgPT09IFwidHJ1ZVwiKXtcblx0XHRcdFx0XHRzY29wZS5hZHYgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpe1xuXHRcdFx0XHRcdHRyYW5zY2x1ZGVGbihmdW5jdGlvbihjbG9uZSl7XG5cdFx0XHRcdFx0XHRhbmd1bGFyLmZvckVhY2goY2xvbmUsZnVuY3Rpb24oY2xvbmVFbCl7XG5cdFx0XHRcdFx0XHRcdGlmKGNsb25lRWwubm9kZU5hbWUgPT0gJ0FEVkFOQ0VELUZJRUxEJyl7XG5cdFx0XHRcdFx0XHRcdFx0c2NvcGUuYXR0cmlidXRlcy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0XHRcdG5hbWU6IGNsb25lRWwuZ2V0QXR0cmlidXRlKCduYW1lJyksXG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBjbG9uZUVsLmdldEF0dHJpYnV0ZSgndHlwZScpXG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHNjb3BlLiRvbignYWR2YW5jZWQnLGZ1bmN0aW9uKGV2LGRhdGEpe1xuXHRcdFx0XHRcdHNjb3BlLiRwYXJlbnQuc2VhcmNoUXVlcmllcyA9IFtdO1xuXHRcdFx0XHRcdHNjb3BlLiRwYXJlbnQuc2VhcmNoUXVlcmllcyA9IGRhdGEuc291cmNlO1xuXHRcdFx0XHRcdHNjb3BlLmFkdmFuY2VkKHtwYXJhbTogZGF0YX0pO1xuXHRcdFx0XHRcdGV2ZW50SGFuZGxlci5hZHZhbmNlZCgpO1xuICAgICAgICB9KTtcblxuXHRcdFx0XHRzY29wZS4kb24oJ25vcm1hbCcsZnVuY3Rpb24oZXYsZGF0YSl7XG5cdFx0XHRcdFx0c2NvcGUubm9ybWFsKHtmaWVsZDogZGF0YS5maWVsZCxwYXJhbTogZGF0YS5wYXJhbX0pO1xuXHRcdFx0XHRcdGV2ZW50SGFuZGxlci5zZWFyY2goKVxuICAgICAgICB9KTtcblxuXHRcdFx0XHRzY29wZS5nZXRBdHRyaWJ1dGVzKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5zZWFyY2guc2VhcmNoJyxbXSlcblx0LmRpcmVjdGl2ZSgnZ3VtZ2FTZWFyY2gnLFNlYXJjaClcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdFNlYXJjaEhlbHBlci4kaW5qZWN0ID0gW107XG5cdGZ1bmN0aW9uIFNlYXJjaEhlbHBlcigpe1xuXHRcdHZhciB0eXBlcyA9e1xuXHRcdFx0XCJzdHJpbmdcIjoge1xuXHRcdFx0XHRcIkhRTFBvc3NpYmlsaXRpZXNcIjogW1xuXHRcdFx0XHR7aHFsOlwiZXFcIixsYWJlbDogXCJpZ3VhbFwiICwgYmVmb3JlOiBcIj0nXCIsYWZ0ZXI6XCInXCJ9LFxuXHRcdFx0XHR7aHFsOlwibmVcIixsYWJlbDogXCJkaWZlcmVudGUgZGVcIiAsIGJlZm9yZTogXCIhPSdcIixhZnRlcjpcIidcIn0sXG5cdFx0XHRcdHtocWw6IFwiY29udGFpbnNcIixsYWJlbDogXCJjb250w6ltXCIgLCBiZWZvcmU6IFwiIGxpa2UgJ1xcJVwiLGFmdGVyOlwiXFwlJ1wifSxcblx0XHRcdFx0e2hxbDogXCJub3RfY29udGFpbnNcIixsYWJlbDpcIm7Do28gY29udMOpbVwiICwgYmVmb3JlOiBcIiBub3QgbGlrZSAnXFwlXCIsYWZ0ZXI6XCJcXCUnXCJ9LFxuXHRcdFx0XHR7aHFsOiBcInN0YXJ0c193aXRoXCIsbGFiZWw6XCJjb21lw6dhIGNvbVwiICwgYmVmb3JlOiBcImxpa2UgJ1wiLGFmdGVyOlwiXFwlJ1wifSxcblx0XHRcdFx0e2hxbDogXCJlbmRzX3dpdGhcIixsYWJlbDogXCJ0ZXJtaW5hIGNvbVwiICwgYmVmb3JlOiBcImxpa2UgJ1xcJVwiLGFmdGVyOlwiJ1wifSxcblx0XHRcdFx0e2hxbDogXCJnZVwiLGxhYmVsOlwibWFpb3IgaWd1YWxcIiAsIGJlZm9yZTogXCI+PSdcIixhZnRlcjpcIidcIn0sXG5cdFx0XHRcdHtocWw6IFwibGVcIixsYWJlbDogXCJtZW5vciBpZ3VhbFwiICwgYmVmb3JlOiBcIjw9J1wiLGFmdGVyOlwiJ1wifV1cblx0XHRcdH0sXG5cdFx0XHRcIm51bWJlclwiOiB7XG5cdFx0XHRcdFwiSFFMUG9zc2liaWxpdGllc1wiOiBbXG5cdFx0XHRcdHtocWw6XCJlcVwiLGxhYmVsOiBcImlndWFsXCIsIGJlZm9yZTogXCI9XCIsYWZ0ZXI6XCJcIn0sXG5cdFx0XHRcdHtocWw6XCJuZVwiLGxhYmVsOiBcImRpZmVyZW50ZSBkZVwiLCBiZWZvcmU6IFwiIT1cIixhZnRlcjpcIlwifSxcblx0XHRcdFx0e2hxbDogXCJndFwiLGxhYmVsOlwibWFpb3IgcXVlXCIsIGJlZm9yZTogXCI+XCIsYWZ0ZXI6XCJcIn0sXG5cdFx0XHRcdHtocWw6IFwiZ2VcIixsYWJlbDpcIm1haW9yIGlndWFsXCIsIGJlZm9yZTogXCI+PVwiLGFmdGVyOlwiXCJ9LFxuXHRcdFx0XHR7aHFsOiBcImx0XCIsbGFiZWw6XCJtZW5vciBxdWVcIiwgYmVmb3JlOiBcIjxcIixhZnRlcjpcIlwifSxcblx0XHRcdFx0e2hxbDogXCJsZVwiLGxhYmVsOlwibWVub3IgaWd1YWxcIiwgYmVmb3JlOiBcIjw9XCIsYWZ0ZXI6XCJcIn1dXG5cdFx0XHR9LFxuXHRcdFx0XCJtb25leVwiOiB7XG5cdFx0XHRcdFwiSFFMUG9zc2liaWxpdGllc1wiOiBbXG5cdFx0XHRcdHtocWw6XCJlcVwiLGxhYmVsOiBcImlndWFsXCIsIGJlZm9yZTogXCI9XCIsYWZ0ZXI6XCJcIn0sXG5cdFx0XHRcdHtocWw6XCJuZVwiLGxhYmVsOiBcImRpZmVyZW50ZSBkZVwiLCBiZWZvcmU6IFwiIT1cIixhZnRlcjpcIlwifSxcblx0XHRcdFx0e2hxbDogXCJndFwiLGxhYmVsOlwibWFpb3IgcXVlXCIsIGJlZm9yZTogXCI+XCIsYWZ0ZXI6XCJcIn0sXG5cdFx0XHRcdHtocWw6IFwiZ2VcIixsYWJlbDpcIm1haW9yIGlndWFsXCIsIGJlZm9yZTogXCI+PVwiLGFmdGVyOlwiXCJ9LFxuXHRcdFx0XHR7aHFsOiBcImx0XCIsbGFiZWw6XCJtZW5vciBxdWVcIiwgYmVmb3JlOiBcIjxcIixhZnRlcjpcIlwifSxcblx0XHRcdFx0e2hxbDogXCJsZVwiLGxhYmVsOlwibWFpb3IgaWd1YWxcIiwgYmVmb3JlOiBcIjw9XCIsYWZ0ZXI6XCJcIn1dXG5cblx0XHRcdH0sXG5cdFx0XHRcImJvb2xlYW5cIjoge1xuXHRcdFx0XHRcIkhRTFBvc3NpYmlsaXRpZXNcIjogW3tocWw6XCJlcVwiLGxhYmVsOiBcImlndWFsXCIgLCBiZWZvcmU6IFwiPSdcIixhZnRlcjpcIidcIn1dXG5cdFx0XHR9LFxuXHRcdFx0XCJkYXRlXCI6IHtcblx0XHRcdFx0XCJIUUxQb3NzaWJpbGl0aWVzXCI6IFtcblx0XHRcdFx0e2hxbDogXCJlcVwiLCBsYWJlbDogXCJpZ3VhbFwiLCBiZWZvcmU6IFwiPSdcIiwgYWZ0ZXI6IFwiJ1wifSxcblx0XHRcdFx0e2hxbDogXCJnZVwiLCBsYWJlbDogXCJtYWlvciBpZ3VhbFwiLCBiZWZvcmU6IFwiPj0nXCIsIGFmdGVyOiBcIidcIn0sXG5cdFx0XHRcdHtocWw6IFwibGVcIiwgbGFiZWw6IFwibWVub3IgaWd1YWxcIiwgYmVmb3JlOiBcIjw9J1wiLCBhZnRlcjogXCInXCJ9XVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIHtcblx0XHRcdGdldFR5cGVMaXN0T2ZIUUxQb3NzaWJpbGl0aWVzOiBmdW5jdGlvbih0eXBlKXtcblx0XHRcdFx0aWYoYW5ndWxhci5pc0RlZmluZWQodHlwZXNbdHlwZV0pKVxuXHRcdFx0XHRcdHJldHVybiB0eXBlc1t0eXBlXS5IUUxQb3NzaWJpbGl0aWVzO1xuXHRcdFx0XHR0aHJvdyAnVHlwZSBkb2VzblxcJ3QgZXhpc3QnO1xuXHRcdFx0fSxcblx0XHRcdHRyYW5zbGF0ZUFycmF5VG9IUUw6IGZ1bmN0aW9uKGFycmF5KXtcblx0XHRcdFx0cmV0dXJuIGFycmF5XG5cdFx0XHRcdC5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHQoYW5ndWxhci5pc0RlZmluZWQoZWxlbWVudC5hdHRyaWJ1dGUpID8gJ29iai4nICsgZWxlbWVudC5hdHRyaWJ1dGUubmFtZSA6ICchJylcblx0XHRcdFx0XHRcdCsgJycgK1xuXHRcdFx0XHRcdFx0KGFuZ3VsYXIuaXNEZWZpbmVkKGVsZW1lbnQuaHFsKSA/IGVsZW1lbnQuaHFsLmJlZm9yZSA6ICcgIScpXG5cdFx0XHRcdFx0XHQrICcnICtcblx0XHRcdFx0XHRcdGVsZW1lbnQudmFsdWVcblx0XHRcdFx0XHRcdCsgKGFuZ3VsYXIuaXNEZWZpbmVkKGVsZW1lbnQuaHFsKSA/IGVsZW1lbnQuaHFsLmFmdGVyIDogJyAhJykgKTtcblx0XHRcdFx0fSkubWFwKGZ1bmN0aW9uKGVsZW1lbnQpe1xuXHRcdFx0XHRcdGlmKGVsZW1lbnQuaW5kZXhPZignIScpICE9IC0xKXtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtZW50LnJlcGxhY2UoLyEvZywnJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBlbGVtZW50O1xuXHRcdFx0XHR9KS5qb2luKFwiXCIpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblx0YW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMuc2VhcmNoLnNlYXJjaGhlbHBlcicsW10pXG5cdC5mYWN0b3J5KCdHdW1nYVNlYXJjaEhlbHBlcicsU2VhcmNoSGVscGVyKVxufSkoKTtcbiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cdFRyYW5zbGF0ZS4kaW5qZWN0ID0gW1wiJGh0dHBcIiwgXCJUcmFuc2xhdGVIZWxwZXJcIl07XG5cdGZ1bmN0aW9uIFRyYW5zbGF0ZSgkaHR0cCxUcmFuc2xhdGVIZWxwZXIpe1xuXHRcdHZhciBjaCA9IDA7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHJlc3RyaWN0OiAnQUVDJyxcblx0XHRcdHNjb3BlOiBmYWxzZSxcblx0XHRcdGxpbms6IGZ1bmN0aW9uKCRzY29wZSwkZWxtLCRhdHRycyl7XG5cdFx0XHRcdHZhciBsYW5ndWFnZSA9ICRhdHRycy5ndW1nYVRyYW5zbGF0ZS50b0xvd2VyQ2FzZSgpIHx8IG5hdmlnYXRvci5sYW5ndWFnZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRpZighVHJhbnNsYXRlSGVscGVyLmdldFNlc3Npb25TdG9yYWdlSXRlbShsYW5ndWFnZSkpe1xuXHRcdFx0XHRcdCRodHRwLmdldCgnLi9pMThuLycgKyBsYW5ndWFnZSArICcuanNvbicpXG5cdFx0XHRcdFx0LnN1Y2Nlc3MoZnVuY3Rpb24odmFsdWVzKXtcblx0XHRcdFx0XHRcdFRyYW5zbGF0ZUhlbHBlci5zZXRUcmFuc2xhdG9ycyhsYW5ndWFnZSx2YWx1ZXMpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0YW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMudHJhbnNsYXRlLnRyYW5zbGF0ZScsWydndW1nYS5kaXJlY3RpdmVzLnRyYW5zbGF0ZS50cmFuc2xhdGVoZWxwZXInXSlcblx0LmRpcmVjdGl2ZSgnZ3VtZ2FUcmFuc2xhdGUnLFRyYW5zbGF0ZSk7XG59KSgpOyIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZnVuY3Rpb24gVHJhbnNsYXRlSGVscGVyKCl7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGdldFNlc3Npb25TdG9yYWdlSXRlbTogZnVuY3Rpb24oa2V5KXtcblx0XHRcdFx0dmFyIGcgPSB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuXHRcdFx0XHRpZighZyl7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRhbmd1bGFyLmZyb21Kc29uKGcpO1xuXHRcdFx0XHR9Y2F0Y2goZSl7XG5cdFx0XHRcdFx0cmV0dXJuIGc7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy50cmFuc2xhdG9ycyA9IGFuZ3VsYXIuZnJvbUpzb24oYW5ndWxhci5mcm9tSnNvbihnKSk7XG5cdFx0XHRcdHJldHVybiBhbmd1bGFyLmZyb21Kc29uKGFuZ3VsYXIuZnJvbUpzb24oZykpO1xuXHRcdFx0fSxcblx0XHRcdHRyYW5zbGF0b3JzOiB7fSxcblx0XHRcdHNldFRyYW5zbGF0b3JzOiBmdW5jdGlvbihsYW5ndWFnZSxvYmope1xuXHRcdFx0XHR0aGlzLnRyYW5zbGF0b3JzID0gb2JqO1xuXHRcdFx0XHR0aGlzLnNldFNlc3Npb25TdG9yYWdlSXRlbShsYW5ndWFnZSxKU09OLnN0cmluZ2lmeShvYmopKTtcblx0XHRcdH0sXG5cdFx0XHRzZXRTZXNzaW9uU3RvcmFnZUl0ZW06IGZ1bmN0aW9uKGtleSx2YWx1ZSl7XG5cdFx0XHRcdHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKGtleSxhbmd1bGFyLnRvSnNvbih2YWx1ZSkpO1xuXHRcdFx0fSxcblx0XHRcdHJldHVyblRyYW5zbGF0aW9uOiBmdW5jdGlvbihzdHJpbmcpe1xuXHRcdFx0XHR2YXIgYXJyYXkgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdG9yc1thcnJheVswXS50b0xvd2VyQ2FzZSgpLnRyaW0oKV1bYXJyYXlbMV0udG9Mb3dlckNhc2UoKS50cmltKCldO1xuXHRcdFx0XHR9IGNhdGNoKGUpe31cblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0YW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMudHJhbnNsYXRlLnRyYW5zbGF0ZWhlbHBlcicsW10pXG5cdC5mYWN0b3J5KCdUcmFuc2xhdGVIZWxwZXInLFRyYW5zbGF0ZUhlbHBlcik7XG5cbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcbiAgJ3VzZSBzdHJpY3QnO1xuICBUcmFuc2xhdGVUYWcuJGluamVjdCA9IFtcIlRyYW5zbGF0ZUhlbHBlclwiLCBcIiRjb21waWxlXCJdO1xuICBmdW5jdGlvbiBUcmFuc2xhdGVUYWcoVHJhbnNsYXRlSGVscGVyLCRjb21waWxlKXtcbiAgICB2YXIgY2hpbGQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSxlbG0sYXR0cnMpe1xuICAgICAgICBpZighYXR0cnMuZ3VtZ2FUcmFuc2xhdGVUYWcpIHRocm93ICdZb3UgbXVzdCBwYXNzIGEgdmFsaWQgdmFsdWUgdG8gZ3VtZ2FUcmFuc2xhdGVUYWcnO1xuICAgICAgICBpZihUcmFuc2xhdGVIZWxwZXIucmV0dXJuVHJhbnNsYXRpb24oYXR0cnMuZ3VtZ2FUcmFuc2xhdGVUYWcpKXtcbiAgICAgICAgICBpZihlbG1bMF0uY2hpbGROb2Rlcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIHNjb3BlLmNoaWxkID0gZWxtWzBdLmNoaWxkTm9kZXNbMF07XG4gICAgICAgICAgICBlbG1bMF0uaW5uZXJIVE1MID0gIFRyYW5zbGF0ZUhlbHBlci5yZXR1cm5UcmFuc2xhdGlvbihhdHRycy5ndW1nYVRyYW5zbGF0ZVRhZyk7XG4gICAgICAgICAgICBlbG0uYXBwZW5kKCRjb21waWxlKHNjb3BlLmNoaWxkKShzY29wZSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbG1bMF0uaW5uZXJIVE1MID0gVHJhbnNsYXRlSGVscGVyLnJldHVyblRyYW5zbGF0aW9uKGF0dHJzLmd1bWdhVHJhbnNsYXRlVGFnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH07XG4gIH1cblxuICBhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy50cmFuc2xhdGUudHJhbnNsYXRldGFnJyxbJ2d1bWdhLmRpcmVjdGl2ZXMudHJhbnNsYXRlLnRyYW5zbGF0ZWhlbHBlciddKVxuICAuZGlyZWN0aXZlKCdndW1nYVRyYW5zbGF0ZVRhZycsVHJhbnNsYXRlVGFnKTtcbn0pKCk7XG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=