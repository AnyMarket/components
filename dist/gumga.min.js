
angular.module('gumga.core',
	['gumga.services',
	'gumga.controllers',
	'gumga.directives']);

(function(){
	'use strict';

	angular.module('gumga.controllers',[]);

})();

(function(){
	'use strict';

	angular.module('gumga.directives',
		[
		'gumga.directives.address',
		'gumga.directives.queries',
		'gumga.directives.alert',
		'gumga.directives.breadcrumb',
		'gumga.directives.counter',
		'gumga.directives.formbuttons',
		'gumga.directives.manytomany',
		'gumga.directives.manytoone',
		'gumga.directives.menu',
		'gumga.directives.nav',
		'gumga.directives.onetomany',
		'gumga.directives.search',
		'gumga.directives.table',
		'gumga.directives.upload',
		'gumga.directives.form',
		'gumga.directives.translate',
		'gumga.directives.mask',
		'gumga.directives.list',
		'gumga.directives.translate'
		]);

})();

(function(){
	'use strict';

	angular.module('gumga.services',[
		'gumga.services.address',
		'gumga.services.keyboard',
		'gumga.services.base',
		'gumga.services.utils',
		'gumga.services.alert',
		'gumga.services.translate',
		'gumga.services.webstorage',
		'gumga.services.populate',
		'gumga.services.rest',
		'gumga.services.notification'
		]);
})();

(function(){
	'use strict';
	/**
	 * @ngdoc directive
	 * @name gumga.core:gumgaAddress
	 * @restrict E
	 * @description O componente GumgaAddress recebe um objeto que será preenchido com o endereço, que pode ser pesquisado através do CEP (Utilizando um WebService GUMGA),
	 * ou preenchido manualmente pelo usuário. Este objeto de entrada pode ser vazio ou preferivelmente no formato do objeto GUMGA.
       * ## Exemplo
       * Veja um exemplo em funcionamento [aqui](http://embed.plnkr.co/7t9mZtLl9bPuVhmig0oI/).
	 * @param {Object} value Atributo obrigatório que irá conter o nome do objeto no $scope no qual os valores do Endereço serão colocados.
	 * @param {String} name Atributo obrigatório e único que irá conter um nome de identificador para a directive.
	 * @param {String} title Atributo opcional que irá conter o título para o panel da directive.
	 * @param {Function} onSearchCepStart Atributo opcional que irá conter o nome de uma função que será executada quando a busca pelo CEP começar.
	 * @param {Function} onSearchCepSuccess Atributo opcional que irá conter o nome de uma função que será executada quando a busca pelo CEP retornar sucesso.
       *  Pode ser chamada com um atributo com os valores `on-search-cep-success="doSomething($value)"`
	 * @param {Function} onSearchCepError Atributo opcional que irá conter o nome de uma função que será executada quando a busca pelo CEP retornar erro.
       *  Pode ser chamada com um atributo com os valores `on-search-cep-error="doSomething($value)"`
      */
	AddressDirective.$inject = ["GumgaAddressService", "$http"];
      function AddressDirective(GumgaAddressService,$http){
      	var template = [
      	'<div class="address" style="padding-left: 0">',
      	'    <div class="col-md-8 col-sm-12 col-xs-12" style="padding-left: 0">',
      	'          <accordion>',
      	'                <accordion-group style="margin-top: 1%" is-open="true" heading="{{::title}}">',
      	'                      <div class="col-md-12">',
      	'                            <label for="input{{::id}}">CEP</label>',
      	'                            <div class="input-group">',
      	'                                  <input type="text" class="form-control" ng-model="value.zipCode" id="input{{::id}}" ng-keypress="custom($event,value.zipCode)">',
      	'                                  <span class="input-group-btn">',
      	'                                        <button class="btn btn-primary" type="button" ng-click="searchCep(value.zipCode)" ng-disabled="loader{{::id}}" id="buttonSearch{{::id}}">Search <i class="glyphicon glyphicon-search"></i></button>',
      	'                                  </span>',
      	'                            </div>',
      	'                      </div>',
      	'                      <div class="col-md-4">',
      	'                            <label for="tipoLogradouro"><small>Tipo Logradouro</small></label>',
      	'                            <select type="text" ng-model="value.premisseType" class="form-control" ng-options="log for log in factoryData.logs"></select>',
      	'                      </div>',
      	'                      <div class="col-md-5" style="padding-left: 0; padding-right: 0">',
      	'                            <label for="Logradouro"><small>Logradouro</small></label>',
      	'                            <input type="text" ng-model="value.premisse" class="form-control id="oi"/>',
      	'                      </div>',
      	'                      <div class="col-md-3">',
      	'                            <label for="Número"><small> Número </small></label>',
      	'                            <input type="text" ng-model="value.number" class="form-control" id="numberInput{{::id}}"/>',
      	'                      </div>',
      	'                      <div class="col-md-12">',
      	'                            <label for="Complemento"><small>Complemento</small></label>',
      	'                            <input type="text" ng-model="value.information" class="form-control"/>',
      	'                      </div>',
      	'                      <div class="col-md-7">',
      	'                            <label for="Bairro"><small> Bairro </small></label>',
      	'                            <input type="text" ng-model="value.neighbourhood" class="form-control"/>',
      	'                      </div>',
      	'                      <div class="col-md-5">',
      	'                            <label for="Localidade"><small> Localidade </small></label>',
      	'                            <input type="text" ng-model="value.localization" class="form-control"/>',
      	'                      </div>',
      	'                      <div class="col-md-4">',
      	'                            <label for="UF"><small> UF </small></label>',
      	'                            <select ng-model="value.state" class="form-control" ng-options="uf for uf in factoryData.ufs"></select>',
      	'                      </div>',
      	'                      <div class="col-md-4">',
      	'                            <label for="País"><small> País </small></label>',
      	'                            <select ng-model="value.country" class="form-control" ng-options="pais for pais in factoryData.availableCountries"></select>',
      	'                      </div>',
      	'                      <div class="col-md-4" style="padding-top: 2%">',
      	'                            <a class="btn btn-default pull-right" ng-href="{{returnLink(value)}}" target="_blank">Maps <i class="glyphicon glyphicon-globe"></i></a>',
      	'                      </div>',
      	'                </accordion-group>',
      	'          </accordion>',
      	'    </div>',
      	'</div>'];
      	return {
      		restrict: 'E',
      		scope: {
      			value: '=',
      			onSearchCepStart: '&?',
      			onSearchCepSuccess: '&?',
      			onSearchCepError: '&?'
      		},
      		template: template.join('\n'),
      		link: function (scope, elm, attrs, ctrl) {
						function isEmpty(obj){
    					for(var key in obj) if(obj.hasOwnProperty(key)){
        				return false;
    					}
    					return true;
						}
	          if(isEmpty(scope.value)) scope.value = GumgaAddressService.returnFormattedObject();
	          if(!attrs.name) throw "É necessário passar um parâmetro 'name' como identificador para GumgaAddress";
      			scope.title = attrs.title || 'Endereço';
      			scope.id = attrs.name;
      			scope['loader' + scope.id] = false;
            scope.factoryData = {
                ufs: GumgaAddressService.everyUf,
                logs: GumgaAddressService.everyLogradouro,
                availableCountries: GumgaAddressService.availableCountries
            };
            var eventHandler = {
                  searchCepStart: (attrs.onSearchCepStart ? scope.onSearchCepStart : angular.noop),
                  searchCepSuccess: (attrs.onSearchCepSuccess ? scope.onSearchCepSuccess : angular.noop),
                  searchCepError: (attrs.onSearchCepError ? scope.onSearchCepError: angular.noop)
            };
      			scope.custom = function ($event, cep) {
              $event.charCode == 13? scope.searchCep(cep) : angular.noop;
      			};

      			scope.returnLink = function (value) {
      				if (!value.number) {
      					value.number = '';
      				}
      				return 'https://www.google.com.br/maps/place/' + value.premisseType + ' ' + value.premisse + ',' + value.number+ ',' + value.localization;
      			};
      			scope.searchCep = function (cep) {
      				scope['loader' + scope.id] = true;
      				eventHandler.searchCepStart();
      				$http.get('http://www.gumga.com.br/services-api/public/cep/'+cep)
      				.success(function (values) {
      					eventHandler.searchCepSuccess({$value: values});
      					scope['loader' + scope.id] = false;
      					if (parseInt(values.resultado) == 1) {
      						scope.value.premisseType = values.tipo_logradouro;
      						scope.value.premisse = values.logradouro;
      						scope.value.localization = values.cidade;
      						scope.value.neighbourhood = values.bairro;
      						scope.value.state = values.uf;
      						scope.value.country = 'Brasil';
      					}

      				})
      				.error(function(data){
      					eventHandler.searchCepError({$value: data});
      				})
      			};
      			if (scope.value.zipCode) {
      				scope.searchCep(scope.value.zipCode);
      			}
      		}
      	};
      }
      angular.module('gumga.directives.address',['gumga.services.address'])
      .directive('gumgaAddress',AddressDirective);
    })();

(function(){
	'use strict';
	/**
	 * @ngdoc directive
	 * @name gumga.core:gumgaAlert
	 * @restrict EA
	 * @element ANY
	 * @description O componente gumgaAlert serve para criar notificações growl-like e é baseada em eventos.
	 * Para o funcionamento da directive, é necessário incluí-la apenas uma vez no seu código html (de preferência no index.html),
	 * para que os listeners sejam adicionados(Atualmente, na nova versão isto não é mais necessário, ver {@link gumga.core:GumgaAlert}). 
	 *
	 * @example
	 * ## Para que o alerta seja realizado, utilize um dos eventos:
	 * <pre>
	 * 	$scope.$emit('dangerMessage',{title: 'Error' ,message: 'Error 404'});
	 * 	$scope.$emit('successMessage',{title: 'Parabéns!' ,message: 'Sua solicitação foi aceita com sucesso!'});
	 *  $scope.$emit('warningMessage',{title: 'Cuidado!' ,message: 'A área que você está entrando é restrita.'});
   * 	$scope.$emit('infoMessage',{title: 'Salvar' ,message: 'Para salvar, entre em contato com o administrador.'});
	 * </pre>
	 *  Para ver um exemplo em funcionamento, clique [aqui](http://embed.plnkr.co/wdlI7U4nQf9kNhGlyCfU/)
	 */
	Alert.$inject = ["$rootScope"];
	function Alert($rootScope){
		return {
			restrict: 'EA',
			scope: false,
			compile: function(){
				function notify(icon, title, message, type) {
					$.notify({
						icon: icon,
						title: title,
						message: message
					}, {
						type: type,
						offset: 50,
						timer: 100,
						delay: 3500,
						onShow: $rootScope.$broadcast('onNotificationShow'),
						onClose: $rootScope.$broadcast('onNotificationClose'),
						allow_dismiss: true,
						animate: {
							enter: 'animated bounceInRight',
							exit: 'animated bounceOutRight'
						},
						template: '<div data-notify="container" class="col-xs-9 col-sm-3 alert alert-{0}" role="alert">' +
						'<button type="button" aria-hidden="true" class="close" data-notify="dismiss">×</button>' +
						'<span data-notify="icon"></span> ' +
						'<span data-notify="title"><b>{1}</b></span><br> ' +
						'<span data-notify="message">{2}</span>' +
						'</div>'
					});
				}

				$rootScope.$on('dangerMessage', function (ev, data) {
					notify('glyphicon glyphicon-exclamation-sign', data.title, data.message, 'danger');
				});
				$rootScope.$on('successMessage', function (ev, data) {
					notify('glyphicon glyphicon-ok', data.title, data.message, 'success');
				});
				$rootScope.$on('warningMessage', function (ev, data) {
					notify('glyphicon glyphicon-warning-sign', data.title, data.message, 'warning');
				});
				$rootScope.$on('infoMessage', function (ev, data) {
					notify('glyphicon glyphicon-info-sign', data.title, data.message, 'info');
				});
			}
		}
	}
	angular.module('gumga.directives.alert',[])
	.directive('gumgaAlert',Alert);
})();
(function(){
	'use strict';

	Breadcrumb.$inject = ["$rootScope"];
	/**
	 * @ngdoc directive
	 * @name gumga.core:gumgaBreadcrumb
	 * @restrict E
	 * @description O componente GumgaBreadcrumb serve para mostrar ao usuário a lista das páginas visitadas. Este componente atuamente
	 * funciona caso exista dependência do [ui-router](https://github.com/angular-ui/ui-router).
	 * 
	 * O componente GumgaBreadcrumb ouve ao evento `breadChanged`, que recebe os states que estão sendo visitados. Uma das implementações possíveis para esse
	 * evento breadChanged é a seguinte:
	 * <pre>
	 * $rootScope.breadcrumbs = [];
      $rootScope.$on('$stateChangeSuccess', function (event, toState) {
        updateBreadcrumb(toState.name, toState.data.id);
      });
      function updateBreadcrumb(state, id) {
          function get(id) {
              for (var i = 0, len = $rootScope.breadcrumbs.length; i < len; i++) {
                  if ($rootScope.breadcrumbs[i].id === id) {
                      return i;
                  }
              }
          }
          if (id && get(id) >= 0) {
              $rootScope.breadcrumbs.splice(get(id), $rootScope.breadcrumbs.length - get(id), {state: state, id: id});
          } else {
              $rootScope.breadcrumbs.push({state: state, id: id});
          }
          !id ? $rootScope.breadcrumbs = [] : angular.noop;
          $rootScope.$broadcast('breadChanged');
      }
	 * </pre> 
	 * Este código foi colocado dentro do `run` do módulo principal da aplicação.
	 */

	function Breadcrumb($rootScope){
		var template = [
		'<ol class="breadcrumb">',
		'<li ng-repeat="bread in breadcrumbs" ><a ui-sref="{{::bread.state}}">{{::bread.state}}</a></li>',
		'</ol>'
		];
		return {
			restrict: 'E',
			template: template.join('\n'),
			replace: true,
			link: function($scope, $elm, $attrs){
				$scope.$on('breadChanged',function(){
					$scope.breadcrumbs = $rootScope.breadcrumbs.filter(function(e){
						return e.state.split('.').length >=2 ;
					});
				});
			}
		};
	}
	angular.module('gumga.directives.breadcrumb',[])
	.directive('gumgaBreadcrumb',Breadcrumb);
})();
// define = Require.js
(function(){
  'use strict';

    Counter.$inject = ["$compile"];
      /**
       * @ngdoc directive
       * @name gumga.core:gumgaCounter
       * @element input
       * @description O componente gumgaCounter permite escolher um tamanho máximo permitido no campo, também cria um contador de caracteres indicando se os caracteres
       * passaram do limite ou não. 
       * 
       * Caso um valor seja passado para a directive, ela atualizará o contador baseado nesse número. Caso não, ela pegará o valor
       * passado para a directive {@link gumga.core:gumgaMaxLength}
       * 
       * @example
       *  Um exemplo da directive gumgaCounter funcionando pode ser encontrado [aqui](http://embed.plnkr.co/6xJuUuiI456kqbXN3Q6f/).
       * <pre>
       * <input name="example" ng-model="example" gumga-counter="15" />
       * </pre>
      */

      function Counter($compile){
            return{
                restrict: 'A',
                link: function (scope, elem, attrs) {
                    scope._max = parseInt(attrs.gumgaMaxLengthText);
                    if (!isNaN(parseInt(attrs.gumgaCounter))) {
                        scope._max = parseInt(attrs.gumgaCounter);
                    }
                    var template = '<p class="{{_max <= teste.length ? \'text-danger\' : \'text-muted\'}}">{{_max <= '+ attrs.ngModel +'.length ? "Você passou o limite de '+scope._max+' caracteres" : _max - '+ attrs.ngModel +'.length + " caracteres restantes" }}</p>';
                    elem.after($compile(template)(scope));
                }
            };
      }

      angular.module('gumga.directives.counter', [])
        .directive('gumgaCounter', Counter);


})();


(function () {


  angular.module('gumga.directives.form',[
    'gumga.directives.form.form',
    'gumga.directives.form.errors',
    'gumga.directives.form.error',
    'gumga.directives.form.max.date',
    'gumga.directives.form.max.length',
    'gumga.directives.form.max.number',
    'gumga.directives.form.min.date',
    'gumga.directives.form.min.length',
    'gumga.directives.form.min.number',
    'gumga.directives.form.pattern',
    'gumga.directives.form.range.date',
    'gumga.directives.form.range.number',
    'gumga.directives.form.required',
    'gumga.directives.formbuttons'
  ])


})();

(function(){
	'use strict';
    /**
     * @ngdoc directive
     * @name gumga.core:gumgaFormButtons
     * @restrict E
     * @description O componente gumgaFormButtons pode ser utilizado para quando necessite de botões para o formulário,
     * tanto de continuar inserindo, de salvar e retroceder.
     *
     *  @param {Function} submit Parâmetro obrigatório que contém uma função que será executada quando o botão de continuar for clicado.
     *  @param {boolean} valid Parâmetro obrigatório que irá conter um valor booleano para validar caso o formulário é válido para liberar o botão de salvar.
     *  @param {Object} continue Object que deverá conter um atributo booleano chamado `value`, para controlar caso continuará inserindo ou não. Essa 
     *  opção aparecerá apenas quando o objeto $stateParams(pertencente ao ui-router) não possuir um id, ou seja, caso esteja numa tela de inserção.
     *  @param {boolean} confirm-dirty Parâmetro não obrigatório que irá conter um booleano para indicar caso deseje ter uma confirmação de saída do formulário
     *  quando este foi alterado alguma vez.
     */
	FormButtons.$inject = ["$state", "$stateParams", "$modal", "$rootScope"];
    function FormButtons($state, $stateParams,$modal,$rootScope) {
        return {
            restrict: 'E',
            scope: {
                do: '&submit',
                valid: '=',
                continue: '=?',
                confirmDirty: '=?'
            },
            template:
            '<div class="full-width-without-margin">'+
            '   <scope></scope>'+
            '   <div ng-class="getPosition()">' +
            '       <label id="continuarInserindo" ng-if="continue" >'+
            '           <input type="checkbox" name="continuar" ng-model="continue.value"/>' +
            '           <span>Continuar Inserindo</span>'+
            '       </label>' +
            '       <button class="btn btn-warning" style="margin-right: 0.8em" ng-click="back()" type="button"><i class="glyphicon glyphicon-floppy-remove"></i> Back</button>' +
            '       <button class="btn btn-primary" style="margin-right: 0" ng-click="do()" ng-disabled="!valid" type="button"><i class="glyphicon glyphicon-floppy-saved"></i> Save</button>' +
            '   </div>'+
            '<div>',
            require: '^form',
            link: function (scope, elm, attrs, ctrl) {
                if(!attrs.confirDirty) scope.confirmDirty = true;
                if(!$stateParams.id) scope.inNew = true;
                if(!attrs.continue) scope.continue = false;

                scope.getPosition = function () {
                    if (attrs.position == 'left') {
                        return 'pull-left';
                    }
                    return 'pull-right';
                };

                scope.back = function () {
                    if(scope.confirmDirty && ctrl.$dirty){
                        var modal = $modal.open({
                            template:
                            '<div>'+
                            '   <section class="modal-body">' +
                            '       <h4>Deseja sair sem salvar as alterações?</h4>' +
                            '   </section>'+
                            '   <div class="modal-footer">'+
                            '       <button class="btn btn-default" ng-click="handleClose(false)">Não</button>' +
                            '       <button class="btn btn-default" ng-click="handleClose(true)">Sim</button>' +
                            '   </div>'+
                            '</div>',
                            backdrop: false,
                            keyboard: false,
                            size: 'sm',
                            controller: ["$scope", "$modalInstance", "$state", "$rootScope", function($scope,$modalInstance,$state,$rootScope){
                                $scope.handleClose = function(_boolean){
                                    _boolean ? $modalInstance.close(true) : $modalInstance.close(false);
                                };  
                                if($state){
                                    $scope.currentState =$state.current.name;
                                    $rootScope.$on('$stateChangeStart',
                                        function(event, toState, toParams, fromState, fromParams){
                                            $modalInstance.dismiss();
                                        })
                                }
                            }]
                        });
                        modal.result.then(function(shouldIGo){
                            if(shouldIGo){
                                $state.go(attrs.back);
                                return 0;
                            }
                        })
                        } else {
                            $state.go(attrs.back);
                        }
                };

            }
        } 
    }

angular.module('gumga.directives.formbuttons',['ui.bootstrap','ui.router'])
.directive('gumgaFormButtons',FormButtons);

})();
(function () {
  'use strict';

  List.$inject = ["GumgaListHelper", "$compile"];

  function List(GumgaListHelper,$compile){
    /**
    * @ngdoc directive
    * @name gumga.core:gumgaList
    * @restrict E
    * @description
    * 	A directive gumgaList foi desenvolvida para substituir a antiga gumgaTable. Ela é mais configurável que a antiga table, e traz um meio mais fácil de configurar.
    *  	O componente possui dois tipos de configuração: diretamente no html e através de um objeto javascript.
    *
    * 	# Configuração da table através de um Objeto Javascript
    *
    *		Para aplicar a configuração na table, existem os seguintes atributos:
    *
    * | Param | Type  | Default | Details |
    * |-------|-------|---------|----------------|
    * |selection|String| single | Valor que será utilizado para definir como será a seleção da tabela. Possíveis valores: <label class="label type-hint type-hint-string">[multi / single]</label> |
    * |itemsPerPage|Array| [10,20,30,40,50] | Valor que será utilizado para definir o número de registros selecionado pelo usuário. O valor escolhido será exposto no $scope através da variável itemsPerPage |
    * |sortDefault | String | | Valor que será utilizado para definir qual o campo padrão de ordenação. Este valor será o identificador da coluna.
    * |columns |String| | Valor que irá definir quais as colunas e a ordenação delas. O formato deve estar no seguinte padrão: <label class="label type-hint type-hint-string">[column1,column2,...,columnN]</label>
    * |conditional | Function | angular.noop | Valor que será utilizado para fazer a formatação condicional do registro. A função deve retornar um objeto que contém a classe e a comparação utilizada <label class="label type-hint type-hint-string">[function(value){ return {'2px solid red': value.age < 18} }]</label>
    * |columnsConfig |Array |[]| Array que será utilizado para configurar as colunas que foram definidas no atributo columns.
    *
    * # Configuração da coluna através de um Objeto Javascript
    *	Para configurar as colunas, dentro do atributo columnsConfig, são criados objetos que poderão ter as seguintes configurações:
    *
    * | Param | Type  | Default | Details |
    * |-------|-------|---------|----------------|
    * |name | String |  | Valor que será utilizado para identificar a coluna. Este name deve ser o mesmo que está no atributo 'columns',
    * |title|String| NOME_DA_COLUNA.toUpperCase() | Valor que será renderizado no título da coluna.
    * |size|String| 'col-md-3' | Tamanho da coluna baseado nos valores do bootstrap. Exemplo: ** col-md-x **
    * |content |String|{{$value.NOME_DA_COLUNA}} | Valor que será renderizado no conteúdo da coluna.
    * |sortField |String | | String que será  usada para fazer a ordenação, e que irá como parâmetro na função de ordenação..
    * |conditional | Function | angular.noop | Valor que será utilizado para fazer a formatação condicional do registro. A função deve retornar um objeto que contém a classe e a comparação utilizada <label class="label type-hint type-hint-string">[function(value){ return {'2px solid red': value.age < 18} }]</label>
    *
    *
    *	  @param {Function} sort Parâmetro que contém uma função que será chamada para que o desenvolvedor possa fazer a ordenação dos registros.
    *	  @param {String} class Parâmetro para aplicar na table uma classe específica.
    *	  @param {Array} data Parâmetro que irá conter os dados que serão mostrados na tabela.
    *	  @param {Function} onClick Função que será executada quando o usuário clicar em um registro
    *	  @param {Function} onSort Função que será executada quando a ordenação for realizada
    *	  @param {Function} onDoubleClick Função que será executada quando o usuário clicar duas vezes em um registro.
    */


    function ctrl($scope, $element, $attrs, $transclude){
      function verifyEmpty($v,other){return (!$attrs.$v ? other : vm[$v])};
      var vm = this;
      // Valores utilizados pela aplicação
      vm.selectedIndexes = []
      vm.selectedItem;
      vm.selectedItemDir;
      vm.$parent = $scope.$parent;

      // Funções utilizadas
      vm.sortProxy = sortProxy;
      vm.selectRow = selectRow;
      vm.double = double;''
      vm.conditional = cond;
      vm.conditionalTableCell = conditionalTableCell;
      vm.selectAll = selectAll;
      // Valores que serão expostos no $scope
      $scope.$parent.selectedValues = [];
      $scope.$parent.itemsPerPage;
      // Número de itens na página
      vm.page = $scope.$parent.itemsPerPage;

      vm.originalData = vm.data;
      vm.data = angular.copy(vm.data) || [];
      vm.config = vm.config || {}
      vm.data.forEach(function(val){val.__checked = false;});
      vm.config.selection = vm.config.selection || 'single';
      vm.config.sortDefault = vm.config.sortDefault;
      vm.config.itemsPerPage = vm.config.itemsPerPage || [10,20,30,40,50];
      vm.config.columnsConfig = vm.config.columnsConfig || [];
      vm.config.conditional = vm.config.conditional || angular.noop;
      vm.config.sort = verifyEmpty('sort',angular.noop);
      vm.config.class = $attrs.class ? 'table ' + $attrs.class : 'table';
      vm.config.onClick = verifyEmpty('onClick',angular.noop);
      vm.config.onDoubleClick = verifyEmpty('onDoublelick',angular.noop);
      vm.config.onSort = verifyEmpty('onSort',angular.noop);
      if(vm.config.sortDefault)sortProxy(vm.config.sortDefault);
      if (vm.data && vm.data.length > 0){
        vm.config.columns =
        !!vm.config.columns ?
        GumgaListHelper.ensureDefaultValues(vm.config.columns.split(','),vm.config.columnsConfig) : GumgaListHelper.loadDefaultColumns(vm.data[0]);
        vm.config.auxColumnsToSort = vm.config.columns;
      }

      $element.append($compile(GumgaListHelper.mountTable(vm.config))($scope));

      function selectAll(checkboxBoolean){
        cleanArrays();
        vm.data.forEach(function(data,index){
          data.__checked = checkboxBoolean;
          if(checkboxBoolean)pushToArrays(data,index);
        })
      }

      function findInOriginalArray(val){
        var copyWithoutCheckedAttributes = angular.copy(val);
        delete copyWithoutCheckedAttributes.__checked;
        return vm.originalData.filter(function(originalRegistry){
          return angular.equals(originalRegistry,copyWithoutCheckedAttributes);
        })[0];
      }
      function cleanArrays(){
        $scope.$parent.selectedValues = [];
        vm.selectedIndexes = [];
      }
      function pushToArrays(val,index){
        vm.selectedIndexes.push(index);
        $scope.$parent.selectedValues.push(findInOriginalArray(val));
      }
      function setEveryCheckedToBoolean(bool){
        vm.data.forEach(function(elm){
          elm.__checked = bool;
        })
      }
      function cleanValueAndArrays(clause,value){
        if(clause){
          setEveryCheckedToBoolean(false);
          cleanArrays();
        }
        if(value) value = false;
      }


      function selectRow(ngRepeatIndex,ngRepeatValue,$event){
        if($event.target.type == 'button' || $event.target.tagName == 'A'){
          $event.stopPropagation();
          return null;
        }
        var selectedValues = $scope.$parent.selectedValues;
        cleanValueAndArrays(vm.checkAll,vm.checkAll);
        if($attrs.onClick)vm.onClick({value: ngRepeatValue});
        if(vm.config.selection == 'single'){
          if(ngRepeatValue.__checked){
            ngRepeatValue.__checked = false;
            cleanArrays();
          } else {
            cleanValueAndArrays(vm.selectedIndexes.length > 0)
            pushToArrays(ngRepeatValue,ngRepeatIndex);
            ngRepeatValue.__checked = true;
          }
        } else {
          ngRepeatValue.__checked = vm.selectedIndexes.filter(function(val){return val == ngRepeatIndex}).length < 1;
          if((ngRepeatValue.__checked) || vm.selectedIndexes.length == 0 ){
            pushToArrays(ngRepeatValue,ngRepeatIndex);
            return 0;
          }
          var indexOfValueSelected;
          selectedValues.forEach(function(val,indx){
            if(angular.equals(val,ngRepeatValue)) indexOfValueSelected = indx;
          })
          $scope.$parent.selectedValues.splice(indexOfValueSelected, 1);
          vm.selectedIndexes.splice(vm.selectedIndexes.indexOf(ngRepeatIndex),1);
        }
      }

      function sortProxy(field){
        if($attrs.onSort) vm.onSort({field: vm.selectedItem, dir: vm.selectedItemDir});
        if(!$attrs.sort) throw 'You have to pass a sort function to GumgaList [sort="sort(field,dir)"]';
        vm.selectedItem = field;
        vm.selectedItemDir == 'asc' ? vm.selectedItemDir = 'desc' : vm.selectedItemDir = 'asc';
        vm.sort({field: vm.selectedItem, dir: vm.selectedItemDir});
      }

      function double(value){
        if($attrs.onDoubleClick) vm.onDoubleClick({value: value});
      }

      function conditionalTableCell(value,ordering){
        var columnToGetTheConditional = vm.config.columns.filter(function(val){return val.name == ordering});
        if(columnToGetTheConditional[0]){
          var obj = columnToGetTheConditional[0].conditional(value)
          ,   trueValue, falseValue;
          for(var key in obj){
            if(obj[key] === true){
              trueValue = key;
            } else {
              falseValue = key;
            }
          }
          return '\"'.concat(trueValue).concat('\"');
        }
        return '\'\'';
      };

      function cond(value){
        var obj = vm.config.conditional(value),trueValue
        ,   falseValue;
        for(var key in obj){
          obj[key] === true ?trueValue = key : falseValue = key;
        }
        if(trueValue){
          return '\"'.concat(trueValue).concat('\"');
        }
        return '\'\'';
      }
    }
    ctrl.$inject = ["$scope", "$element", "$attrs", "$transclude"];;
    return {
      restrict: 'E',
      scope:{
        'sort': '&?',
        'class': '&?',
        'data': '=',
        'onClick': '&?',
        'onDoubleClick': '&?',
        'onSort': '&?',
        'config': '=configuration'
      },
      controller: ctrl,
      controllerAs: 'vm',
      bindToController: true
    }
  }
  angular.module('gumga.directives.list',['gumga.services.listhelper'])
  .directive('gumgaList',List);
})();

(function(){
	'use strict';

	ManyMany.$inject = ["$modal", "$compile", "$timeout"];
	/**
	 * @ngdoc directive
	 * @name gumga.core:gumgaManyToMany
	 * @restrict E
	 * @description
	 * 	O componente gumgaManyToMany é um componente que é utilizado para mostrar duas listas lado a lado, e permitir que um registro seja trocado de uma lista para outra,
	 * 	assim como também visualizado os seus valores(caso seja um objeto). Um exemplo do componente pode ser encontrado [aqui](http://embed.plnkr.co/gyrqAKQQGuEHwp2npv8G/).
	 *
	 * ---
	 * ## Configuração de como será mostrado o valor na lista
	 *
	 *Para que o programador possa escolher como os valores serão demonstrados, foram desenvolvidas duas tags que devem estar dentro do componente manyToMany.
	 * 		<pre> <left-field>{{$value}}</left-field>
	 * 		<right-field>{{$value}}</right-field></pre>
	 *
	 * @param {Array} left-list Parâmetro obrigatório que irá conter uma variável que possuirá um array, para ser mostrado na lista da esquerda.
	 *  *A lista da esquerda será filtrada e não conterá resultados iguais a da lista da direita.*
	 * @param {Array} right-list Parâmetro obrigatório que irá conter uma variável que possuirá um array, para ser mostrado na lista da direita.
	 * @param {Function} left-search Parâmetro obrigatório que irá conter uma variável que possuirá uma função que irá ser executada toda vez
	 * que o usuário digitar algo no input acima da lista. Essa função terá o valor do input como parâmetro. O parâmetro deverá ser este: `left-search="doSearch(text)"`
	 * @param {Function} right-search Parâmetro obrigatório que irá conter uma variável que possuirá uma função que irá ser executada toda vez
	 * que o usuário digitar algo no input acima da lista. Essa função terá o valor do input como parâmetro. O parâmetro deverá ser este: `right-search="doSearch(text)"`
	 * @param {Function} post-method Parâmetro não obrigatório que irá conter uma variável que possuirá uma função que irá ser executada quando o usuário desejar adicionar um valor
	 * caso sua busca não tenha trazido resultados.
	 * @param {Function} on-list-change Parâmetro não obrigatório que irá conter uma variável que possuirá uma função que irá ser executada quando o usuário tiver clicado em um registro
	 * e o mesmo tiver trocado de lista.
	 * @param {Function} on-value-visualization-opened Parâmetro não obrigatório que irá conter uma variável que possuirá uma função que irá ser executada quando o usuário tiver aberto o modal
	 * para visualização de dados
	 * @param {Function} on-value-visualization-closed Parâmetro não obrigatório que irá conter uma variável que possuirá uma função que irá ser executada quando o usuário tiver fechado o modal
	 * para visualização de dados
	 * @param {Boolean} authorize-add Parâmetro não obrigatório que irá conter uma variável que possuirá um booleano que irá fazer o controle para mostrar o botão de adicionar um registro caso a busca não
	 * tenha retornado nenhum registro
	 * @param {String} left-label Parâmetro não obrigatório que irá conter uma String que irá aparecer acima do input e da lista.
	 * @param {String} right-label Parâmetro não obrigatório que irá conter uma String que irá aparecer acima do input e da lista.
	 *

	 */
	function ManyMany($modal,$compile,$timeout){

		return {
			restrict: 'E',
			scope: {
				left: '=leftList',
				right: '=rightList',
				leftFn: '&leftSearch',
				rightFn: '&rightSearch',
				postMethod: '&',
				onListChange: '&?',
				onNewValueAdded: '&?',
				onValueVisualizationOpened: '&?',
				onValueVisualizationClosed: '&?',
				authorizeAdd: '=?'
			},
			transclude: true,
			link: function (scope, elm, attrs, ctrl, transcludeFn) {
				scope.left = scope.left || [];
				scope.right = scope.right || [];
				if (!attrs.authorizeAdd) scope.authorizeAdd = true;
				var mockObject = {};
				scope.texts = {left: '',right: ''};
				scope.template = '';
				scope.labels = {left: attrs.leftLabel,right: attrs.rightLabel};
				var eventHandler = {
					listChange: (attrs.onListChange? scope.onListChange : angular.noop),
					newValueAdded: (attrs.onNewValueAdded ? scope.onNewValueAdded : angular.noop),
					valueVisualizationOpened: (attrs.onValueVisualizationOpened ? scope.onValueVisualizationOpened :angular.noop),
					valueVisualizationClosed: (attrs.onValueVisualizationClosed ? scope.onValueVisualizationClosed :angular.noop)
				};
				transcludeFn(scope,function(cloneEl){
					angular.forEach(cloneEl,function(cl){
						var element = angular.element(cl)[0];
						switch(element.nodeName){
							case 'LEFT-FIELD':
							scope.texts.left = element.innerHTML;
							break;
							case 'RIGHT-FIELD':
							scope.texts.right = element.innerHTML;
							break;
						}
					});
					checkErrors();
				});
				mountRenderedContent();
				scope.$watch('left',function(){
					checkErrors();
					copyObject(scope.left[0]);
				});
				function copyObject(obj) {
					for (var key in obj) if (obj.hasOwnProperty(key)) {
						mockObject[key] = null;
					}
				}
				function checkErrors(){
					var errorTexts = [];
					if(!scope.texts.left || !scope.texts.right){
						errorTexts.push('You have\'nt provided the content to GumgaManyToMany directive');
					}
					errorTexts.forEach(function(txt){
						throw txt;
					});
					removeDuplicates();
				}
				function removeDuplicates(){
					function filterOnRight(text){
						return scope.right.filter(function($elm){
							return $elm[attrs.filterParameter] == text;
						}).length
					}
					scope.leftAux = scope.left.filter(function(elm){
						if(filterOnRight(elm[attrs.filterParameter]) == 0){
							return elm;
						}
					});
				}
				function mountRenderedContent(){
					var text =
					'<div class="full-width-without-padding">\n'+
					'   <div class="col-md-6" style="padding-left: 0">\n'+
					'       <strong><small>{{::labels.left}}</small></strong>\n' +
					'       <div class="{{showClass()}}">'+
					'           <input type="text" name="manymanyleft" ng-model="leftFilter" novalidate class="form-control"' + doesItHaveFunction('left',0) + ' ng-change="leftFn({param: leftFilter})" ng-model-options="{ updateOn: \'default blur\', debounce: {\'default\': 300, \'blur\': 0} }"/>\n' +
					'           <span class="input-group-addon" ng-show="showPlus(leftFilter)"> ' +
					'               <button type="button" style="border: 0;background-color: #EEE" ng-click="addNew(leftFilter)"><i class="glyphicon glyphicon-plus"></i></button>' +
					'           </span>' +
					'       </div>' +
					'       <ul class="list-group" style="max-height: 200px;overflow: auto;">\n' +
					'           <li class="list-group-item" style="display:flex;padding: 7px 15px;" ng-repeat="$value in leftAux ' + doesItHaveFunction('left',1) + '">' +
					'               <a class="inside-list-anchor" ng-click="removeFromAndAddTo(leftAux,right,$value)">' + scope.texts.left + '</a>' +
					'              <button class="badge" style="background-color: #81AEDA;cursor: pointer;border: 0" ng-click="halp($value)"><i class="glyphicon glyphicon-resize-full"></i></button>' +
					'           </li>\n'+
					'       </ul>'+
					'   </div>\n'+
					'   <div class="col-md-6" style="padding-right: 0">\n'+
					'       <strong><small>{{::labels.right}}</small></strong>\n'+
					'       <input type="text" name="manymanyleft" ng-model="rightFilter" novalidate class="form-control"' + doesItHaveFunction('right',0) + '/>\n'+
					'       <ul class="list-group" style="max-height: 200px;overflow: auto;">\n' +
					'           <li class="list-group-item" style="display:flex;padding: 7px 15px;" ng-repeat="$value in right ' + doesItHaveFunction('right',1) + '">' +
					'               <a class="inside-list-anchor" ng-click="removeFromAndAddTo(right,leftAux,$value)">' + scope.texts.right + '</a>' +
					'              <button class="badge badge-helper" ng-click="halp($value)"><i class="glyphicon glyphicon-resize-full"></i></button>' +
					'           </li>\n'+
					'       </ul>\n'+
					'   </div>\n'+
					'</div>\n';
					elm.append($compile(text)(scope));
				}
				scope.removeFromAndAddTo = function(removeFrom,addTo,value){
					removeFrom.splice(removeFrom.indexOf(value),1);
					eventHandler.listChange({$value:value});
					addTo.push(value);
				};
				scope.addNew = function(text){
					scope.leftFilter = '';
					scope.postMethod({value: text });
					eventHandler.newValueAdded();
				};
				scope.showClass = function(){
					if(scope.showPlus()){
						return 'input-group';
					}
					return '';
				};
				scope.halp = function(obj){
					scope.template =
					'<div class="modal-body">\n';
					for (var key in obj) if (obj.hasOwnProperty(key) && key != '$$hashKey' && key != 'oi' && key != 'version') {
						scope.template += '   <div class="form-group">\n';
						scope.template += '       <label><small>'+ key +'</small></label>\n';
						scope.template += '       <input type="text" ng-model="$value.' + key +'" disabled class="form-control"/>\n';
						scope.template += '   </div>\n';
					}
					scope.template += '   <div class="modal-footer">\n';
					scope.template += '       <button type="button" class="btn btn-warning" ng-click="back()">Back</button>\n';
					scope.template += '   </div>\n';
					scope.template += '</div>\n';
					eventHandler.valueVisualizationOpened();
					var mi = $modal.open({
						template: scope.template,
						size: 'sm',
						controller: ["$scope", "$value", "$modalInstance", function($scope,$value,$modalInstance){
							$scope.$value = $value;
							$scope.back = function(){
								$modalInstance.dismiss();
							}
						}],
						resolve: {
							$value: function(){
								return obj;
							}
						}
					});

					mi.result.then(function(){
						eventHandler.valueVisualizationClosed();
					})
				};
				scope.showPlus = function(){
					function filterLeft(){
						return scope.leftAux.filter(function(el){
							return el[attrs.filterParameter] == scope.leftFilter;
						}).length < 1;
					}
					function filterRight(){
						return scope.right.filter(function(el){
							return el[attrs.filterParameter] == scope.leftFilter;
						}).length < 1;
					}
					if(scope.authorizeAdd == true){
						return filterLeft() && filterRight();
					}
					return false;
				};

				scope.doesItHaveClass = function(){
					if(scope.left.length > 0){
						return '';
					}
					return 'input-group';
				};
				function doesItHaveFunction(field,place){
					if(place == 0){
						if(field == 'left' && attrs.leftFn){
							return  'ng-change= "' + attrs.leftFn  +'({text: leftFilter})" ';
						}
						if(field == 'right' && attrs.rightFn){
							return  'ng-change= "' + attrs.leftFn  +'({text: rightFilter})" ';
						}
						return '';
					} else {
						if(field == 'left' && !attrs.leftFn){
							return ' | filter: leftFilter';
						}
						if(field == 'right' && !attrs.rightFn){
							return ' | filter: rightFilter'
						}
						return '';
					}
				}
			}
		}
	}

		angular.module('gumga.directives.manytomany',['ui.bootstrap'])
		.directive('gumgaManyToMany',ManyMany)
	})();

(function(){
    'use strict';

    ManyToOne.$inject = ["$templateCache", "GumgaKeyboard", "$modal"];
    /**
     * @ngdoc directive
     * @name gumga.core:gumgaManyToOne
     * @restrict E
     * @description
     *  A directive gumgaManyToOne pode ser usada para quando o programador precise de um select que filtre uma lista assíncronamente.
     *  Ela também permite adicionar um registro caso a busca retorne uma lista vazia e permite também visualizar os atributos do registro selecionado.
     *  ---
     *  #Exemplo básico de utilização do GumgaManyToOne
     *  O exemplo desse componente pode ser encontrado [aqui](http://embed.plnkr.co/NYL3gItVsWLFcGxt5itz/).
     *
     * @param {Object} value Parâmetro obrigatório que irá conter uma variável que será o registro escolhido na lista.
     * @param {Array} list Parâmetro obrigatório que irá conter uma lista dos registros que foram buscados.
     * @param {Function} search-method Parâmetro obrigatório que irá conter uma função que fará a busca na lista assíncronamente. `search-method="getSearch(param)"`
     * @param {Function} post-method Parâmetro obrigatório que irá conter uma função que dependendo do parâmetro `async`, chamará a função async com o parâmetro
     * `post-method="post(value)"` e caso o parâmetro async não esteja presente ou seja falso, fará um push na lista.
     * @param {String} field Parâmetro obrigatório que irá conter o atributo do registro que está sendo procurado e o que estará na lista.
     * @param {Boolean} authorize-add Parâmetro não obrigatório que irá conter uma variável que possuirá um booleano que irá fazer o controle para mostrar o botão de adicionar um registro caso a busca não
     * tenha retornado nenhum registro
     * @param {Btava veoolean} async Parâmetro não obrigatório que irá dizer caso componente fará um post chamando a função passada ou um push na lista. Por default, o valor é
     * @param {Function} on-new-value-added Parâmetro não obrigatório que irá conter uma variável que possuirá uma função que irá ser executada quando o usuário adicionar um novo valor.
     * @param {Function} on-value-visualization-opened Parâmetro não obrigatório que irá conter uma variável que possuirá uma função que irá ser executada quando o usuário tiver aberto o modal
     * para visualização de dados
     * @param {Function} on-value-visualization-closed Parâmetro não obrigatório que irá conter uma variável que possuirá uma função que irá ser executada quando o usuário tiver fechado o modal
     * para visualização de dados
     */



    function ManyToOne($templateCache,GumgaKeyboard,$modal){
        $templateCache.put('mtoItem.html',
            '<span bind-html-unsafe="match.label | typeaheadHighlight:query" style="cursor: pointer;"></span>');
        var template ='<div class="full-width-without-padding">';
        template += '   <div class="form-group">';
        template += '       <div ng-class="showFullView() || authorizeAdd ? \'input-group\' : \'\'">';
        template += '           <input class="form-control"  ng-model="model" type="text" typeahead="$value as $value[field] for $value in proxySearchMethod()">';
        template += '           <span class="input-group-addon" style="background-color: transparent; padding: 3px 12px;border-left:0" ng-show="showFullView()"> ';
        template += '               <button class="badge" style="background-color: #6ECFFF;border: 0" ng-click="halp(model)" ><i class="glyphicon glyphicon-resize-full"></i></button>';
        template += '           </span>';
        template += '           <span class="input-group-addon" style="padding: 0 0.25%" ng-show="authorizeAdd"> ';
        template += '               <button type="button" style="border: 0;background-color: transparent" ng-click="addNew(model)" ><i class="glyphicon glyphicon-plus"></i></button>';
        template += '           </span>';
        template += '       </div>';
        template += '   </div>';
        template += '</div>';
        return {
            restrict : 'E',
            template: template,
            require: '^form',
            scope : {
                model:'=value',
                list: '=',
                searchMethod: '&',
                postMethod: '&addMethod',
                field: '@',
                onNewValueAdded: '&?',
                onValueVisualizationOpened: '&?',
                onValueVisualizationClosed: '&?'
            },
            link: function(scope, elm, attrs,ctrl){
                scope.formCtrl = ctrl;
                var ngModelCtrl = elm.find('input').controller('ngModel'),
                eventHandler = {
                    newValueAdded: (attrs.onNewValueAdded ? scope.onNewValueAdded : angular.noop),
                    valueVisualizationOpened: (attrs.onValueVisualizationOpened ? scope.onValueVisualizationOpened :angular.noop),
                    valueVisualizationClosed: (attrs.onValueVisualizationClosed ? scope.onValueVisualizationClosed :angular.noop)
                },
                async;
                !attrs.authorizeAdd ? scope.authorizeAdd = true : scope.authorizeAdd = JSON.parse(attrs.authorizeAdd);
                !attrs.async ? async = true : async = JSON.parse(attrs.async);
                scope.list = scope.list || [];
                function checkIfItIsString(string){
                    return ((typeof string).toUpperCase().trim()) === 'string'.toUpperCase().trim() && string.length > 1;
                }
                scope.$watch('model',function(){
                    checkIfItIsString(scope.model) ?
                    ctrl.$setValidity('GumgaManyToOne',false) : ctrl.$setValidity('GumgaManyToOne',true);
                });
                try {
                    GumgaKeyboard.bindToElement(elm.find('input')[0],'down',function(){ngModelCtrl.$setViewValue(' ')});
                } catch(e){

                }

                scope.showFullView = function(){
                    return ((typeof scope.model).toUpperCase().trim()) === 'object'.toUpperCase().trim() && scope.model != undefined;
                };

                scope.showPlus = function(){
                    return (((typeof scope.model).toUpperCase().trim()) === 'string'.toUpperCase().trim() && scope.authorizeAdd === true) ;
                };

                scope.proxySearchMethod = function(){
                  return scope.searchMethod({param: ngModelCtrl.$viewValue});
                };
                scope.addNew = function(text){
                    if(async) {
                        scope.postMethod({value: text})
                        .then(function(values){
                          scope.model = values;
                        })
                    } else {
                        scope.list.push(text);
                    }
                };
                scope.halp = function(obj){
                    var template = '';
                    template =
                    '<div class="modal-body">\n';
                    for (var key in obj) if (obj.hasOwnProperty(key) && key != '$$hashKey' && key != 'oi' && key != 'version' && key != 'password' && typeof obj[key] != 'object') {
                        template += '   <div class="form-group">\n';
                        template += '       <label><small>'+ key +'</small></label>\n';
                        template += '       <input type="text" ng-model="$value.' + key +'" disabled class="form-control"/>\n';
                        template += '   </div>\n';
                    }
                    template += '   <div class="modal-footer">\n';
                    template += '       <button type="button" class="btn btn-warning" ng-click="back()">Back</button>\n';
                    template += '   </div>\n';
                    template += '</div>\n';
                    eventHandler.valueVisualizationOpened();
                    var mi = $modal.open({
                        template: template,
                        size: 'sm',
                        controller: ["$scope", "$value", "$modalInstance", function($scope,$value,$modalInstance){
                            $scope.$value = $value;
                            $scope.back = function(){
                                $modalInstance.dismiss();
                            }
                        }],
                        resolve: {
                            $value: function(){
                                return obj;
                            }
                        }
                    });
                    mi.result.then(function(){
                        eventHandler.valueVisualizationClosed();
                    })
                };
            }
        }
    }
        angular.module('gumga.directives.manytoone',['ui.bootstrap','gumga.services.keyboard'])
        .directive('gumgaManyToOne',ManyToOne);
    })();

(function(){
  'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaMask
   * @restrict A
   * @description O componente **GumgaMask** serve para adicionar máscaras aos elementos inputs que se fazem necessário, como CPF, CNPJ, telefone e etc.
   *
   * @example
   * Um exemplo da directive gumgaTable funcionando pode ser encontrado [aqui](http://embed.plnkr.co/SALkp5bKRZ1aywsrpmEX).
   *  <pre>
   *  	<form class="" action="index.html" method="post">
   *  		<input type="text" name="name" value="" ng-model="cpf" gumga-mask="999.999.999-99" gumga-mask-options="maskOptions">
   *  	</form>
   *    <script type="text/javascript">
   *    $scope.maskOptions = {
   *    	maskDefinitions: {
   *    		'seuRegex': /[regex]/
   *    	},
   *    	clearOnBlur: false,
   *    	eventsToHandle: ['input', 'keyup', 'click', 'focus']
   *    };
   *    </script>
   *  </pre>
   *
   * @param {String} gumga-mask Por padrão o componente tem 3 tipos de regex aceitas, que são **9** (numéricos), **A** (alfanuméricos) e ** * ** (alfanuméricos)
   * @param {Object} gumga-mask-options Objeto em $scope com regex extras ou sobreescrever configurações default.
   * @param {String} gumga-mask-placeholder Trabalha em conjunto com o placeholder nativo, contudo, o **gumga-mask-placeholder** deve seguir o mesmo padrão
   * de caracteres do informado no **gumga-mask**. Enquanto o nativo fica ativo sem atividade no input, ao disparar o evento focus, o gumga-mask-placeholder
   * ficará ativo.
   */
  Mask.$inject = ["$parse"];

  function Mask($parse) {
    function isFocused (elem) {
      return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
    }

    return {
      priority: 100,
      require: 'ngModel',
      restrict: 'A',
      scope: {
        gumgaMaskOptions: '=gumgaMaskOptions'
      },
      compile: function gumgaMaskCompilingFunction() {
        var options = {
          maskDefinitions: {
            // Numéricos
            '9': /\d/,
            // Alfa
            'A': /[a-zA-Z]/,
            // Alfanuméricos
            '*': /[a-zA-Z0-9]/
          },
          // Se true, limpa o campo caso inválido no evento onBlur
          clearOnBlur: true,
          // Eventos para processamento
          eventsToHandle: ['input', 'keyup', 'click', 'focus']
        };

        return function gumgaMaskLinkingFunction(scope, elm, attrs, ctrl) {
          var maskProcessed = false, eventsBound = false,
          maskCaretMap, maskPatterns, maskPlaceholder, maskComponents,
          minRequiredLength,
          value, valueMasked, isValid,
          originalPlaceholder = attrs.placeholder,
          originalMaxlength = attrs.maxlength,
          // // Variáveis usadas exclusivamente para eventos
          oldValue, oldValueUnmasked, oldCaretPosition, oldSelectionLength;

          function initialize(maskAttr) {
            if (!angular.isDefined(maskAttr)) {
              return uninitialize();
            }
            processRawMask(maskAttr);
            if (!maskProcessed) {
              return uninitialize();
            }
            initializeElement();
            bindEventListeners();
            return true;
          }

          function initPlaceholder(placeholderAttr) {
            if (!placeholderAttr) {
              return;
            }

            maskPlaceholder = placeholderAttr;
            // Atualizamos o valor do input
            if (maskProcessed) {
              elm.val(maskValue(unmaskValue(elm.val())));
            }
          }

          function formatter(fromModelValue) {
            if (!maskProcessed) {
              return fromModelValue;
            }
            value = unmaskValue(fromModelValue || '');
            isValid = validateValue(value);
            ctrl.$setValidity('mask', isValid);
            return isValid && value.length ? maskValue(value) : undefined;
          }

          function parser(fromViewValue) {
            if (!maskProcessed) {
              return fromViewValue;
            }
            value = unmaskValue(fromViewValue || '');
            isValid = validateValue(value);
            ctrl.$viewValue = value.length ? maskValue(value) : '';
            ctrl.$setValidity('mask', isValid);
            if (value === '' && attrs.required) {
              ctrl.$setValidity('required', !ctrl.$error.required);
            }
            return isValid ? value : undefined;
          }

          var linkOptions = options;

          if (scope.gumgaMaskOptions) {
            linkOptions = scope.gumgaMaskOptions;
            if (angular.isObject(linkOptions)) {
              linkOptions = (function(original, current) {
                for (var i in original) {
                  if (Object.prototype.hasOwnProperty.call(original, i)) {
                    if (current[i] === undefined) {
                      current[i] = angular.copy(original[i]);
                    } else {
                      angular.extend(current[i], original[i]);
                    }
                  }
                }
                return current;
              })(options, linkOptions);
            }
          } else {
            linkOptions = options;
          }
          console.log(linkOptions);

          attrs.$observe('gumgaMask', initialize);
          if (angular.isDefined(attrs.gumgaMaskPlaceholder)) {
            attrs.$observe('gumgaMaskPlaceholder', initPlaceholder);
          }
          else {
            attrs.$observe('placeholder', initPlaceholder);
          }
          var modelViewValue = false;
          attrs.$observe('modelViewValue', function(val) {
            if (val === 'true') {
              modelViewValue = true;
            }
          });
          scope.$watch(attrs.ngModel, function(val) {
            if (modelViewValue && val) {
              var model = $parse(attrs.ngModel);
              model.assign(scope, ctrl.$viewValue);
            }
          });
          ctrl.$formatters.push(formatter);
          ctrl.$parsers.push(parser);

          function uninitialize() {
            maskProcessed = false;
            unbindEventListeners();

            if (angular.isDefined(originalPlaceholder)) {
              elm.attr('placeholder', originalPlaceholder);
            } else {
              elm.removeAttr('placeholder');
            }

            if (angular.isDefined(originalMaxlength)) {
              elm.attr('maxlength', originalMaxlength);
            } else {
              elm.removeAttr('maxlength');
            }

            elm.val(ctrl.$modelValue);
            ctrl.$viewValue = ctrl.$modelValue;
            return false;
          }

          function initializeElement() {
            value = oldValueUnmasked = unmaskValue(ctrl.$modelValue || '');
            valueMasked = oldValue = maskValue(value);
            isValid = validateValue(value);
            var viewValue = isValid && value.length ? valueMasked : '';
            if (attrs.maxlength) { // Double maxlength to allow pasting new val at end of mask
              elm.attr('maxlength', maskCaretMap[maskCaretMap.length - 1] * 2);
            }
            if ( ! originalPlaceholder) {
              elm.attr('placeholder', maskPlaceholder);
            }
            elm.val(viewValue);
            ctrl.$viewValue = viewValue;
            ctrl.$setValidity('mask', isValid);
            // Não usando $setViewValue, então não sobreescreve
            // o valor do model sem interação do usuário.
          }

          function bindEventListeners() {
            if (eventsBound) {
              return;
            }
            elm.bind('blur', blurHandler);
            elm.bind('mousedown mouseup', mouseDownUpHandler);
            elm.bind(linkOptions.eventsToHandle.join(' '), eventHandler);
            elm.bind('paste', onPasteHandler);
            eventsBound = true;
          }

          function unbindEventListeners() {
            if (!eventsBound) {
              return;
            }
            elm.unbind('blur', blurHandler);
            elm.unbind('mousedown', mouseDownUpHandler);
            elm.unbind('mouseup', mouseDownUpHandler);
            elm.unbind('input', eventHandler);
            elm.unbind('keyup', eventHandler);
            elm.unbind('click', eventHandler);
            elm.unbind('focus', eventHandler);
            elm.unbind('paste', onPasteHandler);
            eventsBound = false;
          }

          function validateValue(value) {
            // Valida o tamanho mínimo requerido da máscara
            return value.length ? value.length >= minRequiredLength : true;
          }

          // Remove máscara
          function unmaskValue(value) {
            var valueUnmasked = '',
            maskPatternsCopy = maskPatterns.slice();
            // Processo para retirar componentes do valor
            value = value.toString();
            angular.forEach(maskComponents, function(component) {
              value = value.replace(component, '');
            });
            angular.forEach(value.split(''), function(chr) {
              if (maskPatternsCopy.length && maskPatternsCopy[0].test(chr)) {
                valueUnmasked += chr;
                maskPatternsCopy.shift();
              }
            });
            return valueUnmasked;
          }

          // Adiciona máscara
          function maskValue(unmaskedValue) {
            var valueMasked = '',
            maskCaretMapCopy = maskCaretMap.slice();

            angular.forEach(maskPlaceholder.split(''), function(chr, i) {
              if (unmaskedValue.length && i === maskCaretMapCopy[0]) {
                valueMasked += unmaskedValue.charAt(0) || '_';
                unmaskedValue = unmaskedValue.substr(1);
                maskCaretMapCopy.shift();
              }
              else {
                valueMasked += chr;
              }
            });
            return valueMasked;
          }

          // O atributo padrão placeholder funciona normalmente,
          // o atributo gumgaMaskPlaceholder define a máscara com o placeholder
          // e deve atender a quantidade de caracteres da máscara.
          function getPlaceholderChar(i) {
            var placeholder = angular.isDefined(attrs.gumgaMaskPlaceholder) ? attrs.gumgaMaskPlaceholder : attrs.placeholder;

            if (typeof placeholder !== 'undefined' && placeholder[i]) {
              return placeholder[i];
            } else {
              return '_';
            }
          }

          function getMaskComponents() {
            return maskPlaceholder.replace(/[_]+/g, '_').replace(/([^_]+)([a-zA-Z0-9])([^_])/g, '$1$2_$3').split('_');
          }

          function processRawMask(mask) {
            var characterCount = 0;

            maskCaretMap = [];
            maskPatterns = [];
            maskPlaceholder = '';

            if (typeof mask === 'string') {
              minRequiredLength = 0;

              var isOptional = false,
              numberOfOptionalCharacters = 0,
              splitMask = mask.split('');

              angular.forEach(splitMask, function(chr, i) {
                if (linkOptions.maskDefinitions[chr]) {

                  maskCaretMap.push(characterCount);

                  maskPlaceholder += getPlaceholderChar(i - numberOfOptionalCharacters);
                  maskPatterns.push(linkOptions.maskDefinitions[chr]);

                  characterCount++;
                  if (!isOptional) {
                    minRequiredLength++;
                  }
                }
                else if (chr === '?') {
                  isOptional = true;
                  numberOfOptionalCharacters++;
                }
                else {
                  maskPlaceholder += chr;
                  characterCount++;
                }
              });
            }
            // Posição do cursor imediatamente após última posição válida
            maskCaretMap.push(maskCaretMap.slice().pop() + 1);

            maskComponents = getMaskComponents();
            maskProcessed = maskCaretMap.length > 1 ? true : false;
          }

          function blurHandler() {
            // Se clearOnBlur for true em options,
            // limpa o campo caso esteja inválido.
            if (linkOptions.clearOnBlur) {
              oldCaretPosition = 0;
              oldSelectionLength = 0;
              if (!isValid || value.length === 0) {
                valueMasked = '';
                elm.val('');
                scope.$apply(function() {
                  ctrl.$setViewValue('');
                });
              }
            }
          }

          function mouseDownUpHandler(e) {
            if (e.type === 'mousedown') {
              elm.bind('mouseout', mouseoutHandler);
            } else {
              elm.unbind('mouseout', mouseoutHandler);
            }
          }

          elm.bind('mousedown mouseup', mouseDownUpHandler);

          function mouseoutHandler() {
            /*jshint validthis: true */
            oldSelectionLength = getSelectionLength(this);
            elm.unbind('mouseout', mouseoutHandler);
          }

          function onPasteHandler() {
            /*jshint validthis: true */
            setCaretPosition(this, elm.val().length);
          }

          function eventHandler(e) {
            /*jshint validthis: true */
            e = e || {};
            // Permite uma minificação mais eficiente
            var eventWhich = e.which,
            eventType = e.type;

            if (eventWhich === 16 || eventWhich === 91) {
              return;
            }

            var val = elm.val(),
            valOld = oldValue,
            valMasked,
            valUnmasked = unmaskValue(val),
            valUnmaskedOld = oldValueUnmasked,
            caretPos = getCaretPosition(this) || 0,
            caretPosOld = oldCaretPosition || 0,
            caretPosDelta = caretPos - caretPosOld,
            caretPosMin = maskCaretMap[0],
            caretPosMax = maskCaretMap[valUnmasked.length] || maskCaretMap.slice().shift(),
            selectionLenOld = oldSelectionLength || 0,
            isSelected = getSelectionLength(this) > 0,
            wasSelected = selectionLenOld > 0,
            // Case: Digitando um caracter para substituir uma seleção
            isAddition = (val.length > valOld.length) || (selectionLenOld && val.length > valOld.length - selectionLenOld),
            // Case: Delete e backspace se comportam de forma idêntica em uma seleção
            isDeletion = (val.length < valOld.length) || (selectionLenOld && val.length === valOld.length - selectionLenOld),
            isSelection = (eventWhich >= 37 && eventWhich <= 40) && e.shiftKey, // Arrow key codes

            isKeyLeftArrow = eventWhich === 37,
            // Necessária devido ao evento não fornecer um keycode
            isKeyBackspace = eventWhich === 8 || (eventType !== 'keyup' && isDeletion && (caretPosDelta === -1)),
            isKeyDelete = eventWhich === 46 || (eventType !== 'keyup' && isDeletion && (caretPosDelta === 0) && !wasSelected),
            // Lida com casos onde acento circunflexo é movido e colocado na frente da posição maskCaretMap inválido.
            // Logic abaixo assegura que, ao clicar ou posicionamento acento circunflexo para a esquerda, acento
            // circunflexo é movido para a esquerda até à direita directamente de caráter não-máscara.
            // Também aplicado para clicar uma vez que os usuários são (discutivelmente) mais propensos a voltar
            // atrás com um personagem ao clicar dentro de uma entrada cheia.
            caretBumpBack = (isKeyLeftArrow || isKeyBackspace || eventType === 'click') && caretPos > caretPosMin;

            oldSelectionLength = getSelectionLength(this);

            // Eventos que não requerem nenhuma ação
            if (isSelection || (isSelected && (eventType === 'click' || eventType === 'keyup'))) {
              return;
            }

            // Controle de valores
            // ==============

            // User attempted to delete but raw value was unaffected--correct this grievous offense
            // O usuário tentou apagar, mas valor bruto não foi afetado - corrigir este grave ofensa
            if ((eventType === 'input') && isDeletion && !wasSelected && valUnmasked === valUnmaskedOld) {
              while (isKeyBackspace && caretPos > caretPosMin && !isValidCaretPosition(caretPos)) {
                caretPos--;
              }
              while (isKeyDelete && caretPos < caretPosMax && maskCaretMap.indexOf(caretPos) === -1) {
                caretPos++;
              }
              var charIndex = maskCaretMap.indexOf(caretPos);
              // Strip out non-mask character that user would have deleted if mask hadn't been in the way.
              valUnmasked = valUnmasked.substring(0, charIndex) + valUnmasked.substring(charIndex + 1);
            }

            // Atualiza valor
            valMasked = maskValue(valUnmasked);

            oldValue = valMasked;
            oldValueUnmasked = valUnmasked;
            elm.val(valMasked);
            ctrl.$setViewValue(valUnmasked);

            // Posição do cursor
            // ===================

            // Caractere digitado a frente nos casos em que o primeiro caractere de entrada é um char máscara e o cursor
            // for colocado na posição 0.
            if (isAddition && (caretPos <= caretPosMin)) {
              caretPos = caretPosMin + 1;
            }

            if (caretBumpBack) {
              caretPos--;
            }

            caretPos = caretPos > caretPosMax ? caretPosMax : caretPos < caretPosMin ? caretPosMin : caretPos;

            while (!isValidCaretPosition(caretPos) && caretPos > caretPosMin && caretPos < caretPosMax) {
              caretPos += caretBumpBack ? -1 : 1;
            }

            if ((caretBumpBack && caretPos < caretPosMax) || (isAddition && !isValidCaretPosition(caretPosOld))) {
              caretPos++;
            }
            oldCaretPosition = caretPos;
            setCaretPosition(this, caretPos);
          }

          function isValidCaretPosition(pos) {
            return maskCaretMap.indexOf(pos) > -1;
          }

          function getCaretPosition(input) {
            if (!input)
            return 0;
            if (input.selectionStart !== undefined) {
              return input.selectionStart;
            } else if (document.selection) {
              if (isFocused(elm[0])) {
                // Maldito seja o IE
                input.focus();
                var selection = document.selection.createRange();
                selection.moveStart('character', input.value ? -input.value.length : 0);
                return selection.text.length;
              }
            }
            return 0;
          }

          function setCaretPosition(input, pos) {
            if (!input)
            return 0;
            if (input.offsetWidth === 0 || input.offsetHeight === 0) {
              return; // Inputs escondidos
            }
            if (input.setSelectionRange) {
              if (isFocused(elm[0])) {
                input.focus();
                input.setSelectionRange(pos, pos);
              }
            }
            else if (input.createTextRange) {
              // Maldito seja o IE
              var range = input.createTextRange();
              range.collapse(true);
              range.moveEnd('character', pos);
              range.moveStart('character', pos);
              range.select();
            }
          }

          function getSelectionLength(input) {
            if (!input)
            return 0;
            if (input.selectionStart !== undefined) {
              return (input.selectionEnd - input.selectionStart);
            }
            if (document.selection) {
              return (document.selection.createRange().text.length);
            }
            return 0;
          }
        }
      }
    }
  }
  angular.module('gumga.directives.mask', [])
  .directive('gumgaMask', Mask);
})();

(function(){
	'use strict';
	Menu.$inject = ["$http", "$compile"];
	/**
	 * @ngdoc directive
	 * @name  gumga.core:gumgaMenu
	 * @restrict E
	 * @description
	 *  O componente gumgaMenu é uma directive que cria um menu na lateral esquerda da tela para facilitar a navegação do usuário no sistema.
	 *  Seus itens são carregados de forma dinâmica através de um arquivo `json` que é carregado através de uma requisição HTTP. Além disso,
	 *  ele faz um filtro de acordo com as keys passadas para ele também através de um arquivo `json`.
	 *  ## Exemplo
     *  Veja um exemplo em funcionamento [aqui](http://embed.plnkr.co/UcMtAor6sUA6s0oZnJiu/preview).
	 *  @param {String} menu-url Parâmetro obrigatório que irá conter uma variável com o endereço do arquivo `json` para que seja carregada as entradas do menu.
	 *  @param {String} keys-url Parâmetro obrigatório que irá conter uma variável com o endereço do arquivo `json` para que seja carregada as chaves que farão o filtro do menu.
	 *  @param {String} image Parâmetro obrigatório que irá conter uma variável com o endereço da imagem que ficará no menu.
	 *
 	 * ## Example
	 * 	###Exemplo de json para o menu:
	 * <pre>
    [
      {
        "label": "Home",
        "URL": "welcome",
        "key": "CRUD-BASE",
        "icon": "glyphicon glyphicon-home",
        "icon_color": "",
        "imageUrl": "",
        "imageWidth": "",
        "imageHeight": "",
        "filhos": []
      }
    ]
	 * 	</pre>
	 * 	###Exemplo de json para as keys:
	 * 	<pre>
    [
      "CRUD-BASE",
      "CRUD-User"
    ]
	 * 	</pre>
	 *
	 *
	 *  @param {String} menu-url Parâmetro obrigatório que irá conter uma variável com o endereço do arquivo `json` para que seja carregada as entradas do menu.
	 *  @param {String} keys-url Parâmetro obrigatório que irá conter uma variável com o endereço do arquivo `json` para que seja carregada as chaves que farão o filtro do menu.
	 *  @param {String} image Parâmetro obrigatório que irá conter uma variável com o endereço da imagem que ficará no menu.
	 *

	 */
	function Menu($http, $compile) {
		return {
			restrict: 'E',
			replace: true,
			scope: {},
			link: function (scope, el, attrs) {
				scope.v = [];
				var indexs = [];
				var count = 0;

				var menuOpen = false;

				$http.get(attrs.menuUrl).then(function (data) {
					scope.dados = data.data;
				}, function (data) {
					throw 'Erro:' + data;
				});

				$http.get(attrs.keysUrl).then(function (data) {
					scope.keys = data.data;
				}, function (data) {
					throw 'Erro:' + data;
				});

				scope.$watchGroup(['dados', 'keys'], function () {
					if (scope.dados && scope.keys) {
						gerateMenus();
					}
				});

				var gerateMenus = function () {
					var template = ['<div>'];
					template.push('<button id="btn-menu" class="btn btn-link" ng-click="mostrarMenu()"><i class="glyphicon glyphicon-align-justify"></i></button>');
					template.push('<nav id="menu" class="col-sm-3" name="menu">');
					template.push('<ul class="menu-holder">');
					template.push('<img ng-src="' + attrs.image + '" alt="logo" width="40%" class="img-centered">');
					for (var i = 0; i < scope.dados.length; i++) {
						if (keyIsValid(scope.dados[i].key)) {
							template.push(gerarNavPill(scope.dados[i], 'menu', {count: -1, label: null}));
						}
					}
					template.push('</ul>');
					template.push('</nav>');
					template.push('</div>');
					template = template.join('\n');
					el.append($compile(template)(scope));
				};

				var gerarNavPill = function (param, type, parent) {

					scope.v[count] = {
						isActive: false,
						parent: parent.count
					};

					var urlSelected = location.hash;
					var url = angular.copy(param.URL);
					url = '#/'+url.replace('.','/')
					if (urlSelected==url) {
							var template = ['<li class="' + type + '-option" style="background: #4ca089" >'];
					} else {
							var template = ['<li class="' + type + '-option">'];
					}

					if (param.filhos.length > 0 && verificarPermicaoFilho(param.filhos)) {
						template.push('<i  ng-class="v[' + count + '].isActive ? \' glyphicon glyphicon-chevron-down \' : \'glyphicon glyphicon-chevron-right\'" class="fa ' + type + '-color"  ng-click="resetarMenu(' + count + ')"></i>');
					} else {
						if (param.icon) {
							if (param.icon_color) {
								template.push('<i  class=" ' + param.icon + ' " style="color: ' + param.icon_color + '" ng-click="resetarMenu(' + count + ')"></i>');
							} else {
								template.push('<i  class=" ' + param.icon + ' " style="color: #fff" ng-click="resetarMenu(' + count + ')"></i>');
							}
						}
					}

					template.push('<a ui-sref="' + param.URL + '" ng-class="v[' + count + '].isActive ? \'is-active\' : \' \'"');
					if (parent.label === null || param.filhos.length > 0) {
						template.push('gumga-translate-tag="' + param.label.toLowerCase() + '.menuLabel">');
					} else if (param.filhos.length === 0) {
						template.push('gumga-translate-tag="' + parent.label.toLowerCase() + '.' + param.label.toLowerCase() + '">');
					}
					template.push(param.label);
					template.push('</a>');

					if (param.imageUrl) {
						if(param.imageWidth && param.imageHeight){
							template.push('<a ui-sref="' + param.URL + '"><img  src="' + param.imageUrl + '" style="width: '+param.imageWidth+'; height: '+param.imageHeight+';" ng-click="resetarMenu(' + count + ')"></i></a>');
						}else
						template.push('<a ui-sref="' + param.URL + '"><img  src="' + param.imageUrl + '" style="width: 20px; height: 20px;" ng-click="resetarMenu(' + count + ')"></i></a>');
					}

					var aux = count;

					count++;
					if (param.filhos.length > 0) {
						template.push('<ul ng-class="v[' + (count - 1) + '].isActive ? \' submenu-group-ativo\' : \'submenu-group\'" class="menu-holder">');
						for (var i = 0; i < param.filhos.length; i++) {
							if (keyIsValid(param.filhos[i].key)) {
								template.push(gerarNavPill(param.filhos[i], 'submenu', {count: aux, label: param.label}));
							}
						}
						template.push('</ul>');
					}
					template.push('</li>');
					return template.join('\n');
				};


				scope.resetarMenu = function (index) {
					var i;
					if (scope.v[index].isActive) {
						for (i = 0; i < scope.v.length; i++) {
							scope.v[index].isActive = false;
						}
						setarTrue(scope.v[index].parent);

					} else {
						for (i = 0; i < scope.v.length; i++) {
							scope.v[i].isActive = false;
						}
						setarTrue(index);
					}

				};

				var keyIsValid = function (key) {
					return scope.keys.indexOf(key) != -1;
				};

				function setarTrue(index) {
					if (index >= 0) {
						scope.v[index].isActive = true;
						setarTrue(scope.v[index].parent);
					}
				}

				scope.mostrarMenu = function () {
					menuOpen = !menuOpen;

					var elm = el.find('nav');
					if (menuOpen) {
						elm.addClass('open-menu');
					} else {
						elm.removeClass('open-menu');
					}
				};

				function verificarPermicaoFilho(filhos) {
					for (var i = 0; i < filhos.length; i++) {
						for (var j = 0; j < scope.keys.length; j++) {
							if (filhos[i].key == scope.keys[j]) {
								return true;
							}
						}
					}
					return false;
				}

			}
		};
	}

	angular.module('gumga.directives.menu',[])
	.directive('gumgaMenu',Menu);

})();

(function(){

  'use strict';
  Nav.$inject = ["$state", "GumgaWebStorage", "$modal", "$rootScope", "$timeout"];
  /**
  * @ngdoc directive
  * @name  gumga.core:gumgaNav
  * @restrict E
  * @description O componente gumgaNav é uma directive que cria uma barra de navegação superior, para ajudar o usuário. Dentro da barra de navegação,
  *  possuímos uma busca que, quando o botão ENTER é pressionado, ele redireciona para a página de Busca Multi-entidades. Possui também informações sobre o usuário que está logado,
  *  uma opção para fazer o logout e outra para alterar a senha.
  *  ## Exemplo
  *  Veja um exemplo em funcionamento [aqui](http://embed.plnkr.co/PeJHAS6viutuekw614ZL/preview).
  *  @param {String} title Parâmetro não obrigatório que contém uma string que será o título que aparecerá na barra de navegação.
  *  @param {Boolean} multi-entity Parâmetro nao obrigatório que contém um valor booleano para compilar ou não a busca multientidade. Por padrão, o valor é true.
  *  @param {String} put-url Parâmetro não obrigatório que contém uma String ou uma variável que estará no $scope da directive para atribuir uma url para fazer o put do alterar a senha.
  *  @param {String} state Parâmetro obrigatório que contém uma String com o $state para qual será redirecionado quando o usuário clicar em Logout.
  */
  function Nav($state, GumgaWebStorage, $modal, $rootScope, $timeout) {
    var template = [
      '<nav id="navbar">',
      ' <a href="#" class="navbar-logo" style=" float: left;">{{title | uppercase}}</a>',
      ' <span style="color: white; font-size: 1.4em;margin-left: 2%; float: left;"><small>{{info.organization}}</small></span>',
      ' <div class="navbar-form navbar-left" ng-transclude></div>',
      ' <b class="pull-right">',
      '   <img ng-show="info.picture" class="img-circle" style="width: 40px; height: 40px; margin-right:10px;" src="{{info.picture}}" />',
      '   <a href ng-blur="hidePanel()" class="status-navbar" ng-click="showPanelNavBar()">',
      '     <small  style="font-size: 85%;">{{info.name}} &nbsp;&nbsp; <i class="glyphicon glyphicon-triangle-bottom" style="margin-left: 1px"></i> </small>',
      '   </a>',
      ' </b>',
      ' <span ng-if="multientity" ng-click="treatUrl()" class="glyphicon glyphicon-search btn pull-right" style="color:#fff; padding-top: 1%; margin-right: 5%; height: 100%;"></span>',
      ' <input ng-if="multientity" type="text" id="inputSearch" ng-keyup="submitSearch($event)" style="background: none repeat scroll 0 0 rgba(244, 214, 214, 0.15); border: double; font-size: 14px; outline: 0; color: #fff; height: 100%; margin: 0; border-color: rgba(0, 0, 0, 0); z-index: 2000;" ng-model="search" ng-show="inputVisible" class="navbar-input flip-right" placeholder="Search">',
      '</nav>',
      '<div class="nav-panel" ng-show="showPanelNav">',
      ' <div class="panel-body" id="navPanelBody">',
      '   <button ng-repeat="link in navlinks" ng-click="handle(link)" class="btn btn-link" style="display:block;width: 100%;color: black; font-size: 0.9em;"><i class="{{link.glyphicon}}"> </i>{{link.text}} </button>',
      ' </div>',
      '</div>'
    ];

    var modalTemplate = [
      '<div class="modal-header">Change Password</div>',
      '<div class="modal-body">' +
      '   <form name="ModalForm" novalidate>' +
      '   <label> <small>Old Password</small></label>' +
      '   <input type="password" ng-keyup="validPassword(user.newpass, user.oldpass)" ng-focus="oldPasswordInvalid=false" class="form-control" ng-model="user.oldpass" required/>' +
      '   <label class="text-danger" style="width: 100%;"  ng-show="oldPasswordInvalid">Esta não é sua senha antiga</label>' +
      '   <label><small> New Password</small></label>' +
      '   <input type="password" class="form-control" ng-keyup="validPassword(user.newpass, user.oldpass)" ng-model="user.newpass" required/>' +
      '   <label class="text-danger" style="width: 100%;"  ng-show="newPasswordInvalid">Por favor insira uma senha diferente da antiga.</label>' +
      '   <label><small> New Password (again)</small></label>' +
      '   <input type="password" class="form-control" ng-keyup="validPasswordConfirm(user.newpass,user.newpasscheck)" ng-model="user.newpasscheck" required/>' +
      '   <label class="text-danger" style="width: 100%;"  ng-show="newPasswordConfirm">Repita a nova senha corretamente.</label>' +
      '</div>',
      '<div class="modal-footer">' +
      '   <button class="btn btn-primary" ng-click="ok(user)" type="submit" ng-disabled="ModalForm.$invalid || !btnEnabled"> Save</button>' +
      '   <button class="btn btn-warning" ng-click="cancel()" type="button"> Cancel</button>' +
      '</div>' +
      '</form>'];
      return {
        restrict: 'E',
        scope: false,
        transclude: true,
        template: template.join('\n'),
        link: function (scope, el, attrs) {
          var putUrl = attrs.putUrl;
          if(attrs.multiEntity == "true" || !attrs.multiEntity) scope.multientity = true;
          (!scope[attrs.putUrl]) ? putUrl = scope[attrs.putUrl] : angular.noop;
          scope.info = GumgaWebStorage.getSessionStorageItem('user');
          scope.navlinks = [{text: 'Change Password', glyphicon: 'glyphicon glyphicon-user', value: 'pass'}, {text: 'Logout', glyphicon: 'glyphicon glyphicon-log-out', value: 'logout'}];
          scope.inputVisible = false;
          scope.title = attrs.title || '';
          scope.treatUrl = function () {
            scope.inputVisible = !scope.inputVisible;
            $timeout(function () {
              document.getElementById('inputSearch').focus();
            },200);

          };
          scope.$on('close', function () {
            scope.showPanelNav = false;
          });
          scope.showPanelNavBar = function () {
            scope.showPanelNav = !scope.showPanelNav;
          };
          var obj = {};

          scope.submitSearch = function (event) {
            var key_code = event.keyCode;
            if (key_code === 13)
            $state.go('multientity', {'search': scope.search})
          }

          scope.hidePanel = function () {
            $timeout(function () {
              scope.showPanelNav = false;
            }, 200);
          };

          scope.handle = function (link) {
            scope.showPanelNav = !scope.showPanelNav;
            switch (link.value) {
              case 'pass':
              var modalInstance = $modal.open({
                template: modalTemplate.join('\n'),
                size: 'sm',
                controller: ["$scope", "$modalInstance", "$http", "GumgaWebStorage", function ($scope, $modalInstance, $http, GumgaWebStorage) {
                  var userSession = GumgaWebStorage.getSessionStorageItem('user');
                  $scope.btnEnabled = false;
                  $scope.oldPasswordInvalid = false;
                  $scope.newPasswordConfirm = false;
                  $scope.newPasswordInvalid = false;

                  $scope.validPasswordConfirm = function (password, confimPassword){
                    if(password !== confimPassword){
                      $scope.newPasswordConfirm = true;
                    }else{
                      $scope.newPasswordConfirm = false;
                    }
                    $scope.enabledBtn();
                  }

                  $scope.validPassword = function (password, oldPassword){
                    $scope.user.newpasscheck = '';
                    if(password == oldPassword && password){
                      $scope.newPasswordInvalid = true;
                    }else{
                      $scope.newPasswordInvalid = false;
                    }
                    $scope.enabledBtn();
                  }

                  $scope.enabledBtn = function (){
                    if(!$scope.newPasswordConfirm && !$scope.newPasswordInvalid){
                      $scope.btnEnabled = true;
                    }else{
                      $scope.btnEnabled= false;
                    }
                  }

                  $scope.ok = function (user) {
                    $http.put(attrs.putUrl, {
                      user: userSession.user,
                      password: user.oldpass,
                      newPassword: user.newpass})
                      .success(function (data) {
                        if (data.response == 'BAD_PASSWORD') {
                          $scope.oldPasswordInvalid = true;
                        } else if (data.response == 'OK') {
                          $scope.$emit('successMessage', {
                            title: 'Senha alterada',
                            message: 'Sua senha foi alterada com sucesso.'
                          })
                          $modalInstance.close();
                        } else {
                          $modalInstance.close();
                        }
                      });
                    };
                    $scope.cancel = function () {
                      $modalInstance.dismiss();
                    };

                  }],
                  resolve: {}
                });
                modalInstance.result.then(function (selectedItem) {
                  scope.selected = selectedItem;
                });
                break;
                case 'logout':
                $state.go(attrs.state);
                break;
              }
            };
            el.find('input')
            .on('keypress', function (k) {
              if (k.keyCode == 13)
              scope.treatUrl()
            });
          }
        };
      }

      angular.module('gumga.directives.nav',['ui.bootstrap'])
      .directive('gumgaNav',Nav)
    })();

(function(){
	'use strict';

	OneToMany.$inject = ["$modal", "$populate"];
	/**
	 * @ngdoc directive
	 * @name gumga.core:gumgaOneToMany
	 * @restrict E
	 * @description
	 * 	A directive gumgaOneToMany pode ser usada quando é necessária a criação de uma lista de objetos dentro do formulário, especialmente quando esses
	 * 	objetos acessam outros Services. Ela lança um modal para a criação destes objetos, que podem ser recursivos. Além disso, possui suporte a edição e remoção
	 * 	destes registros.
	 * @param {Array} children Parâmetro obrigatório que irá conter um Array que será utilizado para construir a lista.
	 * @param {String} template-url Parâmetro obrigatório que irá conter uma string referenciando a url na qual o template do modal estará.
	 * @param {String} property Parâmetro obrigatório que irá conter uma string com a propriedade do objeto que será mostrada na lista.
	 * @param {String} name *Utilizar modal-title*.
	 * @param {String} modal-title Parâmetro não obrigatório que irá conter uma string com o título que será passado para o controller
	 * @param {String} controller Parâmetro obrigatório que irá conter uma String que referenciará o nome do controller que será atribuido ao modal.
	 * *Este controller necessita injetar além do $scope, as propriedades **entity** e **title** *
	 * @param {Function} on-delete Parâmetro não obrigatório que irá conter uma variável que irá conter uma função que será chamada quando um elemento da lista for deletado.
	 * A função que está no on-delete
   * @param {Function} on-value-visualization-opened Parâmetro não obrigatório que irá conter uma variável que possuirá uma função que irá ser executada quando o usuário tiver aberto o modal
   * para visualização de dados
   * @param {Function} on-value-visualization-closed Parâmetro não obrigatório que irá conter uma variável que possuirá uma função que irá ser executada quando o usuário tiver fechado o modal
   * para visualização de dados
	 *
	 */
	function OneToMany($modal,$populate){
		var template = [
		'<div class="col-md-12" style="padding-left: 0;padding-right: 0">',
		'   <button type="button" class="btn btn-default" ng-click="newModal()">New</button>',
		'   <ul class="list-group">',
		'       <li ng-repeat="child in children" class="list-group-item">',
		'           {{::child[property]}}',
		'           <button type="button" class="btn btn-default pull-right btn-sm" ng-click="newModal(child)"><i class="glyphicon glyphicon-pencil"></i></button>',
		'           <button type="button" class="btn btn-danger pull-right btn-sm" ng-click="removeFromList(child)"><i class="glyphicon glyphicon-remove"></i></button>',
		'       <div class="clearfix"></div></li>',
		'   <ul>',
		'</div>',
		'<div class="clearfix"></div>'
		];

		return {
			restrict: 'E',
			template: template.join('\n'),
			scope: {
				children: '=',
				templateUrl: '@',
				property: '@displayableProperty',
				name: '@',
				controller: '@',
				onDelete: '&?',
				onValueVisualizationOpened: '&?',
				onValueVisualizationClosed: '&?',
				modalTitle: '@'
			},
			link: function (scope,elm,attrs) {
				var eventHandler = {
					valueVisualizationOpened: (attrs.onValueVisualizationOpened ? scope.onValueVisualizationOpened :angular.noop),
					valueVisualizationClosed: (attrs.onValueVisualizationClosed ? scope.onValueVisualizationClosed :angular.noop),
					delete: (attrs.onDelete ? scope.onDelete : angular.noop)
				};
				scope.newModal = newModal;
				scope.removeFromList = removeFromList;
				scope.getFromModal = getFromModal;
				var name = attrs.name || 'New';
				if(!scope.children) throw 'You must provide a list to GumgaOneToMany';
				if(!scope.templateUrl) throw 'You must provide a templateUrl for the modal';
				if(!scope.property) throw 'You must provide a property to display in GumgaOneToMany';
				if(!scope.controller) throw 'You must provide a controller to the modal';
				function getFromModal(selected){
					eventHandler.valueVisualizationClosed();
					if(JSON.stringify(scope.etty) !== '{}'){
						scope.children.splice(scope.children.indexOf(scope.etty),1,selected);
					} else {
						scope.children.push(selected);
					}
				}
				function removeFromList(obj){
					eventHandler.delete({$value: obj});
					scope.children.splice(scope.children.indexOf(obj),1);
				}
				function newModal(obj){
					scope.etty = {};
					if(obj){
						scope.etty= obj;
					}
					eventHandler.valueVisualizationOpened();
					var modalInstance = $modal.open({
						templateUrl: scope.templateUrl,
						controller: scope.controller,
						resolve: {
							entity: function(){
								return scope.etty;
							},
							title: function(){
								return scope.name;
							},
							populateScope: function(){
								return $populate.populateScope;
							}
						}
					});
					modalInstance.result.then(getFromModal);
				}


			}
		};
	}

	angular.module('gumga.directives.onetomany',['gumga.services.populate'])
		.directive('gumgaOneToMany',OneToMany)


})();

(function () {
  'use strict';

  Query.$inject= [];
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaQueries
   * @restrict E
   * @description
   * 	O componente gumgaQueries pode ser utilizado como um complemento para a directive gumgaSearch para quando ela for uma busca avançada. Ele utiliza o array searchQueries que é
   * 	exposto pelo componente de Busca Avançada.
   *
   * @param {Function} save-query Função que será executada quando o botão de salvar a pesquisa for clicado.
   * @param {String} label String que será colocada como título
   * @param {String} placeholder String que será colocada como placeholder o input.
   */
  function Query(){
    var _template =
    '<div class="col-md-12" ng-show="hasQueries && $parent.searchQueries.length > 0">'+
    '   <label><small>{{::label}}</small></label>'+
    '   <div class="col-md-12">'+
    '   <div class="col-md-8"  style="padding-left: 0;padding-right: 0;">'+
    '   <gumga-advanced-label '+
    '         ng-repeat="query in $parent.searchQueries"'+
    '         attr="{{query.attribute.name}}"'+
    '         hql="{{query.hql.label}}"'+
    '         value="query.value"'+
    '         index="$index"'+
    '         disabled="true"'+
    '         style="margin-right: .5%">'+
    '   </gumga-advanced-label>'+
    '</div>'+
    ' <div class="col-md-4" style="padding-left: 0;padding-right: 0;">'+
    ' <div class="input-group input-group-sm" style="">'+
    '   <input type="text" ng-model="name" class="form-control" placeholder="{{placeholder}}" />'+
    '     <span class="input-group-btn">'+
    '       <button ng-disabled="(name.length < 1)" class="btn btn-primary" ng-click="saveQuery({query: $parent.searchQueries,name: name})" >'+
    '         <i class="glyphicon glyphicon-floppy-save"></i>'+
    '       </button>'+
    '     </span>'+
    ' </div>'+
    ' </div>'+
    '</div>';
    return {
      restrict: 'E',
      scope:{
        saveQuery: '&',
        placeholder: '@?'
      },
      template: _template,
      link: function (scope,elm,attrs) {
        scope.label = attrs.label || 'Busca ativa:';
        if(scope.$parent.searchQueries){
          scope.hasQueries = true;
        }
      }
    }
  }

  angular.module('gumga.directives.queries',['gumga.directives.search.advancedlabel'])
  .directive('gumgaQueries',Query);
})();


(function(){
	'use strict';
	/**
	 * @ngdoc directive
	 * @name gumga.core:gumgaSearch
	 * @restrict E
	 * @description A directive gumgaSearch pode ser utilizada para fazer montar queries de busca, sejam essas buscas normais ou avançadas. É possível escolher
	 * quais campos no qual a busca será feita, assim como na busca avançada.
	 * ## Exemplo
     * Veja um exemplo em funcionamento [aqui](http://embed.plnkr.co/ezZITh3ZfmwVao0Xz1w6/preview).    
	 *
	 * O componente utiliza-se de tags que só funcionam dentro das tags do componente, que são as tags `<advanced-field></advanced-field>`. A tag de advanced-field 
	 * 	recebe dois atributos como parâmetro: `name` e `type` que recebem , respectivamente, o nome do atributo a ser pesquisado e qual seu tipo.
	 * 	<pre>
	 *  		<advanced-field name="nome" type="string"></advanced-field>
	 *  		<advanced-field name="idade" type="number"></advanced-field>
	 *  </pre>
	 * 
	 * @param {Function} advanced-method Parâmetro obrigatório que irá conter uma função que será utilizada para fazer a busca avançada.
	 * Para receber a query avançada, basta passar um parâmetro `param` para a função. `advanced-method="function(param)"`
	 * @param {Function} search-method Parâmetro obrigatório que irá conter uma função que será utilizada para fazer a busca simples.
	 * Para receber o campo e a pesquisa que foi feita, basta passar os parâmetros `field` e `param` para a função. `search-method="function(field,param)"`.
	 * @param {String} fields Parâmetro obrigatório que irá conter uma sequência de campos com o qual o componente irá criar a lista de atributos que serão pesquisáveis.
	 * Exemplo: `fields="id,name,company,age"`
	 * @param {Boolean} advanced Parâmetro não obrigatório que irá conter um valor booleano para controlar se o componente irá ou não fazer busca avançada
	 * @param {Function} on-search Parâmetro não obrigatório que irá conter uma função que será chamada quando uma busca simples for feita. 
	 * @param {Function} on-advanced-search Parâmetro não obrigatório que irá conter uma função que será chamada quando uma busca avançada for feita. 
	 *
	 * 
	 */
	angular.module('gumga.directives.search',
		[
		'gumga.directives.search.search',
		'gumga.directives.search.normalsearch',
		'gumga.directives.search.advancedsearch',
		'gumga.directives.search.advancedlabel',
		'gumga.directives.search.searchhelper',
		]);

})();

(function(){
  'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaTable
   * @restrict E
   * @description O componente **GumgaTable** serve para expor dados em forma de tabela.
   * O componente expõe no $scope.selectedEntities um array contendo os objetos das linhas selecionadas para que o desenvolvedor possa usa-los em ações.
   *
   * @example
   * Um exemplo da directive gumgaTable funcionando pode ser encontrado [aqui](http://embed.plnkr.co/SALkp5bKRZ1aywsrpmEX).
   *  <pre>
   *    <gumga-table values="list" columns="name,age"></gumga-table>
   *    <script>
   *    $scope.list = [{name: 'Guilherme', age: 28},{name: 'Igor', age: 19}];
   *    </script>
   *  </pre>
   *
   * @param {String} values Atributo obrigatório. Deve ser o nome do array exposto no $scope para popular a tabela.
   * @param {String} columns Atributo obrigatório. As propriedades do objeto que serão apresentados como colunas na tabela,
   * @param {String} size Possuem 3 opções de tamanhos, **large**, **medium** e **small**, que respectivamente ocupam, todo o espaço da row, dois terços e
   * um terço. O valor padrão é large.
   * @param {String} translate-entity Nome da entidade.
   * @param {Array} pages Deve conter os valores para apresentar opções de registros por página.
   * @param {String} table-class Possuem 3 opções, **bordered**, **striped** e **condensed**, que respectivamente, adiciona bordas a tabela,
   * alterna cores das linhas e diminui o espaçamento interno das linhas e colunas. O valor padrão é bordered.
   * o componente seguirá a ordem de colunas adicionada ao atributo.
   * @param {Boolean} multi-selection É true por padrão, determina a possibilidade da seleção de várias entidades ou apenas
   * uma por vez.
   * @param {Function} sort-function Nome da função atribuida ao $scope para manipular a ordenação, a função recebe dois
   * parâmetros, **field** e **way** que serão, a coluna e a direção da ordenação respectivamente, existem duas direções,
   * **asc** ou **desc**.
   * @param {String} sort-default Deve conter a **coluna** e a **direção** separados por virgula, será a ordenação padrão na primeira exibição da tabela.
   * @param {Expression} row-class Deve conter uma expressão condicional para marcar determinadas linhas correspondentes como
   * verdadeiras perante a expressão.
   * @param {Function} onSelect Nome da função que será executada ao evento click.
   * @param {Function} onSort Nome da função que será executada ao evento de sort.
   */
   Table.$inject = ["GumgaUtils", "$compile", "$rootScope", "$state", "GumgaKeyboard", "$timeout"];
   function Table(GumgaUtils, $compile,$rootScope,$state,GumgaKeyboard,$timeout) {
    return {
      restrict: 'E',
      scope: {
        multi: '=?multiSelection',
        list: '=values',
        pages: '=pages',
        sort: '&?sortFunction',
        rowClass: '=?',
        onSelect: '&?',
        onSort: '&?'
      },
      link: LinkFn,
      transclude: true
    };

    function LinkFn(scope, elm, attrs, ctrl, transcludeFn) {
      var eventHandler = {
        select: (attrs.onSelect ? scope.onSelect : angular.noop),
        sort: (attrs.onSort ? scope.onSort: angular.noop)
      };

      scope.$on('_clean',function(){
       scope.cleanSearch();
     });

      var ColumnObject = {};
      scope.indexes = [];
      scope.trs = [];
      scope.$parent.selectedEntities = [];
      scope.objectColumn = [];
      scope.conditionalColumns = [];
      var rawTableConfig = {
        multi: scope.multi,
        list: [],
        pages: scope.pages || [10, 25, 50],
        sortFn: attrs.sort? scope.sort : angular.noop,
        sortDf: !!attrs.sortDefault? attrs.sortDefault.split(',') : false,
        size: attrs.size || 'large',
        class: attrs.tableClass || 'bordered',
        columns: attrs.columns.split(','),
        headings: [],
        translate: attrs.translateEntity,
      };
      var itemsPerPage = window.sessionStorage.getItem('itemsPerPage') || rawTableConfig.pages[0];
      scope.itemsPerPage = itemsPerPage;
      scope.$parent.itemsPerPage = itemsPerPage;

      scope.$watch('list', function () {
        if (scope.list) {
          scope.$parent.selectedEntities = [];
          scope.tableconfig.list = scope.list;
          scope.indexes = [];

        }
      });

      setColumnConfig(rawTableConfig);

      function setColumnConfig(rawConfig) {
        rawConfig.columns.forEach(function (elm) {
          var obj = {
            label: GumgaUtils.camelCase(elm),
            field: elm
          };
          rawConfig.headings.push({label: obj.label, way: null});
          rawConfig.columns.splice(rawConfig.columns.indexOf(elm), 1, obj);
        });

        transcludeFn(function (clone) {
          angular.forEach(clone, function (cloneEl) {
            if (cloneEl.nodeName != "#text") {
              switch (cloneEl.nodeName) {
                case 'GUMGA-BOOLEAN-MASK':
                rawConfig.columns.forEach(function (obj) {
                  if (obj.field == cloneEl.getAttribute('column')) {
                    $.extend(obj, {
                      trueValue: cloneEl.getAttribute('boolean-true'),
                      falseValue: cloneEl.getAttribute('boolean-false')
                    });
                  }
                });
                break;
                case 'BUTTONS-COLUMN':
                scope.buttonElements = cloneEl.children;
                rawConfig.headings.push({label: ' ', way: null});
                break;
                case 'EXTRA-COLUMN':
                scope.extraElements = cloneEl.children;
                rawConfig.headings.push({label: ' ', way: null});
                break;
                case 'OBJECT-COLUMN':
                scope.objectColumn.push({column: cloneEl.getAttribute('column'),value: cloneEl.getAttribute('property')});
                break;
                case 'COLUMN-CLASS':
                scope.conditionalColumns.push({column: cloneEl.getAttribute('column'),conditional: cloneEl.getAttribute('conditional-class')});
                break;

              }
            }
          });
});
scope.tableconfig = rawConfig;
generateTable(scope.tableconfig);
}
function getConditions(){
  var conditionText = attrs.rowClass || '';
  return conditionText.replace(/{/,'').replace(/}/,'').split(',');
}
function generateTable(config) {
  var template = [];
  if (scope.pages) {
    var pagination =
    '<select ng-model="itemsPerPage" ng-change="changeItemsPerPage(itemsPerPage)">' +
    '<option ng-repeat="p in pages" value="{{ p }}" ng-selected="p == itemsPerPage">{{ p }}</option>' +
    '</select>';
    template.push(pagination);
  }
  switch (config.size) {
    case 'large':
    template.push(
      '<div class="full-width-without-padding" style="margin-top: 1%">' +
      '<button class="btn btn-default btn-xs" style="margin-bottom: 0.25%" ng-click="selectAll()">Selecionar todos</button>' +
      '<button class="btn btn-default btn-xs" style="margin-bottom: 0.25%;margin-left:0.25%" ng-click="cleanSearch()"> Limpar pesquisa</button>' +
      '<table class="table table-' + config.class + ' ">');
    break;
    case 'medium':
    template.push(
      '<div class="col-md-8" style="padding-left:0;padding-right: 0;">' +
      '<table class="table table-' + config.class + '">');
    break;
    case 'small':
    template.push(
      '<div class="col-md-4" style="padding-left:0;padding-right: 0;">' +
      '<table class="table table-' + config.class + '">');
    break;
  }
  template.push('<thead>');
  template.push('<tr>');
  if (attrs.sortFunction) {
    template.push(' <td ng-repeat="head in tableconfig.headings track by $index" ng-click="head.label !== \' \' ? sortAux(head) : \'\'"');
    template.push('     ng-class="head.label != \' \' ? \'clickable-td\' : \' \' ">');
    template.push('         <small>{{::head.label}}<i ng-class="(head.way != null && head.label !== \' \') ? (head.way === true ? \'glyphicon glyphicon-menu-up\' : \'glyphicon glyphicon-menu-down\') : \'\'"></i></small></td>');
  } else {
    template.push('<td ng-repeat="head in tableconfig.headings track by $index">{{::head.label}}');
  }
  template.push(' </td>');
  template.push('</tr>');
  template.push('</thead>');
  template.push('<tbody>');
  if (config.multi === false) {
    template.push('<tr style="{{::getClassFromConditionalRow(entity)}}" ng-class="returnClass($index)" ng-repeat="entity in tableconfig.list" class="used" ng-click="handleSingle(entity,$index)" ng-dblclick="goToEdit(entity.id)">' + generateTableCell(config) + '</tr>');
  } else {
    template.push('<tr style="{{::getClassFromConditionalRow(entity)}}" ng-class="returnClass($index)" ng-repeat="entity in tableconfig.list" class="used" ng-click="handleMultiple(entity,$index)" ng-dblclick="goToEdit(entity.id)" >' + generateTableCell(config) + '</tr>');
  }
  template.push('</tbody>');
  template.push('</table></div>');
  elm.append($compile(template.join('\n'))(scope));

}
var selected = false;

scope.goToEdit = function(index){
  $state.go(scope.tableconfig.translate + '.' + 'edit',{id: index});
};
scope.changeItemsPerPage = function(itemsPerPage){
  window.sessionStorage.setItem('itemsPerPage', itemsPerPage);
  scope.$parent.itemsPerPage = itemsPerPage;
};
scope.selectAll = function(){
  if(!selected){
    for(var i = 0, len = scope.tableconfig.list.length;i < len;i++){
      scope.indexes.push(i);
    }
    scope.$parent.selectedEntities = scope.tableconfig.list;
  } else {
    scope.indexes = [];
    scope.$parent.selectedEntities = [];
  }
  selected = !selected;
};


scope.cleanSearch = function(){
  $rootScope.$broadcast('normal',{field:scope.tableconfig.columns[1],param: ''});
  scope.tableconfig.headings.forEach(function(elm){
    elm.way = null;
  })
};

scope.getClassFromConditionalRow = function (entity){
  var HelperObject = {};
  var conditionsFromTag = getConditions();
  conditionsFromTag.forEach(function(elm){
    HelperObject[elm.split(':')[0]] = eval(elm.split(':')[1]);
  });
  for(var key in HelperObject) if(HelperObject.hasOwnProperty(key) && HelperObject[key] === true){
    return 'border-left: 3px solid ' + key.trim();
  }
  return '';
};

function checkObject(field){
  for(var i = 0; i < scope.objectColumn.length;i++){
    if(scope.objectColumn[i].column === field){
      return '{{::entity.'+  scope.objectColumn[i].value +'}}';
    }
  }
  return -1;
}

function getClassFromConditionalCell(column,entity){
  scope.conditionalColumns.forEach(function(elm){
    if(elm.column.toLowerCase().trim() === column.toLowerCase().trim()){
      ColumnObject[elm.column] = {};
      elm.conditional.replace(/{/,'').replace(/}/,'').split(',')
      .forEach(function(arg){
        var x = arg.split(':');
        ColumnObject[elm.column][x[0].trim().replace(/"/g,'')] = x[1].trim();
      })
    }
  });
}


scope.getStyleFromCell = function(entity,column){
  if(ColumnObject[column.trim().toLowerCase()]){
    var auxObj = ColumnObject[column.trim().toLowerCase()];
    for(var key in auxObj) if(auxObj.hasOwnProperty(key) && eval(auxObj[key]) === true){
      return 'border-left: 3px solid ' + key.trim();
    }
  }
};

function generateTableCell(config) {
  var template = [];
  config.columns.forEach(function (elm) {
    getClassFromConditionalCell(elm.field);
    if (elm.trueValue) {
      template.push('<td style="{{::getStyleFromCell(entity,\' '+ elm.field + ' \')}}">{{::entity.' + elm.field + ' === true? \'' + elm.trueValue + '\' : \'' + elm.falseValue + '\'}}</td>');
    } else if(checkObject(elm.field) != -1){
      template.push('<td style="{{::getStyleFromCell(entity,\' '+ elm.field + ' \')}}">' + checkObject(elm.field) +' </td>');
    } else {
      template.push('<td style="{{::getStyleFromCell(entity,\' '+ elm.field + ' \')}}">{{::entity.'+ elm.field + '}} </td>');
    }
  });
  if (scope.buttonElements) {
    template.push('<td style="{{::getStyleFromCell(entity,\' '+ elm.field + ' \')}}">' + getSpecial(scope.buttonElements) + '</td>');
  }
  if (scope.extraElements) {
    template.push('<td style="{{::getStyleFromCell(entity,\' '+ elm.field + ' \')}}">' + getSpecial(scope.extraElements) + '</td>');
  }
  return template.join(' ');
}


function getSpecial(array) {
  var txt = [];
  angular.forEach(array, function (elm) {
    txt.push(elm.outerHTML);
  });
  return txt.join(' ');
}

            // Negação dupla transforma em boolean
            if (!!rawTableConfig.sortDf) {
              // Se houver o atributo sort-default monta o objeto e dispara o evento
              var objSortDefault = {
                field: rawTableConfig.sortDf[0],
                way: rawTableConfig.sortDf[1]
              };
              eventHandler.sort({field: objSortDefault.field});
              scope.sort(objSortDefault);
            }

            scope.sortAux = function (obj) {
                //Quando ele clica, ele verifica se já existe alguma coluna com sort, se já existir, retorna ela para null
                scope.tableconfig.headings.forEach(function (key) {
                  if (key != obj) {
                    if (key.way === true || key.way === false) {
                      key.way = null;
                    }
                  }
                });
                // Pega o index do objeto
                var index = scope.tableconfig.headings.indexOf(obj);
                //Seta o sort dele pra false ou true
                obj.way = !obj.way;
                //Remove da lista anterior o antigo e coloca o novo
                scope.tableconfig.headings.splice(index, 1, obj);
                var aux;
                // Se for true, é ascendente
                if (obj.way === true) {
                  aux = 'asc';
                } else {
                  aux = 'desc';
                }
                // Dispara o evento
                eventHandler.sort({field: obj.label.toLowerCase()});
                scope.sort({field: obj.label.toLowerCase(), way: aux});
              };

              scope.handleMultiple = function (entity, index) {
                if (GumgaUtils.areNotEqualInArray(scope.indexes, index) || scope.indexes.length < 1) {
                  scope.indexes.push(index);
                  scope.$parent.selectedEntities.push(entity);
                } else {
                  scope.indexes.splice(scope.indexes.indexOf(index), 1);
                  scope.$parent.selectedEntities.splice(scope.$parent.selectedEntities.indexOf(entity), 1);
                }
                eventHandler.select({selected: scope.$parent.selectedEntities});
              };

              scope.handleSingle = function (entity, index) {
                if (scope.indexes.length >= 1) {
                  scope.indexes = [];
                  scope.$parent.selectedEntities = [];
                }
                scope.selectedIndex = index;
                scope.indexes.push(index);
                scope.$parent.selectedEntities.push(entity);
                eventHandler.select({selected: scope.$parent.selectedEntities});
              };

              scope.returnClass = function (index) {
                if (!GumgaUtils.areNotEqualInArray(scope.indexes, index)) {
                  return 'info';
                }
                return '';
              };
            }
          }

          angular.module('gumga.directives.table',[])
          .directive('gumgaTable',Table);
        })();

(function(){
	'use strict';
	Upload.$inject = ["$http", "$parse", "$timeout"];
	/**
	 * @ngdoc directive
	 * @name gumga.core:gumgaUpload
	 * @restrict
	 * @description
	 * 	O componente gumgaUpload pode ser utilizado para fazer upload de imagens. O framework GUMGA usa um método de upload
	 * 	de imagens que faz o upload do arquivo para uma pasta temporária e retorna um token. Quando o registro é salvo, o framework gumga
	 * 	faz o bind da string que está no atributo com o arquivo temporário.
	 * 	@param {Objet} model Objeto que irá conter as informações da imagem.
	 * 	@param {Function} upload-method Função que será executada para fazer o upload da imagem para o arquivo temporário.
	 * 	@param {Function} delete-method Função que será executada para deletar a imagem do espaço temporário.
	 * 	@param {String} tooltip-text Mensagem que irá aparecer no tooltip da imagem.
	 */
	function Upload($http,$parse,$timeout){

		var img =
		'<div ng-click="fireClick()" ng-show="flag" class="col-md-1" tooltip="{{::tooltipText}}" tooltip-placement="right">'+
		'	<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="128px" height="128px" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve">'+
		'		<path id="avatar" fill="#cccccc" d="M490.579,383.029c-14.152-22.086-61.763-35.824-108.835-55.453c-47.103-19.633-58.268-26.439-58.268-26.439'+
		'			l-0.445-45.182c0,0,17.646-13.557,23.127-56.074c11.01,3.198,22.619-16.461,23.237-26.824c0.625-9.98-1.508-37.662-14.981-34.877' +
		'			c2.754-20.845,4.741-39.586,3.764-49.505c-3.495-36.295-39.23-74.578-94.182-74.578c-54.95,0-90.7,38.283-94.193,74.578' +
		'			c-0.978,9.919,1.019,28.661,3.758,49.505c-13.455-2.785-15.587,24.897-14.979,34.877c0.635,10.363,12.196,30.021,23.255,26.824' +
		'			c5.462,42.517,23.122,56.074,23.122,56.074l-0.441,45.182c0,0-11.178,6.807-58.268,26.439' +
		'			c-47.104,19.629-94.683,33.367-108.851,55.453c-12.7,19.777-8.882,114.875-8.882,114.875h470.946' +
		'			C499.462,497.904,503.281,402.806,490.579,383.029z"/>' +
		'	</svg>' +
		'</div>';

		var template =
		'<div class="full-width-without-padding">' +
		img +
		'   <img src="#" alt="Uploaded Image" ng-show="!flag" class="img-rounded" style="object-fit: cover"/>' +
		'   <input type="file" name="upload" id="upload" ng-hide="true"/>' +
		'   <div class="col-md-12" style="padding-left: 0">' +
		'   <button type="button" class="btn btn-link" ng-hide="flag" ng-click="deleteImage()"> Delete Image <span class="glyphicon glyphicon-trash"></span></button>' +
		'</div>' +
		'</div>';
		return {
			restrict: 'AE',
			scope: {
				model: '=attribute',
				uploadMethod: '&',
				deleteMethod: '&',
				tooltipText: '@'
			},
			template: template,
			link:function(scope,elm,attrs){
				var model = $parse(attrs.attribute),
				modelSetter = model.assign,
				element = elm.find('input'),
				image = elm.find('img')[0],
				reader = new FileReader();


				scope.fireClick = function(){
					$timeout(function(){
						document.getElementById('upload')
							.click();
					});
				}

				scope.$watch('model',function(){
					if(scope.model){
						if(scope.model.bytes){
							scope.flag = false;
							image.src = 'data:' + scope.model.mimeType + ';base64,' + scope.model.bytes;
							image.width = 200;
							image.height = 200;
						}
					} else {
						scope.model = {};
					}
				});

				if(!attrs.attribute){
					throw 'You must pass an attribute to GumgaUpload';
				}

				scope.flag = true;

				function scaleSize(maxW, maxH, currW, currH){
					var ratio = currH / currW;
					if(currW >= maxW && ratio <= 1){
						currW = maxW;
						currH = currW * ratio;
					} else if(currH >= maxH){
						currH = maxH;
						currW = currH / ratio;
					}
					return [currW, currH];
				}

				scope.deleteImage = function(){
					image.src = '';
					scope.flag = true;
					element[0].files = [];
					scope.deleteMethod();
				};

				element.bind('change',function(){
					scope.$apply(function(){
						var x;
						modelSetter(scope,element[0].files[0]);
						scope.flag = false;
						reader.onloadend = function(){
							image.src = reader.result;
							image.width = 200;
							image.height =200;
							var x = attrs.attribute.split('.');
							scope.uploadMethod({image: scope[x[0]][x[1]]})
							.then(function(val){
								scope.model.name = val.data;
							});
						};
						reader.readAsDataURL(element[0].files[0]);
					});
				});
			}
		};
	}

	angular.module('gumga.directives.upload',[])
		.directive('gumgaUpload',Upload);

})();

(function(){
	'use strict';
	AddressService.$inject = [];
	function AddressService(){
		return {
			everyUf: ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR',
			'RJ', 'RN', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO'],
			everyLogradouro: [	'Outros', 'Aeroporto', 'Alameda', 'Área', 'Avenida', 'Campo', 'Chácara', 'Colônia', 'Condomínio', 'Conjunto', 'Distrito',
			'Esplanada', 'Estação', 'Estrada', 'Favela', 'Fazenda', 'Feira', 'Jardim', 'Ladeira', 'Largo', 'Lago', 'Lagoa', 'Loteamento',
			'Núcleo', 'Parque', 'Passarela', 'Pátio', 'Praça', 'Quadra', 'Recanto', 'Residencial', 'Rodovia', 'Rua', 'Setor', 'Sítio',
			'Travessa', 'Trevo', 'Trecho', 'Vale', 'Vereda', 'Via', 'Viaduto', 'Viela', 'Via'],
			availableCountries: ['Brasil'],
			returnFormattedObject: function(){
				return {
					zipCode : null,
					premisseType: null,
					premisse: null,
					number: null,
					information: null,
					neighbourhood: null,
					localization: null,
					state: null,
					country: null
				}
			}
		}
	}

		angular.module('gumga.services.address',[])
		.factory('GumgaAddressService',AddressService);

	})();

(function(){
	'use strict';

	Alert.$inject = []
	/**
	 * @ngdoc service
	 * @name gumga.core:GumgaAlert
	 * @description O service GumgaAlert é uma nova versão da directive {@link gumga.core:gumgaAlert} e é utilizado para criar
	 * notificações growl-like. Para utilizar o service, basta incluir GumgaAlert como dependência.
	 * 
	 * *Observação: Para utilização do service no config do módulo, utilizar `GumgaAlertProvider`*
	 *
	 *
	 * ## Métodos
	 *
	 * O service GumgaAlert possui quatro métodos de criação de alerta, porém todos recebem o mesmo parâmetro. Foi optado por criar quatro
	 * métodos diferentes para aumentar a legibilidade.
	 * - createWarningMessage(title,message,options)
	 * - createDangerMessage(title,message,options)
	 * - createSuccessMessage(title,message,options)
	 * - createInfomessage(title,message,options)
	 *
	 *  ### Parâmetros
	 *  - `title`: Uma string que irá conter o título da mensagem que será criada.
	 *  - `message`: Uma string que irá conter o corpo da mensagem que será criada.
	 *  - `options`: Um objeto com opções adicionais para o alerta. Os atributos que podem ser passados para este objeto são:
	 *  	<pre>
	 *   		var config = {
	 *   		 offset: 50, //Tamanho da distância entre o alerta e tela.
	 *   		 timer: 100, //Tempo que irá demorar para a mensagem aparecer após
	 *   		 delay: 3500,
	 *   		 alowDismiss:true,
	 *   		 animationEnter: 'animated bounceInRight',
	 *   		 animationExit: 'animated bounceOutRight'
	 *   		}
	 * 		</pre> *Objeto com os valores padrões do alerta*
	 * 		
	 */
	function Alert(){
		return {
			$get: function(){
				return this;
			},
			__config: {
				warn: {
					icon: 'glyphicon glyphicon-warning-sign',
					type: 'warning'
				},
				danger: {
					icon: 'glyphicon glyphicon-exclamation-sign',
					type: 'danger' 
				},
				success: {
					icon:'glyphicon glyphicon-ok',
					type: 'success'
				},
				info: {
					icon: 'glyphicon glyphicon-info-sign',
					type: 'info'
				}
			},
			_notify: function(type,title,message,options){
				var config = this.__config[type]
				,		offset = options.offset || 50
				,		timer = options.timer || 100
				,		delay = options.delay || 3500
				,		alowDismiss = options.alowDismiss || true
				,		animationEnter = options.animationEnter || 'animated bounceInRight'
				,		animationExit = options.animationExit || 'animated bounceOutRight';
				$.notify({
					icon: config.icon,
					title: title,
					message: message
				},{
					type: type,
					offset: offset,
					timer: timer,
					delay: delay,
					alow_dismiss: alowDismiss,
					animate: {
							enter: animationEnter,
							exit: animationExit
						},
					template: '<div data-notify="container" class="col-xs-9 col-sm-3 alert alert-{0}" role="alert">' +
						'<button type="button" aria-hidden="true" class="close" data-notify="dismiss">×</button>' +
						'<span data-notify="icon"></span> ' +
						'<span data-notify="title"><b>{1}</b></span><br> ' +
						'<span data-notify="message">{2}</span>' +
						'</div>'
				})
			},
			createWarningMessage: function(title,message,options){
				if(!options) options = {};
				this._notify('warning',title,message,options);
			},
			createDangerMessage: function(title,message,options){
				if(!options) options = {};
				this._notify('danger',title,message,options);
			},
			createSuccessMessage: function(title,message,options){
				if(!options) options = {};
				this._notify('success',title,message,options);
			},
			createInfoMessage: function(title,message,options){
				if(!options) options = {};
				this._notify('info',title,message,options);
			}
		}
	}

	angular.module('gumga.services.alert',[])
		.provider('GumgaAlert',Alert);
})();
(function(){
	'use strict';

	Base.$inject = ["$http", "$q"];
	/**
	 * @ngdoc service
	 * @name gumga.core:GumgaBase
	 * @description
	 * 	O service GumgaBase pode ser utilizado como helper para fazer chamadas HTTP. Ele permite que o programador não precise incluir o service $http
	 * 	do AngularJS e já vem com algumas funções incluídas. Para utilizar o GumgaBase, basta íncluí-lo como dependência.
	 *
	 *
	 *  # Métodos
	 *  `GumgaBase.get(url,params)`
	 *
	 *  O método get aceita dois parâmetros `url` e `params` e retorna uma promise de uma chamada HTTP do tipo GET.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">url</label>  Endereço no qual a chamada http será feita.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label> <label class="label label-info">params</label> Parâmetros da query que será feita.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retona uma promise da chamada HTTP GET.
	 *  ---
 	 *  `GumgaBase.getById(url,id)`
	 *
	 *  O método getById aceita dois parâmetros `url` e `id` e retorna uma promise de uma chamada HTTP do tipo GET.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">url</label>  Endereço no qual a chamada http será feita.
	 *  - <label class="label label-warning" style="margin-right: 1%">[String|Number]</label> <label class="label label-info">id</label> Identificador do registro que será buscado.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retona uma promise da chamada HTTP GET.
	 *  ---
	 *  `GumgaBase.getNew(url)`
	 *
	 *  O método getById aceita um parâmetro `url` e retorna uma promise de uma chamada HTTP do tipo GET.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">url</label>  Endereço no qual a chamada http será feita e na qual
	 *   será feita a chamada para um novo registro.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP GET.
	 *  ---
 	 *  `GumgaBase.deleteAll(url,array)`
	 *
	 *  O método deleteAll aceita dois parâmetros `url` e `array` e retorna uma promise de uma série de chamadas http do tipo DELETE que serão resolvidas ao mesmo tempo.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">url</label>  Endereço no qual a chamada http será feita.
	 *  - <label class="label label-warning" style="margin-right: 1%">Array</label><label class="label label-info">array</label> Array com todas os registros que serão deletados
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise após todas as chamadas terem sido resolvidas.
	 *  ---
	 *  `GumgaBase.save(url,data)`
	 *
	 *  O método save aceita dois parâmetros `url` e `data` e retorna uma promise de de uma chamada HTTP POST.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">url</label>  Endereço no qual a chamada http será feita.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label><label class="label label-info">data</label> Objeto que deseja ser salvo.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP POST.
	 *  ---
 	 *  `GumgaBase.update(url,data)`
	 *
	 *  O método deleteAll aceita dois parâmetros `url` e `data` e retorna uma promise de de uma chamada HTTP PUT.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">url</label>  Endereço no qual a chamada http será feita.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label><label class="label label-info">data</label> Objeto que deseja ser atualizado.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP POST.
	 *  ---
 	 *  `GumgaBase.del(url,data)`
	 *
	 *  O método del aceita dois parâmetros `url` e `data` e retorna uma promise de de uma chamada HTTP DELETE. Esta função é chamada para cada registro passado dentro do Array
	 *  na função deleteAll.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">url</label>  Endereço no qual a chamada http será feita.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label><label class="label label-info">data</label> Objeto que deseja ser deletado.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP DELETE.
	 *  ---
	 *  `GumgaBase.postImage(url,attribute,data)`
	 *
	 *  O método postImage aceita três parâmetros `url`,`attribute` e `data` e retorna uma promise de de uma chamada HTTP POST FORM-DATA.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">url</label>  Endereço no qual a chamada http será feita.
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">attribute</label> Atributo no qual a imagem será feito o
	 *  bind após o form ter sido enviado completo.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label><label class="label label-info">data</label> Dados da imagem que foi selecionada..
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP POST. Nesta promise, será retornado o valor de uma String que deverá ser atribuída ao atributo
	 *  onde estava a imagem. Esta string é um identificador para quando o registro for enviado através de um post.
	 *  ---
 	 *  `GumgaBase.deleteImage(url,attribute,data)`
	 *
	 *  O método del aceita três parâmetros `url`, `attribute` e `data` e retorna uma promise de uma chamada HTTP DELETE FORM-DATA.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">url</label> Endereço no qual a chamada http será feita.
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">attribute</label> Atributo no qual a imagem será feito o
	 *  bind após o form ter sido enviado completo.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label><label class="label label-info">data</label> Dados da imagem que foi selecionada.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP DELETE.
	 *  ---
	 */
	function Base($http,$q){
		var defaultParams = {};
		this.get = get;
		this.getById = getById;
		this.getNew = getNew;
		this.deleteAll = deleteAll;
		this.save = save;
		this.update = update;
		this.del = del;
		this.postImage = postImage;
		this.deleteImage = deleteImage;

		function get(url,params) {
			if (!params) {
				params = defaultParams;
			}
			return $http.get(url, params);
		}

		function getById(url,id) {
			return $http.get(url + '/' + id);
		}

		function getNew(url){
			return $http.get(url+'/new');
		}

		function deleteAll(url,entities) {
			var promises = entities.map(function(entity){
				return del(url,entity);
			});
			return $q.all(promises);
		}

		function save(url,entity) {
			return $http.post(url, entity);
		}

		function update(url,entity) {
			return $http.put(url + '/' + entity.id, entity);
		}

		function del(url,entity) {
			return $http.delete(url + '/' + entity.id);
		}

		function postImage(url, attribute, model) {
			var fd = new FormData();
			fd.append(attribute, model);
			return $http.post(url + '/' + attribute + '/', fd, {
				transformRequest: angular.identity,
				headers: {'Content-Type': undefined}
			});
		}

		function deleteImage(url, attribute, value) {
			return $http.delete(url + '/' + attribute + '/' + value, {
				transformRequest: angular.identity,
				headers: {'Content-Type': undefined}
			});

		}
	}
	angular.module('gumga.services.base',[])
	.service('GumgaBase',Base);
})();


(function(){
	'use strict';
	DateService.$inject = [];
	function DateService(){
		return {
			formats: {
				DMY: /^(\d{1,2})\-(\d{1,2})\-(\d{4})$/,
				YMD: /^(\d{4})\-(\d{1,2})\-(\d{1,2})$/
			},
			validateFormat: function(format, date) {
				if (!this.formats.hasOwnProperty(format)) {
					throw 'Formato não suportado';
				}
				var regex = new RegExp(this.formats[format]);
				if (!regex.test(date)) {
					throw 'A data ' + date + ' não confere com o formato ' + format + '.';
				}
				return regex.test(date);
			}
		}
	}
	angular.module('gumga.services.date',[])
	.factory('GumgaDateService',DateService);
})();

(function(){
	'use strict';

	Keyboard.$inject = [];
	/**
	 * @ngdoc service
	 * @name gumga.core:GumgaKeyboard
	 * @description 
	 * 	A directive GumgaKeyboard é um Wrapper de uma biblioteca chamada [Mousetrap](https://craig.is/killing/mice) 
	 * 	que é utilizada para adicionar funcionalidades quando determinadas teclas são pressionadas.
	 *
	 * 	# Métodos
	 *
	 *  `GumgaKeyboard.addBind(key,function,event)`
	 *  
	 * 	O método `addBind` adiciona uma função a combinação de teclas passada como parâmetro. Ele recebe três parâmetros, `key` e `function` e `event`.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">key</label> Quais teclas serão clicadas para que a função seja executada.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label> <label class="label label-info">function</label> Função que será executada quando sequência de teclas especificadas for digitada pelo usuário.
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">event</label> Em qual evento de teclado será disparado, como por exemplo `keypress` ou`keydown`
	 *  ### Retorno
	 *  - <label class="label label-warning">Boolean</label> Retona um boolean. Se o bind foi feito, retorna true, caso ao contrário retorna false.
	 *  ---
 	 *  `GumgaKeyboard.removeBind(key)`
	 *  
	 * 	O método `removeBind` remove as funções que estão atribuídas a `key` que foi passada . Ele recebe um parâmetro `key`.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">key</label> Quais teclas que o desenvolvedor deseja remover o bind.
	 *  
	 *  ---
	 *  
 	 *  `GumgaKeyboard.triggerBoundedEvent(key)`
	 *  
	 * 	O método `triggerBoundedEvent` dispara o evento atribuído a `key` que foi passada.
	 * 	
	 *  ###Parâmetros
	 *  
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">key</label> Quais teclas que o desenvolvedor deseja remover o bind.
	 *  
	 *  ---
	 *
	 * 	`GumgaKeyboard.bindToElement(element,key,function,event)`
 	 *  
	 * 	O método `bindToElement` adiciona uma função a combinação de teclas passada como parâmetro em um elemento específico. Ele recebe quatro parâmetros,`element`, `key` e `function` e `event`.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">Element</label><label class="label label-info">element</label> Elemento no qual a sequência de teclas deve ser executada para disparar o evento.
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">key</label> Quais teclas serão clicadas para que a função seja executada.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label> <label class="label label-info">function</label> Função que será executada quando sequência de teclas especificadas for digitada pelo usuário.
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">event</label> Em qual evento de teclado será disparado, como por exemplo `keypress` ou`keydown`
	 *  ### Retorno
	 *  - <label class="label label-warning">Boolean</label> Retona um boolean. Se o bind foi feito, retorna true, caso ao contrário retorna false.
	 *  ---
	 *
 	 * 	`GumgaKeyboard.unbindFromElement(element,key)`
 	 *  
	 * 	O método `unbindFromElement` remove as teclas do elemento passado como parâmetro. Ele recebe dois parâmetros,`element` e `key`.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">Element</label><label class="label label-info">element</label> Elemento no qual a sequência de teclas vai ser retirada.
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">key</label> Quais teclas serão removidas do element.
	 *  ---
	 *  
	 * 	`GumgaKeyboard.bindToMultipleElement(array,key,function,event)`
 	 *  
	 * 	O método `bindToElement` adiciona uma função a combinação de teclas passada como parâmetro em um elemento específico. Ele recebe quatro parâmetros,`element`, `key` e `function` e `event`.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">Array</label><label class="label label-info">array</label> Lista dos elementos que serão adicionados a sequência de teclas.
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">key</label> Quais teclas serão clicadas para que a função seja executada.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label> <label class="label label-info">function</label> Função que será executada quando sequência de teclas especificadas for digitada pelo usuário.
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">event</label> Em qual evento de teclado será disparado, como por exemplo `keypress` ou`keydown`
	 *  ### Retorno
	 *  - <label class="label label-warning">Boolean</label> Retona um boolean. Se o bind foi feito, retorna true, caso ao contrário retorna false.
	 *  ---
	 *
 	 * 	`GumgaKeyboard.getBinds()`
 	 *  
	 * 	O método `getBinds` retorna todos os binds que foram adicionados.
	 *
	 * 
	 *  ### Retorno
	 *  - <label class="label label-warning">Array</label> Retorna uma lista de todos os binds já feitos.
	 *  
	 *  ---
	 */
	function Keyboard(){
		return {
			addBind: function(key,fn,event){
				if(key && fn){
					Mousetrap.bind(key,fn,event? event : '');
					this.__binds.push(key);
					return true;
				}
				return false;
			},removeBind: function(key){
				if(key){
					Mousetrap.unbind(key);
					this.__binds.splice(this.__binds.indexOf(key),1);
				}
			},
			triggerBoundedEvent: function(key){
				if(key){
					Mousetrap.trigger(key);
				}
			},
			bindToElement: function(element,key,fn,event){
				if(element && key && fn){
					Mousetrap(element).bind(key,fn,event ? event: '');
					this.__binds.push(key);
					return true;
				}
				return false;
			},
			unbindFromElement: function(element,key){
				if(element && key) {
					Mousetrap(element).unbind(key);
				}
			},
			bindToMultipleElements: function(arrayOfElements,key,fn,event){
				for(var i = 0, len = arrayOfElements.length; i < len; i++) if(key && fn){
					Mousetrap(arrayOfElements[i]).bind(key,fn,event? event: '');
					this.__binds.push(key);
				}
			},
			getBinds: function(){
				return this.__binds;
			},
			__binds: []
		}
	}
	angular.module('gumga.services.keyboard',[])
		.factory('GumgaKeyboard',Keyboard);
})();
(function(){

  function ListHelper(){
    return {
      'aux': [],
      'returnColumnConfig': function(item,config){
        var itemConfig = config.filter(function(val){ return val.name.toLowerCase().trim() == item.toLowerCase().trim()})[0] || {};
        return {
          title: itemConfig.title || item.toUpperCase(),
          size: itemConfig.size || '',
          name: itemConfig.name || item,
          content: this.contentWithoutParent(itemConfig.content,item),
          sortField: itemConfig.sortField || null,
          conditional: itemConfig.conditional || angular.noop
        }
      },
      'contentWithoutParent':function(content,item){
        if(content && content.indexOf('type="button"') != -1 && content.indexOf('ng-click="') != -1){
          return content.replace(/ng-click="/gi,'ng-click="$parent.$parent.');;
        }
        if(content){
          return content;
        }
        return '{{$value.'+item+'}}';
      },
      'ensureDefaultValues': function(arr,config){
        var self = this;
        return arr.map(function(item,$index){
          return self.returnColumnConfig(item,config);
        })
      },
      'loadDefaultColumns': function(firstObject){
        return Object.keys(firstObject).map(function(key,$index){
          if(key != '__checked'){
            return {
              title: key.toUpperCase(),
              size: '',
              name: 'key',
              content: '{{$value.' + key + '}}',
              sortField: null,
              conditional: angular.noop
            }
          }
        })
      },
      'sortColumns': function(aux,columns){
        return columns.sort(function(value1,value2){
          (aux.indexOf(value1.name) - aux.indexOf(value2.name))
        })
      },
      'addCheckbox': function(){
        return {
          title: '<label><input type="checkbox" ng-model="vm.checkAll" ng-change="vm.selectAll(vm.checkAll)"/><strong ><small>Selecionar Todos</small></strong></label>',
          size: 'col-md-1',
          name:'__checkbox',
          content: '<input name="__checkbox" type="checkbox" ng-model="$value.__checked"/>',
          sortField: null,
          conditional: angular.noop
        };
      },
      'mountTable':function (configuration) {
        function returnFormattableGlyphicon(string){
          return '<i ng-class="vm.selectedItem == \'' + string +'\' ? (vm.selectedItemDir == \'asc\' ? \'glyphicon glyphicon-menu-up\' : \'glyphicon glyphicon-menu-down\' ): \'\'"></i>';
        }
        function returnFormattableTableHeader(bool,string,sf){
          if(bool){
            return '<button type="button" class=" btn btn-link btn-sm" ng-click="vm.sortProxy(\''+ sf +'\',' + '\''.concat(sf).concat('\'') +')">' + string + returnFormattableGlyphicon(sf) + '</button>';
          }
          return string;
        }
        function mountHeader(prev, next){
          return prev+= '\t\t<td class="'+ next.size +'" >' + returnFormattableTableHeader(!!next.sortField,next.title,next.sortField) + '</td>\n';
        }
        function mountAllTableCell(prev,next){
          return prev += '<td ng-style="{borderLeft: {{::vm.conditionalTableCell($value,\''+ next.name +'\')}} }">' + next.content +'</td>';
        }

        configuration.columns.unshift(this.addCheckbox());
        configuration.columns = this.sortColumns(configuration.auxColumnsToSort, configuration.columns);
        var message = '<select ng-options="item for item in vm.config.itemsPerPage" ng-model="vm.$parent.itemsPerPage"></select>';
        message += '<table class="'+ configuration.class +'">\n';
        message += '<thead>';
        message += '\t<tr>\n';
        message = configuration.columns.reduce(mountHeader.bind(this),message);
        message += '\t</tr>\n';
        message += '</thead>';
        message += '<tbody>';
        message += '<tr ng-style="{borderLeft: {{::vm.conditional($value)}} }"  ng-dblclick="vm.double($value)" ng-class="$value.__checked ? \'active\' : \'\'" ng-repeat="$value in vm.data track by $index" ng-click="vm.selectRow($index,$value,$event)" >';
        message += configuration.columns.reduce(mountAllTableCell,'');
        message += '</tr>';
        message += '</tbody>';
        message += '</table>\n';
        return message;
      }
    }
  }

  angular.module('gumga.services.listhelper',[])
  .factory('GumgaListHelper',ListHelper);

})();

(function(){
	'use strict';

	Notification.$inject = ["$http", "$q"];
	/**
	 * @ngdoc service
	 * @name gumga.core:GumgaNotification
	 * @description
	 */
	function Notification($http,$q){
		var token = window.sessionStorage.getItem('token');
		var url = 'http://192.168.25.201/security-api/notifications/source?gumgaToken=' + token;
		var eventSource;

		this.getEvent = getEvent;
		this.newMessages = newMessages;
		this.newMessagesCount = newMessagesCount;

		function setUrl(url) {
			url = url;
		}
		function setToken(token) {
			token = token;
		}
		function getEvent() {
			if (token) url.concat('?gumgaToken=' + token);
			return new EventSource(url);
		}
		function newMessages() {
			getEvent().addEventListener('message', function(event) {
				var data = JSON.parse(event.data);
				console.log(data.newMessages);
				return data.newMessages;
			}, false);
		}
		function newMessagesCount() {
			getEvent().addEventListener('message', function(event) {
				var data = JSON.parse(event.data);
				console.log(data.newMessagesCount);
				return data.newMessagesCount;
			}, false);
		}
	}
	angular.module('gumga.services.notification',[])
	.service('GumgaNotification',Notification);
})();

(function(){
	'use strict';

	Populate.$inject = [];
	/**
	 * @ngdoc service
	 * @name gumga.core:$populateProvider
	 * @description O service **$populate** é utilizado para adicionar funções básicas de CRUD, que já fazem a conexão com o Service
	 *  (*Melhor utilizado com o service GumgaRest*), possibilitando assim que o $scope fique limpo. É possível também criar uma configuração
	 *  nova para ser utilizada, extender as já criadas e recuperar o objeto de controle da configuração.
	 *
	 * 	As funções criam um objeto com o nome do ID passado para armazenar os dados. Além disso, o identificador é utilizado para nomear as funções. Caso o Identificador
	 * 	passado seja `User` e a função seja `get`, o nome da função será `userGet`, para evitar colisão de nomes.
	 * 	Todas as funções possuem eventos que são disparados antes e depois da execução da função, para ajudar o desenvolvedor a extender as funcionalidades
	 * 	das funções sem precisar sobrescrever-las. Para utilizar estes eventos, basta adicionar um listener no $scope, como por exemplo:
	 *  <pre>
	 *  	$scope.$on('beforeGet',function(){
	 *    alert('Antes do Get!');
	 *  	})
	 *
	 * 		$scope.$on('afterGet',function(values){
	 *		  // values é retorno da função asíncrona.
	 * 		})
	 * 	</pre>
	 *
	 *
	 * # Como utilizar:
	 *
	 * 	Para utilizar o assistente, é necessário injetar como dependência no bloco de configuração do módulo:
	 * 	<pre>
	 *  	angular.module('sample',['gumga.core'])
	 *  	.config(function($populateProvider){
	 *     $stateProvider
   *   	 .state('crud.list', {
   *      url: '/list',
	 *      templateUrl: 'app/modules/crud/views/list.html',
	 *      controller: 'CrudController',
   *      resolve:  {
   *       populateScope: function(){
   *        return $populateProvider.populateScope;
   *       }
   *     }
   *   })
	 *   })
	 *  </pre>
	 *
	 * 	E depois no controller, utilizar ele executando a função populateScope que foi passada através do resolve:
	 * 	<pre>
	 * 		angular.module('sample')
	 * 		.controller('SampleController',
	 * 	   ['$scope','populateScope','UserService',function($scope,populateScope,UserService){
	 * 		   populateScope($scope,UserService,'User','base-list');
	 * 	   }])
	 * 	</pre>
	 *
	 * 	Pode-se optar também por não incluir no módulo de configuração, mas direto no controller:
	 * 	<pre>
	 * 		angular.module('sample')
	 * 		.controller('SampleController',
	 * 	   ['$scope','$populate','UserService',function($scope,$populate,UserService){
	 * 		   $populate.populateScope($scope,UserService,'User','base-list');
	 * 	   }])
	 * 	</pre>
	 *
	 * # Configurações:
	 *
	 * 	- `base-list`: A configuração `base-list` serve para incluir funções gerais que são necessárias em páginas de listagem, que são:
	 * 		- `get`
	 * 		- `resetAndGet`
	 * 		- `getById`
	 * 		- `update`
	 * 		- `saveQuery`
	 * 		- `getQuery`
	 * 		- `delete`
	 *
	 *    - `sort`
	 *    - `search`
	 *    - `advancedSearch`
	 *
	 *
	 * 	- `base-form`: A configuração `base-form` serve para incluir funções gerais que são necessárias em páginas de formulário, que são:
	 * 		- `getNew`
	 * 		- `getById`
	 * 		- `save`
	 * 		- `update`
	 * 		- `saveImage`
	 *
	 *    - `deleteImage`
	 *
	 *
	 * 	- `many-to-many`: A configuração `many-to-many` serve para incluir funções que comumente são utilizadas em relações muitos para muitos, que são:
	 * 		- `search`
	 * 		- `save`
	 * 		- `searchAsync`
	 * 		- `saveAsync`
	 *
	 * 	- `many-to-one`: A configuração `many-to-one` serve para incluir funções que comumente são utilizadas em relações muitos para um, que são:
	 * 		- `search`
	 * 		- `save`
	 * 		- `saveAsync`
	 *
	 *	## Implementações:
	 *		Para ver as implementações das funções acima, clique [aqui]().
	 *
	 *	# Métodos
	 *  `$populate.setConfig(name,value)`
	 *
	 *  O método setConfig aceita dois parâmetros `name` e `value`, o nome da configuração e o objeto que irá fazer a configuração.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">name</label> String que será usada para identificar o objeto que será criado.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label> <label class="label label-info">value</label> Objeto de configuração que será usado.
	 *   Para adicionar a função, coloque o nome da função e o valor dele como `true`
	 *
	 *  ---
	 *
	 *  `$populate.getConfig(name)`
	 *
	 *  O método getConfig aceita um parâmetro `name`, que é o nome da configuração desejada.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">name</label> String que será usada para identificar o objeto que será recuperado.
	 *   Para adicionar a função, coloque o nome da função e o valor dele como `true`
	 *
	 * 	### Retorno
	 *
	 *  - <label class="label label-info">Object</label> Configuração que será recuperada da função.
	 *
	 *
	 *  ---
	 *
	 *  `$populate.setMethod(name,config,function)`
	 *
	 *  O método setMethod aceita três parâmetros: `name`,`config`, `function`. Este método é utilizado para extender as funcionalidades de uma configuração.
	 *
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">name</label> String que será usada para identificar como será o nome da função a ser adicionada.
	 *   Para adicionar a função, coloque o nome da função e o valor dele como `true`
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">config</label> String que será usada para identificar qual objeto de configuração esta função será adicionada.
	 *   Para adicionar a função, coloque o nome da função e o valor dele como `true`
	 *  - <label class="label label-warning" style="margin-right: 1%">Function</label><label class="label label-info">function</label> Função que será adicionada ao $scope. *Ao passar a função, o desenvolvedor
	 *  tem acesso a 4 parâmetros que serão utilizados para definir a função no scope: `Scope`, `Service`,`Id`*.
	 *
	 *  ---
	 *
 	 *
	 *  `$populate.populateScope(scope,service,id,config)`
	 *
	 *  O método populateScope aceita quatro parâmetros: `scope`,`service`, `id` e `config`. Este método é utilizado para popular o $scope do controlador com as funções da configuração.
	 *
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label><label class="label label-info">scope</label> Objeto onde as funções são colocadas, caso sejam num controlador, no *$scope*.
	 *   Para adicionar a função, coloque o nome da função e o valor dele como `true`
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">id</label> Identificador que será utilizado para armazenar os dados no $scope, além de nomear
	 *  as funções.
 	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">config</label> String que será utilizada para definir qual configuração será utilizada.
	 *  ---
	 */

	function Populate(){
		var helpers = {}, configs = {}, methods = {};
		helpers.guaranteeString = function(s){ return (s && angular.isString(s))};
		helpers.guaranteeArray = function(a){ return (a && angular.isArray(a))};
		helpers.guaranteeIsDefined = function(d){ return angular.isDefined(d)};
		helpers.guaranteeBasicList = function(s){ return (s && this.guaranteeString(s) && s == 'basic-list')};
		configs['base-list']= {
			get: true,
			resetAndGet: true,
			getById: true,
			update: true,
			delete: true,
			sort: true,
			search: true,
			advancedSearch: true,
			saveQuery: true,
			getQuery: true,
			resetQuery: true
		};
		configs['base-form'] = {
			getNew: true,
			getById: true,
			save: true,
			update: true,
			saveImage: true,
			deleteImage: true
		};

		configs['many-to-many'] = {
			search: true,
			save: true,
			searchAsync: true,
			saveAsync: true
		}

		configs['many-to-one']={
			save: true,
			searchAsync: true,
			saveAsync: true
		}


		methods.searchAsync = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'AsyncSearch'] = function(field,value){
				return Service.getSearch(field, value)
				.then(function (data) {
					return data.data.values;
				});
			}
		}

		methods.getQuery = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'GetQuery'] = function(page){
				return Service.getQuery(page)
				.then(function(data){
					return data.data.values;
				})
			}
		}

		methods.saveQuery = function(Scope,Service,Id){
				Scope[Id.toLowerCase() + 'SaveQuery'] = function(query,name){
					Scope.$broadcast('beforeSaveQuery',{query: query, name: name});
					Service.saveQuery({query: query, name: name})
					.then(function(data){
						Scope.$broadcast('afterSaveQuery',data);
					})
				}
		}

		methods.saveAsync = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'AsyncSave'] = function(value,param){
				var obj = {};
				obj[param] = value;
				return Service.update(obj);
			}
		}
		methods.get = function(Scope,Service,Id){
			Scope[Id]= {};
			Scope.page = 0;
			Scope[Id.toLowerCase() + 'Get']= function(page) {
				Scope.$broadcast('beforeGet');
				Service.get(page)
				.then(function (values) {
					Scope[Id].content = values;
					Scope.$broadcast('afterGet',values);
				})
			}
			Scope[Id.toLowerCase() + 'Get']();
		};
		methods.resetAndGet = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'ResetAndGet'] = function(){
				Scope.page = 0;
				Scope.$broadcast('beforeResetAndGet');
				Service.resetAndGet()
				.then(function(values){
					Scope[Id].content = values;
					Scope.$broadcast('afterResetAndGet',values);
				})
			}
		};
		methods.getNew = function(Scope,Service,Id){
			Scope[Id] = Scope[Id] || {};
			Scope[Id.toLowerCase() + 'GetNew'] = function(){
				Scope.$broadcast('beforeGetNew');
				Service.getNew()
				.then(function(values){
					Scope.$broadcast('afterGetNew',values);
					Scope[Id]['new' + Id] = values;
				})
			}
		};
		methods.getById = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'GetById'] = function(id){
				Scope.$broadcast('beforeGetById');
				Service.getById(id)
				.then(function(values){
					Scope[Id]['id' + id] = values;
					Scope.$broadcast('afterGetById',values);
				})
			}
		};
		methods.save = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'Save'] = function(value,param){
				Scope.$broadcast('beforeSave',value);
				var obj = {};
				obj[param] = value;
				Service.update(obj)
				.then(function(values){
					Scope.$broadcast('afterSave',values);
				})
			}
		};
		methods.update = function(Scope,Service,Id){
			Scope[Id.toLowerCase()+'Update'] = function(value){
				Scope.$broadcast('beforeUpdate',value);
				Service.update(value)
				.then(function(values){
					Scope.$broadcast('afterUpdate',values);
				})
			}
		};
		methods.delete = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'Delete'] = function(value){
				Scope.$broadcast('beforeDelete');
				Service.deleteCollection(value)
				.then(function(values){
					Scope.$broadcast('afterDelete',values);
					Scope[Id.toLowerCase() + 'Get']();
				})
			}
		};
		methods.sort = function(Scope,Service,Id){
			Scope[Id.toLowerCase()+'Sort'] = function(field,way){
				Scope.$broadcast('beforeSort');
				Service.sort(field,way)
				.then(function(values){
					Scope[Id].content = values;
					Scope.$broadcast('afterSort',values);
				})
			}
		};
		methods.saveImage = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'SaveImage'] = function(attribute,model){
				Scope.$broadcast('beforeSaveImage');
				return Service.saveImage(attribute,model);
			}
		};
		methods.deleteImage = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'DeleteImage'] = function(attribute,model){
				Scope.$broadcast('beforeDeleteImage');
				Service.deleteImage(attribute,model)
				.then(function(values){
					Scope.$broadcast('afterDeleteImage',values);
				})
			}
		};
		methods.search = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'Search'] = function(field,param){
				Scope.$broadcast('beforeSearch');
				Service.getSearch(field,param)
				.then(function(values){
					Scope[Id].content = values;
					Scope.$broadcast('afterSearch',values);
				})
			}
		}
		methods.advancedSearch = function(Scope,Service,Id){
			Scope[Id.toLowerCase() + 'AdvancedSearch'] = function(param){
				Scope.$broadcast('beforeAdvancedSearch',param)
				Service.getAdvancedSearch(param)
				.then(function(values){
					Scope[Id].content = values;
					Scope.$broadcast('afterAdvancedSearch',values)
				})
			}
		}
		methods.resetQuery = function(Scope,Service,id){
			Scope[id.toLowerCase() + 'ResetQuery'] = function(){
				Scope.page = 0;
				Service.resetQuery();
			}
		}
		methods
		return {
			setConfig: function(n,v){
				helpers.guaranteeString(n) && helpers.guaranteeIsDefined(v) ? (configs[n] = v) : angular.noop;
			},
			getConfig: function(string){
				return configs[string];
			},
			setMethod: function(name,config,fn){
				if(!(helpers.guaranteeString(name) && helpers.guaranteeString(config)))
					throw 'One of $populateProvider.setMethod arguments is wrong.';
				configs[config][name] = true;
				methods[name] = fn;
			},
			populateScope: function(scp,svc,id,config){
				if(!helpers.guaranteeIsDefined(scp)) throw 'The $scope passed for populateScope wasn\'t defined';
				if(!helpers.guaranteeIsDefined(id)) throw 'The identifier for populateScope must be passed';
				if(!helpers.guaranteeIsDefined(config)) throw 'The configuration for populateScope must be passed';
				if(!helpers.guaranteeIsDefined(svc)) throw 'The service for populateScope must be passed';
				if(configs[config]){
					scp[id] = {};
					scp[id].content = {};
					var configuration = configs[config];
					for (var key in configuration) if(configuration.hasOwnProperty(key)){
						methods[key](scp,svc,id);
					}
				}
			},
			$get: function(){
				return this;
			}
		}
	}
	angular.module('gumga.services.populate',[])
	.provider('$populate',Populate)
})();

(function(){
	'use strict';

	Base.$inject = ["$http", "$q"];
	/**
	 * @ngdoc service
	 * @name gumga.core:GumgaRest
	 * @description
	 * 	O service GumgaRest é uma evolução do service {@link gumga.core:GumgaBase}, pois sua configuração não necessita
	 * 	de nenhuma outra configuração adicional no service que irá chamá-lo.
	 *
	 * ## Exemplo
	 * <pre>
	 * angular.module('sample',['gumga.core'])
	 * .service('GumgaRest',function(GumgaRest){
	 * 	   //Exemplo de utilização.
	 * 	   var service = new GumgaRest('http://www.gumga.com.br/api');
	 *     // Ou, caso não queira adicionar nenhum método, utilizar:
	 *     // return new GumgaRest('http://www.gumga.com.br/api');
	 *
	 *	   service.get = function(page){
	 *	       alert('Modifiquei um método da service e chamei o padrão!');
	 *		     return GumgaRest.prototype.get.call(this,page);
	 *	   }
	 * 	   return service;
	 * })
	 * </pre>
	 *
	 * # Métodos
	 *
	 *  `GumgaRest.get(params)`
	 *
	 *  O método get aceita um parâmetro `url` e retorna uma promise de uma chamada HTTP do tipo GET.
	 *
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label> <label class="label label-info">params</label> Parâmetros da query que será feita.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retona uma promise da chamada HTTP GET.
	 *  ---
	 *  `GumgaRest.resetAndGet()`
	 *
	 *  O método resetAndGet reseta a query atual e performa uma chamada HTTP do tipo GET.
	 *
	 *  ### Retorno
	 *
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP GET.
	 *
	 * 	---
	 *
 	 *  `GumgaRest.getById(id)`
	 *
	 *  O método getById aceita um parâmetro `id` e retorna uma promise de uma chamada HTTP do tipo GET.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">[String|Number]</label> <label class="label label-info">id</label> Identificador do registro que será buscado.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retona uma promise da chamada HTTP GET.
	 *  ---
	 *  `GumgaRest.getNew()`
	 *
	 *  O método getById  retorna uma promise de uma chamada HTTP do tipo GET.
	 *  ### Retorno
	 *
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP GET.
	 *
	 *  ---
 	 *  `GumgaRest.delete(data)`
	 *
	 *  O método delete recebe como parâmetro um objeto que será deletado. O objeto deve ter um parâmetro ID,
	 *  que será passado para a url da chamada.
	 *
 	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label> <label class="label label-info">data</label> Registro que será deletado.
	 *
	 *  ### Retorno
	 *
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP DELETE.
	 *
	 *  ---
	 *
 	 *  `GumgaRest.sort(field,way)`
	 *
	 * O método sort recebe dois parâmetros para fazer a ordenação: `field` e `way`, que determinarão qual campo será ordenado
	 * e se será 'asc' ou 'desc'.
	 *
 	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label> <label class="label label-info">field</label> Qual campo será feita a ordenação
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label> <label class="label label-info">way</label> Em que sentido a ordenação será feita, se será ascendente `asc` ou descendente `desc`.
	 *  ### Retorno
	 *
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP GET.
	 *
	 *  ---
	 *
	 *  `GumgaRest.deleteCollection(array)`
	 *
	 *  O método deleteAll aceita um parâmetro `url`  e retorna uma promise de uma série de chamadas http do tipo DELETE que serão resolvidas ao mesmo tempo.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">Array</label><label class="label label-info">array</label> Array com todas os registros que serão deletados
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise após todas as chamadas terem sido resolvidas.
	 *  ---
	 *
 	 *  `GumgaRest.saveImage(attribute,data)`
	 *
	 *  O método saveImage aceita dois parâmetros `attribute` e `data` e retorna uma promise de de uma chamada HTTP POST FORM-DATA.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">attribute</label> Atributo no qual a imagem será feito o
	 *  bind após o form ter sido enviado completo.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label><label class="label label-info">data</label> Dados da imagem que foi selecionada..
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP POST. Nesta promise, será retornado o valor de uma String que deverá ser atribuída ao atributo
	 *  onde estava a imagem. Esta string é um identificador para quando o registro for enviado através de um post.
	 *  ---
 	 *  `GumgaRest.deleteImage(attribute,data)`
	 *
	 *  O método deleteImage aceita dois parâmetros `url` e `data` e retorna uma promise de de uma chamada HTTP DELETE FORM-DATA.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">attribute</label> Atributo no qual a imagem será feito o
	 *  bind após o form ter sido enviado completo.
	 *  - <label class="label label-warning" style="margin-right: 1%">Object</label><label class="label label-info">data</label> Dados da imagem que foi selecionada.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retorna uma promise da chamada HTTP DELETE.
	 *  ---
 	 *
 	 *  `GumgaRest.getSearch(field,param)`
	 *
	 *  O método getSearch aceita dois parâmetros `field` e `param` e retorna uma promise de uma chamada HTTP do tipo GET.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">[String]</label> <label class="label label-info">field</label> Qual campo a busca será feita. Caso
	 *  queira fazer a busca em mais de um campo, passar uma string com os nomes separados por vírgula.
 	 *  - <label class="label label-warning" style="margin-right: 1%">[Object]</label> <label class="label label-info">param</label> Objeto que irá conter os parâmetros
 	 *  da busca.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retona uma promise da chamada HTTP GET.
	 *  ---
	 *
 	 *  `GumgaRest.getAdvancedSearch(param)`
	 *
	 *  O método getAdvancedSearch aceita um parâmetro `param` e retorna uma promise de uma chamada HTTP do tipo GET.
	 *  ### Parâmetros
 	 *  - <label class="label label-warning" style="margin-right: 1%">[Object]</label> <label class="label label-info">param</label> Objeto que irá conter os parâmetros
 	 *  da busca.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retona uma promise da chamada HTTP GET.
	 *  ---
   *
 	 *  `GumgaRest.resetDefaultState()`
	 *
	 *  O método resetDefaultState retorna o objeto de query ao seu estado padrão.
	 *
	 *  ---
	 *
	 *  `GumgaRest.saveQuery(query)`
	 *
	 *  O método saveQuery aceita um parâmetro `query` e retorna uma promise de uma chamada HTTP do tipo POST.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">[Object]</label> <label class="label label-info">query</label> Objeto que irá conter três atributos necessários
	 *  para salvar a query. Os atributos são: `page`, `data` e `name`. Onde `page` é o nome da página atual, `data` é a busca e `name` é o nome da query a ser salva.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retona uma promise da chamada HTTP POST.
	 *  ---
	 *
	 *  `GumgaRest.getQuery(page)`
	 *
	 *  O método getQuery aceita um parâmetro `page` e retorna uma promise de uma chamada HTTP do tipo GET. Este Parâmetro `page` é o valor de retorno do objeto `location.hash` disponível
	 *  através do browser. Exemplo: `GumgaRest.getQuery(location.hash);`. É necessário este atributo para pegar apenas as queries relacionadas a página. As informações do usuário já são
	 *  passadas através do token.
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">[String]</label> <label class="label label-info">page</label> String que será utilizada para fazer a pesquisa das
	 *  queries relacionadas com a página.
	 *  ### Retorno
	 *  - <label class="label label-info">HttpPromise</label> Retona uma promise da chamada HTTP GET.
	 *  ---
	 */
	function Base($http,$q){
		function RestPrototype(url){
			this._url = url;
			this._query = {params: {start: 0,pageSize: 10}};
		}
		RestPrototype.prototype.get = _get;
		RestPrototype.prototype.resetAndGet = _resetAndGet;
		RestPrototype.prototype.getNew = _getNew;
		RestPrototype.prototype.getById = _getById;
		RestPrototype.prototype.save = _save;
		RestPrototype.prototype.update= _update;
		RestPrototype.prototype.delete = _delete;
		RestPrototype.prototype.sort = _sort;
		RestPrototype.prototype.deleteCollection = _deleteCollection;
		RestPrototype.prototype.saveImage = _saveImage;
		RestPrototype.prototype.deleteImage = _deleteImage;
		RestPrototype.prototype.getSearch = _getSearch;
		RestPrototype.prototype.getAdvancedSearch = _getAdvancedSearch;
		RestPrototype.prototype.resetDefaultState = _resetQuery;
		RestPrototype.prototype.saveQuery = _saveQuery;
		RestPrototype.prototype.getQuery = _getQuery;
		function _get(page){
			if (page) {
				this._query.params.start = (page - 1) * this._query.params.pageSize;
				if (page < 1) throw 'Invalid page';
			}
			return $http.get(this._url,this._query);
		}
		function _getNew () {return $http.get(this._url + '/new')}
		function _getById(id){return $http.get(this._url + '/' + id);}
		function _save (v){return $http.post(this._url,v);}
		function _update (v){
			if(v.id){
				return $http.put(this._url + '/' + v.id ,v);
			}
			return this.save(v);
		}
		function _delete(v){return $http.delete(this._url + '/' + v.id);}
		function _resetQuery(){this._query = {params: {start: 0,pageSize: 10}};}

		function _resetAndGet(){
			this.resetDefaultState();
			return $http.get(this._url,this._query);
		}
		function _sort(f,w){
			this.resetDefaultState();
			this._query.params.sortField = f;
			this._query.params.sortDir = w;
			return $http.get(this._url,this._query);
		}
		function _deleteCollection(arr){
			var url = this._url;
			return $q.all(arr.map(function(v){
				return $http.delete(url + '/' + v.id);
			}))
		}
		function _saveImage(a,m){
			var fd = new FormData();
			fd.append(a,m);
			return $http.post(this._url + '/' +a + '/',fd,{
				transformRequest: angular.identity,
				headers: {'Content-Type': undefined}
			});
		}
		function _deleteImage(a){
			var fd = new FormData();
			fd.append(a,{});
			return $http.delete(this._url + '/' +a,fd,{
				transformRequest: angular.identity,
				headers: {'Content-Type': undefined}
			});
		}
		function _getSearch(f,p){
			this.resetDefaultState();
			(!p) ?  p = '' : angular.noop;
			this._query.params.q = p;
			this._query.params.searchFields = f;
			return this.get();
		}
		function _getAdvancedSearch(p){
			if(typeof p === 'string'){
				this._query.params = {}
				this._query.params.aq = p;
				return $http.get(this._url,this._query);
			}
			this._query.params = {};
			this._query.params.aq = p.hql;
			this._query.params.aqo = JSON.stringify(p.source);
			return $http.get(this._url,this._query);
		}

		function _saveQuery(q){
			var _aux = {
				page: location.hash.replace('#','').replace(/\//gi,'_'),
				data: JSON.stringify(q.query),
				name: q.name
			};
			return $http.post(this._url + '/saq',_aux);
		}

		function _getQuery(page){
				return $http.get(this._url + '/gumgauserdata/aq;' + page.replace('#','').replace(/\//gi,'_'));
		}
		return RestPrototype;
	}

	angular.module('gumga.services.rest',[])
	.service('GumgaRest',Base);

})();

(function(){
	'use strict';


		Translate.$inject= [];
		function Translate(){
			return {
				$get: ["$http", function($http){
					var self = this;
					$http.get('/i18n/'+self._language + '.json')
						.success(function SuccessGet(values){
							localStorage.setItem('GUMGA'+ self._language,JSON.stringify(values));
							localStorage.setItem('GUMGACurrent',self._language);
						})
					return self;
				}],
				setLanguage: function(language){
					if(!language) throw 'You must pass a language to GumgaTranslate';
					this._language.toLowerCase() !== language.toLowerCase() ? this._language = language : function(){};
				},
				_language: 'pt-br'
			}
		}

		angular.module('gumga.services.translate',['gumga.services.translate.helper'])
		.provider('$gumgaTranslate',Translate)
})();
(function(){
	'use strict';

	TranslateHelper.$inject = [];

	function TranslateHelper() {
		return {
			_translation: {},
			__getFromLocalStorage: function(){
				var language = localStorage.getItem('GUMGACurrent')
				,		self = this;
				function iterate(obj,string){
					for(var key in obj) if(obj.hasOwnProperty(key)){
						(typeof obj[key] == 'object') ? 
							iterate(obj[key], string + '.' + key) : self._translation[(string + '.' + key).substring(1)] = obj[key];
					}
				}
				if(language && localStorage.getItem('GUMGA' + language)){
					iterate(JSON.parse(localStorage.getItem('GUMGA' + language)),'');
					return true;
				}
				
			},
			getTranslate: function(toTranslate){
				var self = this;
				if (Object.getOwnPropertyNames(self._translation).length === 0)
					self.__getFromLocalStorage();
				if(!toTranslate || typeof toTranslate != 'string')  
					throw 'The value passed to GumgaTranslate is Wrong!';
				if(self._translation[toTranslate])
					return self._translation[toTranslate];
				return toTranslate;
			}
		}
	}

	angular.module('gumga.services.translate.helper',[])
	.factory('GumgaTranslateHelper',TranslateHelper)

})();
(function(){
  'use strict';

  Utils.$inject = [];

  function Utils(){
    return {
      areNotEqualInArray: function (array, index) {
        var aux = array.filter(function (element) {
          return element == index;
        });
        return (aux.length < 1);
      },
      camelCase: function (string) {
        return string.slice(0, 1).toUpperCase() + string.slice(1, string.length);
      },
      objInArray: function (array, field) {
        var arrayAux = array.filter(function (obj) {
          return obj.field == field;
        });
        return arrayAux.length > 0;
      },
      checkIndex: function (array, txt) {
        var flag = -1;
        array.forEach(function (obj, index) {
          if (obj.field == txt) {
            flag = index;
          }
        });
        return flag;
      },
      errorMessages: {
        max: "You've typed more than the maximum!",
        min: "You've typed less than the minimum!",
        req: "This field is required"
      }
    }
  }
  angular.module('gumga.services.utils',[])
  .factory('GumgaUtils',Utils);
})();

(function(){
	'use strict';

	WebStorage.$inject = [];
	/**
	 * @ngdoc service
	 * @name gumga.core:GumgaWebStorage
	 * @description 
	 * 
	 * 	O service GumgaWebStorage é utilizado para ajudar o desenvolvedor a trabalhar com o storage do Browser.
	 *
	 * 	#Métodos
	 *
	 *	---
	 * 
	 *  `GumgaWebStorage.setSessionStorageItem(key,value)`
	 *  
	 *  O método setSessionStorageItem aceita dois parâmetros `key` e `value`.
 	 *  
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label> <label class="label label-info">key</label> Qual o identificador do valor que será salvo.
	 *  - <label class="label label-warning" style="margin-right: 1%">[String|Number|Object]</label> <label class="label label-info">value</label> Valor que será salvo no sessionStorage.
	 *  ---
 	 * 
	 *  `GumgaWebStorage.getSessionStorageItem(key)`
	 *  
	 *  O método setSessionStorageItem aceita um parâmetro `key`.
 	 *  
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label> <label class="label label-info">key</label> Qual o identificador do valor que será salvo.
	 *
	 *  ### Retorno
	 *  - <label class="label label-warning" style="margin-right: 1%">[String|Number|Object]</label> <label class="label label-info">key</label> Retorna o valor que estiver na sessionStorage daquela key específica. Caso não encontre,
	 *  o valor retornado é null.
	 *  ---
	 *
 	 *  `GumgaWebStorage.removeSessionStorageItem(key)`
	 *  
	 *  O método removeSessionStorageItem aceita um parâmetro `key`.
 	 *  
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label> <label class="label label-info">key</label> Qual o identificador do valor que será removido da sessionStorage.
	 *
	 *  --- 
	 *
	 *  `GumgaWebStorage.clearSessionStorage()`
	 *  
	 *  O método clearSessionStorage não aceita nenhum parâmetro e limpa a sessionStorage.
 	 *  
	 *  --- 
	 *
 	 *
	 *  `GumgaWebStorage.getNumberOfItemsInSessionStorage()`
	 *  
	 *  O método getNumberOfItemsInSessionStorage não aceita nenhum parâmetro, e retorna o número de itens no localStorage.
 	 *  
	 *  --- 
	 *
 	 * 
	 *  `GumgaWebStorage.setLocalStorageItem(key,value)`
	 *  
	 *  O método setLocalStorageItem aceita dois parâmetros `key` e `value`.
 	 *  
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label> <label class="label label-info">key</label> Qual o identificador do valor que será salvo.
	 *  - <label class="label label-warning" style="margin-right: 1%">[String|Number|Object]</label> <label class="label label-info">value</label> Valor que será salvo no LocalStorage.
	 *  ---
 	 * 
	 *  `GumgaWebStorage.getLocalStorageItem(key)`
	 *  
	 *  O método setLocalStorageItem aceita um parâmetro `key`.
 	 *  
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label> <label class="label label-info">key</label> Qual o identificador do valor que será salvo.
	 *
	 *  ### Retorno
	 *  - <label class="label label-warning" style="margin-right: 1%">[String|Number|Object]</label> <label class="label label-info">key</label> Retorna o valor que estiver na LocalStorage daquela key específica. Caso não encontre,
	 *  o valor retornado é null.
	 *  ---
	 *
 	 *  `GumgaWebStorage.removeLocalStorageItem(key)`
	 *  
	 *  O método removeLocalStorageItem aceita um parâmetro `key`.
 	 *  
	 *  ### Parâmetros
	 *  - <label class="label label-warning" style="margin-right: 1%">String</label> <label class="label label-info">key</label> Qual o identificador do valor que será removido da LocalStorage.
	 *
	 *  --- 
	 *
	 *  `GumgaWebStorage.clearLocalStorage()`
	 *  
	 *  O método clearLocalStorage não aceita nenhum parâmetro e limpa o localStorage.
 	 *  
	 *  --- 
 	 *
	 *  `GumgaWebStorage.getNumberOfItemsInLocalStorage()`
	 *  
	 *  O método getNumberOfItemsInLocalStorage não aceita nenhum parâmetro, e retorna o número de itens no localStorage.
 	 *  
	 *  --- 
	 */
	function WebStorage(){
		return {
			setSessionStorageItem: function(key,value){
				var _value = value;
				if(typeof value == 'object'){
					_value = angular.toJson(value);
				}
				window.sessionStorage.setItem(key,_value);
			},
			getSessionStorageItem: function(key){
				var g = window.sessionStorage.getItem(key);
				if(!g){
					return null;
				}
				try {
					angular.fromJson(g);
				}catch(e){
					return g;
				}
				return angular.fromJson(g);
			},
			removeSessionStorageItem: function(key){
				window.sessionStorage.removeItem(key);
			},
			clearSessionStorage: function(){
				window.sessionStorage.clear();
			},
			getNumberOfItemsInSessionStorage: function(){
				return window.sessionStorage.length;
			},
			setLocalStorageItem: function(key,value){
				window.localStorage.setItem(key,angular.toJson(value));
			},
			getLocalStorageItem: function(key){
				var g = window.localStorage.getItem(key);
				try {
					angular.fromJson(g);
				}catch(e){
					return g;
				}
				return angular.fromJson(g);
			},
			removeLocalStorageItem: function(key){
				window.localStorage.removeItem(key);
			},
			clearLocalStorage: function(){
				window.localStorage.clear();
			},
			getNumberOfItemsInLocalStorage: function(){
				return window.localStorage.length;
			}
		}
	}

	angular.module('gumga.services.webstorage',[])
	.factory('GumgaWebStorage',WebStorage)
})();
(function(){
	'use strict';
   /**
    * @ngdoc directive
    * @name gumga.core:gumgaError
    * @element input
    * @restrict A
    * @description O componente gumgaError serve para mostrar mensagens de validações abaixo do input responsável pelo erro.
    *
    * @example
    *  Um exemplo da directive gumgaError funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
    *  <pre>
    *    <form name="myForm">
    *      <input type="number" name="minNumber" ng-model="minNumber" gumga-error gumga-min-number="20">
    *    </form>
    *  </pre>
   */
  Error.$inject = ["$compile"];
  function Error($compile) {
    return {
      restrict: 'A',
			scope: {},
      require: '^form',
      link: function (scope, elm, attrs, ctrl) {
				scope.errors = [];

				scope.errorsContains = function(errors, error) {
					for (var k in errors) {
						if (angular.equals(errors[k], error)) {
							return k;
						}
					}
					return false;
				}

				scope.addError = function(error) {
					if (!scope.errorsContains(scope.errors, error)) {
						scope.errors.push(error);
					}
				}

				scope.removeError = function(error) {
					var errorCopy = angular.copy(error);
					errorCopy.valid = !errorCopy.valid;
					var exist = scope.errorsContains(scope.errors, errorCopy);
					if (exist) {
						scope.errors.splice(exist, 1);
					}
				}
				scope.$on('$errorMessage', function(event, data) {
          if (elm[0].name == data.name) {
            if (data.valid == false) {
  						scope.addError(data);
  					} else {
  						scope.removeError(data);
  					}
          }
				});

        var template = '<ol class="list-errors text-danger"><li ng-repeat="error in errors" >{{ error.fieldMessage }}</li></ol>';
        elm.after($compile(template)(scope));
      }
    }
  }
	angular.module('gumga.directives.form.error',[])
	.directive('gumgaError',Error);
})();

(function(){
	'use strict';
	/**
	 * @ngdoc directive
	 * @name gumga.core:gumgaErrors
	 * @restrict E
	 * @description O componente gumgaErrors serve para mostrar todas mensagens de validações do formulário de forma agrupada.
	 *
	 * @param {String} placement Onde irá aparecer, o padrão é top, mas também aceita right, bottom e left.
	 * @param {String} icon Ícone do botão, por padrão é glyphicon glyphicon-info-sign
	 * @param {String} label Texto do botão
	 * @param {String} title Título do popover de erros
	 *
	 * @example
	 *  Um exemplo da directive gumgaErrors funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
	 *  <pre>
	 *    <form name="myForm">
	 *      <input type="number" name="minNumber" ng-model="minNumber" gumga-min-number="20">
	 *      <gumga-errors placement="right" icon="glyphicon glyphicon-info-sign" label="Campos inválidos" title="Campos inválidos"></gumga-errors>
	 *    </form>
	 *  </pre>
	*/
	Errors.$inject = ["$compile"];
  function Errors($compile) {
    return {
      restrict: 'E',
			scope: {
				errors: '='
			},
      require: '^form',
      link: function (scope, elm, attrs, ctrl) {
				scope.errors = [];

				scope.errorsContains = function(errors, error) {
					for (var k in errors) {
						if (angular.equals(errors[k], error)) {
							return k;
						}
					}
					return false;
				}

				scope.addError = function(error) {
					if (!scope.errorsContains(scope.errors, error)) {
						scope.errors.push(error);
					}
				}

				scope.removeError = function(error) {
					// error.valid = !error.valid;
					var errorCopy = angular.copy(error);
					errorCopy.valid = !errorCopy.valid;
					var exist = scope.errorsContains(scope.errors, errorCopy);
					if (exist) {
						scope.errors.splice(exist, 1);
					}
				}
				scope.$on('$errorMessage', function(event, data) {
					if (data.valid == false) {
						scope.addError(data);
					} else {
						scope.removeError(data);
					}
				});

				var title = attrs.title || 'Erros';
				var placement = attrs.placement || 'top';
				var icon = attrs.icon || 'glyphicon glyphicon-info-sign';

				var template = [
					'<button popover-placement="'+placement+'" popover-template="\'template.html\'" popover-title="'+title+'" type="button" class="btn btn-sm btn-danger">'
				,	'<i class="'+icon+'"></i>'
				, attrs.label
				,	'</button>'
				,	'<script id="template.html" type="text/ng-template">'
				,	'<ol class="list-errors text-danger"><li ng-repeat="error in errors" >{{ error.message }}</li></ol>'
				,	'</script>'
				].join("\n");
				elm.append($compile(template)(scope));

      }
    }
  }
	angular.module('gumga.directives.form.errors',['ui.bootstrap'])
	.directive('gumgaErrors',Errors);
})();

(function(){
	'use strict';
	Form.$inject = ["$timeout", "$rootScope"];
	/**
	* @ngdoc directive
	* @name gumga.core:gumgaForm
	* @restrict A
	* @element form
	* @description A directive gumgaForm é utilizada em conjunto com as directives de validação de input. Ela contém funções que serão
	* usadas para manipular o formulário. Ela expõe no $scope um objeto GumgaForm para agrupar as funções em um lugar só.
	*
	*	# Como utilizar
	*
	* O componente GumgaForm deve ser incluído no elemento `form`, que necessita ter um atributo name. É necessário também que os inputs que serão utilizados tenham um atributo name,
	* pois o controle deles é feito a partir deste atributo.
	*
	*	<pre>
	*  <form name="UserForm" gumga-form>
	*	   ...
	*  </form>
	* </pre>
	*
	*	# Métodos
	*
	*`$scope.GumgaForm.getMessages(name,error)`
  *
  *  O método `getMessages` aceita dois parâmetros `name` e `error`, onde name é o nome do input que desejada
  *  recuperar a mensagem e o erro. Caso o parâmetro error não seja passado, é retornado o objeto com todas as mensagens do campo.
  *  ### Parâmetros
  *  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">name</label> String que terá o nome do in put para retornar os errors.
  *   Para adicionar a função, coloque o nome da função e o valor dele como `true`
	*  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">error</label> String que será terá o nome do erro que será retornado. Caso
	*  não seja passado este parâmetro, será retornado um objeto com todos os erros.
  * 	### Retorno
  *
  *  - <label class="label label-info">[Object|String]</label> String que conterá a mensagem de erro ou o objeto com todas as mensagens de erro.
	*
	* ----
	*
	*`$scope.GumgaForm.changeMessage(name,error,message)`
	*
	*  O método `changeMessage` aceita três parâmetros, `name`,`error` e `message`, onde `name` é o nome do input que desejada
	*  recuperar a mensagem, `error` é qual erro que a mensagem será alterada e `message` qual será a nova mensagem .
	*  ### Parâmetros
	*  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">name</label> String que terá o nome do input para retornar os errors.
	*   Para adicionar a função, coloque o nome da função e o valor dele como `true`
	*  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">error</label> String que será terá o nome do erro que será retornado. Caso
	*  não seja passado este parâmetro, será retornado um objeto com todos os erros.
	*  - <label class="label label-warning" style="margin-right: 1%">String</label><label class="label label-info">message</label> String que será usada como mensagem de erro para a directive.
	* 	### Retorno
	*
	*  - <label class="label label-info">Boolean</label> True caso a mensagem tenha sido alterada, False caso não.
	*
	* ----
	*
	*`$scope.GumgaForm.setFormValid()`
	*
	*  O método `setFormValid` é utilizado para limpar todos os erros que estiverem ativos no formulário. Ele percorre o objeto de erro que o Angular.js cria automaticamente e valida todos os campos
	*  que estiverem com erro.
	*
	* ----
  *
	*`$scope.GumgaForm.setFormPristine()`
	*
	*  O método `setFormPristine` é utilizado para colocar todos os campos em um estado de $pristine, ou seja, quando ainda não foram atualizados pelo usuário.
	*
	* ----
	*
	*`$scope.GumgaForm.clearForm()`
	*
	*  O método `clearForm` é utilizado para limpar todos os campos do formulário e, além disso, colocar eles em um estado de $pristine.
	*
	* ----
	*
	*`$scope.GumgaForm.getFormErrors()`
	*
	*  O método `getFormErrors` é utilizado para quando deseja-se obter todos os erros que estão presentes no formulário.
	*
	* ### Retorno
	*
	*  - <label class="label label-info">[Array]</label> Lista que irá conter todos os erros que estão no formulário.
	*
	* ----
	*/
	function Form($timeout,$rootScope) {
		return {
			restrict: 'A',
			require: '^form',
			scope: false,
			link: function(scope, elm, attrs, ctrl) {
				if(!attrs.name) throw 'É necessário passar um valor para o atributo "name" do element <form>';
				scope.GumgaForm = {};
				var _form = scope[attrs.name];
				var _formControllers = [];
				(function() {
					angular.forEach(elm.find('input'),function(input){
						_formControllers.push({
							name: angular.element(input).controller('ngModel').$name,
							controller: angular.element(input).controller('ngModel'),
							errorMessages: {
								maxdate: 'A data especificada no campo {0} não deve ultrapassar o limite de: {1}.',
								maxlength: 'O texto especificado no campo {0} não deve ultrapassar o limite de: {1}.',
								maxnumber: 'O número especificado no campo {0} não deve ultrapassar o limite de: {1}.',
								mindate: 'A data especificada no campo {0} não deve ser menor que o limite mínimo de: {1}.',
								minlength: 'O texto especificado no campo {0} não deve ser menor que o limite mínimo de: {1}.',
								minnumber: 'O número especificado no campo {0} não deve ser menor que o limite mínimo de: {1}.',
								pattern: 'O texto especificado no campo {0} deve estar dentro do padrão: {1}.',
								rangedate:'A data especificada no campo {0} deve estar dentro do intervalo: {1}.',
								rangenumber: 'O número especificado no campo {0} deve estar dentro do intervalo: {1}.',
								required: 'O campo {0} é obrigatório.'
							}
						})
					})
				})();

				function returnObject(name){
					return _formControllers.filter(function($v){
						return $v.name.trim().toLowerCase() === name.trim().toLowerCase();
					})[0];
				}

				scope.$on('$error',function(ev,data){
					$timeout(function(){
						if (data.error.substring(0,5) == 'range') {
							var auxValue = scope.$eval(data.value);
							data.value = 'mínimo de ' + auxValue.min + ' e máximo de ' + auxValue.max;
						}
						var _aux = returnObject(data.name)
						,		message = _aux.errorMessages[data.error].replace('{1}',data.value)
						,		auxMessage = message;
						if (data.error != 'required') {
							auxMessage = auxMessage.replace('no campo {0}','');
						} else {
							auxMessage = auxMessage.replace('{0}','');
						}
						message = message.replace('{0}',data.label);
						$rootScope.$broadcast('$errorMessage',{
							name: data.name,
							message: message,
							fieldMessage: auxMessage,
							valid: data.valid,
						})
					})
				})
				scope.GumgaForm.getMessages = function(name,error){
					if(!error){
						return returnObject(name).errorMessages;
					}
					if(returnObject(name).errorMessages){
						return returnObject(name).errorMessages[error] || null;
					}
				}
				scope.GumgaForm.changeMessage = function(input,which,message){
					if(!input || !which || !message) throw 'Valores passados errados para a função GumgaForm.changeMessage(input,message)'
					var aux = _formControllers.filter(function(value){
						return input == value.name;
					})[0];
					if(aux.errorMessages && aux.errorMessages[which]){
						aux.errorMessages[which] = message;
						return true;
					}
					return false;
				}
				scope.GumgaForm.setFormValid = function () {
					for(var key in _form.$error) if(_form.$error.hasOwnProperty(key)){
						_form.$error[key].forEach(function (value) {
							value.$setValidity(key,true);
						})
					}
					scope.$apply();
				}
				scope.GumgaForm.clearForm = function(){
					_formControllers.forEach(function(controller){
						controller.controller.$setViewValue('');
						controller.controller.$setPristine();
					})
					scope.$apply();
				}

				scope.GumgaForm.setFormPristine = function () {
					_formControllers.forEach(function(controller){
						controller.controller.$setPristine();
					})
					scope.$apply();
				}

				scope.GumgaForm.getFormErrors = function(){
					var _arr = []
					,		name
					,		aux = [];
					for(var key in _form.$error) if(_form.$error.hasOwnProperty(key)){
						_form.$error[key].forEach(function (value) {
							aux.push(value.$name);
						})
						_arr.push({type: key,fields: aux});
						aux = [];
					}
					return _arr;
				}

			}
		}
	}
	angular.module('gumga.directives.form.form',[])
	.directive('gumgaForm',Form);
})();

(function(){
	'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaMaxDate
   * @element input
   * @restrict A
   * @scope false
   * @description O componente GumgaMaxDate serve para validar datas máximas em entradas de formulários.
   *
   * ## Nota
   * Esta diretiva suporta apenas **inputs** do tipo **date**. O valor do atributo/diretiva é **obrigatório** e deve ser uma **data**.
   *
	 * @param {String} label Usado na integração com {@link gumga.core:gumgaErrors} para indicar em qual campo se encontra o erro.
	 * Se o atributo for omitido, a diretiva usará o atributo name do input.
	 *
   * @example
   *  Um exemplo da directive gumgaMaxDate funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
   *  <pre>
   *    <form name="myForm">
   *      <input type="date" name="maxDate" ng-model="maxDate" gumga-max-date="2015-07-20">
   *      <p ng-show="myForm.maxDate.$error.maxdate" class="text-danger">Data superior a esperada</p>
   *    </form>
   *  </pre>
   */
   MaxDate.$inject = ["$filter"];
   function MaxDate($filter) {
     return {
      restrict: 'A',
      require: 'ngModel',
      link: function (scope, elm, attrs, ctrl) {
	      if (attrs.type != 'date') {
	        throw 'Esta diretiva suporta apenas inputs do tipo date';
	      }
	      if (!attrs.gumgaMaxDate) {
	        throw "O valor da diretiva gumga-max-date não foi informado.";
	      }
        var validateMaxDate = function (inputValue) {
					var error = 'maxdate';
        	var format = 'yyyy-MM-dd';
        	var input = $filter('date')(inputValue, format);
        	var max = $filter('date')(attrs.gumgaMaxDate, format);
        	var isValid = input <= max;
        	ctrl.$setValidity(error, isValid);
					scope.$broadcast('$error', {
						name: attrs.name,
						label: attrs.label || attrs.name,
						valid: isValid,
						error: error,
						value: attrs.gumgaMaxDate
					});
        	return inputValue;
        };
        ctrl.$parsers.unshift(validateMaxDate);
        ctrl.$formatters.push(validateMaxDate);
        attrs.$observe('gumgaMaxDate', function () {
        	validateMaxDate(ctrl.$viewValue);
        });
      }
    }
  }
  angular.module('gumga.directives.form.max.date',[])
  .directive('gumgaMaxDate',MaxDate);
})();

(function(){
	'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaMaxLength
   * @element input
   * @restrict A
   * @scope false
   * @description O componente GumgaMaxLength serve para validar quantidades máximas de caracteres em entradas de formulários.
   *
   * ## Nota
   * O valor do atributo/diretiva é **obrigatório** e deve ser um **número**.
   *
	 * @param {String} label Usado na integração com {@link gumga.core:gumgaErrors} para indicar em qual campo se encontra o erro.
	 * Se o atributo for omitido, a diretiva usará o atributo name do input.
	 *
   * @example
   *  Um exemplo da directive GumgaMaxLength funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
   *  <pre>
   *    <form name="myForm">
   *      <input type="date" name="maxLength" ng-model="maxLength" gumga-max-length="20" id="maxLength">
   *      <p ng-show="myForm.maxLength.$error.maxlength" class="text-danger">Tamanho superior ao esperado</p>
   *    </form>
   *  </pre>
   */
   MaxLength.$inject = [];
   function MaxLength() {
    return {
      restrict: 'A',
      require: 'ngModel',
      link: function (scope, elm, attrs, ctrl) {
        if (!attrs.gumgaMaxLength) {
          throw "O valor da diretiva gumga-max-length não foi informado.";
        }
        var validateMaxLength = function (inputValue) {
					var error = 'maxlength';
          var input = (inputValue == undefined) ? -1 : inputValue.length;
          var max = attrs.gumgaMaxLength;
          var isValid = input <= max && input != -1;
          ctrl.$setValidity(error, isValid);
					scope.$broadcast('$error', {
						name: attrs.name,
						label: attrs.label || attrs.name,
						valid: isValid,
						error: error,
						value: attrs.gumgaMaxLength
					});
          return inputValue;
        };
        ctrl.$parsers.unshift(validateMaxLength);
        ctrl.$formatters.push(validateMaxLength);
        attrs.$observe('gumgaMaxLength', function () {
          validateMaxLength(ctrl.$viewValue);
        });
      }
    }
  }
  angular.module('gumga.directives.form.max.length',[])
  .directive('gumgaMaxLength',MaxLength);
})();

(function(){
	'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaMaxNumber
   * @element input
   * @restrict A
   * @scope false
   * @description O componente GumgaMaxNumber serve para validar números máximos em entradas de formulários.
   *
   * ## Nota
   * Esta diretiva suporta apenas **inputs** do tipo **number**. O valor do atributo/diretiva é **obrigatório** e deve ser um **número**.
   *
	 * @param {String} label Usado na integração com {@link gumga.core:gumgaErrors} para indicar em qual campo se encontra o erro.
	 * Se o atributo for omitido, a diretiva usará o atributo name do input.
	 *
   * @example
   *  Um exemplo da directive GumgaMaxNumber funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
   *  <pre>
   *    <form name="myForm">
   *      <input type="number" name="maxNumber" ng-model="maxNumber" gumga-max-number="20">
   *      <p ng-show="myForm.maxNumber.$error.maxnumber" class="text-danger">Número superior ao esperado</p>
   *    </form>
   *  </pre>
   */
   MaxNumber.$inject = [];
   function MaxNumber() {
     return {
      restrict: 'A',
      require: 'ngModel',
      link: function (scope, elm, attrs, ctrl) {
       if (attrs.type != 'number') {
        throw 'Esta diretiva suporta apenas inputs do tipo number';
      }
      if (!attrs.gumgaMaxNumber) {
        throw "O valor da diretiva gumga-max-number não foi informado.";
      }
      var validateMaxNumber = function (inputValue) {
				var error = 'maxnumber';
        var input = parseInt(inputValue);
        var max = parseInt(attrs.gumgaMaxNumber);
        var isValid = input <= max;
        ctrl.$setValidity(error, isValid);
				scope.$broadcast('$error', {
					name: attrs.name,
					label: attrs.label || attrs.name,
					valid: isValid,
					error: error,
					value: attrs.gumgaMaxNumber
				});
        return inputValue;
      };
      ctrl.$parsers.unshift(validateMaxNumber);
      ctrl.$formatters.push(validateMaxNumber);
      attrs.$observe('gumgaMaxNumber', function () {
        validateMaxNumber(ctrl.$viewValue);
      });

      scope.$on('clearFields',function(event, data) {
       ctrl.$modelValue = null;
       console.log('directive date clear');
					// console.log(elm);
					// console.log();
				});
    }
  }
}
angular.module('gumga.directives.form.max.number',[])
.directive('gumgaMaxNumber',MaxNumber);
})();

(function(){
	'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaMinDate
   * @element input
   * @restrict A
   * @description O componente GumgaMinDate serve para validar datas mínimas em entradas de formulários.
   *
   * ## Nota
   * Esta diretiva suporta apenas **inputs** do tipo **date**. O valor do atributo/diretiva é **obrigatório** e deve ser uma **data**.
   *
	 * @param {String} label Usado na integração com {@link gumga.core:gumgaErrors} para indicar em qual campo se encontra o erro.
	 * Se o atributo for omitido, a diretiva usará o atributo name do input.
	 *
   * @example
   *  Um exemplo da directive GumgaMinDate funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
   *  <pre>
   *    <form name="myForm">
   *      <input type="date" name="minDate" ng-model="minDate" gumga-min-date="2015-07-20">
   *      <p ng-show="myForm.minDate.$error.mindate" class="text-danger">Data inferior a esperada</p>
   *    </form>
   *  </pre>
  */
	 MinDate.$inject = ["$filter"];
	 function MinDate($filter) {
	 	return {
	 		restrict: 'A',
	 		require: 'ngModel',
	 		link: function (scope, elm, attrs, ctrl) {
	 			if (attrs.type != 'date') {
	 				throw 'Esta diretiva suporta apenas inputs do tipo date';
	 			}
	 			if (!attrs.gumgaMinDate) {
	 				throw "O valor da diretiva gumga-min-date não foi informado.";
	 			}
        // if (!GumgaDateService.validateFormat('YMD', attrs.gumgaMinDate)) {
        //   throw 'O valor da diretiva não corresponde ao formato yyyy-mm-dd';
        // }
        var validateMinDate = function (inputValue) {
					var error = 'mindate';
					var format = 'yyyy-MM-dd';
					var input = $filter('date')(inputValue, format);
					var min = $filter('date')(attrs.gumgaMinDate, format);
					var isValid = input >= min;
					ctrl.$setValidity(error, isValid);
					scope.$broadcast('$error', {
						name: attrs.name,
						label: attrs.label || attrs.name,
						valid: isValid,
						error: error,
						value: attrs.gumgaMinDate
					});
					return inputValue;
				};
				ctrl.$parsers.unshift(validateMinDate);
				ctrl.$formatters.push(validateMinDate);
				attrs.$observe('gumgaMinDate', function () {
					validateMinDate(ctrl.$viewValue);
				});
			}
		}
	}
	angular.module('gumga.directives.form.min.date',[])
	.directive('gumgaMinDate',MinDate);
})();

(function(){
	'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaMinLength
   * @element input
   * @restrict A
   * @description O componente GumgaMinLength serve para validar quantidades mínimas de caracteres em entradas de formulários.
   *
   * ## Nota
   * O valor do atributo/diretiva é **obrigatório** e deve ser um **número**.
   *
	 * @param {String} label Usado na integração com {@link gumga.core:gumgaErrors} para indicar em qual campo se encontra o erro.
	 * Se o atributo for omitido, a diretiva usará o atributo name do input.
	 *
   * @example
   *  Um exemplo da directive GumgaMinLength funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
   *  <pre>
   *    <form name="myForm">
   *      <input type="date" name="minLength" ng-model="minLength" gumga-min-length="20" id="minLength">
   *      <p ng-show="myForm.minLength.$error.minlength" class="text-danger">Tamanho inferior ao esperado</p>
   *    </form>
   *  </pre>
  */
	MinLength.$inject = [];
	function MinLength() {
    return {
      restrict: 'A',
      require: 'ngModel',
      link: function (scope, elm, attrs, ctrl) {
        if (!attrs.gumgaMinLength) {
          throw "O valor da diretiva gumga-min-length não foi informado.";
        }
        var validateMinLength = function (inputValue) {
					var error = 'minlength';
          var input = (inputValue == undefined) ? -1 : inputValue.length;
          var min = attrs.gumgaMinLength;
          var isValid = input >= min;
          ctrl.$setValidity(error, isValid);
					scope.$broadcast('$error', {
						name: attrs.name,
						label: attrs.label || attrs.name,
						valid: isValid,
						error: error,
						value: attrs.gumgaMinLength
					});
          return inputValue;
        };
	 			ctrl.$parsers.unshift(validateMinLength);
	 			ctrl.$formatters.push(validateMinLength);
	 			attrs.$observe('gumgaMinLength', function () {
	 				validateMinLength(ctrl.$viewValue);
	 			});
	 		}
	 	}
	 }
	 angular.module('gumga.directives.form.min.length',[])
	 .directive('gumgaMinLength',MinLength);
	})();

(function(){
	'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaMinNumber
   * @element input
   * @restrict A
   * @description O componente GumgaMinNumber serve para validar números mínimos para entradas em formulários.
   *
   * ## Nota
   * Esta diretiva suporta apenas **inputs** do tipo **number**. O valor do atributo/diretiva é **obrigatório** e deve ser um **número**.
   *
	 * @param {String} label Usado na integração com {@link gumga.core:gumgaErrors} para indicar em qual campo se encontra o erro.
	 * Se o atributo for omitido, a diretiva usará o atributo name do input.
	 *
   * @example
   *  Um exemplo da directive GumgaMinNumber funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
   *  <pre>
   *    <form name="myForm">
   *      <input type="number" name="minNumber" ng-model="minNumber" gumga-min-number="20">
   *      <p ng-show="myForm.minNumber.$error.minnumber" class="text-danger">Número inferior ao esperado</p>
   *    </form>
   *  </pre>
  */
	 MinNumber.$inject = [];
	 function MinNumber() {
	 	return {
	 		restrict: 'A',
	 		require: 'ngModel',
	 		link: function (scope, elm, attrs, ctrl) {
	 			if (attrs.type != 'number') {
	 				throw 'Esta diretiva suporta apenas inputs do tipo number';
	 			}
	 			if (!attrs.gumgaMinNumber) {
	 				throw "O valor da diretiva gumga-min-number não foi informado.";
	 			}
	 			var validateMinNumber = function (inputValue) {
					var error = 'minnumber';
	 				var input = parseInt(inputValue);
	 				var min = parseInt(attrs.gumgaMinNumber);
	 				var isValid = input >= min;
	 				ctrl.$setValidity(error, isValid);
					scope.$broadcast('$error', {
						name: attrs.name,
						label: attrs.label || attrs.name,
						valid: isValid,
						error: error,
						value: attrs.gumgaMinNumber
					});
	 				return inputValue;
	 			};
	 			ctrl.$parsers.unshift(validateMinNumber);
	 			ctrl.$formatters.push(validateMinNumber);
	 			attrs.$observe('gumgaMinNumber', function () {
	 				validateMinNumber(ctrl.$viewValue);
	 			});
	 		}
	 	}
	 }
	 angular.module('gumga.directives.form.min.number',[])
	 .directive('gumgaMinNumber',MinNumber);
	})();

(function(){
	'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaPattern
   * @element input
   * @restrict A
   * @description O componente GumgaPattern serve para validar expressões regulares de formulários.
   *
   * ## Nota
   * O valor do atributo/diretiva é **obrigatório** e deve ser uma **expressão regular**.
   *
	 * @param {String} label Usado na integração com {@link gumga.core:gumgaErrors} para indicar em qual campo se encontra o erro.
	 * Se o atributo for omitido, a diretiva usará o atributo name do input.
	 *
   * @example
   *  Um exemplo da directive GumgaPattern funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
   *  <pre>
   *    <form name="myForm">
   *      <input type="text" name="cep" ng-model="cep" gumga-pattern="(\d{5})\-(\d{3})" id="cep" placeholder="99999-999">
   *      <p ng-show="myForm.cep.$error.pattern" class="text-danger">Expressão não corresponde com o formato esperado</p>
   *    </form>
   *  </pre>
  */
	Pattern.$inject = [];
  function Pattern() {
    return {
			restrict: 'A',
	 		require: 'ngModel',
      link: function (scope, elm, attrs, ctrl) {
				if (!attrs.gumgaPattern) {
					throw "O valor da diretiva gumga-pattern não foi informado.";
				}
				var validatePattern = function (inputValue) {
					var error = 'pattern';
					var regex = new RegExp('^' + attrs.gumgaPattern + '$');
					var isValid = regex.test(inputValue);
					ctrl.$setValidity(error, isValid);
					scope.$broadcast('$error', {
						name: attrs.name,
						label: attrs.label || attrs.name,
						valid: isValid,
						error: error,
						value: attrs.patternAlias || attrs.gumgaPattern
					});
					return inputValue;
				};
				ctrl.$parsers.unshift(validatePattern);
				ctrl.$formatters.push(validatePattern);
				attrs.$observe('gumgaPattern', function () {
					validatePattern(ctrl.$viewValue);
				});
      }
    }
  }
  angular.module('gumga.directives.form.pattern',[])
  .directive('gumgaPattern',Pattern);
})();

(function(){
	'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaRangeDate
   * @restrict A
   * @element input
   * @description
	 * O componente GumgaRangeDate serve para validar datas mínimas e máximas para entradas em formulários com campos do tipo date.
   *
   * ## Nota
   * O valor do atributo/diretiva é **obrigatório** e deve ser um **objeto** contendo duas propriedades, **min** e **max**
   * com os valores de suas respectivas datas para execução da validação range.
   *
   * ## Exemplo
   * Um exemplo da directive GumgaRangeDate funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
   *
	 * @param {String} label Usado na integração com {@link gumga.core:gumgaErrors} para indicar em qual campo se encontra o erro.
	 * Se o atributo for omitido, a diretiva usará o atributo name do input.
	 *
   * @example
   *  <pre>
   *    <form name="myForm">
   *      <input type="date" name="rangeDate" ng-model="rangeDate" gumga-range-date="{min: '1986-12-29', max: '2015-07-20'}" id="rangedate">
   *      <p ng-show="myForm.cep.$error.rangedate" class="text-danger">A data informada não está entre os valores esperados</p>
   *    </form>
   *  </pre>
	 */
	 RangeDate.$inject = ["$filter"];
	 function RangeDate($filter) {
	 	return {
	 		restrict: 'A',
	 		require: 'ngModel',
	 		link: function (scope, elm, attrs, ctrl) {
	 			if (attrs.type != 'date') {
	 				throw 'Esta diretiva suporta apenas inputs do tipo date';
	 			}
	 			if (!attrs.gumgaRangeDate) {
	 				throw "O valor da diretiva gumga-range-date não foi informado.";
	 			}
        var validateRangeDate = function (inputValue) {
					var error = 'rangedate';
          var format = 'yyyy-MM-dd';
          var range = scope.$eval(attrs.gumgaRangeDate);
        	var input = $filter('date')(inputValue, format);
          var min = $filter('date')(range.min, format);
        	var max = $filter('date')(range.max, format);
        	var isValid = input >= min && input <= max;
        	ctrl.$setValidity(error, isValid);
					scope.$broadcast('$error', {
						name: attrs.name,
						label: attrs.label || attrs.name,
						valid: isValid,
						error: error,
						value: attrs.gumgaRangeDate
					});
        	return inputValue;
        };
        ctrl.$parsers.unshift(validateRangeDate);
        ctrl.$formatters.push(validateRangeDate);
        attrs.$observe('gumgaRangeDate', function () {
        	validateRangeDate(ctrl.$viewValue);
        });
      }
    }
  }
  angular.module('gumga.directives.form.range.date',[])
  .directive('gumgaRangeDate',RangeDate);
})();

(function(){
	'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaRangeNumber
   * @restrict A
   * @element input
   * @description
	 * O componente GumgaRangeNumber serve para validar números mínimos e máximos em entradas de formulários com campos do tipo number.
   *
   * ## Nota
   * O valor do atributo/diretiva é **obrigatório** e deve ser um **objeto** contendo duas propriedades, **min** e **max**
   * com os valores de suas respectivas datas para execução da validação range.
   *
   * ## Exemplo
   * Um exemplo da directive GumgaRangeNumber funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
   *
	 * @param {String} label Usado na integração com {@link gumga.core:gumgaErrors} para indicar em qual campo se encontra o erro.
	 * Se o atributo for omitido, a diretiva usará o atributo name do input.
	 *
   * @example
   *  <pre>
   *    <form name="myForm">
   *      <input type="date" name="rangeNumber" ng-model="rangeNumber" gumga-number-date="{min: 0, max: 20}">
   *      <p ng-show="myForm.rangeNumber.$error.rangenumber" class="text-danger">O número informado não está entre os valores esperados</p>
   *    </form>
   *  </pre>
	 */
	 RangeNumber.$inject = [];
	 function RangeNumber() {
	 	return {
	 		restrict: 'A',
	 		require: 'ngModel',
	 		link: function (scope, elm, attrs, ctrl) {
	 			if (attrs.type != 'number') {
	 				throw 'Esta diretiva suporta apenas inputs do tipo number';
	 			}
	 			if (!attrs.gumgaRangeNumber) {
	 				throw "O valor da diretiva gumga-range-number não foi informado.";
	 			}
	 			var validateRangeNumber = function (inputValue) {
					var error = 'rangenumber';
          var range = scope.$eval(attrs.gumgaRangeNumber);
          var input = parseInt(inputValue);
          var isValid = input >= range.min && input <= range.max;
          ctrl.$setValidity(error, isValid);
					scope.$broadcast('$error', {
						name: attrs.name,
						label: attrs.label || attrs.name,
						valid: isValid,
						error: error,
						value: attrs.gumgaRangeNumber
					});
	 				return inputValue;
	 			};
	 			ctrl.$parsers.unshift(validateRangeNumber);
	 			ctrl.$formatters.push(validateRangeNumber);
	 			attrs.$observe('gumgaRangeNumber', function () {
	 				validateRangeNumber(ctrl.$viewValue);
	 			});
	 		}
	 	}
	 }
	 angular.module('gumga.directives.form.range.number',[])
	 .directive('gumgaRangeNumber',RangeNumber);
	})();

(function(){
  'use strict';
  /**
   * @ngdoc directive
   * @name gumga.core:gumgaRequired
   * @restrict A
   * @element ANY
   * @description
   * O componente GumgaRequired serve para validar campos obrigatórios.
   *
   * ## Exemplo
   * Um exemplo da directive GumgaRequired funcionando pode ser encontrado [aqui](http://embed.plnkr.co/AcjqcgvgGhdJqDh72eHA).
   *
   * @param {String} label Usado na integração com {@link gumga.core:gumgaErrors} para indicar em qual campo se encontra o erro.
   * Se o atributo for omitido, a diretiva usará o atributo name do input.
	 *
   * @example
   *  <pre>
   *    <form name="myForm">
   *      <input type="text" name="required" ng-model="required" gumga-required>
   *      <p ng-show="myForm.required.$error.required" class="text-danger">Campo obrigatório</p>
   *    </form>
   *  </pre>
   */
  Required.$inject = [];
  function Required() {
    return {
      restrict: 'A',
      require: 'ngModel',
      link: function (scope, elm, attrs, ctrl) {
        attrs.required = true;
        var validateRequired = function (inputValue) {
          var error = 'required';
          var isValid = !attrs.required || !ctrl.$isEmpty(inputValue);
          ctrl.$setValidity(error, isValid);
          scope.$broadcast('$error', {
            name: attrs.name,
            label: attrs.label || attrs.name,
            valid: isValid,
            error: error,
            value: attrs.gumgaRequired
          });
          return inputValue;
        };
        ctrl.$parsers.unshift(validateRequired);
        ctrl.$formatters.push(validateRequired);
        attrs.$observe('gumgaRequired', function () {
          validateRequired(ctrl.$viewValue);
        });
      }
    }
  }
  angular.module('gumga.directives.form.required',[])
  .directive('gumgaRequired',Required);
})();

(function(){
	'use strict';

	AdvancedLabel.$inject = [];
	function AdvancedLabel(){
		var template =
		'<div class="btn-group">' +
		'   <button class="btn btn-default btn-xs" ng-disabled="disabled" id="btn{{attr}}" ng-click="orOrAnd(value)"><strong>{{attr}}</strong> {{hql}} <strong>{{value}}</strong></button>' +
		'   <button class="btn btn-default btn-xs" ng-disabled="disabled" ng-click="emitDelete()" ng-if="getVisibility(value)"><span aria-hidden="true">&times;</span></button>' +
		'</div>';

		return {
			restrict: 'E',
			template: template,
			scope: {
				attr: '@',
				hql: '@',
				value: '=',
				index: '=',
				disabled: '='
			},
			link: function(scope,$elm,$attrs){
				if(!$attrs.disabled) scope.disabled = false;
				scope.bol = false;

				scope.orOrAnd = function(){

					if(typeof scope.value === 'string' && scope.value.toUpperCase() === 'OR' && !scope.hql){
						scope.value = 'AND';
					}   else  if(scope.value.toUpperCase() === 'AND' && !scope.hql){
						scope.value = 'OR';
					}
				};

				scope.emitDelete = function(){
					scope.$emit('deletepls',scope.index);
				};


				scope.getVisibility = function(val){
					return !(val == 'AND' || val == 'OR');
				}
			}
		};
	}
	angular.module('gumga.directives.search.advancedlabel',[])
	.directive('gumgaAdvancedLabel',AdvancedLabel)
})();

(function(){
	'use strict';

	AdvancedSearch.$inject = ["GumgaSearchHelper"];
	function AdvancedSearch(GumgaSearchHelper){
		var template =
		'   <div class="input-group">' +
		'       	<span class="input-group-btn" dropdown is-open="status.isopen">'+
		'						<span dropdown on-toggle="toggled(open)">'+
		'							<a href id="simple-dropdown" class="btn btn-default" style="margin-right:-3px;" dropdown-toggle>'+
		'								<i class="glyphicon glyphicon-hourglass"></i>	'+
		'							</a>'+
		'							<ul class="dropdown-menu" aria-labelledby="simple-dropdown" style="width: auto;">'+
		'								<li ng-repeat="choice in $parent.availableQueries">'+
		'									<a href ng-click="doQuery(choice)">{{choice.description}}</a>'+
		'								</li>'+
		'							</ul>'+
		'						</span>'+
		'       	</span>' +
		'       <input type="text" ng-model="searchInputText" class="form-control" ng-disabled="isPanelOpen" id="textMain"/> ' +
		'       <span class="input-group-btn">' +
		'           <button class="my-button btn-default" ng-click="showLittlePanel = !showLittlePanel"><span class="glyphicon glyphicon-chevron-down"></span></button>' +
		'           <button class="my-button btn-default" type="button" ng-click="isPanelOpen = !isPanelOpen"><span class="glyphicon glyphicon-filter"></span>' +
		'           <button class="my-button btn-primary last" type="button" ng-disabled="isPanelOpen" ng-click="doSearch(searchInputText)">Search <span class="glyphicon glyphicon-search"></span>' +
		'       </span>' +
		'   </div>' +
		'   <div class="panel-advanced" ng-show="isPanelOpen">' +
		'       <div class="panel-body">' +
		'           <div class="col-md-3">' +
		'           <h3 style="margin-top: 0;margin-bottom: 0"><small>Advanced Search</small></h3>' +
		'           </div>' +
		'           <div class="form-inline col-md-9">' +
		'               <div class="form-group">' +
		'                   <div class="list-holder">' +
		'                           <ul class="list-selectable" ng-show="selectAttribute">\n' +
		'                               <li ng-repeat="attr in attributes" ng-click="attributeHasChanged(attr)" class="hover-list"><button class="btn btn-link">{{attr.name}}</button></li>\n' +
		'                           </ul>\n' +
		'                       </div>' +
		'                       <button type=button class="btn btn-default" ng-click="selectAttribute = !selectAttribute" >{{query.attribute.name || \'Attribute\'}}<span class="caret"></span></button>' +
		'                      <div class="list-holder">' +
		'                           <ul class="list-selectable" ng-show="selectHQL">\n' +
		'                               <li ng-repeat="opt in hqlOpts" class="hover-list" ng-click="handleHqlOption(opt)"><button class="btn btn-link" >{{opt.label}}</button></li>\n' +
		'                           </ul>\n' +
		'                       </div>' +
		'                    <button type="button" class="btn btn-default" ng-click="selectHQL = !selectHQL"> {{ query.hql.label || \'HQL\'  }} <span class="caret"></span></button>  '+
		'                   <input type="{{typeInput}}" class="form-control col-x-3" ng-model="query.value" id="selectableAdvancedValue" ng-init="input = this"/>' +
		'                   <button type="button" class="btn btn-default" ng-click="addQuery(query)" ng-disabled="query.value.length > 0 ? false : true"><span class="glyphicon glyphicon-plus"></span></button>' +
		'               </div>' +
		'           </div>' +
		'       </div>'+
		'           <hr/>' +
		'       <div class="col-md-12" style="padding-bottom: 2%">' +
		'       <gumga-advanced-label ng-repeat="query in queries" attr="{{query.attribute.name}}" hql="{{query.hql.label}}" value="query.value" index="$index" style="margin-right: 1%"></gumga-advanced-label>' +
		'       <div class="col-md-12" style="margin-top: 1%;">' +
		'       <button class="btn btn-primary pull-right" type="button" ng-disabled="queries.length == 0" ng-click="showArray(queries)">Advanced Search<span class="glyphicon glyphicon-search"></span>' +
		'       </div>' +
		'       </div>' +
		'       <div class="clearfix" style="margin-bottom: 2%"></div>' +
		'   </div>' +
		'<div class="little-panel" ng-show="showLittlePanel">' +
		'   <div class="panel-body">' +
		'       <label ng-repeat="field in normalFields" style="display: block" ><input type="checkbox" ng-model="models[field.value]" style="margin-right: 1%" ><span>{{field.value}}</span></label>' +
		'   </div>' +
		'</div>';
		return {
			restrict: 'E',
			template: template,
			scope: false,
			require: '^?gumgaSearch',
			link: function(scope,elm,attrs,ctrl){
				scope.isPanelOpen = false;
				scope.selectHQL = false;
				scope.models = {};
				scope.searchField = '';
				scope.translate = scope.$parent.entityToTranslate;

				scope.doQuery = function (choice) {
					var query = JSON.parse(choice.value);
					scope.$emit('advanced', {hql: GumgaSearchHelper.translateArrayToHQL(query), source: query});
				}

				scope.$on('_doSearch',function(){
					if(scope.queries.length != 0){
						scope.showArray(scope.queries);
					} else {
						if(scope.searchInputText){
							scope.doSearch(scope.searchInputText);
						}
					}
				});

				scope.$on('_focus',function(){
					if(scope.isPanelOpen){
						document.getElementById('selectableAdvancedValue').focus();
					} else {
						document.getElementById('textMain').focus();
					}
				});

				if(!scope.$parent.normalFields.length > 0 || !scope.$parent.entityToTranslate){
					throw 'Missing some parameters in GumgaSearch';
				}

				scope.normalFields = scope.$parent.normalFields.map(function(elm,$index){
					scope.models[elm] = false;
					$index == 0 && (scope.models[elm] = true);
					return {
						name: elm.slice(0,1).toUpperCase() + elm.slice(1,elm.length).toLowerCase(),
						value: elm
					};
				});


				scope.$on('showPanel',function(){
					scope.isPanelOpen = !scope.isPanelOpen;
					scope.$apply();
				});

				scope.models.returnString = function(){
					var txt = '';
					for(var key in this) if(this.hasOwnProperty(key) && key != 'returnString' && this[key]){
						txt += key + ',';
					}
					if(txt.length == 0){
						return scope.normalFields[0].value;
					}
					return txt.slice(0,-1);
				};

				scope.$watch('isPanelOpen',function(){
					if(scope.isPanelOpen === true){
						scope.selectAttribute = true;
					} else {
						scope.queries = [];
					}
					scope.query = {};
				});
				scope.attributes = scope.$parent.attributes;
				scope.hqlOpts = [];
				scope.queries = [];

				scope.attributeHasChanged = function(attribute) {
					scope.query.attribute = attribute;
					if(attribute.type === 'date'){
						scope.typeInput = 'date';
					} else {
						scope.typeInput = 'text';
					}
					scope.hqlOpts = GumgaSearchHelper.getTypeListOfHQLPossibilities(attribute.type);
					scope.selectHQL = true ;
					scope.selectAttribute = false;
				};

				scope.handleHqlOption = function(hq){
					scope.query.hql = hq;
					scope.selectHQL = false;
				};

				angular.element(document.getElementById('selectableAdvancedValue'))
				.on('keydown',function(ev){
					if(ev.keyCode == 13 && ev.target.value.length > 0){
						scope.addQuery(scope.query);
					}
					scope.$apply();
				});

				angular.element(document.getElementById('textMain'))
				.on('keydown',function(ev){
					if(ev.keyCode == 13 && ev.target.value.length > 0){
						scope.$emit('normal',{field: scope.models.returnString(),param:scope.searchInputText || ''});
						if(scope.showLittlePanel){
							scope.showLittlePanel = !scope.showLittlePanel;
						}
					}
				});

				scope.addQuery = function(query){
					if(scope.queries.length === 0){
						scope.queries.push(query);
					} else if(scope.queries.length >= 1){
						scope.queries.splice(scope.queries.length,1,{value: 'AND'},query);
					}
					scope.query = {};
					scope.typeInput = 'text';
				};

				scope.$on('deletepls',function(ev,data){
					scope.queries.splice(data,1);
				});

				scope.showArray = function(array){
					scope.isPanelOpen = false;
					scope.$emit('advanced',{hql: GumgaSearchHelper.translateArrayToHQL(array),source: array});
				};

				scope.doSearch = function(txt){
					scope.$emit('normal',{field: scope.models.returnString(),param:txt || ''});
					scope.searchInputText = '';
				};
			}
		};
	}
	angular.module('gumga.directives.search.advancedsearch',['gumga.directives.search.searchhelper'])
	.directive('gumgaAdvancedSearch',AdvancedSearch)
})();

(function(){
	'use strict';
	
	NormalSearch.$inject = [];
	function NormalSearch(){
		var template =
		'<div class="input-group">' +
		'   <input type="text" class="form-control" ng-model="searchField" placeholder="Search"/>' +
		'   <span class="input-group-btn">' +
		'       <button class="my-button btn-default" ng-click="showLittlePanel = !showLittlePanel"><span class="glyphicon glyphicon-chevron-down"></span></button>' +
		'       <button class="my-button btn-primary last" type="button" ng-disabled="!searchField" ng-click="doSearch(searchField)" >Search <span class="glyphicon glyphicon-search"></span></button>' +
		'   </span>' +
		'</div>' +
		'<div class="little-panel" ng-show="showLittlePanel">' +
		'   <div class="panel-body">' +
		'       <label ng-repeat="field in normalFields" style="display: block" ><input type="checkbox" ng-model="models[field.value]" style="margin-right: 1%" ><span>{{field.value}}</span></label>' +
		'   </div>' +
		'</div>';
		return {
			restrict: 'E',
			template: template,
			link: function(scope,elm,attrs){
				if(!scope.$parent.normalFields.length > 0 || !scope.$parent.entityToTranslate){
					throw 'Missing some parameters in GumgaSearch';
				}
				scope.models = {};
				scope.searchField = '';
				scope.translate = scope.$parent.entityToTranslate;
				scope.normalFields = scope.$parent.normalFields.map(function(elm,$index){
					scope.models[elm] = false;
					$index == 0 && (scope.models[elm] = true);
					return {
						name: elm.slice(0,1).toUpperCase() + elm.slice(1,elm.length).toLowerCase(),
						value: elm
					};
				});

				scope.models.returnString = function(){
					var txt = '';
					for(var key in this) if(this.hasOwnProperty(key) && key != 'returnString' && this[key]){
						txt += key + ',';
					}
					if(txt.length == 0){
						return scope.normalFields[0].value;
					}
					return txt.slice(0,-1);
				};

				elm.find('input')
				.bind('keypress',function(ev){
					if(ev.keyCode == 13 && scope.searchField.length > 0){
						scope.$emit('normal',{field: scope.models.returnString(),param:scope.searchField});
						if(scope.showLittlePanel){
							scope.showLittlePanel = !scope.showLittlePanel;
						}
					}
				});

				scope.doSearch = function(txt){
					scope.$emit('normal',{field: scope.models.returnString(),param:txt || ''});
					scope.showLittlePanel = !scope.showLittlePanel;
					scope.searchField = '';
				};

			}
		};
	}
	angular.module('gumga.directives.search.normalsearch',[])
	.directive('gumgaNormalSearch',NormalSearch)
})();
(function(){
	'use strict';

	Search.$inject = [];
	function Search(){
		var template =
		'<div class="full-width-without-padding">' +
		'     <div ng-if="!adv">' +
		'         <gumga-normal-search></gumga-normal-search>' +
		'     </div>' +
		'     <div ng-if="adv">' +
		'         <gumga-advanced-search></gumga-advanced-search>' +
		'     </div>' +
		'</div>';
		return {
			restrict: 'E',
			template: template,
			transclude: true,
			scope : {
				advanced: '&advancedMethod',
				normal: '&searchMethod',
				onSearch: '&',
				onAdvancedSearch: '&',
				getQueries: '&?'
			},
			link: function(scope,elm,attrs,controller,transcludeFn){
				scope.adv = false;
				scope.attributes = [];
				scope.normalFields = attrs.fields.split(',');
				scope.entityToTranslate = attrs.translateEntity;
				scope.$parent.searchQueries = [];
				scope.availableQueries = [];
				scope.saveQuery = false;
				if(attrs.getQueries){
					scope.saveQuery = true;
					scope.getQueries({page: location.hash})
					.then(function(data){
						scope.availableQueries = data;
					})
				}

				var eventHandler = {
					search: attrs.onSearch ? scope.onSearch : angular.noop,
					advanced: attrs.onAdvancedSearch ? scope.onAdvancedSearch : angular.noop
				}
				if(attrs.advanced === "true"){
					scope.adv = true;
				}

				scope.getAttributes = function (){
					transcludeFn(function(clone){
						angular.forEach(clone,function(cloneEl){
							if(cloneEl.nodeName == 'ADVANCED-FIELD'){
								scope.attributes.push({
									name: cloneEl.getAttribute('name'),
									type: cloneEl.getAttribute('type')
								});
							}
						});
					});
				};

				scope.$on('advanced',function(ev,data){
					scope.$parent.searchQueries = [];
					scope.$parent.searchQueries = data.source;
					scope.advanced({param: data});
					eventHandler.advanced();
        });

				scope.$on('normal',function(ev,data){
					scope.normal({field: data.field,param: data.param});
					eventHandler.search()
        });

				scope.getAttributes();
			}
		};
	}
	angular.module('gumga.directives.search.search',[])
	.directive('gumgaSearch',Search)
})();

(function(){
	'use strict';

	SearchHelper.$inject = [];
	function SearchHelper(){
		var types ={
			"string": {
				"HQLPossibilities": [
				{hql:"eq",label: "igual" , before: "='",after:"'"},
				{hql:"ne",label: "diferente de" , before: "!='",after:"'"},
				{hql: "contains",label: "contém" , before: " like '\%",after:"\%'"},
				{hql: "not_contains",label:"não contém" , before: " not like '\%",after:"\%'"},
				{hql: "starts_with",label:"começa com" , before: "like '",after:"\%'"},
				{hql: "ends_with",label: "termina com" , before: "like '\%",after:"'"},
				{hql: "ge",label:"maior igual" , before: ">='",after:"'"},
				{hql: "le",label: "menor igual" , before: "<='",after:"'"}]
			},
			"number": {
				"HQLPossibilities": [
				{hql:"eq",label: "igual", before: "=",after:""},
				{hql:"ne",label: "diferente de", before: "!=",after:""},
				{hql: "gt",label:"maior que", before: ">",after:""},
				{hql: "ge",label:"maior igual", before: ">=",after:""},
				{hql: "lt",label:"menor que", before: "<",after:""},
				{hql: "le",label:"menor igual", before: "<=",after:""}]
			},
			"money": {
				"HQLPossibilities": [
				{hql:"eq",label: "igual", before: "=",after:""},
				{hql:"ne",label: "diferente de", before: "!=",after:""},
				{hql: "gt",label:"maior que", before: ">",after:""},
				{hql: "ge",label:"maior igual", before: ">=",after:""},
				{hql: "lt",label:"menor que", before: "<",after:""},
				{hql: "le",label:"maior igual", before: "<=",after:""}]

			},
			"boolean": {
				"HQLPossibilities": [{hql:"eq",label: "igual" , before: "='",after:"'"}]
			},
			"date": {
				"HQLPossibilities": [
				{hql: "eq", label: "igual", before: "='", after: "'"},
				{hql: "ge", label: "maior igual", before: ">='", after: "'"},
				{hql: "le", label: "menor igual", before: "<='", after: "'"}]
			}
		};
		return {
			getTypeListOfHQLPossibilities: function(type){
				if(angular.isDefined(types[type]))
					return types[type].HQLPossibilities;
				throw 'Type doesn\'t exist';
			},
			translateArrayToHQL: function(array){
				return array
				.map(function(element) {
					return (
						(angular.isDefined(element.attribute) ? 'obj.' + element.attribute.name : '!')
						+ '' +
						(angular.isDefined(element.hql) ? element.hql.before : ' !')
						+ '' +
						element.value
						+ (angular.isDefined(element.hql) ? element.hql.after : ' !') );
				}).map(function(element){
					if(element.indexOf('!') != -1){
						return element.replace(/!/g,'');
					}
					return element;
				}).join("");
			}
		};
	}
	angular.module('gumga.directives.search.searchhelper',[])
	.factory('GumgaSearchHelper',SearchHelper)
})();

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LmpzIiwiY29udHJvbGxlcnMvbW9kdWxlLmpzIiwiZGlyZWN0aXZlcy9tb2R1bGUuanMiLCJzZXJ2aWNlcy9tb2R1bGUuanMiLCJkaXJlY3RpdmVzL0FkZHJlc3MvQWRkcmVzcy5qcyIsImRpcmVjdGl2ZXMvQWxlcnQvQWxlcnQuanMiLCJkaXJlY3RpdmVzL0JyZWFkY3J1bWIvQnJlYWRjcnVtYi5qcyIsImRpcmVjdGl2ZXMvQ291bnRlci9Db3VudGVyLmpzIiwiZGlyZWN0aXZlcy9Gb3JtL0Zvcm0uanMiLCJkaXJlY3RpdmVzL0Zvcm0vbW9kdWxlLmpzIiwiZGlyZWN0aXZlcy9Gb3JtQnV0dG9ucy9Gb3JtQnV0dG9ucy5qcyIsImRpcmVjdGl2ZXMvTGlzdC9MaXN0LmpzIiwiZGlyZWN0aXZlcy9NYW55VG9NYW55L01hbnlUb01hbnkuanMiLCJkaXJlY3RpdmVzL01hbnlUb09uZS9NYW55VG9PbmUuanMiLCJkaXJlY3RpdmVzL01hc2svTWFzay5qcyIsImRpcmVjdGl2ZXMvTWVudS9NZW51LmpzIiwiZGlyZWN0aXZlcy9OYXYvTmF2LmpzIiwiZGlyZWN0aXZlcy9PbmVUb01hbnkvT25lVG9NYW55LmpzIiwiZGlyZWN0aXZlcy9RdWVyeS9RdWVyeS5qcyIsImRpcmVjdGl2ZXMvU2VhcmNoL1NlYXJjaC5qcyIsImRpcmVjdGl2ZXMvU2VhcmNoL21vZHVsZS5qcyIsImRpcmVjdGl2ZXMvVGFibGUvVGFibGUuanMiLCJkaXJlY3RpdmVzL1VwbG9hZC9VcGxvYWQuanMiLCJzZXJ2aWNlcy9BZGRyZXNzU2VydmljZS9BZGRyZXNzU2VydmljZS5qcyIsInNlcnZpY2VzL0FsZXJ0L0FsZXJ0LmpzIiwic2VydmljZXMvQmFzZS9CYXNlLmpzIiwic2VydmljZXMvQnJvYWRjYXN0ZXIvQnJvYWRjYXN0ZXIuanMiLCJzZXJ2aWNlcy9EYXRlL0RhdGUuanMiLCJzZXJ2aWNlcy9LZXlib2FyZC9LZXlib2FyZC5qcyIsInNlcnZpY2VzL0xpc3RIZWxwZXIvTGlzdEhlbHBlci5qcyIsInNlcnZpY2VzL05vdGlmaWNhdGlvbi9Ob3RpZmljYXRpb24uanMiLCJzZXJ2aWNlcy9Qb3B1bGF0ZVByb3ZpZGVyL1BvcHVsYXRlUHJvdmlkZXIuanMiLCJzZXJ2aWNlcy9SZXN0L1Jlc3QuanMiLCJzZXJ2aWNlcy9UcmFuc2xhdGUvVHJhbnNsYXRlLmpzIiwic2VydmljZXMvVHJhbnNsYXRlL1RyYW5zbGF0ZUhlbHBlci5qcyIsInNlcnZpY2VzL1V0aWxzL1V0aWxzLmpzIiwic2VydmljZXMvV2ViU3RvcmFnZS9XZWJTdG9yYWdlLmpzIiwiZGlyZWN0aXZlcy9Gb3JtL0Vycm9yL0Vycm9yLmpzIiwiZGlyZWN0aXZlcy9Gb3JtL0Vycm9ycy9FcnJvcnMuanMiLCJkaXJlY3RpdmVzL0Zvcm0vRm9ybS9Gb3JtLmpzIiwiZGlyZWN0aXZlcy9Gb3JtL01heC9EYXRlLmpzIiwiZGlyZWN0aXZlcy9Gb3JtL01heC9MZW5ndGguanMiLCJkaXJlY3RpdmVzL0Zvcm0vTWF4L051bWJlci5qcyIsImRpcmVjdGl2ZXMvRm9ybS9NaW4vRGF0ZS5qcyIsImRpcmVjdGl2ZXMvRm9ybS9NaW4vTGVuZ3RoLmpzIiwiZGlyZWN0aXZlcy9Gb3JtL01pbi9OdW1iZXIuanMiLCJkaXJlY3RpdmVzL0Zvcm0vUGF0dGVybi9QYXR0ZXJuLmpzIiwiZGlyZWN0aXZlcy9Gb3JtL1JhbmdlL0RhdGUuanMiLCJkaXJlY3RpdmVzL0Zvcm0vUmFuZ2UvTnVtYmVyLmpzIiwiZGlyZWN0aXZlcy9Gb3JtL1JlcXVpcmVkL1JlcXVpcmVkLmpzIiwiZGlyZWN0aXZlcy9TZWFyY2gvQWR2YW5jZWRMYWJlbC9BZHZhbmNlZExhYmVsLmpzIiwiZGlyZWN0aXZlcy9TZWFyY2gvQWR2YW5jZWRTZWFyY2gvQWR2YW5jZWRTZWFyY2guanMiLCJkaXJlY3RpdmVzL1NlYXJjaC9Ob3JtYWxTZWFyY2gvTm9ybWFsU2VhcmNoLmpzIiwiZGlyZWN0aXZlcy9TZWFyY2gvU2VhcmNoL1NlYXJjaC5qcyIsImRpcmVjdGl2ZXMvU2VhcmNoL1NlYXJjaEhlbHBlci9TZWFyY2hIZWxwZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDekNBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDamhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM5REE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdlhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN2S0E7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDN01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJndW1nYS5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmFuZ3VsYXIubW9kdWxlKCdndW1nYS5jb3JlJyxcblx0WydndW1nYS5zZXJ2aWNlcycsXG5cdCdndW1nYS5jb250cm9sbGVycycsXG5cdCdndW1nYS5kaXJlY3RpdmVzJ10pO1xuIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuY29udHJvbGxlcnMnLFtdKTtcblxufSkoKTtcbiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cblx0YW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMnLFxuXHRcdFtcblx0XHQnZ3VtZ2EuZGlyZWN0aXZlcy5hZGRyZXNzJyxcblx0XHQnZ3VtZ2EuZGlyZWN0aXZlcy5xdWVyaWVzJyxcblx0XHQnZ3VtZ2EuZGlyZWN0aXZlcy5hbGVydCcsXG5cdFx0J2d1bWdhLmRpcmVjdGl2ZXMuYnJlYWRjcnVtYicsXG5cdFx0J2d1bWdhLmRpcmVjdGl2ZXMuY291bnRlcicsXG5cdFx0J2d1bWdhLmRpcmVjdGl2ZXMuZm9ybWJ1dHRvbnMnLFxuXHRcdCdndW1nYS5kaXJlY3RpdmVzLm1hbnl0b21hbnknLFxuXHRcdCdndW1nYS5kaXJlY3RpdmVzLm1hbnl0b29uZScsXG5cdFx0J2d1bWdhLmRpcmVjdGl2ZXMubWVudScsXG5cdFx0J2d1bWdhLmRpcmVjdGl2ZXMubmF2Jyxcblx0XHQnZ3VtZ2EuZGlyZWN0aXZlcy5vbmV0b21hbnknLFxuXHRcdCdndW1nYS5kaXJlY3RpdmVzLnNlYXJjaCcsXG5cdFx0J2d1bWdhLmRpcmVjdGl2ZXMudGFibGUnLFxuXHRcdCdndW1nYS5kaXJlY3RpdmVzLnVwbG9hZCcsXG5cdFx0J2d1bWdhLmRpcmVjdGl2ZXMuZm9ybScsXG5cdFx0J2d1bWdhLmRpcmVjdGl2ZXMudHJhbnNsYXRlJyxcblx0XHQnZ3VtZ2EuZGlyZWN0aXZlcy5tYXNrJyxcblx0XHQnZ3VtZ2EuZGlyZWN0aXZlcy5saXN0Jyxcblx0XHQnZ3VtZ2EuZGlyZWN0aXZlcy50cmFuc2xhdGUnXG5cdFx0XSk7XG5cbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGFuZ3VsYXIubW9kdWxlKCdndW1nYS5zZXJ2aWNlcycsW1xuXHRcdCdndW1nYS5zZXJ2aWNlcy5hZGRyZXNzJyxcblx0XHQnZ3VtZ2Euc2VydmljZXMua2V5Ym9hcmQnLFxuXHRcdCdndW1nYS5zZXJ2aWNlcy5iYXNlJyxcblx0XHQnZ3VtZ2Euc2VydmljZXMudXRpbHMnLFxuXHRcdCdndW1nYS5zZXJ2aWNlcy5hbGVydCcsXG5cdFx0J2d1bWdhLnNlcnZpY2VzLnRyYW5zbGF0ZScsXG5cdFx0J2d1bWdhLnNlcnZpY2VzLndlYnN0b3JhZ2UnLFxuXHRcdCdndW1nYS5zZXJ2aWNlcy5wb3B1bGF0ZScsXG5cdFx0J2d1bWdhLnNlcnZpY2VzLnJlc3QnLFxuXHRcdCdndW1nYS5zZXJ2aWNlcy5ub3RpZmljYXRpb24nXG5cdFx0XSk7XG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0Jztcblx0LyoqXG5cdCAqIEBuZ2RvYyBkaXJlY3RpdmVcblx0ICogQG5hbWUgZ3VtZ2EuY29yZTpndW1nYUFkZHJlc3Ncblx0ICogQHJlc3RyaWN0IEVcblx0ICogQGRlc2NyaXB0aW9uIE8gY29tcG9uZW50ZSBHdW1nYUFkZHJlc3MgcmVjZWJlIHVtIG9iamV0byBxdWUgc2Vyw6EgcHJlZW5jaGlkbyBjb20gbyBlbmRlcmXDp28sIHF1ZSBwb2RlIHNlciBwZXNxdWlzYWRvIGF0cmF2w6lzIGRvIENFUCAoVXRpbGl6YW5kbyB1bSBXZWJTZXJ2aWNlIEdVTUdBKSxcblx0ICogb3UgcHJlZW5jaGlkbyBtYW51YWxtZW50ZSBwZWxvIHVzdcOhcmlvLiBFc3RlIG9iamV0byBkZSBlbnRyYWRhIHBvZGUgc2VyIHZhemlvIG91IHByZWZlcml2ZWxtZW50ZSBubyBmb3JtYXRvIGRvIG9iamV0byBHVU1HQS5cbiAgICAgICAqICMjIEV4ZW1wbG9cbiAgICAgICAqIFZlamEgdW0gZXhlbXBsbyBlbSBmdW5jaW9uYW1lbnRvIFthcXVpXShodHRwOi8vZW1iZWQucGxua3IuY28vN3Q5bVp0TGw5YlB1VmhtaWcwb0kvKS5cblx0ICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIEF0cmlidXRvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgbyBub21lIGRvIG9iamV0byBubyAkc2NvcGUgbm8gcXVhbCBvcyB2YWxvcmVzIGRvIEVuZGVyZcOnbyBzZXLDo28gY29sb2NhZG9zLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBBdHJpYnV0byBvYnJpZ2F0w7NyaW8gZSDDum5pY28gcXVlIGlyw6EgY29udGVyIHVtIG5vbWUgZGUgaWRlbnRpZmljYWRvciBwYXJhIGEgZGlyZWN0aXZlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGl0bGUgQXRyaWJ1dG8gb3BjaW9uYWwgcXVlIGlyw6EgY29udGVyIG8gdMOtdHVsbyBwYXJhIG8gcGFuZWwgZGEgZGlyZWN0aXZlLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblNlYXJjaENlcFN0YXJ0IEF0cmlidXRvIG9wY2lvbmFsIHF1ZSBpcsOhIGNvbnRlciBvIG5vbWUgZGUgdW1hIGZ1bsOnw6NvIHF1ZSBzZXLDoSBleGVjdXRhZGEgcXVhbmRvIGEgYnVzY2EgcGVsbyBDRVAgY29tZcOnYXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9uU2VhcmNoQ2VwU3VjY2VzcyBBdHJpYnV0byBvcGNpb25hbCBxdWUgaXLDoSBjb250ZXIgbyBub21lIGRlIHVtYSBmdW7Dp8OjbyBxdWUgc2Vyw6EgZXhlY3V0YWRhIHF1YW5kbyBhIGJ1c2NhIHBlbG8gQ0VQIHJldG9ybmFyIHN1Y2Vzc28uXG4gICAgICAgKiAgUG9kZSBzZXIgY2hhbWFkYSBjb20gdW0gYXRyaWJ1dG8gY29tIG9zIHZhbG9yZXMgYG9uLXNlYXJjaC1jZXAtc3VjY2Vzcz1cImRvU29tZXRoaW5nKCR2YWx1ZSlcImBcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gb25TZWFyY2hDZXBFcnJvciBBdHJpYnV0byBvcGNpb25hbCBxdWUgaXLDoSBjb250ZXIgbyBub21lIGRlIHVtYSBmdW7Dp8OjbyBxdWUgc2Vyw6EgZXhlY3V0YWRhIHF1YW5kbyBhIGJ1c2NhIHBlbG8gQ0VQIHJldG9ybmFyIGVycm8uXG4gICAgICAgKiAgUG9kZSBzZXIgY2hhbWFkYSBjb20gdW0gYXRyaWJ1dG8gY29tIG9zIHZhbG9yZXMgYG9uLXNlYXJjaC1jZXAtZXJyb3I9XCJkb1NvbWV0aGluZygkdmFsdWUpXCJgXG4gICAgICAqL1xuXHRBZGRyZXNzRGlyZWN0aXZlLiRpbmplY3QgPSBbXCJHdW1nYUFkZHJlc3NTZXJ2aWNlXCIsIFwiJGh0dHBcIl07XG4gICAgICBmdW5jdGlvbiBBZGRyZXNzRGlyZWN0aXZlKEd1bWdhQWRkcmVzc1NlcnZpY2UsJGh0dHApe1xuICAgICAgXHR2YXIgdGVtcGxhdGUgPSBbXG4gICAgICBcdCc8ZGl2IGNsYXNzPVwiYWRkcmVzc1wiIHN0eWxlPVwicGFkZGluZy1sZWZ0OiAwXCI+JyxcbiAgICAgIFx0JyAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTggY29sLXNtLTEyIGNvbC14cy0xMlwiIHN0eWxlPVwicGFkZGluZy1sZWZ0OiAwXCI+JyxcbiAgICAgIFx0JyAgICAgICAgICA8YWNjb3JkaW9uPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgPGFjY29yZGlvbi1ncm91cCBzdHlsZT1cIm1hcmdpbi10b3A6IDElXCIgaXMtb3Blbj1cInRydWVcIiBoZWFkaW5nPVwie3s6OnRpdGxlfX1cIj4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtMTJcIj4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJpbnB1dHt7OjppZH19XCI+Q0VQPC9sYWJlbD4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cFwiPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBuZy1tb2RlbD1cInZhbHVlLnppcENvZGVcIiBpZD1cImlucHV0e3s6OmlkfX1cIiBuZy1rZXlwcmVzcz1cImN1c3RvbSgkZXZlbnQsdmFsdWUuemlwQ29kZSlcIj4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYnRuXCI+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5XCIgdHlwZT1cImJ1dHRvblwiIG5nLWNsaWNrPVwic2VhcmNoQ2VwKHZhbHVlLnppcENvZGUpXCIgbmctZGlzYWJsZWQ9XCJsb2FkZXJ7ezo6aWR9fVwiIGlkPVwiYnV0dG9uU2VhcmNoe3s6OmlkfX1cIj5TZWFyY2ggPGkgY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXNlYXJjaFwiPjwvaT48L2J1dHRvbj4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTRcIj4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJ0aXBvTG9ncmFkb3Vyb1wiPjxzbWFsbD5UaXBvIExvZ3JhZG91cm88L3NtYWxsPjwvbGFiZWw+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJ2YWx1ZS5wcmVtaXNzZVR5cGVcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIG5nLW9wdGlvbnM9XCJsb2cgZm9yIGxvZyBpbiBmYWN0b3J5RGF0YS5sb2dzXCI+PC9zZWxlY3Q+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNVwiIHN0eWxlPVwicGFkZGluZy1sZWZ0OiAwOyBwYWRkaW5nLXJpZ2h0OiAwXCI+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwiTG9ncmFkb3Vyb1wiPjxzbWFsbD5Mb2dyYWRvdXJvPC9zbWFsbD48L2xhYmVsPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJ2YWx1ZS5wcmVtaXNzZVwiIGNsYXNzPVwiZm9ybS1jb250cm9sIGlkPVwib2lcIi8+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtM1wiPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cIk7Dum1lcm9cIj48c21hbGw+IE7Dum1lcm8gPC9zbWFsbD48L2xhYmVsPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJ2YWx1ZS5udW1iZXJcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwibnVtYmVySW5wdXR7ezo6aWR9fVwiLz4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC0xMlwiPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cIkNvbXBsZW1lbnRvXCI+PHNtYWxsPkNvbXBsZW1lbnRvPC9zbWFsbD48L2xhYmVsPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJ2YWx1ZS5pbmZvcm1hdGlvblwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIvPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTdcIj4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJCYWlycm9cIj48c21hbGw+IEJhaXJybyA8L3NtYWxsPjwvbGFiZWw+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cInZhbHVlLm5laWdoYm91cmhvb2RcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiLz4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC01XCI+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwiTG9jYWxpZGFkZVwiPjxzbWFsbD4gTG9jYWxpZGFkZSA8L3NtYWxsPjwvbGFiZWw+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cInZhbHVlLmxvY2FsaXphdGlvblwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIvPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTRcIj4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJVRlwiPjxzbWFsbD4gVUYgPC9zbWFsbD48L2xhYmVsPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBuZy1tb2RlbD1cInZhbHVlLnN0YXRlXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBuZy1vcHRpb25zPVwidWYgZm9yIHVmIGluIGZhY3RvcnlEYXRhLnVmc1wiPjwvc2VsZWN0PicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTRcIj4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJQYcOtc1wiPjxzbWFsbD4gUGHDrXMgPC9zbWFsbD48L2xhYmVsPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBuZy1tb2RlbD1cInZhbHVlLmNvdW50cnlcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIG5nLW9wdGlvbnM9XCJwYWlzIGZvciBwYWlzIGluIGZhY3RvcnlEYXRhLmF2YWlsYWJsZUNvdW50cmllc1wiPjwvc2VsZWN0PicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTRcIiBzdHlsZT1cInBhZGRpbmctdG9wOiAyJVwiPicsXG4gICAgICBcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHQgcHVsbC1yaWdodFwiIG5nLWhyZWY9XCJ7e3JldHVybkxpbmsodmFsdWUpfX1cIiB0YXJnZXQ9XCJfYmxhbmtcIj5NYXBzIDxpIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1nbG9iZVwiPjwvaT48L2E+JyxcbiAgICAgIFx0JyAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4nLFxuICAgICAgXHQnICAgICAgICAgICAgICAgIDwvYWNjb3JkaW9uLWdyb3VwPicsXG4gICAgICBcdCcgICAgICAgICAgPC9hY2NvcmRpb24+JyxcbiAgICAgIFx0JyAgICA8L2Rpdj4nLFxuICAgICAgXHQnPC9kaXY+J107XG4gICAgICBcdHJldHVybiB7XG4gICAgICBcdFx0cmVzdHJpY3Q6ICdFJyxcbiAgICAgIFx0XHRzY29wZToge1xuICAgICAgXHRcdFx0dmFsdWU6ICc9JyxcbiAgICAgIFx0XHRcdG9uU2VhcmNoQ2VwU3RhcnQ6ICcmPycsXG4gICAgICBcdFx0XHRvblNlYXJjaENlcFN1Y2Nlc3M6ICcmPycsXG4gICAgICBcdFx0XHRvblNlYXJjaENlcEVycm9yOiAnJj8nXG4gICAgICBcdFx0fSxcbiAgICAgIFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuam9pbignXFxuJyksXG4gICAgICBcdFx0bGluazogZnVuY3Rpb24gKHNjb3BlLCBlbG0sIGF0dHJzLCBjdHJsKSB7XG5cdFx0XHRcdFx0XHRmdW5jdGlvbiBpc0VtcHR5KG9iail7XG4gICAgXHRcdFx0XHRcdGZvcih2YXIga2V5IGluIG9iaikgaWYob2JqLmhhc093blByb3BlcnR5KGtleSkpe1xuICAgICAgICBcdFx0XHRcdHJldHVybiBmYWxzZTtcbiAgICBcdFx0XHRcdFx0fVxuICAgIFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0ICAgICAgICAgIGlmKGlzRW1wdHkoc2NvcGUudmFsdWUpKSBzY29wZS52YWx1ZSA9IEd1bWdhQWRkcmVzc1NlcnZpY2UucmV0dXJuRm9ybWF0dGVkT2JqZWN0KCk7XG5cdCAgICAgICAgICBpZighYXR0cnMubmFtZSkgdGhyb3cgXCLDiSBuZWNlc3PDoXJpbyBwYXNzYXIgdW0gcGFyw6JtZXRybyAnbmFtZScgY29tbyBpZGVudGlmaWNhZG9yIHBhcmEgR3VtZ2FBZGRyZXNzXCI7XG4gICAgICBcdFx0XHRzY29wZS50aXRsZSA9IGF0dHJzLnRpdGxlIHx8ICdFbmRlcmXDp28nO1xuICAgICAgXHRcdFx0c2NvcGUuaWQgPSBhdHRycy5uYW1lO1xuICAgICAgXHRcdFx0c2NvcGVbJ2xvYWRlcicgKyBzY29wZS5pZF0gPSBmYWxzZTtcbiAgICAgICAgICAgIHNjb3BlLmZhY3RvcnlEYXRhID0ge1xuICAgICAgICAgICAgICAgIHVmczogR3VtZ2FBZGRyZXNzU2VydmljZS5ldmVyeVVmLFxuICAgICAgICAgICAgICAgIGxvZ3M6IEd1bWdhQWRkcmVzc1NlcnZpY2UuZXZlcnlMb2dyYWRvdXJvLFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUNvdW50cmllczogR3VtZ2FBZGRyZXNzU2VydmljZS5hdmFpbGFibGVDb3VudHJpZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZXZlbnRIYW5kbGVyID0ge1xuICAgICAgICAgICAgICAgICAgc2VhcmNoQ2VwU3RhcnQ6IChhdHRycy5vblNlYXJjaENlcFN0YXJ0ID8gc2NvcGUub25TZWFyY2hDZXBTdGFydCA6IGFuZ3VsYXIubm9vcCksXG4gICAgICAgICAgICAgICAgICBzZWFyY2hDZXBTdWNjZXNzOiAoYXR0cnMub25TZWFyY2hDZXBTdWNjZXNzID8gc2NvcGUub25TZWFyY2hDZXBTdWNjZXNzIDogYW5ndWxhci5ub29wKSxcbiAgICAgICAgICAgICAgICAgIHNlYXJjaENlcEVycm9yOiAoYXR0cnMub25TZWFyY2hDZXBFcnJvciA/IHNjb3BlLm9uU2VhcmNoQ2VwRXJyb3I6IGFuZ3VsYXIubm9vcClcbiAgICAgICAgICAgIH07XG4gICAgICBcdFx0XHRzY29wZS5jdXN0b20gPSBmdW5jdGlvbiAoJGV2ZW50LCBjZXApIHtcbiAgICAgICAgICAgICAgJGV2ZW50LmNoYXJDb2RlID09IDEzPyBzY29wZS5zZWFyY2hDZXAoY2VwKSA6IGFuZ3VsYXIubm9vcDtcbiAgICAgIFx0XHRcdH07XG5cbiAgICAgIFx0XHRcdHNjb3BlLnJldHVybkxpbmsgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIFx0XHRcdFx0aWYgKCF2YWx1ZS5udW1iZXIpIHtcbiAgICAgIFx0XHRcdFx0XHR2YWx1ZS5udW1iZXIgPSAnJztcbiAgICAgIFx0XHRcdFx0fVxuICAgICAgXHRcdFx0XHRyZXR1cm4gJ2h0dHBzOi8vd3d3Lmdvb2dsZS5jb20uYnIvbWFwcy9wbGFjZS8nICsgdmFsdWUucHJlbWlzc2VUeXBlICsgJyAnICsgdmFsdWUucHJlbWlzc2UgKyAnLCcgKyB2YWx1ZS5udW1iZXIrICcsJyArIHZhbHVlLmxvY2FsaXphdGlvbjtcbiAgICAgIFx0XHRcdH07XG4gICAgICBcdFx0XHRzY29wZS5zZWFyY2hDZXAgPSBmdW5jdGlvbiAoY2VwKSB7XG4gICAgICBcdFx0XHRcdHNjb3BlWydsb2FkZXInICsgc2NvcGUuaWRdID0gdHJ1ZTtcbiAgICAgIFx0XHRcdFx0ZXZlbnRIYW5kbGVyLnNlYXJjaENlcFN0YXJ0KCk7XG4gICAgICBcdFx0XHRcdCRodHRwLmdldCgnaHR0cDovL3d3dy5ndW1nYS5jb20uYnIvc2VydmljZXMtYXBpL3B1YmxpYy9jZXAvJytjZXApXG4gICAgICBcdFx0XHRcdC5zdWNjZXNzKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgIFx0XHRcdFx0XHRldmVudEhhbmRsZXIuc2VhcmNoQ2VwU3VjY2Vzcyh7JHZhbHVlOiB2YWx1ZXN9KTtcbiAgICAgIFx0XHRcdFx0XHRzY29wZVsnbG9hZGVyJyArIHNjb3BlLmlkXSA9IGZhbHNlO1xuICAgICAgXHRcdFx0XHRcdGlmIChwYXJzZUludCh2YWx1ZXMucmVzdWx0YWRvKSA9PSAxKSB7XG4gICAgICBcdFx0XHRcdFx0XHRzY29wZS52YWx1ZS5wcmVtaXNzZVR5cGUgPSB2YWx1ZXMudGlwb19sb2dyYWRvdXJvO1xuICAgICAgXHRcdFx0XHRcdFx0c2NvcGUudmFsdWUucHJlbWlzc2UgPSB2YWx1ZXMubG9ncmFkb3VybztcbiAgICAgIFx0XHRcdFx0XHRcdHNjb3BlLnZhbHVlLmxvY2FsaXphdGlvbiA9IHZhbHVlcy5jaWRhZGU7XG4gICAgICBcdFx0XHRcdFx0XHRzY29wZS52YWx1ZS5uZWlnaGJvdXJob29kID0gdmFsdWVzLmJhaXJybztcbiAgICAgIFx0XHRcdFx0XHRcdHNjb3BlLnZhbHVlLnN0YXRlID0gdmFsdWVzLnVmO1xuICAgICAgXHRcdFx0XHRcdFx0c2NvcGUudmFsdWUuY291bnRyeSA9ICdCcmFzaWwnO1xuICAgICAgXHRcdFx0XHRcdH1cblxuICAgICAgXHRcdFx0XHR9KVxuICAgICAgXHRcdFx0XHQuZXJyb3IoZnVuY3Rpb24oZGF0YSl7XG4gICAgICBcdFx0XHRcdFx0ZXZlbnRIYW5kbGVyLnNlYXJjaENlcEVycm9yKHskdmFsdWU6IGRhdGF9KTtcbiAgICAgIFx0XHRcdFx0fSlcbiAgICAgIFx0XHRcdH07XG4gICAgICBcdFx0XHRpZiAoc2NvcGUudmFsdWUuemlwQ29kZSkge1xuICAgICAgXHRcdFx0XHRzY29wZS5zZWFyY2hDZXAoc2NvcGUudmFsdWUuemlwQ29kZSk7XG4gICAgICBcdFx0XHR9XG4gICAgICBcdFx0fVxuICAgICAgXHR9O1xuICAgICAgfVxuICAgICAgYW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMuYWRkcmVzcycsWydndW1nYS5zZXJ2aWNlcy5hZGRyZXNzJ10pXG4gICAgICAuZGlyZWN0aXZlKCdndW1nYUFkZHJlc3MnLEFkZHJlc3NEaXJlY3RpdmUpO1xuICAgIH0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXHQvKipcblx0ICogQG5nZG9jIGRpcmVjdGl2ZVxuXHQgKiBAbmFtZSBndW1nYS5jb3JlOmd1bWdhQWxlcnRcblx0ICogQHJlc3RyaWN0IEVBXG5cdCAqIEBlbGVtZW50IEFOWVxuXHQgKiBAZGVzY3JpcHRpb24gTyBjb21wb25lbnRlIGd1bWdhQWxlcnQgc2VydmUgcGFyYSBjcmlhciBub3RpZmljYcOnw7VlcyBncm93bC1saWtlIGUgw6kgYmFzZWFkYSBlbSBldmVudG9zLlxuXHQgKiBQYXJhIG8gZnVuY2lvbmFtZW50byBkYSBkaXJlY3RpdmUsIMOpIG5lY2Vzc8OhcmlvIGluY2x1w60tbGEgYXBlbmFzIHVtYSB2ZXogbm8gc2V1IGPDs2RpZ28gaHRtbCAoZGUgcHJlZmVyw6puY2lhIG5vIGluZGV4Lmh0bWwpLFxuXHQgKiBwYXJhIHF1ZSBvcyBsaXN0ZW5lcnMgc2VqYW0gYWRpY2lvbmFkb3MoQXR1YWxtZW50ZSwgbmEgbm92YSB2ZXJzw6NvIGlzdG8gbsOjbyDDqSBtYWlzIG5lY2Vzc8OhcmlvLCB2ZXIge0BsaW5rIGd1bWdhLmNvcmU6R3VtZ2FBbGVydH0pLiBcblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogIyMgUGFyYSBxdWUgbyBhbGVydGEgc2VqYSByZWFsaXphZG8sIHV0aWxpemUgdW0gZG9zIGV2ZW50b3M6XG5cdCAqIDxwcmU+XG5cdCAqIFx0JHNjb3BlLiRlbWl0KCdkYW5nZXJNZXNzYWdlJyx7dGl0bGU6ICdFcnJvcicgLG1lc3NhZ2U6ICdFcnJvciA0MDQnfSk7XG5cdCAqIFx0JHNjb3BlLiRlbWl0KCdzdWNjZXNzTWVzc2FnZScse3RpdGxlOiAnUGFyYWLDqW5zIScgLG1lc3NhZ2U6ICdTdWEgc29saWNpdGHDp8OjbyBmb2kgYWNlaXRhIGNvbSBzdWNlc3NvISd9KTtcblx0ICogICRzY29wZS4kZW1pdCgnd2FybmluZ01lc3NhZ2UnLHt0aXRsZTogJ0N1aWRhZG8hJyAsbWVzc2FnZTogJ0Egw6FyZWEgcXVlIHZvY8OqIGVzdMOhIGVudHJhbmRvIMOpIHJlc3RyaXRhLid9KTtcbiAgICogXHQkc2NvcGUuJGVtaXQoJ2luZm9NZXNzYWdlJyx7dGl0bGU6ICdTYWx2YXInICxtZXNzYWdlOiAnUGFyYSBzYWx2YXIsIGVudHJlIGVtIGNvbnRhdG8gY29tIG8gYWRtaW5pc3RyYWRvci4nfSk7XG5cdCAqIDwvcHJlPlxuXHQgKiAgUGFyYSB2ZXIgdW0gZXhlbXBsbyBlbSBmdW5jaW9uYW1lbnRvLCBjbGlxdWUgW2FxdWldKGh0dHA6Ly9lbWJlZC5wbG5rci5jby93ZGxJN1U0blFmOWtOaEdseUNmVS8pXG5cdCAqL1xuXHRBbGVydC4kaW5qZWN0ID0gW1wiJHJvb3RTY29wZVwiXTtcblx0ZnVuY3Rpb24gQWxlcnQoJHJvb3RTY29wZSl7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHJlc3RyaWN0OiAnRUEnLFxuXHRcdFx0c2NvcGU6IGZhbHNlLFxuXHRcdFx0Y29tcGlsZTogZnVuY3Rpb24oKXtcblx0XHRcdFx0ZnVuY3Rpb24gbm90aWZ5KGljb24sIHRpdGxlLCBtZXNzYWdlLCB0eXBlKSB7XG5cdFx0XHRcdFx0JC5ub3RpZnkoe1xuXHRcdFx0XHRcdFx0aWNvbjogaWNvbixcblx0XHRcdFx0XHRcdHRpdGxlOiB0aXRsZSxcblx0XHRcdFx0XHRcdG1lc3NhZ2U6IG1lc3NhZ2Vcblx0XHRcdFx0XHR9LCB7XG5cdFx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdFx0b2Zmc2V0OiA1MCxcblx0XHRcdFx0XHRcdHRpbWVyOiAxMDAsXG5cdFx0XHRcdFx0XHRkZWxheTogMzUwMCxcblx0XHRcdFx0XHRcdG9uU2hvdzogJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdvbk5vdGlmaWNhdGlvblNob3cnKSxcblx0XHRcdFx0XHRcdG9uQ2xvc2U6ICRyb290U2NvcGUuJGJyb2FkY2FzdCgnb25Ob3RpZmljYXRpb25DbG9zZScpLFxuXHRcdFx0XHRcdFx0YWxsb3dfZGlzbWlzczogdHJ1ZSxcblx0XHRcdFx0XHRcdGFuaW1hdGU6IHtcblx0XHRcdFx0XHRcdFx0ZW50ZXI6ICdhbmltYXRlZCBib3VuY2VJblJpZ2h0Jyxcblx0XHRcdFx0XHRcdFx0ZXhpdDogJ2FuaW1hdGVkIGJvdW5jZU91dFJpZ2h0J1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdHRlbXBsYXRlOiAnPGRpdiBkYXRhLW5vdGlmeT1cImNvbnRhaW5lclwiIGNsYXNzPVwiY29sLXhzLTkgY29sLXNtLTMgYWxlcnQgYWxlcnQtezB9XCIgcm9sZT1cImFsZXJ0XCI+JyArXG5cdFx0XHRcdFx0XHQnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgY2xhc3M9XCJjbG9zZVwiIGRhdGEtbm90aWZ5PVwiZGlzbWlzc1wiPsOXPC9idXR0b24+JyArXG5cdFx0XHRcdFx0XHQnPHNwYW4gZGF0YS1ub3RpZnk9XCJpY29uXCI+PC9zcGFuPiAnICtcblx0XHRcdFx0XHRcdCc8c3BhbiBkYXRhLW5vdGlmeT1cInRpdGxlXCI+PGI+ezF9PC9iPjwvc3Bhbj48YnI+ICcgK1xuXHRcdFx0XHRcdFx0JzxzcGFuIGRhdGEtbm90aWZ5PVwibWVzc2FnZVwiPnsyfTwvc3Bhbj4nICtcblx0XHRcdFx0XHRcdCc8L2Rpdj4nXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQkcm9vdFNjb3BlLiRvbignZGFuZ2VyTWVzc2FnZScsIGZ1bmN0aW9uIChldiwgZGF0YSkge1xuXHRcdFx0XHRcdG5vdGlmeSgnZ2x5cGhpY29uIGdseXBoaWNvbi1leGNsYW1hdGlvbi1zaWduJywgZGF0YS50aXRsZSwgZGF0YS5tZXNzYWdlLCAnZGFuZ2VyJyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHQkcm9vdFNjb3BlLiRvbignc3VjY2Vzc01lc3NhZ2UnLCBmdW5jdGlvbiAoZXYsIGRhdGEpIHtcblx0XHRcdFx0XHRub3RpZnkoJ2dseXBoaWNvbiBnbHlwaGljb24tb2snLCBkYXRhLnRpdGxlLCBkYXRhLm1lc3NhZ2UsICdzdWNjZXNzJyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHQkcm9vdFNjb3BlLiRvbignd2FybmluZ01lc3NhZ2UnLCBmdW5jdGlvbiAoZXYsIGRhdGEpIHtcblx0XHRcdFx0XHRub3RpZnkoJ2dseXBoaWNvbiBnbHlwaGljb24td2FybmluZy1zaWduJywgZGF0YS50aXRsZSwgZGF0YS5tZXNzYWdlLCAnd2FybmluZycpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0JHJvb3RTY29wZS4kb24oJ2luZm9NZXNzYWdlJywgZnVuY3Rpb24gKGV2LCBkYXRhKSB7XG5cdFx0XHRcdFx0bm90aWZ5KCdnbHlwaGljb24gZ2x5cGhpY29uLWluZm8tc2lnbicsIGRhdGEudGl0bGUsIGRhdGEubWVzc2FnZSwgJ2luZm8nKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGFuZ3VsYXIubW9kdWxlKCdndW1nYS5kaXJlY3RpdmVzLmFsZXJ0JyxbXSlcblx0LmRpcmVjdGl2ZSgnZ3VtZ2FBbGVydCcsQWxlcnQpO1xufSkoKTsiLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdEJyZWFkY3J1bWIuJGluamVjdCA9IFtcIiRyb290U2NvcGVcIl07XG5cdC8qKlxuXHQgKiBAbmdkb2MgZGlyZWN0aXZlXG5cdCAqIEBuYW1lIGd1bWdhLmNvcmU6Z3VtZ2FCcmVhZGNydW1iXG5cdCAqIEByZXN0cmljdCBFXG5cdCAqIEBkZXNjcmlwdGlvbiBPIGNvbXBvbmVudGUgR3VtZ2FCcmVhZGNydW1iIHNlcnZlIHBhcmEgbW9zdHJhciBhbyB1c3XDoXJpbyBhIGxpc3RhIGRhcyBww6FnaW5hcyB2aXNpdGFkYXMuIEVzdGUgY29tcG9uZW50ZSBhdHVhbWVudGVcblx0ICogZnVuY2lvbmEgY2FzbyBleGlzdGEgZGVwZW5kw6puY2lhIGRvIFt1aS1yb3V0ZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyLXVpL3VpLXJvdXRlcikuXG5cdCAqIFxuXHQgKiBPIGNvbXBvbmVudGUgR3VtZ2FCcmVhZGNydW1iIG91dmUgYW8gZXZlbnRvIGBicmVhZENoYW5nZWRgLCBxdWUgcmVjZWJlIG9zIHN0YXRlcyBxdWUgZXN0w6NvIHNlbmRvIHZpc2l0YWRvcy4gVW1hIGRhcyBpbXBsZW1lbnRhw6fDtWVzIHBvc3PDrXZlaXMgcGFyYSBlc3NlXG5cdCAqIGV2ZW50byBicmVhZENoYW5nZWQgw6kgYSBzZWd1aW50ZTpcblx0ICogPHByZT5cblx0ICogJHJvb3RTY29wZS5icmVhZGNydW1icyA9IFtdO1xuICAgICAgJHJvb3RTY29wZS4kb24oJyRzdGF0ZUNoYW5nZVN1Y2Nlc3MnLCBmdW5jdGlvbiAoZXZlbnQsIHRvU3RhdGUpIHtcbiAgICAgICAgdXBkYXRlQnJlYWRjcnVtYih0b1N0YXRlLm5hbWUsIHRvU3RhdGUuZGF0YS5pZCk7XG4gICAgICB9KTtcbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZUJyZWFkY3J1bWIoc3RhdGUsIGlkKSB7XG4gICAgICAgICAgZnVuY3Rpb24gZ2V0KGlkKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSAkcm9vdFNjb3BlLmJyZWFkY3J1bWJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS5icmVhZGNydW1ic1tpXS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaWQgJiYgZ2V0KGlkKSA+PSAwKSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuYnJlYWRjcnVtYnMuc3BsaWNlKGdldChpZCksICRyb290U2NvcGUuYnJlYWRjcnVtYnMubGVuZ3RoIC0gZ2V0KGlkKSwge3N0YXRlOiBzdGF0ZSwgaWQ6IGlkfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5icmVhZGNydW1icy5wdXNoKHtzdGF0ZTogc3RhdGUsIGlkOiBpZH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAhaWQgPyAkcm9vdFNjb3BlLmJyZWFkY3J1bWJzID0gW10gOiBhbmd1bGFyLm5vb3A7XG4gICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdicmVhZENoYW5nZWQnKTtcbiAgICAgIH1cblx0ICogPC9wcmU+IFxuXHQgKiBFc3RlIGPDs2RpZ28gZm9pIGNvbG9jYWRvIGRlbnRybyBkbyBgcnVuYCBkbyBtw7NkdWxvIHByaW5jaXBhbCBkYSBhcGxpY2HDp8Ojby5cblx0ICovXG5cblx0ZnVuY3Rpb24gQnJlYWRjcnVtYigkcm9vdFNjb3BlKXtcblx0XHR2YXIgdGVtcGxhdGUgPSBbXG5cdFx0JzxvbCBjbGFzcz1cImJyZWFkY3J1bWJcIj4nLFxuXHRcdCc8bGkgbmctcmVwZWF0PVwiYnJlYWQgaW4gYnJlYWRjcnVtYnNcIiA+PGEgdWktc3JlZj1cInt7OjpicmVhZC5zdGF0ZX19XCI+e3s6OmJyZWFkLnN0YXRlfX08L2E+PC9saT4nLFxuXHRcdCc8L29sPidcblx0XHRdO1xuXHRcdHJldHVybiB7XG5cdFx0XHRyZXN0cmljdDogJ0UnLFxuXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmpvaW4oJ1xcbicpLFxuXHRcdFx0cmVwbGFjZTogdHJ1ZSxcblx0XHRcdGxpbms6IGZ1bmN0aW9uKCRzY29wZSwgJGVsbSwgJGF0dHJzKXtcblx0XHRcdFx0JHNjb3BlLiRvbignYnJlYWRDaGFuZ2VkJyxmdW5jdGlvbigpe1xuXHRcdFx0XHRcdCRzY29wZS5icmVhZGNydW1icyA9ICRyb290U2NvcGUuYnJlYWRjcnVtYnMuZmlsdGVyKGZ1bmN0aW9uKGUpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIGUuc3RhdGUuc3BsaXQoJy4nKS5sZW5ndGggPj0yIDtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5icmVhZGNydW1iJyxbXSlcblx0LmRpcmVjdGl2ZSgnZ3VtZ2FCcmVhZGNydW1iJyxCcmVhZGNydW1iKTtcbn0pKCk7IiwiLy8gZGVmaW5lID0gUmVxdWlyZS5qc1xuKGZ1bmN0aW9uKCl7XG4gICd1c2Ugc3RyaWN0JztcblxuICAgIENvdW50ZXIuJGluamVjdCA9IFtcIiRjb21waWxlXCJdO1xuICAgICAgLyoqXG4gICAgICAgKiBAbmdkb2MgZGlyZWN0aXZlXG4gICAgICAgKiBAbmFtZSBndW1nYS5jb3JlOmd1bWdhQ291bnRlclxuICAgICAgICogQGVsZW1lbnQgaW5wdXRcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBPIGNvbXBvbmVudGUgZ3VtZ2FDb3VudGVyIHBlcm1pdGUgZXNjb2xoZXIgdW0gdGFtYW5obyBtw6F4aW1vIHBlcm1pdGlkbyBubyBjYW1wbywgdGFtYsOpbSBjcmlhIHVtIGNvbnRhZG9yIGRlIGNhcmFjdGVyZXMgaW5kaWNhbmRvIHNlIG9zIGNhcmFjdGVyZXNcbiAgICAgICAqIHBhc3NhcmFtIGRvIGxpbWl0ZSBvdSBuw6NvLiBcbiAgICAgICAqIFxuICAgICAgICogQ2FzbyB1bSB2YWxvciBzZWphIHBhc3NhZG8gcGFyYSBhIGRpcmVjdGl2ZSwgZWxhIGF0dWFsaXphcsOhIG8gY29udGFkb3IgYmFzZWFkbyBuZXNzZSBuw7ptZXJvLiBDYXNvIG7Do28sIGVsYSBwZWdhcsOhIG8gdmFsb3JcbiAgICAgICAqIHBhc3NhZG8gcGFyYSBhIGRpcmVjdGl2ZSB7QGxpbmsgZ3VtZ2EuY29yZTpndW1nYU1heExlbmd0aH1cbiAgICAgICAqIFxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqICBVbSBleGVtcGxvIGRhIGRpcmVjdGl2ZSBndW1nYUNvdW50ZXIgZnVuY2lvbmFuZG8gcG9kZSBzZXIgZW5jb250cmFkbyBbYXF1aV0oaHR0cDovL2VtYmVkLnBsbmtyLmNvLzZ4SnVVdWlJNDU2a3FiWE4zUTZmLykuXG4gICAgICAgKiA8cHJlPlxuICAgICAgICogPGlucHV0IG5hbWU9XCJleGFtcGxlXCIgbmctbW9kZWw9XCJleGFtcGxlXCIgZ3VtZ2EtY291bnRlcj1cIjE1XCIgLz5cbiAgICAgICAqIDwvcHJlPlxuICAgICAgKi9cblxuICAgICAgZnVuY3Rpb24gQ291bnRlcigkY29tcGlsZSl7XG4gICAgICAgICAgICByZXR1cm57XG4gICAgICAgICAgICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgICAgICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW0sIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLl9tYXggPSBwYXJzZUludChhdHRycy5ndW1nYU1heExlbmd0aFRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHBhcnNlSW50KGF0dHJzLmd1bWdhQ291bnRlcikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5fbWF4ID0gcGFyc2VJbnQoYXR0cnMuZ3VtZ2FDb3VudGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSAnPHAgY2xhc3M9XCJ7e19tYXggPD0gdGVzdGUubGVuZ3RoID8gXFwndGV4dC1kYW5nZXJcXCcgOiBcXCd0ZXh0LW11dGVkXFwnfX1cIj57e19tYXggPD0gJysgYXR0cnMubmdNb2RlbCArJy5sZW5ndGggPyBcIlZvY8OqIHBhc3NvdSBvIGxpbWl0ZSBkZSAnK3Njb3BlLl9tYXgrJyBjYXJhY3RlcmVzXCIgOiBfbWF4IC0gJysgYXR0cnMubmdNb2RlbCArJy5sZW5ndGggKyBcIiBjYXJhY3RlcmVzIHJlc3RhbnRlc1wiIH19PC9wPic7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0uYWZ0ZXIoJGNvbXBpbGUodGVtcGxhdGUpKHNjb3BlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgYW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMuY291bnRlcicsIFtdKVxuICAgICAgICAuZGlyZWN0aXZlKCdndW1nYUNvdW50ZXInLCBDb3VudGVyKTtcblxuXG59KSgpO1xuIiwiIiwiKGZ1bmN0aW9uICgpIHtcblxuXG4gIGFuZ3VsYXIubW9kdWxlKCdndW1nYS5kaXJlY3RpdmVzLmZvcm0nLFtcbiAgICAnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtLmZvcm0nLFxuICAgICdndW1nYS5kaXJlY3RpdmVzLmZvcm0uZXJyb3JzJyxcbiAgICAnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtLmVycm9yJyxcbiAgICAnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtLm1heC5kYXRlJyxcbiAgICAnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtLm1heC5sZW5ndGgnLFxuICAgICdndW1nYS5kaXJlY3RpdmVzLmZvcm0ubWF4Lm51bWJlcicsXG4gICAgJ2d1bWdhLmRpcmVjdGl2ZXMuZm9ybS5taW4uZGF0ZScsXG4gICAgJ2d1bWdhLmRpcmVjdGl2ZXMuZm9ybS5taW4ubGVuZ3RoJyxcbiAgICAnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtLm1pbi5udW1iZXInLFxuICAgICdndW1nYS5kaXJlY3RpdmVzLmZvcm0ucGF0dGVybicsXG4gICAgJ2d1bWdhLmRpcmVjdGl2ZXMuZm9ybS5yYW5nZS5kYXRlJyxcbiAgICAnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtLnJhbmdlLm51bWJlcicsXG4gICAgJ2d1bWdhLmRpcmVjdGl2ZXMuZm9ybS5yZXF1aXJlZCcsXG4gICAgJ2d1bWdhLmRpcmVjdGl2ZXMuZm9ybWJ1dHRvbnMnXG4gIF0pXG5cblxufSkoKTtcbiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogQG5nZG9jIGRpcmVjdGl2ZVxuICAgICAqIEBuYW1lIGd1bWdhLmNvcmU6Z3VtZ2FGb3JtQnV0dG9uc1xuICAgICAqIEByZXN0cmljdCBFXG4gICAgICogQGRlc2NyaXB0aW9uIE8gY29tcG9uZW50ZSBndW1nYUZvcm1CdXR0b25zIHBvZGUgc2VyIHV0aWxpemFkbyBwYXJhIHF1YW5kbyBuZWNlc3NpdGUgZGUgYm90w7VlcyBwYXJhIG8gZm9ybXVsw6FyaW8sXG4gICAgICogdGFudG8gZGUgY29udGludWFyIGluc2VyaW5kbywgZGUgc2FsdmFyIGUgcmV0cm9jZWRlci5cbiAgICAgKlxuICAgICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJtaXQgUGFyw6JtZXRybyBvYnJpZ2F0w7NyaW8gcXVlIGNvbnTDqW0gdW1hIGZ1bsOnw6NvIHF1ZSBzZXLDoSBleGVjdXRhZGEgcXVhbmRvIG8gYm90w6NvIGRlIGNvbnRpbnVhciBmb3IgY2xpY2Fkby5cbiAgICAgKiAgQHBhcmFtIHtib29sZWFufSB2YWxpZCBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW0gdmFsb3IgYm9vbGVhbm8gcGFyYSB2YWxpZGFyIGNhc28gbyBmb3JtdWzDoXJpbyDDqSB2w6FsaWRvIHBhcmEgbGliZXJhciBvIGJvdMOjbyBkZSBzYWx2YXIuXG4gICAgICogIEBwYXJhbSB7T2JqZWN0fSBjb250aW51ZSBPYmplY3QgcXVlIGRldmVyw6EgY29udGVyIHVtIGF0cmlidXRvIGJvb2xlYW5vIGNoYW1hZG8gYHZhbHVlYCwgcGFyYSBjb250cm9sYXIgY2FzbyBjb250aW51YXLDoSBpbnNlcmluZG8gb3UgbsOjby4gRXNzYSBcbiAgICAgKiAgb3DDp8OjbyBhcGFyZWNlcsOhIGFwZW5hcyBxdWFuZG8gbyBvYmpldG8gJHN0YXRlUGFyYW1zKHBlcnRlbmNlbnRlIGFvIHVpLXJvdXRlcikgbsOjbyBwb3NzdWlyIHVtIGlkLCBvdSBzZWphLCBjYXNvIGVzdGVqYSBudW1hIHRlbGEgZGUgaW5zZXLDp8Ojby5cbiAgICAgKiAgQHBhcmFtIHtib29sZWFufSBjb25maXJtLWRpcnR5IFBhcsOibWV0cm8gbsOjbyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtIGJvb2xlYW5vIHBhcmEgaW5kaWNhciBjYXNvIGRlc2VqZSB0ZXIgdW1hIGNvbmZpcm1hw6fDo28gZGUgc2HDrWRhIGRvIGZvcm11bMOhcmlvXG4gICAgICogIHF1YW5kbyBlc3RlIGZvaSBhbHRlcmFkbyBhbGd1bWEgdmV6LlxuICAgICAqL1xuXHRGb3JtQnV0dG9ucy4kaW5qZWN0ID0gW1wiJHN0YXRlXCIsIFwiJHN0YXRlUGFyYW1zXCIsIFwiJG1vZGFsXCIsIFwiJHJvb3RTY29wZVwiXTtcbiAgICBmdW5jdGlvbiBGb3JtQnV0dG9ucygkc3RhdGUsICRzdGF0ZVBhcmFtcywkbW9kYWwsJHJvb3RTY29wZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgICAgICAgZG86ICcmc3VibWl0JyxcbiAgICAgICAgICAgICAgICB2YWxpZDogJz0nLFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOiAnPT8nLFxuICAgICAgICAgICAgICAgIGNvbmZpcm1EaXJ0eTogJz0/J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlOlxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmdWxsLXdpZHRoLXdpdGhvdXQtbWFyZ2luXCI+JytcbiAgICAgICAgICAgICcgICA8c2NvcGU+PC9zY29wZT4nK1xuICAgICAgICAgICAgJyAgIDxkaXYgbmctY2xhc3M9XCJnZXRQb3NpdGlvbigpXCI+JyArXG4gICAgICAgICAgICAnICAgICAgIDxsYWJlbCBpZD1cImNvbnRpbnVhckluc2VyaW5kb1wiIG5nLWlmPVwiY29udGludWVcIiA+JytcbiAgICAgICAgICAgICcgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuYW1lPVwiY29udGludWFyXCIgbmctbW9kZWw9XCJjb250aW51ZS52YWx1ZVwiLz4nICtcbiAgICAgICAgICAgICcgICAgICAgICAgIDxzcGFuPkNvbnRpbnVhciBJbnNlcmluZG88L3NwYW4+JytcbiAgICAgICAgICAgICcgICAgICAgPC9sYWJlbD4nICtcbiAgICAgICAgICAgICcgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4td2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAwLjhlbVwiIG5nLWNsaWNrPVwiYmFjaygpXCIgdHlwZT1cImJ1dHRvblwiPjxpIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1mbG9wcHktcmVtb3ZlXCI+PC9pPiBCYWNrPC9idXR0b24+JyArXG4gICAgICAgICAgICAnICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXByaW1hcnlcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMFwiIG5nLWNsaWNrPVwiZG8oKVwiIG5nLWRpc2FibGVkPVwiIXZhbGlkXCIgdHlwZT1cImJ1dHRvblwiPjxpIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1mbG9wcHktc2F2ZWRcIj48L2k+IFNhdmU8L2J1dHRvbj4nICtcbiAgICAgICAgICAgICcgICA8L2Rpdj4nK1xuICAgICAgICAgICAgJzxkaXY+JyxcbiAgICAgICAgICAgIHJlcXVpcmU6ICdeZm9ybScsXG4gICAgICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsbSwgYXR0cnMsIGN0cmwpIHtcbiAgICAgICAgICAgICAgICBpZighYXR0cnMuY29uZmlyRGlydHkpIHNjb3BlLmNvbmZpcm1EaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYoISRzdGF0ZVBhcmFtcy5pZCkgc2NvcGUuaW5OZXcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmKCFhdHRycy5jb250aW51ZSkgc2NvcGUuY29udGludWUgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHNjb3BlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cnMucG9zaXRpb24gPT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3B1bGwtbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdwdWxsLXJpZ2h0JztcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgc2NvcGUuYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoc2NvcGUuY29uZmlybURpcnR5ICYmIGN0cmwuJGRpcnR5KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RhbCA9ICRtb2RhbC5vcGVuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGRpdj4nK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgICA8c2VjdGlvbiBjbGFzcz1cIm1vZGFsLWJvZHlcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnICAgICAgIDxoND5EZXNlamEgc2FpciBzZW0gc2FsdmFyIGFzIGFsdGVyYcOnw7Vlcz88L2g0PicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgICA8L3NlY3Rpb24+JytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnICAgPGRpdiBjbGFzcz1cIm1vZGFsLWZvb3RlclwiPicrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0XCIgbmctY2xpY2s9XCJoYW5kbGVDbG9zZShmYWxzZSlcIj5Ow6NvPC9idXR0b24+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0XCIgbmctY2xpY2s9XCJoYW5kbGVDbG9zZSh0cnVlKVwiPlNpbTwvYnV0dG9uPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgICA8L2Rpdj4nK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tkcm9wOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlib2FyZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogJ3NtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBbXCIkc2NvcGVcIiwgXCIkbW9kYWxJbnN0YW5jZVwiLCBcIiRzdGF0ZVwiLCBcIiRyb290U2NvcGVcIiwgZnVuY3Rpb24oJHNjb3BlLCRtb2RhbEluc3RhbmNlLCRzdGF0ZSwkcm9vdFNjb3BlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmhhbmRsZUNsb3NlID0gZnVuY3Rpb24oX2Jvb2xlYW4pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Jvb2xlYW4gPyAkbW9kYWxJbnN0YW5jZS5jbG9zZSh0cnVlKSA6ICRtb2RhbEluc3RhbmNlLmNsb3NlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTsgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZigkc3RhdGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmN1cnJlbnRTdGF0ZSA9JHN0YXRlLmN1cnJlbnQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJG9uKCckc3RhdGVDaGFuZ2VTdGFydCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXZlbnQsIHRvU3RhdGUsIHRvUGFyYW1zLCBmcm9tU3RhdGUsIGZyb21QYXJhbXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW9kYWxJbnN0YW5jZS5kaXNtaXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGFsLnJlc3VsdC50aGVuKGZ1bmN0aW9uKHNob3VsZElHbyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2hvdWxkSUdvKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKGF0dHJzLmJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oYXR0cnMuYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9IFxuICAgIH1cblxuYW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMuZm9ybWJ1dHRvbnMnLFsndWkuYm9vdHN0cmFwJywndWkucm91dGVyJ10pXG4uZGlyZWN0aXZlKCdndW1nYUZvcm1CdXR0b25zJyxGb3JtQnV0dG9ucyk7XG5cbn0pKCk7IiwiKGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIExpc3QuJGluamVjdCA9IFtcIkd1bWdhTGlzdEhlbHBlclwiLCBcIiRjb21waWxlXCJdO1xuXG4gIGZ1bmN0aW9uIExpc3QoR3VtZ2FMaXN0SGVscGVyLCRjb21waWxlKXtcbiAgICAvKipcbiAgICAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAgICAqIEBuYW1lIGd1bWdhLmNvcmU6Z3VtZ2FMaXN0XG4gICAgKiBAcmVzdHJpY3QgRVxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiBcdEEgZGlyZWN0aXZlIGd1bWdhTGlzdCBmb2kgZGVzZW52b2x2aWRhIHBhcmEgc3Vic3RpdHVpciBhIGFudGlnYSBndW1nYVRhYmxlLiBFbGEgw6kgbWFpcyBjb25maWd1csOhdmVsIHF1ZSBhIGFudGlnYSB0YWJsZSwgZSB0cmF6IHVtIG1laW8gbWFpcyBmw6FjaWwgZGUgY29uZmlndXJhci5cbiAgICAqICBcdE8gY29tcG9uZW50ZSBwb3NzdWkgZG9pcyB0aXBvcyBkZSBjb25maWd1cmHDp8OjbzogZGlyZXRhbWVudGUgbm8gaHRtbCBlIGF0cmF2w6lzIGRlIHVtIG9iamV0byBqYXZhc2NyaXB0LlxuICAgICpcbiAgICAqIFx0IyBDb25maWd1cmHDp8OjbyBkYSB0YWJsZSBhdHJhdsOpcyBkZSB1bSBPYmpldG8gSmF2YXNjcmlwdFxuICAgICpcbiAgICAqXHRcdFBhcmEgYXBsaWNhciBhIGNvbmZpZ3VyYcOnw6NvIG5hIHRhYmxlLCBleGlzdGVtIG9zIHNlZ3VpbnRlcyBhdHJpYnV0b3M6XG4gICAgKlxuICAgICogfCBQYXJhbSB8IFR5cGUgIHwgRGVmYXVsdCB8IERldGFpbHMgfFxuICAgICogfC0tLS0tLS18LS0tLS0tLXwtLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLXxcbiAgICAqIHxzZWxlY3Rpb258U3RyaW5nfCBzaW5nbGUgfCBWYWxvciBxdWUgc2Vyw6EgdXRpbGl6YWRvIHBhcmEgZGVmaW5pciBjb21vIHNlcsOhIGEgc2VsZcOnw6NvIGRhIHRhYmVsYS4gUG9zc8OtdmVpcyB2YWxvcmVzOiA8bGFiZWwgY2xhc3M9XCJsYWJlbCB0eXBlLWhpbnQgdHlwZS1oaW50LXN0cmluZ1wiPlttdWx0aSAvIHNpbmdsZV08L2xhYmVsPiB8XG4gICAgKiB8aXRlbXNQZXJQYWdlfEFycmF5fCBbMTAsMjAsMzAsNDAsNTBdIHwgVmFsb3IgcXVlIHNlcsOhIHV0aWxpemFkbyBwYXJhIGRlZmluaXIgbyBuw7ptZXJvIGRlIHJlZ2lzdHJvcyBzZWxlY2lvbmFkbyBwZWxvIHVzdcOhcmlvLiBPIHZhbG9yIGVzY29saGlkbyBzZXLDoSBleHBvc3RvIG5vICRzY29wZSBhdHJhdsOpcyBkYSB2YXJpw6F2ZWwgaXRlbXNQZXJQYWdlIHxcbiAgICAqIHxzb3J0RGVmYXVsdCB8IFN0cmluZyB8IHwgVmFsb3IgcXVlIHNlcsOhIHV0aWxpemFkbyBwYXJhIGRlZmluaXIgcXVhbCBvIGNhbXBvIHBhZHLDo28gZGUgb3JkZW5hw6fDo28uIEVzdGUgdmFsb3Igc2Vyw6EgbyBpZGVudGlmaWNhZG9yIGRhIGNvbHVuYS5cbiAgICAqIHxjb2x1bW5zIHxTdHJpbmd8IHwgVmFsb3IgcXVlIGlyw6EgZGVmaW5pciBxdWFpcyBhcyBjb2x1bmFzIGUgYSBvcmRlbmHDp8OjbyBkZWxhcy4gTyBmb3JtYXRvIGRldmUgZXN0YXIgbm8gc2VndWludGUgcGFkcsOjbzogPGxhYmVsIGNsYXNzPVwibGFiZWwgdHlwZS1oaW50IHR5cGUtaGludC1zdHJpbmdcIj5bY29sdW1uMSxjb2x1bW4yLC4uLixjb2x1bW5OXTwvbGFiZWw+XG4gICAgKiB8Y29uZGl0aW9uYWwgfCBGdW5jdGlvbiB8IGFuZ3VsYXIubm9vcCB8IFZhbG9yIHF1ZSBzZXLDoSB1dGlsaXphZG8gcGFyYSBmYXplciBhIGZvcm1hdGHDp8OjbyBjb25kaWNpb25hbCBkbyByZWdpc3Ryby4gQSBmdW7Dp8OjbyBkZXZlIHJldG9ybmFyIHVtIG9iamV0byBxdWUgY29udMOpbSBhIGNsYXNzZSBlIGEgY29tcGFyYcOnw6NvIHV0aWxpemFkYSA8bGFiZWwgY2xhc3M9XCJsYWJlbCB0eXBlLWhpbnQgdHlwZS1oaW50LXN0cmluZ1wiPltmdW5jdGlvbih2YWx1ZSl7IHJldHVybiB7JzJweCBzb2xpZCByZWQnOiB2YWx1ZS5hZ2UgPCAxOH0gfV08L2xhYmVsPlxuICAgICogfGNvbHVtbnNDb25maWcgfEFycmF5IHxbXXwgQXJyYXkgcXVlIHNlcsOhIHV0aWxpemFkbyBwYXJhIGNvbmZpZ3VyYXIgYXMgY29sdW5hcyBxdWUgZm9yYW0gZGVmaW5pZGFzIG5vIGF0cmlidXRvIGNvbHVtbnMuXG4gICAgKlxuICAgICogIyBDb25maWd1cmHDp8OjbyBkYSBjb2x1bmEgYXRyYXbDqXMgZGUgdW0gT2JqZXRvIEphdmFzY3JpcHRcbiAgICAqXHRQYXJhIGNvbmZpZ3VyYXIgYXMgY29sdW5hcywgZGVudHJvIGRvIGF0cmlidXRvIGNvbHVtbnNDb25maWcsIHPDo28gY3JpYWRvcyBvYmpldG9zIHF1ZSBwb2RlcsOjbyB0ZXIgYXMgc2VndWludGVzIGNvbmZpZ3VyYcOnw7VlczpcbiAgICAqXG4gICAgKiB8IFBhcmFtIHwgVHlwZSAgfCBEZWZhdWx0IHwgRGV0YWlscyB8XG4gICAgKiB8LS0tLS0tLXwtLS0tLS0tfC0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tfFxuICAgICogfG5hbWUgfCBTdHJpbmcgfCAgfCBWYWxvciBxdWUgc2Vyw6EgdXRpbGl6YWRvIHBhcmEgaWRlbnRpZmljYXIgYSBjb2x1bmEuIEVzdGUgbmFtZSBkZXZlIHNlciBvIG1lc21vIHF1ZSBlc3TDoSBubyBhdHJpYnV0byAnY29sdW1ucycsXG4gICAgKiB8dGl0bGV8U3RyaW5nfCBOT01FX0RBX0NPTFVOQS50b1VwcGVyQ2FzZSgpIHwgVmFsb3IgcXVlIHNlcsOhIHJlbmRlcml6YWRvIG5vIHTDrXR1bG8gZGEgY29sdW5hLlxuICAgICogfHNpemV8U3RyaW5nfCAnY29sLW1kLTMnIHwgVGFtYW5obyBkYSBjb2x1bmEgYmFzZWFkbyBub3MgdmFsb3JlcyBkbyBib290c3RyYXAuIEV4ZW1wbG86ICoqIGNvbC1tZC14ICoqXG4gICAgKiB8Y29udGVudCB8U3RyaW5nfHt7JHZhbHVlLk5PTUVfREFfQ09MVU5BfX0gfCBWYWxvciBxdWUgc2Vyw6EgcmVuZGVyaXphZG8gbm8gY29udGXDumRvIGRhIGNvbHVuYS5cbiAgICAqIHxzb3J0RmllbGQgfFN0cmluZyB8IHwgU3RyaW5nIHF1ZSBzZXLDoSAgdXNhZGEgcGFyYSBmYXplciBhIG9yZGVuYcOnw6NvLCBlIHF1ZSBpcsOhIGNvbW8gcGFyw6JtZXRybyBuYSBmdW7Dp8OjbyBkZSBvcmRlbmHDp8Ojby4uXG4gICAgKiB8Y29uZGl0aW9uYWwgfCBGdW5jdGlvbiB8IGFuZ3VsYXIubm9vcCB8IFZhbG9yIHF1ZSBzZXLDoSB1dGlsaXphZG8gcGFyYSBmYXplciBhIGZvcm1hdGHDp8OjbyBjb25kaWNpb25hbCBkbyByZWdpc3Ryby4gQSBmdW7Dp8OjbyBkZXZlIHJldG9ybmFyIHVtIG9iamV0byBxdWUgY29udMOpbSBhIGNsYXNzZSBlIGEgY29tcGFyYcOnw6NvIHV0aWxpemFkYSA8bGFiZWwgY2xhc3M9XCJsYWJlbCB0eXBlLWhpbnQgdHlwZS1oaW50LXN0cmluZ1wiPltmdW5jdGlvbih2YWx1ZSl7IHJldHVybiB7JzJweCBzb2xpZCByZWQnOiB2YWx1ZS5hZ2UgPCAxOH0gfV08L2xhYmVsPlxuICAgICpcbiAgICAqXG4gICAgKlx0ICBAcGFyYW0ge0Z1bmN0aW9ufSBzb3J0IFBhcsOibWV0cm8gcXVlIGNvbnTDqW0gdW1hIGZ1bsOnw6NvIHF1ZSBzZXLDoSBjaGFtYWRhIHBhcmEgcXVlIG8gZGVzZW52b2x2ZWRvciBwb3NzYSBmYXplciBhIG9yZGVuYcOnw6NvIGRvcyByZWdpc3Ryb3MuXG4gICAgKlx0ICBAcGFyYW0ge1N0cmluZ30gY2xhc3MgUGFyw6JtZXRybyBwYXJhIGFwbGljYXIgbmEgdGFibGUgdW1hIGNsYXNzZSBlc3BlY8OtZmljYS5cbiAgICAqXHQgIEBwYXJhbSB7QXJyYXl9IGRhdGEgUGFyw6JtZXRybyBxdWUgaXLDoSBjb250ZXIgb3MgZGFkb3MgcXVlIHNlcsOjbyBtb3N0cmFkb3MgbmEgdGFiZWxhLlxuICAgICpcdCAgQHBhcmFtIHtGdW5jdGlvbn0gb25DbGljayBGdW7Dp8OjbyBxdWUgc2Vyw6EgZXhlY3V0YWRhIHF1YW5kbyBvIHVzdcOhcmlvIGNsaWNhciBlbSB1bSByZWdpc3Ryb1xuICAgICpcdCAgQHBhcmFtIHtGdW5jdGlvbn0gb25Tb3J0IEZ1bsOnw6NvIHF1ZSBzZXLDoSBleGVjdXRhZGEgcXVhbmRvIGEgb3JkZW5hw6fDo28gZm9yIHJlYWxpemFkYVxuICAgICpcdCAgQHBhcmFtIHtGdW5jdGlvbn0gb25Eb3VibGVDbGljayBGdW7Dp8OjbyBxdWUgc2Vyw6EgZXhlY3V0YWRhIHF1YW5kbyBvIHVzdcOhcmlvIGNsaWNhciBkdWFzIHZlemVzIGVtIHVtIHJlZ2lzdHJvLlxuICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGN0cmwoJHNjb3BlLCAkZWxlbWVudCwgJGF0dHJzLCAkdHJhbnNjbHVkZSl7XG4gICAgICBmdW5jdGlvbiB2ZXJpZnlFbXB0eSgkdixvdGhlcil7cmV0dXJuICghJGF0dHJzLiR2ID8gb3RoZXIgOiB2bVskdl0pfTtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICAvLyBWYWxvcmVzIHV0aWxpemFkb3MgcGVsYSBhcGxpY2HDp8Ojb1xuICAgICAgdm0uc2VsZWN0ZWRJbmRleGVzID0gW11cbiAgICAgIHZtLnNlbGVjdGVkSXRlbTtcbiAgICAgIHZtLnNlbGVjdGVkSXRlbURpcjtcbiAgICAgIHZtLiRwYXJlbnQgPSAkc2NvcGUuJHBhcmVudDtcblxuICAgICAgLy8gRnVuw6fDtWVzIHV0aWxpemFkYXNcbiAgICAgIHZtLnNvcnRQcm94eSA9IHNvcnRQcm94eTtcbiAgICAgIHZtLnNlbGVjdFJvdyA9IHNlbGVjdFJvdztcbiAgICAgIHZtLmRvdWJsZSA9IGRvdWJsZTsnJ1xuICAgICAgdm0uY29uZGl0aW9uYWwgPSBjb25kO1xuICAgICAgdm0uY29uZGl0aW9uYWxUYWJsZUNlbGwgPSBjb25kaXRpb25hbFRhYmxlQ2VsbDtcbiAgICAgIHZtLnNlbGVjdEFsbCA9IHNlbGVjdEFsbDtcbiAgICAgIC8vIFZhbG9yZXMgcXVlIHNlcsOjbyBleHBvc3RvcyBubyAkc2NvcGVcbiAgICAgICRzY29wZS4kcGFyZW50LnNlbGVjdGVkVmFsdWVzID0gW107XG4gICAgICAkc2NvcGUuJHBhcmVudC5pdGVtc1BlclBhZ2U7XG4gICAgICAvLyBOw7ptZXJvIGRlIGl0ZW5zIG5hIHDDoWdpbmFcbiAgICAgIHZtLnBhZ2UgPSAkc2NvcGUuJHBhcmVudC5pdGVtc1BlclBhZ2U7XG5cbiAgICAgIHZtLm9yaWdpbmFsRGF0YSA9IHZtLmRhdGE7XG4gICAgICB2bS5kYXRhID0gYW5ndWxhci5jb3B5KHZtLmRhdGEpIHx8IFtdO1xuICAgICAgdm0uY29uZmlnID0gdm0uY29uZmlnIHx8IHt9XG4gICAgICB2bS5kYXRhLmZvckVhY2goZnVuY3Rpb24odmFsKXt2YWwuX19jaGVja2VkID0gZmFsc2U7fSk7XG4gICAgICB2bS5jb25maWcuc2VsZWN0aW9uID0gdm0uY29uZmlnLnNlbGVjdGlvbiB8fCAnc2luZ2xlJztcbiAgICAgIHZtLmNvbmZpZy5zb3J0RGVmYXVsdCA9IHZtLmNvbmZpZy5zb3J0RGVmYXVsdDtcbiAgICAgIHZtLmNvbmZpZy5pdGVtc1BlclBhZ2UgPSB2bS5jb25maWcuaXRlbXNQZXJQYWdlIHx8IFsxMCwyMCwzMCw0MCw1MF07XG4gICAgICB2bS5jb25maWcuY29sdW1uc0NvbmZpZyA9IHZtLmNvbmZpZy5jb2x1bW5zQ29uZmlnIHx8IFtdO1xuICAgICAgdm0uY29uZmlnLmNvbmRpdGlvbmFsID0gdm0uY29uZmlnLmNvbmRpdGlvbmFsIHx8IGFuZ3VsYXIubm9vcDtcbiAgICAgIHZtLmNvbmZpZy5zb3J0ID0gdmVyaWZ5RW1wdHkoJ3NvcnQnLGFuZ3VsYXIubm9vcCk7XG4gICAgICB2bS5jb25maWcuY2xhc3MgPSAkYXR0cnMuY2xhc3MgPyAndGFibGUgJyArICRhdHRycy5jbGFzcyA6ICd0YWJsZSc7XG4gICAgICB2bS5jb25maWcub25DbGljayA9IHZlcmlmeUVtcHR5KCdvbkNsaWNrJyxhbmd1bGFyLm5vb3ApO1xuICAgICAgdm0uY29uZmlnLm9uRG91YmxlQ2xpY2sgPSB2ZXJpZnlFbXB0eSgnb25Eb3VibGVsaWNrJyxhbmd1bGFyLm5vb3ApO1xuICAgICAgdm0uY29uZmlnLm9uU29ydCA9IHZlcmlmeUVtcHR5KCdvblNvcnQnLGFuZ3VsYXIubm9vcCk7XG4gICAgICBpZih2bS5jb25maWcuc29ydERlZmF1bHQpc29ydFByb3h5KHZtLmNvbmZpZy5zb3J0RGVmYXVsdCk7XG4gICAgICBpZiAodm0uZGF0YSAmJiB2bS5kYXRhLmxlbmd0aCA+IDApe1xuICAgICAgICB2bS5jb25maWcuY29sdW1ucyA9XG4gICAgICAgICEhdm0uY29uZmlnLmNvbHVtbnMgP1xuICAgICAgICBHdW1nYUxpc3RIZWxwZXIuZW5zdXJlRGVmYXVsdFZhbHVlcyh2bS5jb25maWcuY29sdW1ucy5zcGxpdCgnLCcpLHZtLmNvbmZpZy5jb2x1bW5zQ29uZmlnKSA6IEd1bWdhTGlzdEhlbHBlci5sb2FkRGVmYXVsdENvbHVtbnModm0uZGF0YVswXSk7XG4gICAgICAgIHZtLmNvbmZpZy5hdXhDb2x1bW5zVG9Tb3J0ID0gdm0uY29uZmlnLmNvbHVtbnM7XG4gICAgICB9XG5cbiAgICAgICRlbGVtZW50LmFwcGVuZCgkY29tcGlsZShHdW1nYUxpc3RIZWxwZXIubW91bnRUYWJsZSh2bS5jb25maWcpKSgkc2NvcGUpKTtcblxuICAgICAgZnVuY3Rpb24gc2VsZWN0QWxsKGNoZWNrYm94Qm9vbGVhbil7XG4gICAgICAgIGNsZWFuQXJyYXlzKCk7XG4gICAgICAgIHZtLmRhdGEuZm9yRWFjaChmdW5jdGlvbihkYXRhLGluZGV4KXtcbiAgICAgICAgICBkYXRhLl9fY2hlY2tlZCA9IGNoZWNrYm94Qm9vbGVhbjtcbiAgICAgICAgICBpZihjaGVja2JveEJvb2xlYW4pcHVzaFRvQXJyYXlzKGRhdGEsaW5kZXgpO1xuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmaW5kSW5PcmlnaW5hbEFycmF5KHZhbCl7XG4gICAgICAgIHZhciBjb3B5V2l0aG91dENoZWNrZWRBdHRyaWJ1dGVzID0gYW5ndWxhci5jb3B5KHZhbCk7XG4gICAgICAgIGRlbGV0ZSBjb3B5V2l0aG91dENoZWNrZWRBdHRyaWJ1dGVzLl9fY2hlY2tlZDtcbiAgICAgICAgcmV0dXJuIHZtLm9yaWdpbmFsRGF0YS5maWx0ZXIoZnVuY3Rpb24ob3JpZ2luYWxSZWdpc3RyeSl7XG4gICAgICAgICAgcmV0dXJuIGFuZ3VsYXIuZXF1YWxzKG9yaWdpbmFsUmVnaXN0cnksY29weVdpdGhvdXRDaGVja2VkQXR0cmlidXRlcyk7XG4gICAgICAgIH0pWzBdO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY2xlYW5BcnJheXMoKXtcbiAgICAgICAgJHNjb3BlLiRwYXJlbnQuc2VsZWN0ZWRWYWx1ZXMgPSBbXTtcbiAgICAgICAgdm0uc2VsZWN0ZWRJbmRleGVzID0gW107XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwdXNoVG9BcnJheXModmFsLGluZGV4KXtcbiAgICAgICAgdm0uc2VsZWN0ZWRJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICAkc2NvcGUuJHBhcmVudC5zZWxlY3RlZFZhbHVlcy5wdXNoKGZpbmRJbk9yaWdpbmFsQXJyYXkodmFsKSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzZXRFdmVyeUNoZWNrZWRUb0Jvb2xlYW4oYm9vbCl7XG4gICAgICAgIHZtLmRhdGEuZm9yRWFjaChmdW5jdGlvbihlbG0pe1xuICAgICAgICAgIGVsbS5fX2NoZWNrZWQgPSBib29sO1xuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY2xlYW5WYWx1ZUFuZEFycmF5cyhjbGF1c2UsdmFsdWUpe1xuICAgICAgICBpZihjbGF1c2Upe1xuICAgICAgICAgIHNldEV2ZXJ5Q2hlY2tlZFRvQm9vbGVhbihmYWxzZSk7XG4gICAgICAgICAgY2xlYW5BcnJheXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZih2YWx1ZSkgdmFsdWUgPSBmYWxzZTtcbiAgICAgIH1cblxuXG4gICAgICBmdW5jdGlvbiBzZWxlY3RSb3cobmdSZXBlYXRJbmRleCxuZ1JlcGVhdFZhbHVlLCRldmVudCl7XG4gICAgICAgIGlmKCRldmVudC50YXJnZXQudHlwZSA9PSAnYnV0dG9uJyB8fCAkZXZlbnQudGFyZ2V0LnRhZ05hbWUgPT0gJ0EnKXtcbiAgICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGVjdGVkVmFsdWVzID0gJHNjb3BlLiRwYXJlbnQuc2VsZWN0ZWRWYWx1ZXM7XG4gICAgICAgIGNsZWFuVmFsdWVBbmRBcnJheXModm0uY2hlY2tBbGwsdm0uY2hlY2tBbGwpO1xuICAgICAgICBpZigkYXR0cnMub25DbGljayl2bS5vbkNsaWNrKHt2YWx1ZTogbmdSZXBlYXRWYWx1ZX0pO1xuICAgICAgICBpZih2bS5jb25maWcuc2VsZWN0aW9uID09ICdzaW5nbGUnKXtcbiAgICAgICAgICBpZihuZ1JlcGVhdFZhbHVlLl9fY2hlY2tlZCl7XG4gICAgICAgICAgICBuZ1JlcGVhdFZhbHVlLl9fY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY2xlYW5BcnJheXMoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xlYW5WYWx1ZUFuZEFycmF5cyh2bS5zZWxlY3RlZEluZGV4ZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHB1c2hUb0FycmF5cyhuZ1JlcGVhdFZhbHVlLG5nUmVwZWF0SW5kZXgpO1xuICAgICAgICAgICAgbmdSZXBlYXRWYWx1ZS5fX2NoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZ1JlcGVhdFZhbHVlLl9fY2hlY2tlZCA9IHZtLnNlbGVjdGVkSW5kZXhlcy5maWx0ZXIoZnVuY3Rpb24odmFsKXtyZXR1cm4gdmFsID09IG5nUmVwZWF0SW5kZXh9KS5sZW5ndGggPCAxO1xuICAgICAgICAgIGlmKChuZ1JlcGVhdFZhbHVlLl9fY2hlY2tlZCkgfHwgdm0uc2VsZWN0ZWRJbmRleGVzLmxlbmd0aCA9PSAwICl7XG4gICAgICAgICAgICBwdXNoVG9BcnJheXMobmdSZXBlYXRWYWx1ZSxuZ1JlcGVhdEluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5kZXhPZlZhbHVlU2VsZWN0ZWQ7XG4gICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbih2YWwsaW5keCl7XG4gICAgICAgICAgICBpZihhbmd1bGFyLmVxdWFscyh2YWwsbmdSZXBlYXRWYWx1ZSkpIGluZGV4T2ZWYWx1ZVNlbGVjdGVkID0gaW5keDtcbiAgICAgICAgICB9KVxuICAgICAgICAgICRzY29wZS4kcGFyZW50LnNlbGVjdGVkVmFsdWVzLnNwbGljZShpbmRleE9mVmFsdWVTZWxlY3RlZCwgMSk7XG4gICAgICAgICAgdm0uc2VsZWN0ZWRJbmRleGVzLnNwbGljZSh2bS5zZWxlY3RlZEluZGV4ZXMuaW5kZXhPZihuZ1JlcGVhdEluZGV4KSwxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzb3J0UHJveHkoZmllbGQpe1xuICAgICAgICBpZigkYXR0cnMub25Tb3J0KSB2bS5vblNvcnQoe2ZpZWxkOiB2bS5zZWxlY3RlZEl0ZW0sIGRpcjogdm0uc2VsZWN0ZWRJdGVtRGlyfSk7XG4gICAgICAgIGlmKCEkYXR0cnMuc29ydCkgdGhyb3cgJ1lvdSBoYXZlIHRvIHBhc3MgYSBzb3J0IGZ1bmN0aW9uIHRvIEd1bWdhTGlzdCBbc29ydD1cInNvcnQoZmllbGQsZGlyKVwiXSc7XG4gICAgICAgIHZtLnNlbGVjdGVkSXRlbSA9IGZpZWxkO1xuICAgICAgICB2bS5zZWxlY3RlZEl0ZW1EaXIgPT0gJ2FzYycgPyB2bS5zZWxlY3RlZEl0ZW1EaXIgPSAnZGVzYycgOiB2bS5zZWxlY3RlZEl0ZW1EaXIgPSAnYXNjJztcbiAgICAgICAgdm0uc29ydCh7ZmllbGQ6IHZtLnNlbGVjdGVkSXRlbSwgZGlyOiB2bS5zZWxlY3RlZEl0ZW1EaXJ9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZG91YmxlKHZhbHVlKXtcbiAgICAgICAgaWYoJGF0dHJzLm9uRG91YmxlQ2xpY2spIHZtLm9uRG91YmxlQ2xpY2soe3ZhbHVlOiB2YWx1ZX0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjb25kaXRpb25hbFRhYmxlQ2VsbCh2YWx1ZSxvcmRlcmluZyl7XG4gICAgICAgIHZhciBjb2x1bW5Ub0dldFRoZUNvbmRpdGlvbmFsID0gdm0uY29uZmlnLmNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uKHZhbCl7cmV0dXJuIHZhbC5uYW1lID09IG9yZGVyaW5nfSk7XG4gICAgICAgIGlmKGNvbHVtblRvR2V0VGhlQ29uZGl0aW9uYWxbMF0pe1xuICAgICAgICAgIHZhciBvYmogPSBjb2x1bW5Ub0dldFRoZUNvbmRpdGlvbmFsWzBdLmNvbmRpdGlvbmFsKHZhbHVlKVxuICAgICAgICAgICwgICB0cnVlVmFsdWUsIGZhbHNlVmFsdWU7XG4gICAgICAgICAgZm9yKHZhciBrZXkgaW4gb2JqKXtcbiAgICAgICAgICAgIGlmKG9ialtrZXldID09PSB0cnVlKXtcbiAgICAgICAgICAgICAgdHJ1ZVZhbHVlID0ga2V5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmFsc2VWYWx1ZSA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICdcXFwiJy5jb25jYXQodHJ1ZVZhbHVlKS5jb25jYXQoJ1xcXCInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ1xcJ1xcJyc7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBjb25kKHZhbHVlKXtcbiAgICAgICAgdmFyIG9iaiA9IHZtLmNvbmZpZy5jb25kaXRpb25hbCh2YWx1ZSksdHJ1ZVZhbHVlXG4gICAgICAgICwgICBmYWxzZVZhbHVlO1xuICAgICAgICBmb3IodmFyIGtleSBpbiBvYmope1xuICAgICAgICAgIG9ialtrZXldID09PSB0cnVlID90cnVlVmFsdWUgPSBrZXkgOiBmYWxzZVZhbHVlID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmKHRydWVWYWx1ZSl7XG4gICAgICAgICAgcmV0dXJuICdcXFwiJy5jb25jYXQodHJ1ZVZhbHVlKS5jb25jYXQoJ1xcXCInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ1xcJ1xcJyc7XG4gICAgICB9XG4gICAgfVxuICAgIGN0cmwuJGluamVjdCA9IFtcIiRzY29wZVwiLCBcIiRlbGVtZW50XCIsIFwiJGF0dHJzXCIsIFwiJHRyYW5zY2x1ZGVcIl07O1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgc2NvcGU6e1xuICAgICAgICAnc29ydCc6ICcmPycsXG4gICAgICAgICdjbGFzcyc6ICcmPycsXG4gICAgICAgICdkYXRhJzogJz0nLFxuICAgICAgICAnb25DbGljayc6ICcmPycsXG4gICAgICAgICdvbkRvdWJsZUNsaWNrJzogJyY/JyxcbiAgICAgICAgJ29uU29ydCc6ICcmPycsXG4gICAgICAgICdjb25maWcnOiAnPWNvbmZpZ3VyYXRpb24nXG4gICAgICB9LFxuICAgICAgY29udHJvbGxlcjogY3RybCxcbiAgICAgIGNvbnRyb2xsZXJBczogJ3ZtJyxcbiAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHRydWVcbiAgICB9XG4gIH1cbiAgYW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMubGlzdCcsWydndW1nYS5zZXJ2aWNlcy5saXN0aGVscGVyJ10pXG4gIC5kaXJlY3RpdmUoJ2d1bWdhTGlzdCcsTGlzdCk7XG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRNYW55TWFueS4kaW5qZWN0ID0gW1wiJG1vZGFsXCIsIFwiJGNvbXBpbGVcIiwgXCIkdGltZW91dFwiXTtcblx0LyoqXG5cdCAqIEBuZ2RvYyBkaXJlY3RpdmVcblx0ICogQG5hbWUgZ3VtZ2EuY29yZTpndW1nYU1hbnlUb01hbnlcblx0ICogQHJlc3RyaWN0IEVcblx0ICogQGRlc2NyaXB0aW9uXG5cdCAqIFx0TyBjb21wb25lbnRlIGd1bWdhTWFueVRvTWFueSDDqSB1bSBjb21wb25lbnRlIHF1ZSDDqSB1dGlsaXphZG8gcGFyYSBtb3N0cmFyIGR1YXMgbGlzdGFzIGxhZG8gYSBsYWRvLCBlIHBlcm1pdGlyIHF1ZSB1bSByZWdpc3RybyBzZWphIHRyb2NhZG8gZGUgdW1hIGxpc3RhIHBhcmEgb3V0cmEsXG5cdCAqIFx0YXNzaW0gY29tbyB0YW1iw6ltIHZpc3VhbGl6YWRvIG9zIHNldXMgdmFsb3JlcyhjYXNvIHNlamEgdW0gb2JqZXRvKS4gVW0gZXhlbXBsbyBkbyBjb21wb25lbnRlIHBvZGUgc2VyIGVuY29udHJhZG8gW2FxdWldKGh0dHA6Ly9lbWJlZC5wbG5rci5jby9neXJxQUtRUUd1RUh3cDJucHY4Ry8pLlxuXHQgKlxuXHQgKiAtLS1cblx0ICogIyMgQ29uZmlndXJhw6fDo28gZGUgY29tbyBzZXLDoSBtb3N0cmFkbyBvIHZhbG9yIG5hIGxpc3RhXG5cdCAqXG5cdCAqUGFyYSBxdWUgbyBwcm9ncmFtYWRvciBwb3NzYSBlc2NvbGhlciBjb21vIG9zIHZhbG9yZXMgc2Vyw6NvIGRlbW9uc3RyYWRvcywgZm9yYW0gZGVzZW52b2x2aWRhcyBkdWFzIHRhZ3MgcXVlIGRldmVtIGVzdGFyIGRlbnRybyBkbyBjb21wb25lbnRlIG1hbnlUb01hbnkuXG5cdCAqIFx0XHQ8cHJlPiA8bGVmdC1maWVsZD57eyR2YWx1ZX19PC9sZWZ0LWZpZWxkPlxuXHQgKiBcdFx0PHJpZ2h0LWZpZWxkPnt7JHZhbHVlfX08L3JpZ2h0LWZpZWxkPjwvcHJlPlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBsZWZ0LWxpc3QgUGFyw6JtZXRybyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSB2YXJpw6F2ZWwgcXVlIHBvc3N1aXLDoSB1bSBhcnJheSwgcGFyYSBzZXIgbW9zdHJhZG8gbmEgbGlzdGEgZGEgZXNxdWVyZGEuXG5cdCAqICAqQSBsaXN0YSBkYSBlc3F1ZXJkYSBzZXLDoSBmaWx0cmFkYSBlIG7Do28gY29udGVyw6EgcmVzdWx0YWRvcyBpZ3VhaXMgYSBkYSBsaXN0YSBkYSBkaXJlaXRhLipcblx0ICogQHBhcmFtIHtBcnJheX0gcmlnaHQtbGlzdCBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIHZhcmnDoXZlbCBxdWUgcG9zc3VpcsOhIHVtIGFycmF5LCBwYXJhIHNlciBtb3N0cmFkbyBuYSBsaXN0YSBkYSBkaXJlaXRhLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsZWZ0LXNlYXJjaCBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIHZhcmnDoXZlbCBxdWUgcG9zc3VpcsOhIHVtYSBmdW7Dp8OjbyBxdWUgaXLDoSBzZXIgZXhlY3V0YWRhIHRvZGEgdmV6XG5cdCAqIHF1ZSBvIHVzdcOhcmlvIGRpZ2l0YXIgYWxnbyBubyBpbnB1dCBhY2ltYSBkYSBsaXN0YS4gRXNzYSBmdW7Dp8OjbyB0ZXLDoSBvIHZhbG9yIGRvIGlucHV0IGNvbW8gcGFyw6JtZXRyby4gTyBwYXLDom1ldHJvIGRldmVyw6Egc2VyIGVzdGU6IGBsZWZ0LXNlYXJjaD1cImRvU2VhcmNoKHRleHQpXCJgXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHJpZ2h0LXNlYXJjaCBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIHZhcmnDoXZlbCBxdWUgcG9zc3VpcsOhIHVtYSBmdW7Dp8OjbyBxdWUgaXLDoSBzZXIgZXhlY3V0YWRhIHRvZGEgdmV6XG5cdCAqIHF1ZSBvIHVzdcOhcmlvIGRpZ2l0YXIgYWxnbyBubyBpbnB1dCBhY2ltYSBkYSBsaXN0YS4gRXNzYSBmdW7Dp8OjbyB0ZXLDoSBvIHZhbG9yIGRvIGlucHV0IGNvbW8gcGFyw6JtZXRyby4gTyBwYXLDom1ldHJvIGRldmVyw6Egc2VyIGVzdGU6IGByaWdodC1zZWFyY2g9XCJkb1NlYXJjaCh0ZXh0KVwiYFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwb3N0LW1ldGhvZCBQYXLDom1ldHJvIG7Do28gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgdmFyacOhdmVsIHF1ZSBwb3NzdWlyw6EgdW1hIGZ1bsOnw6NvIHF1ZSBpcsOhIHNlciBleGVjdXRhZGEgcXVhbmRvIG8gdXN1w6FyaW8gZGVzZWphciBhZGljaW9uYXIgdW0gdmFsb3Jcblx0ICogY2FzbyBzdWEgYnVzY2EgbsOjbyB0ZW5oYSB0cmF6aWRvIHJlc3VsdGFkb3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9uLWxpc3QtY2hhbmdlIFBhcsOibWV0cm8gbsOjbyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSB2YXJpw6F2ZWwgcXVlIHBvc3N1aXLDoSB1bWEgZnVuw6fDo28gcXVlIGlyw6Egc2VyIGV4ZWN1dGFkYSBxdWFuZG8gbyB1c3XDoXJpbyB0aXZlciBjbGljYWRvIGVtIHVtIHJlZ2lzdHJvXG5cdCAqIGUgbyBtZXNtbyB0aXZlciB0cm9jYWRvIGRlIGxpc3RhLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbi12YWx1ZS12aXN1YWxpemF0aW9uLW9wZW5lZCBQYXLDom1ldHJvIG7Do28gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgdmFyacOhdmVsIHF1ZSBwb3NzdWlyw6EgdW1hIGZ1bsOnw6NvIHF1ZSBpcsOhIHNlciBleGVjdXRhZGEgcXVhbmRvIG8gdXN1w6FyaW8gdGl2ZXIgYWJlcnRvIG8gbW9kYWxcblx0ICogcGFyYSB2aXN1YWxpemHDp8OjbyBkZSBkYWRvc1xuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbi12YWx1ZS12aXN1YWxpemF0aW9uLWNsb3NlZCBQYXLDom1ldHJvIG7Do28gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgdmFyacOhdmVsIHF1ZSBwb3NzdWlyw6EgdW1hIGZ1bsOnw6NvIHF1ZSBpcsOhIHNlciBleGVjdXRhZGEgcXVhbmRvIG8gdXN1w6FyaW8gdGl2ZXIgZmVjaGFkbyBvIG1vZGFsXG5cdCAqIHBhcmEgdmlzdWFsaXphw6fDo28gZGUgZGFkb3Ncblx0ICogQHBhcmFtIHtCb29sZWFufSBhdXRob3JpemUtYWRkIFBhcsOibWV0cm8gbsOjbyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSB2YXJpw6F2ZWwgcXVlIHBvc3N1aXLDoSB1bSBib29sZWFubyBxdWUgaXLDoSBmYXplciBvIGNvbnRyb2xlIHBhcmEgbW9zdHJhciBvIGJvdMOjbyBkZSBhZGljaW9uYXIgdW0gcmVnaXN0cm8gY2FzbyBhIGJ1c2NhIG7Do29cblx0ICogdGVuaGEgcmV0b3JuYWRvIG5lbmh1bSByZWdpc3Ryb1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gbGVmdC1sYWJlbCBQYXLDom1ldHJvIG7Do28gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgU3RyaW5nIHF1ZSBpcsOhIGFwYXJlY2VyIGFjaW1hIGRvIGlucHV0IGUgZGEgbGlzdGEuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSByaWdodC1sYWJlbCBQYXLDom1ldHJvIG7Do28gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgU3RyaW5nIHF1ZSBpcsOhIGFwYXJlY2VyIGFjaW1hIGRvIGlucHV0IGUgZGEgbGlzdGEuXG5cdCAqXG5cblx0ICovXG5cdGZ1bmN0aW9uIE1hbnlNYW55KCRtb2RhbCwkY29tcGlsZSwkdGltZW91dCl7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0cmVzdHJpY3Q6ICdFJyxcblx0XHRcdHNjb3BlOiB7XG5cdFx0XHRcdGxlZnQ6ICc9bGVmdExpc3QnLFxuXHRcdFx0XHRyaWdodDogJz1yaWdodExpc3QnLFxuXHRcdFx0XHRsZWZ0Rm46ICcmbGVmdFNlYXJjaCcsXG5cdFx0XHRcdHJpZ2h0Rm46ICcmcmlnaHRTZWFyY2gnLFxuXHRcdFx0XHRwb3N0TWV0aG9kOiAnJicsXG5cdFx0XHRcdG9uTGlzdENoYW5nZTogJyY/Jyxcblx0XHRcdFx0b25OZXdWYWx1ZUFkZGVkOiAnJj8nLFxuXHRcdFx0XHRvblZhbHVlVmlzdWFsaXphdGlvbk9wZW5lZDogJyY/Jyxcblx0XHRcdFx0b25WYWx1ZVZpc3VhbGl6YXRpb25DbG9zZWQ6ICcmPycsXG5cdFx0XHRcdGF1dGhvcml6ZUFkZDogJz0/J1xuXHRcdFx0fSxcblx0XHRcdHRyYW5zY2x1ZGU6IHRydWUsXG5cdFx0XHRsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsbSwgYXR0cnMsIGN0cmwsIHRyYW5zY2x1ZGVGbikge1xuXHRcdFx0XHRzY29wZS5sZWZ0ID0gc2NvcGUubGVmdCB8fCBbXTtcblx0XHRcdFx0c2NvcGUucmlnaHQgPSBzY29wZS5yaWdodCB8fCBbXTtcblx0XHRcdFx0aWYgKCFhdHRycy5hdXRob3JpemVBZGQpIHNjb3BlLmF1dGhvcml6ZUFkZCA9IHRydWU7XG5cdFx0XHRcdHZhciBtb2NrT2JqZWN0ID0ge307XG5cdFx0XHRcdHNjb3BlLnRleHRzID0ge2xlZnQ6ICcnLHJpZ2h0OiAnJ307XG5cdFx0XHRcdHNjb3BlLnRlbXBsYXRlID0gJyc7XG5cdFx0XHRcdHNjb3BlLmxhYmVscyA9IHtsZWZ0OiBhdHRycy5sZWZ0TGFiZWwscmlnaHQ6IGF0dHJzLnJpZ2h0TGFiZWx9O1xuXHRcdFx0XHR2YXIgZXZlbnRIYW5kbGVyID0ge1xuXHRcdFx0XHRcdGxpc3RDaGFuZ2U6IChhdHRycy5vbkxpc3RDaGFuZ2U/IHNjb3BlLm9uTGlzdENoYW5nZSA6IGFuZ3VsYXIubm9vcCksXG5cdFx0XHRcdFx0bmV3VmFsdWVBZGRlZDogKGF0dHJzLm9uTmV3VmFsdWVBZGRlZCA/IHNjb3BlLm9uTmV3VmFsdWVBZGRlZCA6IGFuZ3VsYXIubm9vcCksXG5cdFx0XHRcdFx0dmFsdWVWaXN1YWxpemF0aW9uT3BlbmVkOiAoYXR0cnMub25WYWx1ZVZpc3VhbGl6YXRpb25PcGVuZWQgPyBzY29wZS5vblZhbHVlVmlzdWFsaXphdGlvbk9wZW5lZCA6YW5ndWxhci5ub29wKSxcblx0XHRcdFx0XHR2YWx1ZVZpc3VhbGl6YXRpb25DbG9zZWQ6IChhdHRycy5vblZhbHVlVmlzdWFsaXphdGlvbkNsb3NlZCA/IHNjb3BlLm9uVmFsdWVWaXN1YWxpemF0aW9uQ2xvc2VkIDphbmd1bGFyLm5vb3ApXG5cdFx0XHRcdH07XG5cdFx0XHRcdHRyYW5zY2x1ZGVGbihzY29wZSxmdW5jdGlvbihjbG9uZUVsKXtcblx0XHRcdFx0XHRhbmd1bGFyLmZvckVhY2goY2xvbmVFbCxmdW5jdGlvbihjbCl7XG5cdFx0XHRcdFx0XHR2YXIgZWxlbWVudCA9IGFuZ3VsYXIuZWxlbWVudChjbClbMF07XG5cdFx0XHRcdFx0XHRzd2l0Y2goZWxlbWVudC5ub2RlTmFtZSl7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ0xFRlQtRklFTEQnOlxuXHRcdFx0XHRcdFx0XHRzY29wZS50ZXh0cy5sZWZ0ID0gZWxlbWVudC5pbm5lckhUTUw7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlICdSSUdIVC1GSUVMRCc6XG5cdFx0XHRcdFx0XHRcdHNjb3BlLnRleHRzLnJpZ2h0ID0gZWxlbWVudC5pbm5lckhUTUw7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGNoZWNrRXJyb3JzKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRtb3VudFJlbmRlcmVkQ29udGVudCgpO1xuXHRcdFx0XHRzY29wZS4kd2F0Y2goJ2xlZnQnLGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0Y2hlY2tFcnJvcnMoKTtcblx0XHRcdFx0XHRjb3B5T2JqZWN0KHNjb3BlLmxlZnRbMF0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0ZnVuY3Rpb24gY29weU9iamVjdChvYmopIHtcblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRcdG1vY2tPYmplY3Rba2V5XSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGZ1bmN0aW9uIGNoZWNrRXJyb3JzKCl7XG5cdFx0XHRcdFx0dmFyIGVycm9yVGV4dHMgPSBbXTtcblx0XHRcdFx0XHRpZighc2NvcGUudGV4dHMubGVmdCB8fCAhc2NvcGUudGV4dHMucmlnaHQpe1xuXHRcdFx0XHRcdFx0ZXJyb3JUZXh0cy5wdXNoKCdZb3UgaGF2ZVxcJ250IHByb3ZpZGVkIHRoZSBjb250ZW50IHRvIEd1bWdhTWFueVRvTWFueSBkaXJlY3RpdmUnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZXJyb3JUZXh0cy5mb3JFYWNoKGZ1bmN0aW9uKHR4dCl7XG5cdFx0XHRcdFx0XHR0aHJvdyB0eHQ7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0cmVtb3ZlRHVwbGljYXRlcygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZXMoKXtcblx0XHRcdFx0XHRmdW5jdGlvbiBmaWx0ZXJPblJpZ2h0KHRleHQpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIHNjb3BlLnJpZ2h0LmZpbHRlcihmdW5jdGlvbigkZWxtKXtcblx0XHRcdFx0XHRcdFx0cmV0dXJuICRlbG1bYXR0cnMuZmlsdGVyUGFyYW1ldGVyXSA9PSB0ZXh0O1xuXHRcdFx0XHRcdFx0fSkubGVuZ3RoXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNjb3BlLmxlZnRBdXggPSBzY29wZS5sZWZ0LmZpbHRlcihmdW5jdGlvbihlbG0pe1xuXHRcdFx0XHRcdFx0aWYoZmlsdGVyT25SaWdodChlbG1bYXR0cnMuZmlsdGVyUGFyYW1ldGVyXSkgPT0gMCl7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBlbG07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnVuY3Rpb24gbW91bnRSZW5kZXJlZENvbnRlbnQoKXtcblx0XHRcdFx0XHR2YXIgdGV4dCA9XG5cdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmdWxsLXdpZHRoLXdpdGhvdXQtcGFkZGluZ1wiPlxcbicrXG5cdFx0XHRcdFx0JyAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiIHN0eWxlPVwicGFkZGluZy1sZWZ0OiAwXCI+XFxuJytcblx0XHRcdFx0XHQnICAgICAgIDxzdHJvbmc+PHNtYWxsPnt7OjpsYWJlbHMubGVmdH19PC9zbWFsbD48L3N0cm9uZz5cXG4nICtcblx0XHRcdFx0XHQnICAgICAgIDxkaXYgY2xhc3M9XCJ7e3Nob3dDbGFzcygpfX1cIj4nK1xuXHRcdFx0XHRcdCcgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJtYW55bWFueWxlZnRcIiBuZy1tb2RlbD1cImxlZnRGaWx0ZXJcIiBub3ZhbGlkYXRlIGNsYXNzPVwiZm9ybS1jb250cm9sXCInICsgZG9lc0l0SGF2ZUZ1bmN0aW9uKCdsZWZ0JywwKSArICcgbmctY2hhbmdlPVwibGVmdEZuKHtwYXJhbTogbGVmdEZpbHRlcn0pXCIgbmctbW9kZWwtb3B0aW9ucz1cInsgdXBkYXRlT246IFxcJ2RlZmF1bHQgYmx1clxcJywgZGVib3VuY2U6IHtcXCdkZWZhdWx0XFwnOiAzMDAsIFxcJ2JsdXJcXCc6IDB9IH1cIi8+XFxuJyArXG5cdFx0XHRcdFx0JyAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvblwiIG5nLXNob3c9XCJzaG93UGx1cyhsZWZ0RmlsdGVyKVwiPiAnICtcblx0XHRcdFx0XHQnICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgc3R5bGU9XCJib3JkZXI6IDA7YmFja2dyb3VuZC1jb2xvcjogI0VFRVwiIG5nLWNsaWNrPVwiYWRkTmV3KGxlZnRGaWx0ZXIpXCI+PGkgY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXBsdXNcIj48L2k+PC9idXR0b24+JyArXG5cdFx0XHRcdFx0JyAgICAgICAgICAgPC9zcGFuPicgK1xuXHRcdFx0XHRcdCcgICAgICAgPC9kaXY+JyArXG5cdFx0XHRcdFx0JyAgICAgICA8dWwgY2xhc3M9XCJsaXN0LWdyb3VwXCIgc3R5bGU9XCJtYXgtaGVpZ2h0OiAyMDBweDtvdmVyZmxvdzogYXV0bztcIj5cXG4nICtcblx0XHRcdFx0XHQnICAgICAgICAgICA8bGkgY2xhc3M9XCJsaXN0LWdyb3VwLWl0ZW1cIiBzdHlsZT1cImRpc3BsYXk6ZmxleDtwYWRkaW5nOiA3cHggMTVweDtcIiBuZy1yZXBlYXQ9XCIkdmFsdWUgaW4gbGVmdEF1eCAnICsgZG9lc0l0SGF2ZUZ1bmN0aW9uKCdsZWZ0JywxKSArICdcIj4nICtcblx0XHRcdFx0XHQnICAgICAgICAgICAgICAgPGEgY2xhc3M9XCJpbnNpZGUtbGlzdC1hbmNob3JcIiBuZy1jbGljaz1cInJlbW92ZUZyb21BbmRBZGRUbyhsZWZ0QXV4LHJpZ2h0LCR2YWx1ZSlcIj4nICsgc2NvcGUudGV4dHMubGVmdCArICc8L2E+JyArXG5cdFx0XHRcdFx0JyAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJhZGdlXCIgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiAjODFBRURBO2N1cnNvcjogcG9pbnRlcjtib3JkZXI6IDBcIiBuZy1jbGljaz1cImhhbHAoJHZhbHVlKVwiPjxpIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZXNpemUtZnVsbFwiPjwvaT48L2J1dHRvbj4nICtcblx0XHRcdFx0XHQnICAgICAgICAgICA8L2xpPlxcbicrXG5cdFx0XHRcdFx0JyAgICAgICA8L3VsPicrXG5cdFx0XHRcdFx0JyAgIDwvZGl2PlxcbicrXG5cdFx0XHRcdFx0JyAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiIHN0eWxlPVwicGFkZGluZy1yaWdodDogMFwiPlxcbicrXG5cdFx0XHRcdFx0JyAgICAgICA8c3Ryb25nPjxzbWFsbD57ezo6bGFiZWxzLnJpZ2h0fX08L3NtYWxsPjwvc3Ryb25nPlxcbicrXG5cdFx0XHRcdFx0JyAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwibWFueW1hbnlsZWZ0XCIgbmctbW9kZWw9XCJyaWdodEZpbHRlclwiIG5vdmFsaWRhdGUgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIicgKyBkb2VzSXRIYXZlRnVuY3Rpb24oJ3JpZ2h0JywwKSArICcvPlxcbicrXG5cdFx0XHRcdFx0JyAgICAgICA8dWwgY2xhc3M9XCJsaXN0LWdyb3VwXCIgc3R5bGU9XCJtYXgtaGVpZ2h0OiAyMDBweDtvdmVyZmxvdzogYXV0bztcIj5cXG4nICtcblx0XHRcdFx0XHQnICAgICAgICAgICA8bGkgY2xhc3M9XCJsaXN0LWdyb3VwLWl0ZW1cIiBzdHlsZT1cImRpc3BsYXk6ZmxleDtwYWRkaW5nOiA3cHggMTVweDtcIiBuZy1yZXBlYXQ9XCIkdmFsdWUgaW4gcmlnaHQgJyArIGRvZXNJdEhhdmVGdW5jdGlvbigncmlnaHQnLDEpICsgJ1wiPicgK1xuXHRcdFx0XHRcdCcgICAgICAgICAgICAgICA8YSBjbGFzcz1cImluc2lkZS1saXN0LWFuY2hvclwiIG5nLWNsaWNrPVwicmVtb3ZlRnJvbUFuZEFkZFRvKHJpZ2h0LGxlZnRBdXgsJHZhbHVlKVwiPicgKyBzY29wZS50ZXh0cy5yaWdodCArICc8L2E+JyArXG5cdFx0XHRcdFx0JyAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJhZGdlIGJhZGdlLWhlbHBlclwiIG5nLWNsaWNrPVwiaGFscCgkdmFsdWUpXCI+PGkgY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXJlc2l6ZS1mdWxsXCI+PC9pPjwvYnV0dG9uPicgK1xuXHRcdFx0XHRcdCcgICAgICAgICAgIDwvbGk+XFxuJytcblx0XHRcdFx0XHQnICAgICAgIDwvdWw+XFxuJytcblx0XHRcdFx0XHQnICAgPC9kaXY+XFxuJytcblx0XHRcdFx0XHQnPC9kaXY+XFxuJztcblx0XHRcdFx0XHRlbG0uYXBwZW5kKCRjb21waWxlKHRleHQpKHNjb3BlKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2NvcGUucmVtb3ZlRnJvbUFuZEFkZFRvID0gZnVuY3Rpb24ocmVtb3ZlRnJvbSxhZGRUbyx2YWx1ZSl7XG5cdFx0XHRcdFx0cmVtb3ZlRnJvbS5zcGxpY2UocmVtb3ZlRnJvbS5pbmRleE9mKHZhbHVlKSwxKTtcblx0XHRcdFx0XHRldmVudEhhbmRsZXIubGlzdENoYW5nZSh7JHZhbHVlOnZhbHVlfSk7XG5cdFx0XHRcdFx0YWRkVG8ucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHNjb3BlLmFkZE5ldyA9IGZ1bmN0aW9uKHRleHQpe1xuXHRcdFx0XHRcdHNjb3BlLmxlZnRGaWx0ZXIgPSAnJztcblx0XHRcdFx0XHRzY29wZS5wb3N0TWV0aG9kKHt2YWx1ZTogdGV4dCB9KTtcblx0XHRcdFx0XHRldmVudEhhbmRsZXIubmV3VmFsdWVBZGRlZCgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRzY29wZS5zaG93Q2xhc3MgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGlmKHNjb3BlLnNob3dQbHVzKCkpe1xuXHRcdFx0XHRcdFx0cmV0dXJuICdpbnB1dC1ncm91cCc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiAnJztcblx0XHRcdFx0fTtcblx0XHRcdFx0c2NvcGUuaGFscCA9IGZ1bmN0aW9uKG9iail7XG5cdFx0XHRcdFx0c2NvcGUudGVtcGxhdGUgPVxuXHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwibW9kYWwtYm9keVwiPlxcbic7XG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG9iaikgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGtleSAhPSAnJCRoYXNoS2V5JyAmJiBrZXkgIT0gJ29pJyAmJiBrZXkgIT0gJ3ZlcnNpb24nKSB7XG5cdFx0XHRcdFx0XHRzY29wZS50ZW1wbGF0ZSArPSAnICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cXG4nO1xuXHRcdFx0XHRcdFx0c2NvcGUudGVtcGxhdGUgKz0gJyAgICAgICA8bGFiZWw+PHNtYWxsPicrIGtleSArJzwvc21hbGw+PC9sYWJlbD5cXG4nO1xuXHRcdFx0XHRcdFx0c2NvcGUudGVtcGxhdGUgKz0gJyAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cIiR2YWx1ZS4nICsga2V5ICsnXCIgZGlzYWJsZWQgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIi8+XFxuJztcblx0XHRcdFx0XHRcdHNjb3BlLnRlbXBsYXRlICs9ICcgICA8L2Rpdj5cXG4nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzY29wZS50ZW1wbGF0ZSArPSAnICAgPGRpdiBjbGFzcz1cIm1vZGFsLWZvb3RlclwiPlxcbic7XG5cdFx0XHRcdFx0c2NvcGUudGVtcGxhdGUgKz0gJyAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4td2FybmluZ1wiIG5nLWNsaWNrPVwiYmFjaygpXCI+QmFjazwvYnV0dG9uPlxcbic7XG5cdFx0XHRcdFx0c2NvcGUudGVtcGxhdGUgKz0gJyAgIDwvZGl2Plxcbic7XG5cdFx0XHRcdFx0c2NvcGUudGVtcGxhdGUgKz0gJzwvZGl2Plxcbic7XG5cdFx0XHRcdFx0ZXZlbnRIYW5kbGVyLnZhbHVlVmlzdWFsaXphdGlvbk9wZW5lZCgpO1xuXHRcdFx0XHRcdHZhciBtaSA9ICRtb2RhbC5vcGVuKHtcblx0XHRcdFx0XHRcdHRlbXBsYXRlOiBzY29wZS50ZW1wbGF0ZSxcblx0XHRcdFx0XHRcdHNpemU6ICdzbScsXG5cdFx0XHRcdFx0XHRjb250cm9sbGVyOiBbXCIkc2NvcGVcIiwgXCIkdmFsdWVcIiwgXCIkbW9kYWxJbnN0YW5jZVwiLCBmdW5jdGlvbigkc2NvcGUsJHZhbHVlLCRtb2RhbEluc3RhbmNlKXtcblx0XHRcdFx0XHRcdFx0JHNjb3BlLiR2YWx1ZSA9ICR2YWx1ZTtcblx0XHRcdFx0XHRcdFx0JHNjb3BlLmJhY2sgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHRcdCRtb2RhbEluc3RhbmNlLmRpc21pc3MoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fV0sXG5cdFx0XHRcdFx0XHRyZXNvbHZlOiB7XG5cdFx0XHRcdFx0XHRcdCR2YWx1ZTogZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRtaS5yZXN1bHQudGhlbihmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0ZXZlbnRIYW5kbGVyLnZhbHVlVmlzdWFsaXphdGlvbkNsb3NlZCgpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH07XG5cdFx0XHRcdHNjb3BlLnNob3dQbHVzID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRmdW5jdGlvbiBmaWx0ZXJMZWZ0KCl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc2NvcGUubGVmdEF1eC5maWx0ZXIoZnVuY3Rpb24oZWwpe1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZWxbYXR0cnMuZmlsdGVyUGFyYW1ldGVyXSA9PSBzY29wZS5sZWZ0RmlsdGVyO1xuXHRcdFx0XHRcdFx0fSkubGVuZ3RoIDwgMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZnVuY3Rpb24gZmlsdGVyUmlnaHQoKXtcblx0XHRcdFx0XHRcdHJldHVybiBzY29wZS5yaWdodC5maWx0ZXIoZnVuY3Rpb24oZWwpe1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZWxbYXR0cnMuZmlsdGVyUGFyYW1ldGVyXSA9PSBzY29wZS5sZWZ0RmlsdGVyO1xuXHRcdFx0XHRcdFx0fSkubGVuZ3RoIDwgMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoc2NvcGUuYXV0aG9yaXplQWRkID09IHRydWUpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZpbHRlckxlZnQoKSAmJiBmaWx0ZXJSaWdodCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0c2NvcGUuZG9lc0l0SGF2ZUNsYXNzID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRpZihzY29wZS5sZWZ0Lmxlbmd0aCA+IDApe1xuXHRcdFx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gJ2lucHV0LWdyb3VwJztcblx0XHRcdFx0fTtcblx0XHRcdFx0ZnVuY3Rpb24gZG9lc0l0SGF2ZUZ1bmN0aW9uKGZpZWxkLHBsYWNlKXtcblx0XHRcdFx0XHRpZihwbGFjZSA9PSAwKXtcblx0XHRcdFx0XHRcdGlmKGZpZWxkID09ICdsZWZ0JyAmJiBhdHRycy5sZWZ0Rm4pe1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gICduZy1jaGFuZ2U9IFwiJyArIGF0dHJzLmxlZnRGbiAgKycoe3RleHQ6IGxlZnRGaWx0ZXJ9KVwiICc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihmaWVsZCA9PSAncmlnaHQnICYmIGF0dHJzLnJpZ2h0Rm4pe1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gICduZy1jaGFuZ2U9IFwiJyArIGF0dHJzLmxlZnRGbiAgKycoe3RleHQ6IHJpZ2h0RmlsdGVyfSlcIiAnO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZihmaWVsZCA9PSAnbGVmdCcgJiYgIWF0dHJzLmxlZnRGbil7XG5cdFx0XHRcdFx0XHRcdHJldHVybiAnIHwgZmlsdGVyOiBsZWZ0RmlsdGVyJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKGZpZWxkID09ICdyaWdodCcgJiYgIWF0dHJzLnJpZ2h0Rm4pe1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gJyB8IGZpbHRlcjogcmlnaHRGaWx0ZXInXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0XHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5tYW55dG9tYW55JyxbJ3VpLmJvb3RzdHJhcCddKVxuXHRcdC5kaXJlY3RpdmUoJ2d1bWdhTWFueVRvTWFueScsTWFueU1hbnkpXG5cdH0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBNYW55VG9PbmUuJGluamVjdCA9IFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIFwiR3VtZ2FLZXlib2FyZFwiLCBcIiRtb2RhbFwiXTtcbiAgICAvKipcbiAgICAgKiBAbmdkb2MgZGlyZWN0aXZlXG4gICAgICogQG5hbWUgZ3VtZ2EuY29yZTpndW1nYU1hbnlUb09uZVxuICAgICAqIEByZXN0cmljdCBFXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogIEEgZGlyZWN0aXZlIGd1bWdhTWFueVRvT25lIHBvZGUgc2VyIHVzYWRhIHBhcmEgcXVhbmRvIG8gcHJvZ3JhbWFkb3IgcHJlY2lzZSBkZSB1bSBzZWxlY3QgcXVlIGZpbHRyZSB1bWEgbGlzdGEgYXNzw61uY3JvbmFtZW50ZS5cbiAgICAgKiAgRWxhIHRhbWLDqW0gcGVybWl0ZSBhZGljaW9uYXIgdW0gcmVnaXN0cm8gY2FzbyBhIGJ1c2NhIHJldG9ybmUgdW1hIGxpc3RhIHZhemlhIGUgcGVybWl0ZSB0YW1iw6ltIHZpc3VhbGl6YXIgb3MgYXRyaWJ1dG9zIGRvIHJlZ2lzdHJvIHNlbGVjaW9uYWRvLlxuICAgICAqICAtLS1cbiAgICAgKiAgI0V4ZW1wbG8gYsOhc2ljbyBkZSB1dGlsaXphw6fDo28gZG8gR3VtZ2FNYW55VG9PbmVcbiAgICAgKiAgTyBleGVtcGxvIGRlc3NlIGNvbXBvbmVudGUgcG9kZSBzZXIgZW5jb250cmFkbyBbYXF1aV0oaHR0cDovL2VtYmVkLnBsbmtyLmNvL05ZTDNnSXRWc1dMRmNHeHQ1aXR6LykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgUGFyw6JtZXRybyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSB2YXJpw6F2ZWwgcXVlIHNlcsOhIG8gcmVnaXN0cm8gZXNjb2xoaWRvIG5hIGxpc3RhLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgUGFyw6JtZXRybyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSBsaXN0YSBkb3MgcmVnaXN0cm9zIHF1ZSBmb3JhbSBidXNjYWRvcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZWFyY2gtbWV0aG9kIFBhcsOibWV0cm8gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgZnVuw6fDo28gcXVlIGZhcsOhIGEgYnVzY2EgbmEgbGlzdGEgYXNzw61uY3JvbmFtZW50ZS4gYHNlYXJjaC1tZXRob2Q9XCJnZXRTZWFyY2gocGFyYW0pXCJgXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcG9zdC1tZXRob2QgUGFyw6JtZXRybyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSBmdW7Dp8OjbyBxdWUgZGVwZW5kZW5kbyBkbyBwYXLDom1ldHJvIGBhc3luY2AsIGNoYW1hcsOhIGEgZnVuw6fDo28gYXN5bmMgY29tIG8gcGFyw6JtZXRyb1xuICAgICAqIGBwb3N0LW1ldGhvZD1cInBvc3QodmFsdWUpXCJgIGUgY2FzbyBvIHBhcsOibWV0cm8gYXN5bmMgbsOjbyBlc3RlamEgcHJlc2VudGUgb3Ugc2VqYSBmYWxzbywgZmFyw6EgdW0gcHVzaCBuYSBsaXN0YS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmllbGQgUGFyw6JtZXRybyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIG8gYXRyaWJ1dG8gZG8gcmVnaXN0cm8gcXVlIGVzdMOhIHNlbmRvIHByb2N1cmFkbyBlIG8gcXVlIGVzdGFyw6EgbmEgbGlzdGEuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhdXRob3JpemUtYWRkIFBhcsOibWV0cm8gbsOjbyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSB2YXJpw6F2ZWwgcXVlIHBvc3N1aXLDoSB1bSBib29sZWFubyBxdWUgaXLDoSBmYXplciBvIGNvbnRyb2xlIHBhcmEgbW9zdHJhciBvIGJvdMOjbyBkZSBhZGljaW9uYXIgdW0gcmVnaXN0cm8gY2FzbyBhIGJ1c2NhIG7Do29cbiAgICAgKiB0ZW5oYSByZXRvcm5hZG8gbmVuaHVtIHJlZ2lzdHJvXG4gICAgICogQHBhcmFtIHtCdGF2YSB2ZW9vbGVhbn0gYXN5bmMgUGFyw6JtZXRybyBuw6NvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBkaXplciBjYXNvIGNvbXBvbmVudGUgZmFyw6EgdW0gcG9zdCBjaGFtYW5kbyBhIGZ1bsOnw6NvIHBhc3NhZGEgb3UgdW0gcHVzaCBuYSBsaXN0YS4gUG9yIGRlZmF1bHQsIG8gdmFsb3Igw6lcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbi1uZXctdmFsdWUtYWRkZWQgUGFyw6JtZXRybyBuw6NvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIHZhcmnDoXZlbCBxdWUgcG9zc3VpcsOhIHVtYSBmdW7Dp8OjbyBxdWUgaXLDoSBzZXIgZXhlY3V0YWRhIHF1YW5kbyBvIHVzdcOhcmlvIGFkaWNpb25hciB1bSBub3ZvIHZhbG9yLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uLXZhbHVlLXZpc3VhbGl6YXRpb24tb3BlbmVkIFBhcsOibWV0cm8gbsOjbyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSB2YXJpw6F2ZWwgcXVlIHBvc3N1aXLDoSB1bWEgZnVuw6fDo28gcXVlIGlyw6Egc2VyIGV4ZWN1dGFkYSBxdWFuZG8gbyB1c3XDoXJpbyB0aXZlciBhYmVydG8gbyBtb2RhbFxuICAgICAqIHBhcmEgdmlzdWFsaXphw6fDo28gZGUgZGFkb3NcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbi12YWx1ZS12aXN1YWxpemF0aW9uLWNsb3NlZCBQYXLDom1ldHJvIG7Do28gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgdmFyacOhdmVsIHF1ZSBwb3NzdWlyw6EgdW1hIGZ1bsOnw6NvIHF1ZSBpcsOhIHNlciBleGVjdXRhZGEgcXVhbmRvIG8gdXN1w6FyaW8gdGl2ZXIgZmVjaGFkbyBvIG1vZGFsXG4gICAgICogcGFyYSB2aXN1YWxpemHDp8OjbyBkZSBkYWRvc1xuICAgICAqL1xuXG5cblxuICAgIGZ1bmN0aW9uIE1hbnlUb09uZSgkdGVtcGxhdGVDYWNoZSxHdW1nYUtleWJvYXJkLCRtb2RhbCl7XG4gICAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnbXRvSXRlbS5odG1sJyxcbiAgICAgICAgICAgICc8c3BhbiBiaW5kLWh0bWwtdW5zYWZlPVwibWF0Y2gubGFiZWwgfCB0eXBlYWhlYWRIaWdobGlnaHQ6cXVlcnlcIiBzdHlsZT1cImN1cnNvcjogcG9pbnRlcjtcIj48L3NwYW4+Jyk7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9JzxkaXYgY2xhc3M9XCJmdWxsLXdpZHRoLXdpdGhvdXQtcGFkZGluZ1wiPic7XG4gICAgICAgIHRlbXBsYXRlICs9ICcgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPic7XG4gICAgICAgIHRlbXBsYXRlICs9ICcgICAgICAgPGRpdiBuZy1jbGFzcz1cInNob3dGdWxsVmlldygpIHx8IGF1dGhvcml6ZUFkZCA/IFxcJ2lucHV0LWdyb3VwXFwnIDogXFwnXFwnXCI+JztcbiAgICAgICAgdGVtcGxhdGUgKz0gJyAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jb250cm9sXCIgIG5nLW1vZGVsPVwibW9kZWxcIiB0eXBlPVwidGV4dFwiIHR5cGVhaGVhZD1cIiR2YWx1ZSBhcyAkdmFsdWVbZmllbGRdIGZvciAkdmFsdWUgaW4gcHJveHlTZWFyY2hNZXRob2QoKVwiPic7XG4gICAgICAgIHRlbXBsYXRlICs9ICcgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb25cIiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyBwYWRkaW5nOiAzcHggMTJweDtib3JkZXItbGVmdDowXCIgbmctc2hvdz1cInNob3dGdWxsVmlldygpXCI+ICc7XG4gICAgICAgIHRlbXBsYXRlICs9ICcgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYmFkZ2VcIiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6ICM2RUNGRkY7Ym9yZGVyOiAwXCIgbmctY2xpY2s9XCJoYWxwKG1vZGVsKVwiID48aSBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tcmVzaXplLWZ1bGxcIj48L2k+PC9idXR0b24+JztcbiAgICAgICAgdGVtcGxhdGUgKz0gJyAgICAgICAgICAgPC9zcGFuPic7XG4gICAgICAgIHRlbXBsYXRlICs9ICcgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb25cIiBzdHlsZT1cInBhZGRpbmc6IDAgMC4yNSVcIiBuZy1zaG93PVwiYXV0aG9yaXplQWRkXCI+ICc7XG4gICAgICAgIHRlbXBsYXRlICs9ICcgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBzdHlsZT1cImJvcmRlcjogMDtiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudFwiIG5nLWNsaWNrPVwiYWRkTmV3KG1vZGVsKVwiID48aSBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tcGx1c1wiPjwvaT48L2J1dHRvbj4nO1xuICAgICAgICB0ZW1wbGF0ZSArPSAnICAgICAgICAgICA8L3NwYW4+JztcbiAgICAgICAgdGVtcGxhdGUgKz0gJyAgICAgICA8L2Rpdj4nO1xuICAgICAgICB0ZW1wbGF0ZSArPSAnICAgPC9kaXY+JztcbiAgICAgICAgdGVtcGxhdGUgKz0gJzwvZGl2Pic7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdCA6ICdFJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICAgICAgICAgIHJlcXVpcmU6ICdeZm9ybScsXG4gICAgICAgICAgICBzY29wZSA6IHtcbiAgICAgICAgICAgICAgICBtb2RlbDonPXZhbHVlJyxcbiAgICAgICAgICAgICAgICBsaXN0OiAnPScsXG4gICAgICAgICAgICAgICAgc2VhcmNoTWV0aG9kOiAnJicsXG4gICAgICAgICAgICAgICAgcG9zdE1ldGhvZDogJyZhZGRNZXRob2QnLFxuICAgICAgICAgICAgICAgIGZpZWxkOiAnQCcsXG4gICAgICAgICAgICAgICAgb25OZXdWYWx1ZUFkZGVkOiAnJj8nLFxuICAgICAgICAgICAgICAgIG9uVmFsdWVWaXN1YWxpemF0aW9uT3BlbmVkOiAnJj8nLFxuICAgICAgICAgICAgICAgIG9uVmFsdWVWaXN1YWxpemF0aW9uQ2xvc2VkOiAnJj8nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsbSwgYXR0cnMsY3RybCl7XG4gICAgICAgICAgICAgICAgc2NvcGUuZm9ybUN0cmwgPSBjdHJsO1xuICAgICAgICAgICAgICAgIHZhciBuZ01vZGVsQ3RybCA9IGVsbS5maW5kKCdpbnB1dCcpLmNvbnRyb2xsZXIoJ25nTW9kZWwnKSxcbiAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlQWRkZWQ6IChhdHRycy5vbk5ld1ZhbHVlQWRkZWQgPyBzY29wZS5vbk5ld1ZhbHVlQWRkZWQgOiBhbmd1bGFyLm5vb3ApLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVZpc3VhbGl6YXRpb25PcGVuZWQ6IChhdHRycy5vblZhbHVlVmlzdWFsaXphdGlvbk9wZW5lZCA/IHNjb3BlLm9uVmFsdWVWaXN1YWxpemF0aW9uT3BlbmVkIDphbmd1bGFyLm5vb3ApLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVZpc3VhbGl6YXRpb25DbG9zZWQ6IChhdHRycy5vblZhbHVlVmlzdWFsaXphdGlvbkNsb3NlZCA/IHNjb3BlLm9uVmFsdWVWaXN1YWxpemF0aW9uQ2xvc2VkIDphbmd1bGFyLm5vb3ApXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhc3luYztcbiAgICAgICAgICAgICAgICAhYXR0cnMuYXV0aG9yaXplQWRkID8gc2NvcGUuYXV0aG9yaXplQWRkID0gdHJ1ZSA6IHNjb3BlLmF1dGhvcml6ZUFkZCA9IEpTT04ucGFyc2UoYXR0cnMuYXV0aG9yaXplQWRkKTtcbiAgICAgICAgICAgICAgICAhYXR0cnMuYXN5bmMgPyBhc3luYyA9IHRydWUgOiBhc3luYyA9IEpTT04ucGFyc2UoYXR0cnMuYXN5bmMpO1xuICAgICAgICAgICAgICAgIHNjb3BlLmxpc3QgPSBzY29wZS5saXN0IHx8IFtdO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrSWZJdElzU3RyaW5nKHN0cmluZyl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHR5cGVvZiBzdHJpbmcpLnRvVXBwZXJDYXNlKCkudHJpbSgpKSA9PT0gJ3N0cmluZycudG9VcHBlckNhc2UoKS50cmltKCkgJiYgc3RyaW5nLmxlbmd0aCA+IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNjb3BlLiR3YXRjaCgnbW9kZWwnLGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrSWZJdElzU3RyaW5nKHNjb3BlLm1vZGVsKSA/XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCdHdW1nYU1hbnlUb09uZScsZmFsc2UpIDogY3RybC4kc2V0VmFsaWRpdHkoJ0d1bWdhTWFueVRvT25lJyx0cnVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBHdW1nYUtleWJvYXJkLmJpbmRUb0VsZW1lbnQoZWxtLmZpbmQoJ2lucHV0JylbMF0sJ2Rvd24nLGZ1bmN0aW9uKCl7bmdNb2RlbEN0cmwuJHNldFZpZXdWYWx1ZSgnICcpfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaChlKXtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNjb3BlLnNob3dGdWxsVmlldyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHR5cGVvZiBzY29wZS5tb2RlbCkudG9VcHBlckNhc2UoKS50cmltKCkpID09PSAnb2JqZWN0Jy50b1VwcGVyQ2FzZSgpLnRyaW0oKSAmJiBzY29wZS5tb2RlbCAhPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHNjb3BlLnNob3dQbHVzID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoKHR5cGVvZiBzY29wZS5tb2RlbCkudG9VcHBlckNhc2UoKS50cmltKCkpID09PSAnc3RyaW5nJy50b1VwcGVyQ2FzZSgpLnRyaW0oKSAmJiBzY29wZS5hdXRob3JpemVBZGQgPT09IHRydWUpIDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgc2NvcGUucHJveHlTZWFyY2hNZXRob2QgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLnNlYXJjaE1ldGhvZCh7cGFyYW06IG5nTW9kZWxDdHJsLiR2aWV3VmFsdWV9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNjb3BlLmFkZE5ldyA9IGZ1bmN0aW9uKHRleHQpe1xuICAgICAgICAgICAgICAgICAgICBpZihhc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucG9zdE1ldGhvZCh7dmFsdWU6IHRleHR9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUubW9kZWwgPSB2YWx1ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUubGlzdC5wdXNoKHRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzY29wZS5oYWxwID0gZnVuY3Rpb24ob2JqKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlID1cbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJtb2RhbC1ib2R5XCI+XFxuJztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGtleSAhPSAnJCRoYXNoS2V5JyAmJiBrZXkgIT0gJ29pJyAmJiBrZXkgIT0gJ3ZlcnNpb24nICYmIGtleSAhPSAncGFzc3dvcmQnICYmIHR5cGVvZiBvYmpba2V5XSAhPSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgKz0gJyAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+XFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlICs9ICcgICAgICAgPGxhYmVsPjxzbWFsbD4nKyBrZXkgKyc8L3NtYWxsPjwvbGFiZWw+XFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlICs9ICcgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCIkdmFsdWUuJyArIGtleSArJ1wiIGRpc2FibGVkIGNsYXNzPVwiZm9ybS1jb250cm9sXCIvPlxcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZSArPSAnICAgPC9kaXY+XFxuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZSArPSAnICAgPGRpdiBjbGFzcz1cIm1vZGFsLWZvb3RlclwiPlxcbic7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlICs9ICcgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXdhcm5pbmdcIiBuZy1jbGljaz1cImJhY2soKVwiPkJhY2s8L2J1dHRvbj5cXG4nO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZSArPSAnICAgPC9kaXY+XFxuJztcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgKz0gJzwvZGl2Plxcbic7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlci52YWx1ZVZpc3VhbGl6YXRpb25PcGVuZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pID0gJG1vZGFsLm9wZW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogJ3NtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IFtcIiRzY29wZVwiLCBcIiR2YWx1ZVwiLCBcIiRtb2RhbEluc3RhbmNlXCIsIGZ1bmN0aW9uKCRzY29wZSwkdmFsdWUsJG1vZGFsSW5zdGFuY2Upe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS4kdmFsdWUgPSAkdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmJhY2sgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbW9kYWxJbnN0YW5jZS5kaXNtaXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHZhbHVlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG1pLnJlc3VsdC50aGVuKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIudmFsdWVWaXN1YWxpemF0aW9uQ2xvc2VkKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAgICAgYW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMubWFueXRvb25lJyxbJ3VpLmJvb3RzdHJhcCcsJ2d1bWdhLnNlcnZpY2VzLmtleWJvYXJkJ10pXG4gICAgICAgIC5kaXJlY3RpdmUoJ2d1bWdhTWFueVRvT25lJyxNYW55VG9PbmUpO1xuICAgIH0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogQG5nZG9jIGRpcmVjdGl2ZVxuICAgKiBAbmFtZSBndW1nYS5jb3JlOmd1bWdhTWFza1xuICAgKiBAcmVzdHJpY3QgQVxuICAgKiBAZGVzY3JpcHRpb24gTyBjb21wb25lbnRlICoqR3VtZ2FNYXNrKiogc2VydmUgcGFyYSBhZGljaW9uYXIgbcOhc2NhcmFzIGFvcyBlbGVtZW50b3MgaW5wdXRzIHF1ZSBzZSBmYXplbSBuZWNlc3PDoXJpbywgY29tbyBDUEYsIENOUEosIHRlbGVmb25lIGUgZXRjLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBVbSBleGVtcGxvIGRhIGRpcmVjdGl2ZSBndW1nYVRhYmxlIGZ1bmNpb25hbmRvIHBvZGUgc2VyIGVuY29udHJhZG8gW2FxdWldKGh0dHA6Ly9lbWJlZC5wbG5rci5jby9TQUxrcDViS1JaMWF5d3NycG1FWCkuXG4gICAqICA8cHJlPlxuICAgKiAgXHQ8Zm9ybSBjbGFzcz1cIlwiIGFjdGlvbj1cImluZGV4Lmh0bWxcIiBtZXRob2Q9XCJwb3N0XCI+XG4gICAqICBcdFx0PGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cIm5hbWVcIiB2YWx1ZT1cIlwiIG5nLW1vZGVsPVwiY3BmXCIgZ3VtZ2EtbWFzaz1cIjk5OS45OTkuOTk5LTk5XCIgZ3VtZ2EtbWFzay1vcHRpb25zPVwibWFza09wdGlvbnNcIj5cbiAgICogIFx0PC9mb3JtPlxuICAgKiAgICA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIj5cbiAgICogICAgJHNjb3BlLm1hc2tPcHRpb25zID0ge1xuICAgKiAgICBcdG1hc2tEZWZpbml0aW9uczoge1xuICAgKiAgICBcdFx0J3NldVJlZ2V4JzogL1tyZWdleF0vXG4gICAqICAgIFx0fSxcbiAgICogICAgXHRjbGVhck9uQmx1cjogZmFsc2UsXG4gICAqICAgIFx0ZXZlbnRzVG9IYW5kbGU6IFsnaW5wdXQnLCAna2V5dXAnLCAnY2xpY2snLCAnZm9jdXMnXVxuICAgKiAgICB9O1xuICAgKiAgICA8L3NjcmlwdD5cbiAgICogIDwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZ3VtZ2EtbWFzayBQb3IgcGFkcsOjbyBvIGNvbXBvbmVudGUgdGVtIDMgdGlwb3MgZGUgcmVnZXggYWNlaXRhcywgcXVlIHPDo28gKio5KiogKG51bcOpcmljb3MpLCAqKkEqKiAoYWxmYW51bcOpcmljb3MpIGUgKiogKiAqKiAoYWxmYW51bcOpcmljb3MpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBndW1nYS1tYXNrLW9wdGlvbnMgT2JqZXRvIGVtICRzY29wZSBjb20gcmVnZXggZXh0cmFzIG91IHNvYnJlZXNjcmV2ZXIgY29uZmlndXJhw6fDtWVzIGRlZmF1bHQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBndW1nYS1tYXNrLXBsYWNlaG9sZGVyIFRyYWJhbGhhIGVtIGNvbmp1bnRvIGNvbSBvIHBsYWNlaG9sZGVyIG5hdGl2bywgY29udHVkbywgbyAqKmd1bWdhLW1hc2stcGxhY2Vob2xkZXIqKiBkZXZlIHNlZ3VpciBvIG1lc21vIHBhZHLDo29cbiAgICogZGUgY2FyYWN0ZXJlcyBkbyBpbmZvcm1hZG8gbm8gKipndW1nYS1tYXNrKiouIEVucXVhbnRvIG8gbmF0aXZvIGZpY2EgYXRpdm8gc2VtIGF0aXZpZGFkZSBubyBpbnB1dCwgYW8gZGlzcGFyYXIgbyBldmVudG8gZm9jdXMsIG8gZ3VtZ2EtbWFzay1wbGFjZWhvbGRlclxuICAgKiBmaWNhcsOhIGF0aXZvLlxuICAgKi9cbiAgTWFzay4kaW5qZWN0ID0gW1wiJHBhcnNlXCJdO1xuXG4gIGZ1bmN0aW9uIE1hc2soJHBhcnNlKSB7XG4gICAgZnVuY3Rpb24gaXNGb2N1c2VkIChlbGVtKSB7XG4gICAgICByZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwcmlvcml0eTogMTAwLFxuICAgICAgcmVxdWlyZTogJ25nTW9kZWwnLFxuICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIGd1bWdhTWFza09wdGlvbnM6ICc9Z3VtZ2FNYXNrT3B0aW9ucydcbiAgICAgIH0sXG4gICAgICBjb21waWxlOiBmdW5jdGlvbiBndW1nYU1hc2tDb21waWxpbmdGdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgbWFza0RlZmluaXRpb25zOiB7XG4gICAgICAgICAgICAvLyBOdW3DqXJpY29zXG4gICAgICAgICAgICAnOSc6IC9cXGQvLFxuICAgICAgICAgICAgLy8gQWxmYVxuICAgICAgICAgICAgJ0EnOiAvW2EtekEtWl0vLFxuICAgICAgICAgICAgLy8gQWxmYW51bcOpcmljb3NcbiAgICAgICAgICAgICcqJzogL1thLXpBLVowLTldL1xuICAgICAgICAgIH0sXG4gICAgICAgICAgLy8gU2UgdHJ1ZSwgbGltcGEgbyBjYW1wbyBjYXNvIGludsOhbGlkbyBubyBldmVudG8gb25CbHVyXG4gICAgICAgICAgY2xlYXJPbkJsdXI6IHRydWUsXG4gICAgICAgICAgLy8gRXZlbnRvcyBwYXJhIHByb2Nlc3NhbWVudG9cbiAgICAgICAgICBldmVudHNUb0hhbmRsZTogWydpbnB1dCcsICdrZXl1cCcsICdjbGljaycsICdmb2N1cyddXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGd1bWdhTWFza0xpbmtpbmdGdW5jdGlvbihzY29wZSwgZWxtLCBhdHRycywgY3RybCkge1xuICAgICAgICAgIHZhciBtYXNrUHJvY2Vzc2VkID0gZmFsc2UsIGV2ZW50c0JvdW5kID0gZmFsc2UsXG4gICAgICAgICAgbWFza0NhcmV0TWFwLCBtYXNrUGF0dGVybnMsIG1hc2tQbGFjZWhvbGRlciwgbWFza0NvbXBvbmVudHMsXG4gICAgICAgICAgbWluUmVxdWlyZWRMZW5ndGgsXG4gICAgICAgICAgdmFsdWUsIHZhbHVlTWFza2VkLCBpc1ZhbGlkLFxuICAgICAgICAgIG9yaWdpbmFsUGxhY2Vob2xkZXIgPSBhdHRycy5wbGFjZWhvbGRlcixcbiAgICAgICAgICBvcmlnaW5hbE1heGxlbmd0aCA9IGF0dHJzLm1heGxlbmd0aCxcbiAgICAgICAgICAvLyAvLyBWYXJpw6F2ZWlzIHVzYWRhcyBleGNsdXNpdmFtZW50ZSBwYXJhIGV2ZW50b3NcbiAgICAgICAgICBvbGRWYWx1ZSwgb2xkVmFsdWVVbm1hc2tlZCwgb2xkQ2FyZXRQb3NpdGlvbiwgb2xkU2VsZWN0aW9uTGVuZ3RoO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaW5pdGlhbGl6ZShtYXNrQXR0cikge1xuICAgICAgICAgICAgaWYgKCFhbmd1bGFyLmlzRGVmaW5lZChtYXNrQXR0cikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVuaW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvY2Vzc1Jhd01hc2sobWFza0F0dHIpO1xuICAgICAgICAgICAgaWYgKCFtYXNrUHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bmluaXRpYWxpemUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluaXRpYWxpemVFbGVtZW50KCk7XG4gICAgICAgICAgICBiaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGluaXRQbGFjZWhvbGRlcihwbGFjZWhvbGRlckF0dHIpIHtcbiAgICAgICAgICAgIGlmICghcGxhY2Vob2xkZXJBdHRyKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWFza1BsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXJBdHRyO1xuICAgICAgICAgICAgLy8gQXR1YWxpemFtb3MgbyB2YWxvciBkbyBpbnB1dFxuICAgICAgICAgICAgaWYgKG1hc2tQcm9jZXNzZWQpIHtcbiAgICAgICAgICAgICAgZWxtLnZhbChtYXNrVmFsdWUodW5tYXNrVmFsdWUoZWxtLnZhbCgpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGZvcm1hdHRlcihmcm9tTW9kZWxWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFtYXNrUHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmcm9tTW9kZWxWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gdW5tYXNrVmFsdWUoZnJvbU1vZGVsVmFsdWUgfHwgJycpO1xuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbGlkYXRlVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ21hc2snLCBpc1ZhbGlkKTtcbiAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkICYmIHZhbHVlLmxlbmd0aCA/IG1hc2tWYWx1ZSh2YWx1ZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcGFyc2VyKGZyb21WaWV3VmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghbWFza1Byb2Nlc3NlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZnJvbVZpZXdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gdW5tYXNrVmFsdWUoZnJvbVZpZXdWYWx1ZSB8fCAnJyk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gdmFsaWRhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICBjdHJsLiR2aWV3VmFsdWUgPSB2YWx1ZS5sZW5ndGggPyBtYXNrVmFsdWUodmFsdWUpIDogJyc7XG4gICAgICAgICAgICBjdHJsLiRzZXRWYWxpZGl0eSgnbWFzaycsIGlzVmFsaWQpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnJyAmJiBhdHRycy5yZXF1aXJlZCkge1xuICAgICAgICAgICAgICBjdHJsLiRzZXRWYWxpZGl0eSgncmVxdWlyZWQnLCAhY3RybC4kZXJyb3IucmVxdWlyZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWQgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbGlua09wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICAgICAgaWYgKHNjb3BlLmd1bWdhTWFza09wdGlvbnMpIHtcbiAgICAgICAgICAgIGxpbmtPcHRpb25zID0gc2NvcGUuZ3VtZ2FNYXNrT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzT2JqZWN0KGxpbmtPcHRpb25zKSkge1xuICAgICAgICAgICAgICBsaW5rT3B0aW9ucyA9IChmdW5jdGlvbihvcmlnaW5hbCwgY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gb3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3JpZ2luYWwsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50W2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50W2ldID0gYW5ndWxhci5jb3B5KG9yaWdpbmFsW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmV4dGVuZChjdXJyZW50W2ldLCBvcmlnaW5hbFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgICAgICAgIH0pKG9wdGlvbnMsIGxpbmtPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlua09wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zb2xlLmxvZyhsaW5rT3B0aW9ucyk7XG5cbiAgICAgICAgICBhdHRycy4kb2JzZXJ2ZSgnZ3VtZ2FNYXNrJywgaW5pdGlhbGl6ZSk7XG4gICAgICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLmd1bWdhTWFza1BsYWNlaG9sZGVyKSkge1xuICAgICAgICAgICAgYXR0cnMuJG9ic2VydmUoJ2d1bWdhTWFza1BsYWNlaG9sZGVyJywgaW5pdFBsYWNlaG9sZGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhdHRycy4kb2JzZXJ2ZSgncGxhY2Vob2xkZXInLCBpbml0UGxhY2Vob2xkZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbW9kZWxWaWV3VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICBhdHRycy4kb2JzZXJ2ZSgnbW9kZWxWaWV3VmFsdWUnLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgICBtb2RlbFZpZXdWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2NvcGUuJHdhdGNoKGF0dHJzLm5nTW9kZWwsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgaWYgKG1vZGVsVmlld1ZhbHVlICYmIHZhbCkge1xuICAgICAgICAgICAgICB2YXIgbW9kZWwgPSAkcGFyc2UoYXR0cnMubmdNb2RlbCk7XG4gICAgICAgICAgICAgIG1vZGVsLmFzc2lnbihzY29wZSwgY3RybC4kdmlld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjdHJsLiRmb3JtYXR0ZXJzLnB1c2goZm9ybWF0dGVyKTtcbiAgICAgICAgICBjdHJsLiRwYXJzZXJzLnB1c2gocGFyc2VyKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIHVuaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgICAgIG1hc2tQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHVuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChvcmlnaW5hbFBsYWNlaG9sZGVyKSkge1xuICAgICAgICAgICAgICBlbG0uYXR0cigncGxhY2Vob2xkZXInLCBvcmlnaW5hbFBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsbS5yZW1vdmVBdHRyKCdwbGFjZWhvbGRlcicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQob3JpZ2luYWxNYXhsZW5ndGgpKSB7XG4gICAgICAgICAgICAgIGVsbS5hdHRyKCdtYXhsZW5ndGgnLCBvcmlnaW5hbE1heGxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbG0ucmVtb3ZlQXR0cignbWF4bGVuZ3RoJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsbS52YWwoY3RybC4kbW9kZWxWYWx1ZSk7XG4gICAgICAgICAgICBjdHJsLiR2aWV3VmFsdWUgPSBjdHJsLiRtb2RlbFZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGluaXRpYWxpemVFbGVtZW50KCkge1xuICAgICAgICAgICAgdmFsdWUgPSBvbGRWYWx1ZVVubWFza2VkID0gdW5tYXNrVmFsdWUoY3RybC4kbW9kZWxWYWx1ZSB8fCAnJyk7XG4gICAgICAgICAgICB2YWx1ZU1hc2tlZCA9IG9sZFZhbHVlID0gbWFza1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSB2YWxpZGF0ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIHZhciB2aWV3VmFsdWUgPSBpc1ZhbGlkICYmIHZhbHVlLmxlbmd0aCA/IHZhbHVlTWFza2VkIDogJyc7XG4gICAgICAgICAgICBpZiAoYXR0cnMubWF4bGVuZ3RoKSB7IC8vIERvdWJsZSBtYXhsZW5ndGggdG8gYWxsb3cgcGFzdGluZyBuZXcgdmFsIGF0IGVuZCBvZiBtYXNrXG4gICAgICAgICAgICAgIGVsbS5hdHRyKCdtYXhsZW5ndGgnLCBtYXNrQ2FyZXRNYXBbbWFza0NhcmV0TWFwLmxlbmd0aCAtIDFdICogMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoICEgb3JpZ2luYWxQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICBlbG0uYXR0cigncGxhY2Vob2xkZXInLCBtYXNrUGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxtLnZhbCh2aWV3VmFsdWUpO1xuICAgICAgICAgICAgY3RybC4kdmlld1ZhbHVlID0gdmlld1ZhbHVlO1xuICAgICAgICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ21hc2snLCBpc1ZhbGlkKTtcbiAgICAgICAgICAgIC8vIE7Do28gdXNhbmRvICRzZXRWaWV3VmFsdWUsIGVudMOjbyBuw6NvIHNvYnJlZXNjcmV2ZVxuICAgICAgICAgICAgLy8gbyB2YWxvciBkbyBtb2RlbCBzZW0gaW50ZXJhw6fDo28gZG8gdXN1w6FyaW8uXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50c0JvdW5kKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsbS5iaW5kKCdibHVyJywgYmx1ckhhbmRsZXIpO1xuICAgICAgICAgICAgZWxtLmJpbmQoJ21vdXNlZG93biBtb3VzZXVwJywgbW91c2VEb3duVXBIYW5kbGVyKTtcbiAgICAgICAgICAgIGVsbS5iaW5kKGxpbmtPcHRpb25zLmV2ZW50c1RvSGFuZGxlLmpvaW4oJyAnKSwgZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgICAgIGVsbS5iaW5kKCdwYXN0ZScsIG9uUGFzdGVIYW5kbGVyKTtcbiAgICAgICAgICAgIGV2ZW50c0JvdW5kID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB1bmJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgICAgIGlmICghZXZlbnRzQm91bmQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxtLnVuYmluZCgnYmx1cicsIGJsdXJIYW5kbGVyKTtcbiAgICAgICAgICAgIGVsbS51bmJpbmQoJ21vdXNlZG93bicsIG1vdXNlRG93blVwSGFuZGxlcik7XG4gICAgICAgICAgICBlbG0udW5iaW5kKCdtb3VzZXVwJywgbW91c2VEb3duVXBIYW5kbGVyKTtcbiAgICAgICAgICAgIGVsbS51bmJpbmQoJ2lucHV0JywgZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgICAgIGVsbS51bmJpbmQoJ2tleXVwJywgZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgICAgIGVsbS51bmJpbmQoJ2NsaWNrJywgZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgICAgIGVsbS51bmJpbmQoJ2ZvY3VzJywgZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgICAgIGVsbS51bmJpbmQoJ3Bhc3RlJywgb25QYXN0ZUhhbmRsZXIpO1xuICAgICAgICAgICAgZXZlbnRzQm91bmQgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBWYWxpZGEgbyB0YW1hbmhvIG3DrW5pbW8gcmVxdWVyaWRvIGRhIG3DoXNjYXJhXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID8gdmFsdWUubGVuZ3RoID49IG1pblJlcXVpcmVkTGVuZ3RoIDogdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZW1vdmUgbcOhc2NhcmFcbiAgICAgICAgICBmdW5jdGlvbiB1bm1hc2tWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlVW5tYXNrZWQgPSAnJyxcbiAgICAgICAgICAgIG1hc2tQYXR0ZXJuc0NvcHkgPSBtYXNrUGF0dGVybnMuc2xpY2UoKTtcbiAgICAgICAgICAgIC8vIFByb2Nlc3NvIHBhcmEgcmV0aXJhciBjb21wb25lbnRlcyBkbyB2YWxvclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKG1hc2tDb21wb25lbnRzLCBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKGNvbXBvbmVudCwgJycpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2godmFsdWUuc3BsaXQoJycpLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgICAgICAgICAgaWYgKG1hc2tQYXR0ZXJuc0NvcHkubGVuZ3RoICYmIG1hc2tQYXR0ZXJuc0NvcHlbMF0udGVzdChjaHIpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVVbm1hc2tlZCArPSBjaHI7XG4gICAgICAgICAgICAgICAgbWFza1BhdHRlcm5zQ29weS5zaGlmdCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVVubWFza2VkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEFkaWNpb25hIG3DoXNjYXJhXG4gICAgICAgICAgZnVuY3Rpb24gbWFza1ZhbHVlKHVubWFza2VkVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZU1hc2tlZCA9ICcnLFxuICAgICAgICAgICAgbWFza0NhcmV0TWFwQ29weSA9IG1hc2tDYXJldE1hcC5zbGljZSgpO1xuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gobWFza1BsYWNlaG9sZGVyLnNwbGl0KCcnKSwgZnVuY3Rpb24oY2hyLCBpKSB7XG4gICAgICAgICAgICAgIGlmICh1bm1hc2tlZFZhbHVlLmxlbmd0aCAmJiBpID09PSBtYXNrQ2FyZXRNYXBDb3B5WzBdKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVNYXNrZWQgKz0gdW5tYXNrZWRWYWx1ZS5jaGFyQXQoMCkgfHwgJ18nO1xuICAgICAgICAgICAgICAgIHVubWFza2VkVmFsdWUgPSB1bm1hc2tlZFZhbHVlLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICBtYXNrQ2FyZXRNYXBDb3B5LnNoaWZ0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWVNYXNrZWQgKz0gY2hyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZU1hc2tlZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBPIGF0cmlidXRvIHBhZHLDo28gcGxhY2Vob2xkZXIgZnVuY2lvbmEgbm9ybWFsbWVudGUsXG4gICAgICAgICAgLy8gbyBhdHJpYnV0byBndW1nYU1hc2tQbGFjZWhvbGRlciBkZWZpbmUgYSBtw6FzY2FyYSBjb20gbyBwbGFjZWhvbGRlclxuICAgICAgICAgIC8vIGUgZGV2ZSBhdGVuZGVyIGEgcXVhbnRpZGFkZSBkZSBjYXJhY3RlcmVzIGRhIG3DoXNjYXJhLlxuICAgICAgICAgIGZ1bmN0aW9uIGdldFBsYWNlaG9sZGVyQ2hhcihpKSB7XG4gICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5ndW1nYU1hc2tQbGFjZWhvbGRlcikgPyBhdHRycy5ndW1nYU1hc2tQbGFjZWhvbGRlciA6IGF0dHJzLnBsYWNlaG9sZGVyO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBsYWNlaG9sZGVyICE9PSAndW5kZWZpbmVkJyAmJiBwbGFjZWhvbGRlcltpXSkge1xuICAgICAgICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXJbaV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gJ18nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGdldE1hc2tDb21wb25lbnRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hc2tQbGFjZWhvbGRlci5yZXBsYWNlKC9bX10rL2csICdfJykucmVwbGFjZSgvKFteX10rKShbYS16QS1aMC05XSkoW15fXSkvZywgJyQxJDJfJDMnKS5zcGxpdCgnXycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NSYXdNYXNrKG1hc2spIHtcbiAgICAgICAgICAgIHZhciBjaGFyYWN0ZXJDb3VudCA9IDA7XG5cbiAgICAgICAgICAgIG1hc2tDYXJldE1hcCA9IFtdO1xuICAgICAgICAgICAgbWFza1BhdHRlcm5zID0gW107XG4gICAgICAgICAgICBtYXNrUGxhY2Vob2xkZXIgPSAnJztcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtYXNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBtaW5SZXF1aXJlZExlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgICAgdmFyIGlzT3B0aW9uYWwgPSBmYWxzZSxcbiAgICAgICAgICAgICAgbnVtYmVyT2ZPcHRpb25hbENoYXJhY3RlcnMgPSAwLFxuICAgICAgICAgICAgICBzcGxpdE1hc2sgPSBtYXNrLnNwbGl0KCcnKTtcblxuICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc3BsaXRNYXNrLCBmdW5jdGlvbihjaHIsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlua09wdGlvbnMubWFza0RlZmluaXRpb25zW2Nocl0pIHtcblxuICAgICAgICAgICAgICAgICAgbWFza0NhcmV0TWFwLnB1c2goY2hhcmFjdGVyQ291bnQpO1xuXG4gICAgICAgICAgICAgICAgICBtYXNrUGxhY2Vob2xkZXIgKz0gZ2V0UGxhY2Vob2xkZXJDaGFyKGkgLSBudW1iZXJPZk9wdGlvbmFsQ2hhcmFjdGVycyk7XG4gICAgICAgICAgICAgICAgICBtYXNrUGF0dGVybnMucHVzaChsaW5rT3B0aW9ucy5tYXNrRGVmaW5pdGlvbnNbY2hyXSk7XG5cbiAgICAgICAgICAgICAgICAgIGNoYXJhY3RlckNvdW50Kys7XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluUmVxdWlyZWRMZW5ndGgrKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hyID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICAgIGlzT3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZPcHRpb25hbENoYXJhY3RlcnMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtYXNrUGxhY2Vob2xkZXIgKz0gY2hyO1xuICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyQ291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUG9zacOnw6NvIGRvIGN1cnNvciBpbWVkaWF0YW1lbnRlIGFww7NzIMO6bHRpbWEgcG9zacOnw6NvIHbDoWxpZGFcbiAgICAgICAgICAgIG1hc2tDYXJldE1hcC5wdXNoKG1hc2tDYXJldE1hcC5zbGljZSgpLnBvcCgpICsgMSk7XG5cbiAgICAgICAgICAgIG1hc2tDb21wb25lbnRzID0gZ2V0TWFza0NvbXBvbmVudHMoKTtcbiAgICAgICAgICAgIG1hc2tQcm9jZXNzZWQgPSBtYXNrQ2FyZXRNYXAubGVuZ3RoID4gMSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBibHVySGFuZGxlcigpIHtcbiAgICAgICAgICAgIC8vIFNlIGNsZWFyT25CbHVyIGZvciB0cnVlIGVtIG9wdGlvbnMsXG4gICAgICAgICAgICAvLyBsaW1wYSBvIGNhbXBvIGNhc28gZXN0ZWphIGludsOhbGlkby5cbiAgICAgICAgICAgIGlmIChsaW5rT3B0aW9ucy5jbGVhck9uQmx1cikge1xuICAgICAgICAgICAgICBvbGRDYXJldFBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgb2xkU2VsZWN0aW9uTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhbHVlTWFza2VkID0gJyc7XG4gICAgICAgICAgICAgICAgZWxtLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgY3RybC4kc2V0Vmlld1ZhbHVlKCcnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIG1vdXNlRG93blVwSGFuZGxlcihlKSB7XG4gICAgICAgICAgICBpZiAoZS50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgICBlbG0uYmluZCgnbW91c2VvdXQnLCBtb3VzZW91dEhhbmRsZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxtLnVuYmluZCgnbW91c2VvdXQnLCBtb3VzZW91dEhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsbS5iaW5kKCdtb3VzZWRvd24gbW91c2V1cCcsIG1vdXNlRG93blVwSGFuZGxlcik7XG5cbiAgICAgICAgICBmdW5jdGlvbiBtb3VzZW91dEhhbmRsZXIoKSB7XG4gICAgICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cbiAgICAgICAgICAgIG9sZFNlbGVjdGlvbkxlbmd0aCA9IGdldFNlbGVjdGlvbkxlbmd0aCh0aGlzKTtcbiAgICAgICAgICAgIGVsbS51bmJpbmQoJ21vdXNlb3V0JywgbW91c2VvdXRIYW5kbGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBvblBhc3RlSGFuZGxlcigpIHtcbiAgICAgICAgICAgIC8qanNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICAgICAgICAgICAgc2V0Q2FyZXRQb3NpdGlvbih0aGlzLCBlbG0udmFsKCkubGVuZ3RoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBldmVudEhhbmRsZXIoZSkge1xuICAgICAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gICAgICAgICAgICBlID0gZSB8fCB7fTtcbiAgICAgICAgICAgIC8vIFBlcm1pdGUgdW1hIG1pbmlmaWNhw6fDo28gbWFpcyBlZmljaWVudGVcbiAgICAgICAgICAgIHZhciBldmVudFdoaWNoID0gZS53aGljaCxcbiAgICAgICAgICAgIGV2ZW50VHlwZSA9IGUudHlwZTtcblxuICAgICAgICAgICAgaWYgKGV2ZW50V2hpY2ggPT09IDE2IHx8IGV2ZW50V2hpY2ggPT09IDkxKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbCA9IGVsbS52YWwoKSxcbiAgICAgICAgICAgIHZhbE9sZCA9IG9sZFZhbHVlLFxuICAgICAgICAgICAgdmFsTWFza2VkLFxuICAgICAgICAgICAgdmFsVW5tYXNrZWQgPSB1bm1hc2tWYWx1ZSh2YWwpLFxuICAgICAgICAgICAgdmFsVW5tYXNrZWRPbGQgPSBvbGRWYWx1ZVVubWFza2VkLFxuICAgICAgICAgICAgY2FyZXRQb3MgPSBnZXRDYXJldFBvc2l0aW9uKHRoaXMpIHx8IDAsXG4gICAgICAgICAgICBjYXJldFBvc09sZCA9IG9sZENhcmV0UG9zaXRpb24gfHwgMCxcbiAgICAgICAgICAgIGNhcmV0UG9zRGVsdGEgPSBjYXJldFBvcyAtIGNhcmV0UG9zT2xkLFxuICAgICAgICAgICAgY2FyZXRQb3NNaW4gPSBtYXNrQ2FyZXRNYXBbMF0sXG4gICAgICAgICAgICBjYXJldFBvc01heCA9IG1hc2tDYXJldE1hcFt2YWxVbm1hc2tlZC5sZW5ndGhdIHx8IG1hc2tDYXJldE1hcC5zbGljZSgpLnNoaWZ0KCksXG4gICAgICAgICAgICBzZWxlY3Rpb25MZW5PbGQgPSBvbGRTZWxlY3Rpb25MZW5ndGggfHwgMCxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQgPSBnZXRTZWxlY3Rpb25MZW5ndGgodGhpcykgPiAwLFxuICAgICAgICAgICAgd2FzU2VsZWN0ZWQgPSBzZWxlY3Rpb25MZW5PbGQgPiAwLFxuICAgICAgICAgICAgLy8gQ2FzZTogRGlnaXRhbmRvIHVtIGNhcmFjdGVyIHBhcmEgc3Vic3RpdHVpciB1bWEgc2VsZcOnw6NvXG4gICAgICAgICAgICBpc0FkZGl0aW9uID0gKHZhbC5sZW5ndGggPiB2YWxPbGQubGVuZ3RoKSB8fCAoc2VsZWN0aW9uTGVuT2xkICYmIHZhbC5sZW5ndGggPiB2YWxPbGQubGVuZ3RoIC0gc2VsZWN0aW9uTGVuT2xkKSxcbiAgICAgICAgICAgIC8vIENhc2U6IERlbGV0ZSBlIGJhY2tzcGFjZSBzZSBjb21wb3J0YW0gZGUgZm9ybWEgaWTDqm50aWNhIGVtIHVtYSBzZWxlw6fDo29cbiAgICAgICAgICAgIGlzRGVsZXRpb24gPSAodmFsLmxlbmd0aCA8IHZhbE9sZC5sZW5ndGgpIHx8IChzZWxlY3Rpb25MZW5PbGQgJiYgdmFsLmxlbmd0aCA9PT0gdmFsT2xkLmxlbmd0aCAtIHNlbGVjdGlvbkxlbk9sZCksXG4gICAgICAgICAgICBpc1NlbGVjdGlvbiA9IChldmVudFdoaWNoID49IDM3ICYmIGV2ZW50V2hpY2ggPD0gNDApICYmIGUuc2hpZnRLZXksIC8vIEFycm93IGtleSBjb2Rlc1xuXG4gICAgICAgICAgICBpc0tleUxlZnRBcnJvdyA9IGV2ZW50V2hpY2ggPT09IDM3LFxuICAgICAgICAgICAgLy8gTmVjZXNzw6FyaWEgZGV2aWRvIGFvIGV2ZW50byBuw6NvIGZvcm5lY2VyIHVtIGtleWNvZGVcbiAgICAgICAgICAgIGlzS2V5QmFja3NwYWNlID0gZXZlbnRXaGljaCA9PT0gOCB8fCAoZXZlbnRUeXBlICE9PSAna2V5dXAnICYmIGlzRGVsZXRpb24gJiYgKGNhcmV0UG9zRGVsdGEgPT09IC0xKSksXG4gICAgICAgICAgICBpc0tleURlbGV0ZSA9IGV2ZW50V2hpY2ggPT09IDQ2IHx8IChldmVudFR5cGUgIT09ICdrZXl1cCcgJiYgaXNEZWxldGlvbiAmJiAoY2FyZXRQb3NEZWx0YSA9PT0gMCkgJiYgIXdhc1NlbGVjdGVkKSxcbiAgICAgICAgICAgIC8vIExpZGEgY29tIGNhc29zIG9uZGUgYWNlbnRvIGNpcmN1bmZsZXhvIMOpIG1vdmlkbyBlIGNvbG9jYWRvIG5hIGZyZW50ZSBkYSBwb3Npw6fDo28gbWFza0NhcmV0TWFwIGludsOhbGlkby5cbiAgICAgICAgICAgIC8vIExvZ2ljIGFiYWl4byBhc3NlZ3VyYSBxdWUsIGFvIGNsaWNhciBvdSBwb3NpY2lvbmFtZW50byBhY2VudG8gY2lyY3VuZmxleG8gcGFyYSBhIGVzcXVlcmRhLCBhY2VudG9cbiAgICAgICAgICAgIC8vIGNpcmN1bmZsZXhvIMOpIG1vdmlkbyBwYXJhIGEgZXNxdWVyZGEgYXTDqSDDoCBkaXJlaXRhIGRpcmVjdGFtZW50ZSBkZSBjYXLDoXRlciBuw6NvLW3DoXNjYXJhLlxuICAgICAgICAgICAgLy8gVGFtYsOpbSBhcGxpY2FkbyBwYXJhIGNsaWNhciB1bWEgdmV6IHF1ZSBvcyB1c3XDoXJpb3Mgc8OjbyAoZGlzY3V0aXZlbG1lbnRlKSBtYWlzIHByb3BlbnNvcyBhIHZvbHRhclxuICAgICAgICAgICAgLy8gYXRyw6FzIGNvbSB1bSBwZXJzb25hZ2VtIGFvIGNsaWNhciBkZW50cm8gZGUgdW1hIGVudHJhZGEgY2hlaWEuXG4gICAgICAgICAgICBjYXJldEJ1bXBCYWNrID0gKGlzS2V5TGVmdEFycm93IHx8IGlzS2V5QmFja3NwYWNlIHx8IGV2ZW50VHlwZSA9PT0gJ2NsaWNrJykgJiYgY2FyZXRQb3MgPiBjYXJldFBvc01pbjtcblxuICAgICAgICAgICAgb2xkU2VsZWN0aW9uTGVuZ3RoID0gZ2V0U2VsZWN0aW9uTGVuZ3RoKHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBFdmVudG9zIHF1ZSBuw6NvIHJlcXVlcmVtIG5lbmh1bWEgYcOnw6NvXG4gICAgICAgICAgICBpZiAoaXNTZWxlY3Rpb24gfHwgKGlzU2VsZWN0ZWQgJiYgKGV2ZW50VHlwZSA9PT0gJ2NsaWNrJyB8fCBldmVudFR5cGUgPT09ICdrZXl1cCcpKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnRyb2xlIGRlIHZhbG9yZXNcbiAgICAgICAgICAgIC8vID09PT09PT09PT09PT09XG5cbiAgICAgICAgICAgIC8vIFVzZXIgYXR0ZW1wdGVkIHRvIGRlbGV0ZSBidXQgcmF3IHZhbHVlIHdhcyB1bmFmZmVjdGVkLS1jb3JyZWN0IHRoaXMgZ3JpZXZvdXMgb2ZmZW5zZVxuICAgICAgICAgICAgLy8gTyB1c3XDoXJpbyB0ZW50b3UgYXBhZ2FyLCBtYXMgdmFsb3IgYnJ1dG8gbsOjbyBmb2kgYWZldGFkbyAtIGNvcnJpZ2lyIGVzdGUgZ3JhdmUgb2ZlbnNhXG4gICAgICAgICAgICBpZiAoKGV2ZW50VHlwZSA9PT0gJ2lucHV0JykgJiYgaXNEZWxldGlvbiAmJiAhd2FzU2VsZWN0ZWQgJiYgdmFsVW5tYXNrZWQgPT09IHZhbFVubWFza2VkT2xkKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChpc0tleUJhY2tzcGFjZSAmJiBjYXJldFBvcyA+IGNhcmV0UG9zTWluICYmICFpc1ZhbGlkQ2FyZXRQb3NpdGlvbihjYXJldFBvcykpIHtcbiAgICAgICAgICAgICAgICBjYXJldFBvcy0tO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlIChpc0tleURlbGV0ZSAmJiBjYXJldFBvcyA8IGNhcmV0UG9zTWF4ICYmIG1hc2tDYXJldE1hcC5pbmRleE9mKGNhcmV0UG9zKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjYXJldFBvcysrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBjaGFySW5kZXggPSBtYXNrQ2FyZXRNYXAuaW5kZXhPZihjYXJldFBvcyk7XG4gICAgICAgICAgICAgIC8vIFN0cmlwIG91dCBub24tbWFzayBjaGFyYWN0ZXIgdGhhdCB1c2VyIHdvdWxkIGhhdmUgZGVsZXRlZCBpZiBtYXNrIGhhZG4ndCBiZWVuIGluIHRoZSB3YXkuXG4gICAgICAgICAgICAgIHZhbFVubWFza2VkID0gdmFsVW5tYXNrZWQuc3Vic3RyaW5nKDAsIGNoYXJJbmRleCkgKyB2YWxVbm1hc2tlZC5zdWJzdHJpbmcoY2hhckluZGV4ICsgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEF0dWFsaXphIHZhbG9yXG4gICAgICAgICAgICB2YWxNYXNrZWQgPSBtYXNrVmFsdWUodmFsVW5tYXNrZWQpO1xuXG4gICAgICAgICAgICBvbGRWYWx1ZSA9IHZhbE1hc2tlZDtcbiAgICAgICAgICAgIG9sZFZhbHVlVW5tYXNrZWQgPSB2YWxVbm1hc2tlZDtcbiAgICAgICAgICAgIGVsbS52YWwodmFsTWFza2VkKTtcbiAgICAgICAgICAgIGN0cmwuJHNldFZpZXdWYWx1ZSh2YWxVbm1hc2tlZCk7XG5cbiAgICAgICAgICAgIC8vIFBvc2nDp8OjbyBkbyBjdXJzb3JcbiAgICAgICAgICAgIC8vID09PT09PT09PT09PT09PT09PT1cblxuICAgICAgICAgICAgLy8gQ2FyYWN0ZXJlIGRpZ2l0YWRvIGEgZnJlbnRlIG5vcyBjYXNvcyBlbSBxdWUgbyBwcmltZWlybyBjYXJhY3RlcmUgZGUgZW50cmFkYSDDqSB1bSBjaGFyIG3DoXNjYXJhIGUgbyBjdXJzb3JcbiAgICAgICAgICAgIC8vIGZvciBjb2xvY2FkbyBuYSBwb3Npw6fDo28gMC5cbiAgICAgICAgICAgIGlmIChpc0FkZGl0aW9uICYmIChjYXJldFBvcyA8PSBjYXJldFBvc01pbikpIHtcbiAgICAgICAgICAgICAgY2FyZXRQb3MgPSBjYXJldFBvc01pbiArIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjYXJldEJ1bXBCYWNrKSB7XG4gICAgICAgICAgICAgIGNhcmV0UG9zLS07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhcmV0UG9zID0gY2FyZXRQb3MgPiBjYXJldFBvc01heCA/IGNhcmV0UG9zTWF4IDogY2FyZXRQb3MgPCBjYXJldFBvc01pbiA/IGNhcmV0UG9zTWluIDogY2FyZXRQb3M7XG5cbiAgICAgICAgICAgIHdoaWxlICghaXNWYWxpZENhcmV0UG9zaXRpb24oY2FyZXRQb3MpICYmIGNhcmV0UG9zID4gY2FyZXRQb3NNaW4gJiYgY2FyZXRQb3MgPCBjYXJldFBvc01heCkge1xuICAgICAgICAgICAgICBjYXJldFBvcyArPSBjYXJldEJ1bXBCYWNrID8gLTEgOiAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKGNhcmV0QnVtcEJhY2sgJiYgY2FyZXRQb3MgPCBjYXJldFBvc01heCkgfHwgKGlzQWRkaXRpb24gJiYgIWlzVmFsaWRDYXJldFBvc2l0aW9uKGNhcmV0UG9zT2xkKSkpIHtcbiAgICAgICAgICAgICAgY2FyZXRQb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9sZENhcmV0UG9zaXRpb24gPSBjYXJldFBvcztcbiAgICAgICAgICAgIHNldENhcmV0UG9zaXRpb24odGhpcywgY2FyZXRQb3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGlzVmFsaWRDYXJldFBvc2l0aW9uKHBvcykge1xuICAgICAgICAgICAgcmV0dXJuIG1hc2tDYXJldE1hcC5pbmRleE9mKHBvcykgPiAtMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRDYXJldFBvc2l0aW9uKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIWlucHV0KVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBpZiAoaW5wdXQuc2VsZWN0aW9uU3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gaW5wdXQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuICAgICAgICAgICAgICBpZiAoaXNGb2N1c2VkKGVsbVswXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBNYWxkaXRvIHNlamEgbyBJRVxuICAgICAgICAgICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIGlucHV0LnZhbHVlID8gLWlucHV0LnZhbHVlLmxlbmd0aCA6IDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb24udGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHNldENhcmV0UG9zaXRpb24oaW5wdXQsIHBvcykge1xuICAgICAgICAgICAgaWYgKCFpbnB1dClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgaWYgKGlucHV0Lm9mZnNldFdpZHRoID09PSAwIHx8IGlucHV0Lm9mZnNldEhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm47IC8vIElucHV0cyBlc2NvbmRpZG9zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAgICAgICAgICAgaWYgKGlzRm9jdXNlZChlbG1bMF0pKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBpbnB1dC5zZXRTZWxlY3Rpb25SYW5nZShwb3MsIHBvcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlucHV0LmNyZWF0ZVRleHRSYW5nZSkge1xuICAgICAgICAgICAgICAvLyBNYWxkaXRvIHNlamEgbyBJRVxuICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBpbnB1dC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgICAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIHBvcyk7XG4gICAgICAgICAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgcG9zKTtcbiAgICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0U2VsZWN0aW9uTGVuZ3RoKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIWlucHV0KVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBpZiAoaW5wdXQuc2VsZWN0aW9uU3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gKGlucHV0LnNlbGVjdGlvbkVuZCAtIGlucHV0LnNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS50ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMubWFzaycsIFtdKVxuICAuZGlyZWN0aXZlKCdndW1nYU1hc2snLCBNYXNrKTtcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXHRNZW51LiRpbmplY3QgPSBbXCIkaHR0cFwiLCBcIiRjb21waWxlXCJdO1xuXHQvKipcblx0ICogQG5nZG9jIGRpcmVjdGl2ZVxuXHQgKiBAbmFtZSAgZ3VtZ2EuY29yZTpndW1nYU1lbnVcblx0ICogQHJlc3RyaWN0IEVcblx0ICogQGRlc2NyaXB0aW9uXG5cdCAqICBPIGNvbXBvbmVudGUgZ3VtZ2FNZW51IMOpIHVtYSBkaXJlY3RpdmUgcXVlIGNyaWEgdW0gbWVudSBuYSBsYXRlcmFsIGVzcXVlcmRhIGRhIHRlbGEgcGFyYSBmYWNpbGl0YXIgYSBuYXZlZ2HDp8OjbyBkbyB1c3XDoXJpbyBubyBzaXN0ZW1hLlxuXHQgKiAgU2V1cyBpdGVucyBzw6NvIGNhcnJlZ2Fkb3MgZGUgZm9ybWEgZGluw6JtaWNhIGF0cmF2w6lzIGRlIHVtIGFycXVpdm8gYGpzb25gIHF1ZSDDqSBjYXJyZWdhZG8gYXRyYXbDqXMgZGUgdW1hIHJlcXVpc2nDp8OjbyBIVFRQLiBBbMOpbSBkaXNzbyxcblx0ICogIGVsZSBmYXogdW0gZmlsdHJvIGRlIGFjb3JkbyBjb20gYXMga2V5cyBwYXNzYWRhcyBwYXJhIGVsZSB0YW1iw6ltIGF0cmF2w6lzIGRlIHVtIGFycXVpdm8gYGpzb25gLlxuXHQgKiAgIyMgRXhlbXBsb1xuICAgICAqICBWZWphIHVtIGV4ZW1wbG8gZW0gZnVuY2lvbmFtZW50byBbYXF1aV0oaHR0cDovL2VtYmVkLnBsbmtyLmNvL1VjTXRBb3I2c1VBNnMwb1puSml1L3ByZXZpZXcpLlxuXHQgKiAgQHBhcmFtIHtTdHJpbmd9IG1lbnUtdXJsIFBhcsOibWV0cm8gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgdmFyacOhdmVsIGNvbSBvIGVuZGVyZcOnbyBkbyBhcnF1aXZvIGBqc29uYCBwYXJhIHF1ZSBzZWphIGNhcnJlZ2FkYSBhcyBlbnRyYWRhcyBkbyBtZW51LlxuXHQgKiAgQHBhcmFtIHtTdHJpbmd9IGtleXMtdXJsIFBhcsOibWV0cm8gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgdmFyacOhdmVsIGNvbSBvIGVuZGVyZcOnbyBkbyBhcnF1aXZvIGBqc29uYCBwYXJhIHF1ZSBzZWphIGNhcnJlZ2FkYSBhcyBjaGF2ZXMgcXVlIGZhcsOjbyBvIGZpbHRybyBkbyBtZW51LlxuXHQgKiAgQHBhcmFtIHtTdHJpbmd9IGltYWdlIFBhcsOibWV0cm8gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgdmFyacOhdmVsIGNvbSBvIGVuZGVyZcOnbyBkYSBpbWFnZW0gcXVlIGZpY2Fyw6Egbm8gbWVudS5cblx0ICpcbiBcdCAqICMjIEV4YW1wbGVcblx0ICogXHQjIyNFeGVtcGxvIGRlIGpzb24gcGFyYSBvIG1lbnU6XG5cdCAqIDxwcmU+XG4gICAgW1xuICAgICAge1xuICAgICAgICBcImxhYmVsXCI6IFwiSG9tZVwiLFxuICAgICAgICBcIlVSTFwiOiBcIndlbGNvbWVcIixcbiAgICAgICAgXCJrZXlcIjogXCJDUlVELUJBU0VcIixcbiAgICAgICAgXCJpY29uXCI6IFwiZ2x5cGhpY29uIGdseXBoaWNvbi1ob21lXCIsXG4gICAgICAgIFwiaWNvbl9jb2xvclwiOiBcIlwiLFxuICAgICAgICBcImltYWdlVXJsXCI6IFwiXCIsXG4gICAgICAgIFwiaW1hZ2VXaWR0aFwiOiBcIlwiLFxuICAgICAgICBcImltYWdlSGVpZ2h0XCI6IFwiXCIsXG4gICAgICAgIFwiZmlsaG9zXCI6IFtdXG4gICAgICB9XG4gICAgXVxuXHQgKiBcdDwvcHJlPlxuXHQgKiBcdCMjI0V4ZW1wbG8gZGUganNvbiBwYXJhIGFzIGtleXM6XG5cdCAqIFx0PHByZT5cbiAgICBbXG4gICAgICBcIkNSVUQtQkFTRVwiLFxuICAgICAgXCJDUlVELVVzZXJcIlxuICAgIF1cblx0ICogXHQ8L3ByZT5cblx0ICpcblx0ICpcblx0ICogIEBwYXJhbSB7U3RyaW5nfSBtZW51LXVybCBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIHZhcmnDoXZlbCBjb20gbyBlbmRlcmXDp28gZG8gYXJxdWl2byBganNvbmAgcGFyYSBxdWUgc2VqYSBjYXJyZWdhZGEgYXMgZW50cmFkYXMgZG8gbWVudS5cblx0ICogIEBwYXJhbSB7U3RyaW5nfSBrZXlzLXVybCBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIHZhcmnDoXZlbCBjb20gbyBlbmRlcmXDp28gZG8gYXJxdWl2byBganNvbmAgcGFyYSBxdWUgc2VqYSBjYXJyZWdhZGEgYXMgY2hhdmVzIHF1ZSBmYXLDo28gbyBmaWx0cm8gZG8gbWVudS5cblx0ICogIEBwYXJhbSB7U3RyaW5nfSBpbWFnZSBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIHZhcmnDoXZlbCBjb20gbyBlbmRlcmXDp28gZGEgaW1hZ2VtIHF1ZSBmaWNhcsOhIG5vIG1lbnUuXG5cdCAqXG5cblx0ICovXG5cdGZ1bmN0aW9uIE1lbnUoJGh0dHAsICRjb21waWxlKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHJlc3RyaWN0OiAnRScsXG5cdFx0XHRyZXBsYWNlOiB0cnVlLFxuXHRcdFx0c2NvcGU6IHt9LFxuXHRcdFx0bGluazogZnVuY3Rpb24gKHNjb3BlLCBlbCwgYXR0cnMpIHtcblx0XHRcdFx0c2NvcGUudiA9IFtdO1xuXHRcdFx0XHR2YXIgaW5kZXhzID0gW107XG5cdFx0XHRcdHZhciBjb3VudCA9IDA7XG5cblx0XHRcdFx0dmFyIG1lbnVPcGVuID0gZmFsc2U7XG5cblx0XHRcdFx0JGh0dHAuZ2V0KGF0dHJzLm1lbnVVcmwpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRcdFx0XHRzY29wZS5kYWRvcyA9IGRhdGEuZGF0YTtcblx0XHRcdFx0fSwgZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRcdFx0XHR0aHJvdyAnRXJybzonICsgZGF0YTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0JGh0dHAuZ2V0KGF0dHJzLmtleXNVcmwpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRcdFx0XHRzY29wZS5rZXlzID0gZGF0YS5kYXRhO1xuXHRcdFx0XHR9LCBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0XHRcdHRocm93ICdFcnJvOicgKyBkYXRhO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRzY29wZS4kd2F0Y2hHcm91cChbJ2RhZG9zJywgJ2tleXMnXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmIChzY29wZS5kYWRvcyAmJiBzY29wZS5rZXlzKSB7XG5cdFx0XHRcdFx0XHRnZXJhdGVNZW51cygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dmFyIGdlcmF0ZU1lbnVzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHZhciB0ZW1wbGF0ZSA9IFsnPGRpdj4nXTtcblx0XHRcdFx0XHR0ZW1wbGF0ZS5wdXNoKCc8YnV0dG9uIGlkPVwiYnRuLW1lbnVcIiBjbGFzcz1cImJ0biBidG4tbGlua1wiIG5nLWNsaWNrPVwibW9zdHJhck1lbnUoKVwiPjxpIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1hbGlnbi1qdXN0aWZ5XCI+PC9pPjwvYnV0dG9uPicpO1xuXHRcdFx0XHRcdHRlbXBsYXRlLnB1c2goJzxuYXYgaWQ9XCJtZW51XCIgY2xhc3M9XCJjb2wtc20tM1wiIG5hbWU9XCJtZW51XCI+Jyk7XG5cdFx0XHRcdFx0dGVtcGxhdGUucHVzaCgnPHVsIGNsYXNzPVwibWVudS1ob2xkZXJcIj4nKTtcblx0XHRcdFx0XHR0ZW1wbGF0ZS5wdXNoKCc8aW1nIG5nLXNyYz1cIicgKyBhdHRycy5pbWFnZSArICdcIiBhbHQ9XCJsb2dvXCIgd2lkdGg9XCI0MCVcIiBjbGFzcz1cImltZy1jZW50ZXJlZFwiPicpO1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2NvcGUuZGFkb3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChrZXlJc1ZhbGlkKHNjb3BlLmRhZG9zW2ldLmtleSkpIHtcblx0XHRcdFx0XHRcdFx0dGVtcGxhdGUucHVzaChnZXJhck5hdlBpbGwoc2NvcGUuZGFkb3NbaV0sICdtZW51Jywge2NvdW50OiAtMSwgbGFiZWw6IG51bGx9KSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRlbXBsYXRlLnB1c2goJzwvdWw+Jyk7XG5cdFx0XHRcdFx0dGVtcGxhdGUucHVzaCgnPC9uYXY+Jyk7XG5cdFx0XHRcdFx0dGVtcGxhdGUucHVzaCgnPC9kaXY+Jyk7XG5cdFx0XHRcdFx0dGVtcGxhdGUgPSB0ZW1wbGF0ZS5qb2luKCdcXG4nKTtcblx0XHRcdFx0XHRlbC5hcHBlbmQoJGNvbXBpbGUodGVtcGxhdGUpKHNjb3BlKSk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dmFyIGdlcmFyTmF2UGlsbCA9IGZ1bmN0aW9uIChwYXJhbSwgdHlwZSwgcGFyZW50KSB7XG5cblx0XHRcdFx0XHRzY29wZS52W2NvdW50XSA9IHtcblx0XHRcdFx0XHRcdGlzQWN0aXZlOiBmYWxzZSxcblx0XHRcdFx0XHRcdHBhcmVudDogcGFyZW50LmNvdW50XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdHZhciB1cmxTZWxlY3RlZCA9IGxvY2F0aW9uLmhhc2g7XG5cdFx0XHRcdFx0dmFyIHVybCA9IGFuZ3VsYXIuY29weShwYXJhbS5VUkwpO1xuXHRcdFx0XHRcdHVybCA9ICcjLycrdXJsLnJlcGxhY2UoJy4nLCcvJylcblx0XHRcdFx0XHRpZiAodXJsU2VsZWN0ZWQ9PXVybCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGVtcGxhdGUgPSBbJzxsaSBjbGFzcz1cIicgKyB0eXBlICsgJy1vcHRpb25cIiBzdHlsZT1cImJhY2tncm91bmQ6ICM0Y2EwODlcIiA+J107XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRlbXBsYXRlID0gWyc8bGkgY2xhc3M9XCInICsgdHlwZSArICctb3B0aW9uXCI+J107XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHBhcmFtLmZpbGhvcy5sZW5ndGggPiAwICYmIHZlcmlmaWNhclBlcm1pY2FvRmlsaG8ocGFyYW0uZmlsaG9zKSkge1xuXHRcdFx0XHRcdFx0dGVtcGxhdGUucHVzaCgnPGkgIG5nLWNsYXNzPVwidlsnICsgY291bnQgKyAnXS5pc0FjdGl2ZSA/IFxcJyBnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tZG93biBcXCcgOiBcXCdnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tcmlnaHRcXCdcIiBjbGFzcz1cImZhICcgKyB0eXBlICsgJy1jb2xvclwiICBuZy1jbGljaz1cInJlc2V0YXJNZW51KCcgKyBjb3VudCArICcpXCI+PC9pPicpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAocGFyYW0uaWNvbikge1xuXHRcdFx0XHRcdFx0XHRpZiAocGFyYW0uaWNvbl9jb2xvcikge1xuXHRcdFx0XHRcdFx0XHRcdHRlbXBsYXRlLnB1c2goJzxpICBjbGFzcz1cIiAnICsgcGFyYW0uaWNvbiArICcgXCIgc3R5bGU9XCJjb2xvcjogJyArIHBhcmFtLmljb25fY29sb3IgKyAnXCIgbmctY2xpY2s9XCJyZXNldGFyTWVudSgnICsgY291bnQgKyAnKVwiPjwvaT4nKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0ZW1wbGF0ZS5wdXNoKCc8aSAgY2xhc3M9XCIgJyArIHBhcmFtLmljb24gKyAnIFwiIHN0eWxlPVwiY29sb3I6ICNmZmZcIiBuZy1jbGljaz1cInJlc2V0YXJNZW51KCcgKyBjb3VudCArICcpXCI+PC9pPicpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGVtcGxhdGUucHVzaCgnPGEgdWktc3JlZj1cIicgKyBwYXJhbS5VUkwgKyAnXCIgbmctY2xhc3M9XCJ2WycgKyBjb3VudCArICddLmlzQWN0aXZlID8gXFwnaXMtYWN0aXZlXFwnIDogXFwnIFxcJ1wiJyk7XG5cdFx0XHRcdFx0aWYgKHBhcmVudC5sYWJlbCA9PT0gbnVsbCB8fCBwYXJhbS5maWxob3MubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0dGVtcGxhdGUucHVzaCgnZ3VtZ2EtdHJhbnNsYXRlLXRhZz1cIicgKyBwYXJhbS5sYWJlbC50b0xvd2VyQ2FzZSgpICsgJy5tZW51TGFiZWxcIj4nKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBhcmFtLmZpbGhvcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdHRlbXBsYXRlLnB1c2goJ2d1bWdhLXRyYW5zbGF0ZS10YWc9XCInICsgcGFyZW50LmxhYmVsLnRvTG93ZXJDYXNlKCkgKyAnLicgKyBwYXJhbS5sYWJlbC50b0xvd2VyQ2FzZSgpICsgJ1wiPicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0ZW1wbGF0ZS5wdXNoKHBhcmFtLmxhYmVsKTtcblx0XHRcdFx0XHR0ZW1wbGF0ZS5wdXNoKCc8L2E+Jyk7XG5cblx0XHRcdFx0XHRpZiAocGFyYW0uaW1hZ2VVcmwpIHtcblx0XHRcdFx0XHRcdGlmKHBhcmFtLmltYWdlV2lkdGggJiYgcGFyYW0uaW1hZ2VIZWlnaHQpe1xuXHRcdFx0XHRcdFx0XHR0ZW1wbGF0ZS5wdXNoKCc8YSB1aS1zcmVmPVwiJyArIHBhcmFtLlVSTCArICdcIj48aW1nICBzcmM9XCInICsgcGFyYW0uaW1hZ2VVcmwgKyAnXCIgc3R5bGU9XCJ3aWR0aDogJytwYXJhbS5pbWFnZVdpZHRoKyc7IGhlaWdodDogJytwYXJhbS5pbWFnZUhlaWdodCsnO1wiIG5nLWNsaWNrPVwicmVzZXRhck1lbnUoJyArIGNvdW50ICsgJylcIj48L2k+PC9hPicpO1xuXHRcdFx0XHRcdFx0fWVsc2Vcblx0XHRcdFx0XHRcdHRlbXBsYXRlLnB1c2goJzxhIHVpLXNyZWY9XCInICsgcGFyYW0uVVJMICsgJ1wiPjxpbWcgIHNyYz1cIicgKyBwYXJhbS5pbWFnZVVybCArICdcIiBzdHlsZT1cIndpZHRoOiAyMHB4OyBoZWlnaHQ6IDIwcHg7XCIgbmctY2xpY2s9XCJyZXNldGFyTWVudSgnICsgY291bnQgKyAnKVwiPjwvaT48L2E+Jyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIGF1eCA9IGNvdW50O1xuXG5cdFx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0XHRpZiAocGFyYW0uZmlsaG9zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdHRlbXBsYXRlLnB1c2goJzx1bCBuZy1jbGFzcz1cInZbJyArIChjb3VudCAtIDEpICsgJ10uaXNBY3RpdmUgPyBcXCcgc3VibWVudS1ncm91cC1hdGl2b1xcJyA6IFxcJ3N1Ym1lbnUtZ3JvdXBcXCdcIiBjbGFzcz1cIm1lbnUtaG9sZGVyXCI+Jyk7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtLmZpbGhvcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRpZiAoa2V5SXNWYWxpZChwYXJhbS5maWxob3NbaV0ua2V5KSkge1xuXHRcdFx0XHRcdFx0XHRcdHRlbXBsYXRlLnB1c2goZ2VyYXJOYXZQaWxsKHBhcmFtLmZpbGhvc1tpXSwgJ3N1Ym1lbnUnLCB7Y291bnQ6IGF1eCwgbGFiZWw6IHBhcmFtLmxhYmVsfSkpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0ZW1wbGF0ZS5wdXNoKCc8L3VsPicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0ZW1wbGF0ZS5wdXNoKCc8L2xpPicpO1xuXHRcdFx0XHRcdHJldHVybiB0ZW1wbGF0ZS5qb2luKCdcXG4nKTtcblx0XHRcdFx0fTtcblxuXG5cdFx0XHRcdHNjb3BlLnJlc2V0YXJNZW51ID0gZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0XHRcdFx0dmFyIGk7XG5cdFx0XHRcdFx0aWYgKHNjb3BlLnZbaW5kZXhdLmlzQWN0aXZlKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc2NvcGUudi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRzY29wZS52W2luZGV4XS5pc0FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c2V0YXJUcnVlKHNjb3BlLnZbaW5kZXhdLnBhcmVudCk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHNjb3BlLnYubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0c2NvcGUudltpXS5pc0FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c2V0YXJUcnVlKGluZGV4KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fTtcblxuXHRcdFx0XHR2YXIga2V5SXNWYWxpZCA9IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0XHRyZXR1cm4gc2NvcGUua2V5cy5pbmRleE9mKGtleSkgIT0gLTE7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0ZnVuY3Rpb24gc2V0YXJUcnVlKGluZGV4KSB7XG5cdFx0XHRcdFx0aWYgKGluZGV4ID49IDApIHtcblx0XHRcdFx0XHRcdHNjb3BlLnZbaW5kZXhdLmlzQWN0aXZlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHNldGFyVHJ1ZShzY29wZS52W2luZGV4XS5wYXJlbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLm1vc3RyYXJNZW51ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG1lbnVPcGVuID0gIW1lbnVPcGVuO1xuXG5cdFx0XHRcdFx0dmFyIGVsbSA9IGVsLmZpbmQoJ25hdicpO1xuXHRcdFx0XHRcdGlmIChtZW51T3Blbikge1xuXHRcdFx0XHRcdFx0ZWxtLmFkZENsYXNzKCdvcGVuLW1lbnUnKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZWxtLnJlbW92ZUNsYXNzKCdvcGVuLW1lbnUnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0ZnVuY3Rpb24gdmVyaWZpY2FyUGVybWljYW9GaWxobyhmaWxob3MpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGZpbGhvcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzY29wZS5rZXlzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChmaWxob3NbaV0ua2V5ID09IHNjb3BlLmtleXNbal0pIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5tZW51JyxbXSlcblx0LmRpcmVjdGl2ZSgnZ3VtZ2FNZW51JyxNZW51KTtcblxufSkoKTtcbiIsIihmdW5jdGlvbigpe1xuXG4gICd1c2Ugc3RyaWN0JztcbiAgTmF2LiRpbmplY3QgPSBbXCIkc3RhdGVcIiwgXCJHdW1nYVdlYlN0b3JhZ2VcIiwgXCIkbW9kYWxcIiwgXCIkcm9vdFNjb3BlXCIsIFwiJHRpbWVvdXRcIl07XG4gIC8qKlxuICAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAgKiBAbmFtZSAgZ3VtZ2EuY29yZTpndW1nYU5hdlxuICAqIEByZXN0cmljdCBFXG4gICogQGRlc2NyaXB0aW9uIE8gY29tcG9uZW50ZSBndW1nYU5hdiDDqSB1bWEgZGlyZWN0aXZlIHF1ZSBjcmlhIHVtYSBiYXJyYSBkZSBuYXZlZ2HDp8OjbyBzdXBlcmlvciwgcGFyYSBhanVkYXIgbyB1c3XDoXJpby4gRGVudHJvIGRhIGJhcnJhIGRlIG5hdmVnYcOnw6NvLFxuICAqICBwb3NzdcOtbW9zIHVtYSBidXNjYSBxdWUsIHF1YW5kbyBvIGJvdMOjbyBFTlRFUiDDqSBwcmVzc2lvbmFkbywgZWxlIHJlZGlyZWNpb25hIHBhcmEgYSBww6FnaW5hIGRlIEJ1c2NhIE11bHRpLWVudGlkYWRlcy4gUG9zc3VpIHRhbWLDqW0gaW5mb3JtYcOnw7VlcyBzb2JyZSBvIHVzdcOhcmlvIHF1ZSBlc3TDoSBsb2dhZG8sXG4gICogIHVtYSBvcMOnw6NvIHBhcmEgZmF6ZXIgbyBsb2dvdXQgZSBvdXRyYSBwYXJhIGFsdGVyYXIgYSBzZW5oYS5cbiAgKiAgIyMgRXhlbXBsb1xuICAqICBWZWphIHVtIGV4ZW1wbG8gZW0gZnVuY2lvbmFtZW50byBbYXF1aV0oaHR0cDovL2VtYmVkLnBsbmtyLmNvL1BlSkhBUzZ2aXV0dWVrdzYxNFpML3ByZXZpZXcpLlxuICAqICBAcGFyYW0ge1N0cmluZ30gdGl0bGUgUGFyw6JtZXRybyBuw6NvIG9icmlnYXTDs3JpbyBxdWUgY29udMOpbSB1bWEgc3RyaW5nIHF1ZSBzZXLDoSBvIHTDrXR1bG8gcXVlIGFwYXJlY2Vyw6EgbmEgYmFycmEgZGUgbmF2ZWdhw6fDo28uXG4gICogIEBwYXJhbSB7Qm9vbGVhbn0gbXVsdGktZW50aXR5IFBhcsOibWV0cm8gbmFvIG9icmlnYXTDs3JpbyBxdWUgY29udMOpbSB1bSB2YWxvciBib29sZWFubyBwYXJhIGNvbXBpbGFyIG91IG7Do28gYSBidXNjYSBtdWx0aWVudGlkYWRlLiBQb3IgcGFkcsOjbywgbyB2YWxvciDDqSB0cnVlLlxuICAqICBAcGFyYW0ge1N0cmluZ30gcHV0LXVybCBQYXLDom1ldHJvIG7Do28gb2JyaWdhdMOzcmlvIHF1ZSBjb250w6ltIHVtYSBTdHJpbmcgb3UgdW1hIHZhcmnDoXZlbCBxdWUgZXN0YXLDoSBubyAkc2NvcGUgZGEgZGlyZWN0aXZlIHBhcmEgYXRyaWJ1aXIgdW1hIHVybCBwYXJhIGZhemVyIG8gcHV0IGRvIGFsdGVyYXIgYSBzZW5oYS5cbiAgKiAgQHBhcmFtIHtTdHJpbmd9IHN0YXRlIFBhcsOibWV0cm8gb2JyaWdhdMOzcmlvIHF1ZSBjb250w6ltIHVtYSBTdHJpbmcgY29tIG8gJHN0YXRlIHBhcmEgcXVhbCBzZXLDoSByZWRpcmVjaW9uYWRvIHF1YW5kbyBvIHVzdcOhcmlvIGNsaWNhciBlbSBMb2dvdXQuXG4gICovXG4gIGZ1bmN0aW9uIE5hdigkc3RhdGUsIEd1bWdhV2ViU3RvcmFnZSwgJG1vZGFsLCAkcm9vdFNjb3BlLCAkdGltZW91dCkge1xuICAgIHZhciB0ZW1wbGF0ZSA9IFtcbiAgICAgICc8bmF2IGlkPVwibmF2YmFyXCI+JyxcbiAgICAgICcgPGEgaHJlZj1cIiNcIiBjbGFzcz1cIm5hdmJhci1sb2dvXCIgc3R5bGU9XCIgZmxvYXQ6IGxlZnQ7XCI+e3t0aXRsZSB8IHVwcGVyY2FzZX19PC9hPicsXG4gICAgICAnIDxzcGFuIHN0eWxlPVwiY29sb3I6IHdoaXRlOyBmb250LXNpemU6IDEuNGVtO21hcmdpbi1sZWZ0OiAyJTsgZmxvYXQ6IGxlZnQ7XCI+PHNtYWxsPnt7aW5mby5vcmdhbml6YXRpb259fTwvc21hbGw+PC9zcGFuPicsXG4gICAgICAnIDxkaXYgY2xhc3M9XCJuYXZiYXItZm9ybSBuYXZiYXItbGVmdFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+JyxcbiAgICAgICcgPGIgY2xhc3M9XCJwdWxsLXJpZ2h0XCI+JyxcbiAgICAgICcgICA8aW1nIG5nLXNob3c9XCJpbmZvLnBpY3R1cmVcIiBjbGFzcz1cImltZy1jaXJjbGVcIiBzdHlsZT1cIndpZHRoOiA0MHB4OyBoZWlnaHQ6IDQwcHg7IG1hcmdpbi1yaWdodDoxMHB4O1wiIHNyYz1cInt7aW5mby5waWN0dXJlfX1cIiAvPicsXG4gICAgICAnICAgPGEgaHJlZiBuZy1ibHVyPVwiaGlkZVBhbmVsKClcIiBjbGFzcz1cInN0YXR1cy1uYXZiYXJcIiBuZy1jbGljaz1cInNob3dQYW5lbE5hdkJhcigpXCI+JyxcbiAgICAgICcgICAgIDxzbWFsbCAgc3R5bGU9XCJmb250LXNpemU6IDg1JTtcIj57e2luZm8ubmFtZX19ICZuYnNwOyZuYnNwOyA8aSBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tdHJpYW5nbGUtYm90dG9tXCIgc3R5bGU9XCJtYXJnaW4tbGVmdDogMXB4XCI+PC9pPiA8L3NtYWxsPicsXG4gICAgICAnICAgPC9hPicsXG4gICAgICAnIDwvYj4nLFxuICAgICAgJyA8c3BhbiBuZy1pZj1cIm11bHRpZW50aXR5XCIgbmctY2xpY2s9XCJ0cmVhdFVybCgpXCIgY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXNlYXJjaCBidG4gcHVsbC1yaWdodFwiIHN0eWxlPVwiY29sb3I6I2ZmZjsgcGFkZGluZy10b3A6IDElOyBtYXJnaW4tcmlnaHQ6IDUlOyBoZWlnaHQ6IDEwMCU7XCI+PC9zcGFuPicsXG4gICAgICAnIDxpbnB1dCBuZy1pZj1cIm11bHRpZW50aXR5XCIgdHlwZT1cInRleHRcIiBpZD1cImlucHV0U2VhcmNoXCIgbmcta2V5dXA9XCJzdWJtaXRTZWFyY2goJGV2ZW50KVwiIHN0eWxlPVwiYmFja2dyb3VuZDogbm9uZSByZXBlYXQgc2Nyb2xsIDAgMCByZ2JhKDI0NCwgMjE0LCAyMTQsIDAuMTUpOyBib3JkZXI6IGRvdWJsZTsgZm9udC1zaXplOiAxNHB4OyBvdXRsaW5lOiAwOyBjb2xvcjogI2ZmZjsgaGVpZ2h0OiAxMDAlOyBtYXJnaW46IDA7IGJvcmRlci1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTsgei1pbmRleDogMjAwMDtcIiBuZy1tb2RlbD1cInNlYXJjaFwiIG5nLXNob3c9XCJpbnB1dFZpc2libGVcIiBjbGFzcz1cIm5hdmJhci1pbnB1dCBmbGlwLXJpZ2h0XCIgcGxhY2Vob2xkZXI9XCJTZWFyY2hcIj4nLFxuICAgICAgJzwvbmF2PicsXG4gICAgICAnPGRpdiBjbGFzcz1cIm5hdi1wYW5lbFwiIG5nLXNob3c9XCJzaG93UGFuZWxOYXZcIj4nLFxuICAgICAgJyA8ZGl2IGNsYXNzPVwicGFuZWwtYm9keVwiIGlkPVwibmF2UGFuZWxCb2R5XCI+JyxcbiAgICAgICcgICA8YnV0dG9uIG5nLXJlcGVhdD1cImxpbmsgaW4gbmF2bGlua3NcIiBuZy1jbGljaz1cImhhbmRsZShsaW5rKVwiIGNsYXNzPVwiYnRuIGJ0bi1saW5rXCIgc3R5bGU9XCJkaXNwbGF5OmJsb2NrO3dpZHRoOiAxMDAlO2NvbG9yOiBibGFjazsgZm9udC1zaXplOiAwLjllbTtcIj48aSBjbGFzcz1cInt7bGluay5nbHlwaGljb259fVwiPiA8L2k+e3tsaW5rLnRleHR9fSA8L2J1dHRvbj4nLFxuICAgICAgJyA8L2Rpdj4nLFxuICAgICAgJzwvZGl2PidcbiAgICBdO1xuXG4gICAgdmFyIG1vZGFsVGVtcGxhdGUgPSBbXG4gICAgICAnPGRpdiBjbGFzcz1cIm1vZGFsLWhlYWRlclwiPkNoYW5nZSBQYXNzd29yZDwvZGl2PicsXG4gICAgICAnPGRpdiBjbGFzcz1cIm1vZGFsLWJvZHlcIj4nICtcbiAgICAgICcgICA8Zm9ybSBuYW1lPVwiTW9kYWxGb3JtXCIgbm92YWxpZGF0ZT4nICtcbiAgICAgICcgICA8bGFiZWw+IDxzbWFsbD5PbGQgUGFzc3dvcmQ8L3NtYWxsPjwvbGFiZWw+JyArXG4gICAgICAnICAgPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiIG5nLWtleXVwPVwidmFsaWRQYXNzd29yZCh1c2VyLm5ld3Bhc3MsIHVzZXIub2xkcGFzcylcIiBuZy1mb2N1cz1cIm9sZFBhc3N3b3JkSW52YWxpZD1mYWxzZVwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgbmctbW9kZWw9XCJ1c2VyLm9sZHBhc3NcIiByZXF1aXJlZC8+JyArXG4gICAgICAnICAgPGxhYmVsIGNsYXNzPVwidGV4dC1kYW5nZXJcIiBzdHlsZT1cIndpZHRoOiAxMDAlO1wiICBuZy1zaG93PVwib2xkUGFzc3dvcmRJbnZhbGlkXCI+RXN0YSBuw6NvIMOpIHN1YSBzZW5oYSBhbnRpZ2E8L2xhYmVsPicgK1xuICAgICAgJyAgIDxsYWJlbD48c21hbGw+IE5ldyBQYXNzd29yZDwvc21hbGw+PC9sYWJlbD4nICtcbiAgICAgICcgICA8aW5wdXQgdHlwZT1cInBhc3N3b3JkXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBuZy1rZXl1cD1cInZhbGlkUGFzc3dvcmQodXNlci5uZXdwYXNzLCB1c2VyLm9sZHBhc3MpXCIgbmctbW9kZWw9XCJ1c2VyLm5ld3Bhc3NcIiByZXF1aXJlZC8+JyArXG4gICAgICAnICAgPGxhYmVsIGNsYXNzPVwidGV4dC1kYW5nZXJcIiBzdHlsZT1cIndpZHRoOiAxMDAlO1wiICBuZy1zaG93PVwibmV3UGFzc3dvcmRJbnZhbGlkXCI+UG9yIGZhdm9yIGluc2lyYSB1bWEgc2VuaGEgZGlmZXJlbnRlIGRhIGFudGlnYS48L2xhYmVsPicgK1xuICAgICAgJyAgIDxsYWJlbD48c21hbGw+IE5ldyBQYXNzd29yZCAoYWdhaW4pPC9zbWFsbD48L2xhYmVsPicgK1xuICAgICAgJyAgIDxpbnB1dCB0eXBlPVwicGFzc3dvcmRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIG5nLWtleXVwPVwidmFsaWRQYXNzd29yZENvbmZpcm0odXNlci5uZXdwYXNzLHVzZXIubmV3cGFzc2NoZWNrKVwiIG5nLW1vZGVsPVwidXNlci5uZXdwYXNzY2hlY2tcIiByZXF1aXJlZC8+JyArXG4gICAgICAnICAgPGxhYmVsIGNsYXNzPVwidGV4dC1kYW5nZXJcIiBzdHlsZT1cIndpZHRoOiAxMDAlO1wiICBuZy1zaG93PVwibmV3UGFzc3dvcmRDb25maXJtXCI+UmVwaXRhIGEgbm92YSBzZW5oYSBjb3JyZXRhbWVudGUuPC9sYWJlbD4nICtcbiAgICAgICc8L2Rpdj4nLFxuICAgICAgJzxkaXYgY2xhc3M9XCJtb2RhbC1mb290ZXJcIj4nICtcbiAgICAgICcgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5XCIgbmctY2xpY2s9XCJvayh1c2VyKVwiIHR5cGU9XCJzdWJtaXRcIiBuZy1kaXNhYmxlZD1cIk1vZGFsRm9ybS4kaW52YWxpZCB8fCAhYnRuRW5hYmxlZFwiPiBTYXZlPC9idXR0b24+JyArXG4gICAgICAnICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4td2FybmluZ1wiIG5nLWNsaWNrPVwiY2FuY2VsKClcIiB0eXBlPVwiYnV0dG9uXCI+IENhbmNlbDwvYnV0dG9uPicgK1xuICAgICAgJzwvZGl2PicgK1xuICAgICAgJzwvZm9ybT4nXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgIHNjb3BlOiBmYWxzZSxcbiAgICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlLmpvaW4oJ1xcbicpLFxuICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsLCBhdHRycykge1xuICAgICAgICAgIHZhciBwdXRVcmwgPSBhdHRycy5wdXRVcmw7XG4gICAgICAgICAgaWYoYXR0cnMubXVsdGlFbnRpdHkgPT0gXCJ0cnVlXCIgfHwgIWF0dHJzLm11bHRpRW50aXR5KSBzY29wZS5tdWx0aWVudGl0eSA9IHRydWU7XG4gICAgICAgICAgKCFzY29wZVthdHRycy5wdXRVcmxdKSA/IHB1dFVybCA9IHNjb3BlW2F0dHJzLnB1dFVybF0gOiBhbmd1bGFyLm5vb3A7XG4gICAgICAgICAgc2NvcGUuaW5mbyA9IEd1bWdhV2ViU3RvcmFnZS5nZXRTZXNzaW9uU3RvcmFnZUl0ZW0oJ3VzZXInKTtcbiAgICAgICAgICBzY29wZS5uYXZsaW5rcyA9IFt7dGV4dDogJ0NoYW5nZSBQYXNzd29yZCcsIGdseXBoaWNvbjogJ2dseXBoaWNvbiBnbHlwaGljb24tdXNlcicsIHZhbHVlOiAncGFzcyd9LCB7dGV4dDogJ0xvZ291dCcsIGdseXBoaWNvbjogJ2dseXBoaWNvbiBnbHlwaGljb24tbG9nLW91dCcsIHZhbHVlOiAnbG9nb3V0J31dO1xuICAgICAgICAgIHNjb3BlLmlucHV0VmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgIHNjb3BlLnRpdGxlID0gYXR0cnMudGl0bGUgfHwgJyc7XG4gICAgICAgICAgc2NvcGUudHJlYXRVcmwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzY29wZS5pbnB1dFZpc2libGUgPSAhc2NvcGUuaW5wdXRWaXNpYmxlO1xuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5wdXRTZWFyY2gnKS5mb2N1cygpO1xuICAgICAgICAgICAgfSwyMDApO1xuXG4gICAgICAgICAgfTtcbiAgICAgICAgICBzY29wZS4kb24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2NvcGUuc2hvd1BhbmVsTmF2ID0gZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2NvcGUuc2hvd1BhbmVsTmF2QmFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2NvcGUuc2hvd1BhbmVsTmF2ID0gIXNjb3BlLnNob3dQYW5lbE5hdjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBvYmogPSB7fTtcblxuICAgICAgICAgIHNjb3BlLnN1Ym1pdFNlYXJjaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGtleV9jb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICAgICAgICAgIGlmIChrZXlfY29kZSA9PT0gMTMpXG4gICAgICAgICAgICAkc3RhdGUuZ28oJ211bHRpZW50aXR5JywgeydzZWFyY2gnOiBzY29wZS5zZWFyY2h9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNjb3BlLmhpZGVQYW5lbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgc2NvcGUuc2hvd1BhbmVsTmF2ID0gZmFsc2U7XG4gICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBzY29wZS5oYW5kbGUgPSBmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgICAgc2NvcGUuc2hvd1BhbmVsTmF2ID0gIXNjb3BlLnNob3dQYW5lbE5hdjtcbiAgICAgICAgICAgIHN3aXRjaCAobGluay52YWx1ZSkge1xuICAgICAgICAgICAgICBjYXNlICdwYXNzJzpcbiAgICAgICAgICAgICAgdmFyIG1vZGFsSW5zdGFuY2UgPSAkbW9kYWwub3Blbih7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IG1vZGFsVGVtcGxhdGUuam9pbignXFxuJyksXG4gICAgICAgICAgICAgICAgc2l6ZTogJ3NtJyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBbXCIkc2NvcGVcIiwgXCIkbW9kYWxJbnN0YW5jZVwiLCBcIiRodHRwXCIsIFwiR3VtZ2FXZWJTdG9yYWdlXCIsIGZ1bmN0aW9uICgkc2NvcGUsICRtb2RhbEluc3RhbmNlLCAkaHR0cCwgR3VtZ2FXZWJTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdXNlclNlc3Npb24gPSBHdW1nYVdlYlN0b3JhZ2UuZ2V0U2Vzc2lvblN0b3JhZ2VJdGVtKCd1c2VyJyk7XG4gICAgICAgICAgICAgICAgICAkc2NvcGUuYnRuRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgJHNjb3BlLm9sZFBhc3N3b3JkSW52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgJHNjb3BlLm5ld1Bhc3N3b3JkQ29uZmlybSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgJHNjb3BlLm5ld1Bhc3N3b3JkSW52YWxpZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAkc2NvcGUudmFsaWRQYXNzd29yZENvbmZpcm0gPSBmdW5jdGlvbiAocGFzc3dvcmQsIGNvbmZpbVBhc3N3b3JkKXtcbiAgICAgICAgICAgICAgICAgICAgaWYocGFzc3dvcmQgIT09IGNvbmZpbVBhc3N3b3JkKXtcbiAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUubmV3UGFzc3dvcmRDb25maXJtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm5ld1Bhc3N3b3JkQ29uZmlybSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5lbmFibGVkQnRuKCk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICRzY29wZS52YWxpZFBhc3N3b3JkID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBvbGRQYXNzd29yZCl7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS51c2VyLm5ld3Bhc3NjaGVjayA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZihwYXNzd29yZCA9PSBvbGRQYXNzd29yZCAmJiBwYXNzd29yZCl7XG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm5ld1Bhc3N3b3JkSW52YWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5uZXdQYXNzd29yZEludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZW5hYmxlZEJ0bigpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAkc2NvcGUuZW5hYmxlZEJ0biA9IGZ1bmN0aW9uICgpe1xuICAgICAgICAgICAgICAgICAgICBpZighJHNjb3BlLm5ld1Bhc3N3b3JkQ29uZmlybSAmJiAhJHNjb3BlLm5ld1Bhc3N3b3JkSW52YWxpZCl7XG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmJ0bkVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYnRuRW5hYmxlZD0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgJHNjb3BlLm9rID0gZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgJGh0dHAucHV0KGF0dHJzLnB1dFVybCwge1xuICAgICAgICAgICAgICAgICAgICAgIHVzZXI6IHVzZXJTZXNzaW9uLnVzZXIsXG4gICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHVzZXIub2xkcGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICBuZXdQYXNzd29yZDogdXNlci5uZXdwYXNzfSlcbiAgICAgICAgICAgICAgICAgICAgICAuc3VjY2VzcyhmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEucmVzcG9uc2UgPT0gJ0JBRF9QQVNTV09SRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm9sZFBhc3N3b3JkSW52YWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEucmVzcG9uc2UgPT0gJ09LJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJGVtaXQoJ3N1Y2Nlc3NNZXNzYWdlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnU2VuaGEgYWx0ZXJhZGEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdTdWEgc2VuaGEgZm9pIGFsdGVyYWRhIGNvbSBzdWNlc3NvLidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJG1vZGFsSW5zdGFuY2UuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICRtb2RhbEluc3RhbmNlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJG1vZGFsSW5zdGFuY2UuZGlzbWlzcygpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICAgIHJlc29sdmU6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbW9kYWxJbnN0YW5jZS5yZXN1bHQudGhlbihmdW5jdGlvbiAoc2VsZWN0ZWRJdGVtKSB7XG4gICAgICAgICAgICAgICAgICBzY29wZS5zZWxlY3RlZCA9IHNlbGVjdGVkSXRlbTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdsb2dvdXQnOlxuICAgICAgICAgICAgICAgICRzdGF0ZS5nbyhhdHRycy5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbC5maW5kKCdpbnB1dCcpXG4gICAgICAgICAgICAub24oJ2tleXByZXNzJywgZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgaWYgKGsua2V5Q29kZSA9PSAxMylcbiAgICAgICAgICAgICAgc2NvcGUudHJlYXRVcmwoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5uYXYnLFsndWkuYm9vdHN0cmFwJ10pXG4gICAgICAuZGlyZWN0aXZlKCdndW1nYU5hdicsTmF2KVxuICAgIH0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdE9uZVRvTWFueS4kaW5qZWN0ID0gW1wiJG1vZGFsXCIsIFwiJHBvcHVsYXRlXCJdO1xuXHQvKipcblx0ICogQG5nZG9jIGRpcmVjdGl2ZVxuXHQgKiBAbmFtZSBndW1nYS5jb3JlOmd1bWdhT25lVG9NYW55XG5cdCAqIEByZXN0cmljdCBFXG5cdCAqIEBkZXNjcmlwdGlvblxuXHQgKiBcdEEgZGlyZWN0aXZlIGd1bWdhT25lVG9NYW55IHBvZGUgc2VyIHVzYWRhIHF1YW5kbyDDqSBuZWNlc3PDoXJpYSBhIGNyaWHDp8OjbyBkZSB1bWEgbGlzdGEgZGUgb2JqZXRvcyBkZW50cm8gZG8gZm9ybXVsw6FyaW8sIGVzcGVjaWFsbWVudGUgcXVhbmRvIGVzc2VzXG5cdCAqIFx0b2JqZXRvcyBhY2Vzc2FtIG91dHJvcyBTZXJ2aWNlcy4gRWxhIGxhbsOnYSB1bSBtb2RhbCBwYXJhIGEgY3JpYcOnw6NvIGRlc3RlcyBvYmpldG9zLCBxdWUgcG9kZW0gc2VyIHJlY3Vyc2l2b3MuIEFsw6ltIGRpc3NvLCBwb3NzdWkgc3Vwb3J0ZSBhIGVkacOnw6NvIGUgcmVtb8Onw6NvXG5cdCAqIFx0ZGVzdGVzIHJlZ2lzdHJvcy5cblx0ICogQHBhcmFtIHtBcnJheX0gY2hpbGRyZW4gUGFyw6JtZXRybyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtIEFycmF5IHF1ZSBzZXLDoSB1dGlsaXphZG8gcGFyYSBjb25zdHJ1aXIgYSBsaXN0YS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlLXVybCBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIHN0cmluZyByZWZlcmVuY2lhbmRvIGEgdXJsIG5hIHF1YWwgbyB0ZW1wbGF0ZSBkbyBtb2RhbCBlc3RhcsOhLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUGFyw6JtZXRybyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSBzdHJpbmcgY29tIGEgcHJvcHJpZWRhZGUgZG8gb2JqZXRvIHF1ZSBzZXLDoSBtb3N0cmFkYSBuYSBsaXN0YS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgKlV0aWxpemFyIG1vZGFsLXRpdGxlKi5cblx0ICogQHBhcmFtIHtTdHJpbmd9IG1vZGFsLXRpdGxlIFBhcsOibWV0cm8gbsOjbyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSBzdHJpbmcgY29tIG8gdMOtdHVsbyBxdWUgc2Vyw6EgcGFzc2FkbyBwYXJhIG8gY29udHJvbGxlclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29udHJvbGxlciBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIFN0cmluZyBxdWUgcmVmZXJlbmNpYXLDoSBvIG5vbWUgZG8gY29udHJvbGxlciBxdWUgc2Vyw6EgYXRyaWJ1aWRvIGFvIG1vZGFsLlxuXHQgKiAqRXN0ZSBjb250cm9sbGVyIG5lY2Vzc2l0YSBpbmpldGFyIGFsw6ltIGRvICRzY29wZSwgYXMgcHJvcHJpZWRhZGVzICoqZW50aXR5KiogZSAqKnRpdGxlKiogKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbi1kZWxldGUgUGFyw6JtZXRybyBuw6NvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIHZhcmnDoXZlbCBxdWUgaXLDoSBjb250ZXIgdW1hIGZ1bsOnw6NvIHF1ZSBzZXLDoSBjaGFtYWRhIHF1YW5kbyB1bSBlbGVtZW50byBkYSBsaXN0YSBmb3IgZGVsZXRhZG8uXG5cdCAqIEEgZnVuw6fDo28gcXVlIGVzdMOhIG5vIG9uLWRlbGV0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbi12YWx1ZS12aXN1YWxpemF0aW9uLW9wZW5lZCBQYXLDom1ldHJvIG7Do28gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgdmFyacOhdmVsIHF1ZSBwb3NzdWlyw6EgdW1hIGZ1bsOnw6NvIHF1ZSBpcsOhIHNlciBleGVjdXRhZGEgcXVhbmRvIG8gdXN1w6FyaW8gdGl2ZXIgYWJlcnRvIG8gbW9kYWxcbiAgICogcGFyYSB2aXN1YWxpemHDp8OjbyBkZSBkYWRvc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbi12YWx1ZS12aXN1YWxpemF0aW9uLWNsb3NlZCBQYXLDom1ldHJvIG7Do28gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgdmFyacOhdmVsIHF1ZSBwb3NzdWlyw6EgdW1hIGZ1bsOnw6NvIHF1ZSBpcsOhIHNlciBleGVjdXRhZGEgcXVhbmRvIG8gdXN1w6FyaW8gdGl2ZXIgZmVjaGFkbyBvIG1vZGFsXG4gICAqIHBhcmEgdmlzdWFsaXphw6fDo28gZGUgZGFkb3Ncblx0ICpcblx0ICovXG5cdGZ1bmN0aW9uIE9uZVRvTWFueSgkbW9kYWwsJHBvcHVsYXRlKXtcblx0XHR2YXIgdGVtcGxhdGUgPSBbXG5cdFx0JzxkaXYgY2xhc3M9XCJjb2wtbWQtMTJcIiBzdHlsZT1cInBhZGRpbmctbGVmdDogMDtwYWRkaW5nLXJpZ2h0OiAwXCI+Jyxcblx0XHQnICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHRcIiBuZy1jbGljaz1cIm5ld01vZGFsKClcIj5OZXc8L2J1dHRvbj4nLFxuXHRcdCcgICA8dWwgY2xhc3M9XCJsaXN0LWdyb3VwXCI+Jyxcblx0XHQnICAgICAgIDxsaSBuZy1yZXBlYXQ9XCJjaGlsZCBpbiBjaGlsZHJlblwiIGNsYXNzPVwibGlzdC1ncm91cC1pdGVtXCI+Jyxcblx0XHQnICAgICAgICAgICB7ezo6Y2hpbGRbcHJvcGVydHldfX0nLFxuXHRcdCcgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0IHB1bGwtcmlnaHQgYnRuLXNtXCIgbmctY2xpY2s9XCJuZXdNb2RhbChjaGlsZClcIj48aSBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tcGVuY2lsXCI+PC9pPjwvYnV0dG9uPicsXG5cdFx0JyAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWRhbmdlciBwdWxsLXJpZ2h0IGJ0bi1zbVwiIG5nLWNsaWNrPVwicmVtb3ZlRnJvbUxpc3QoY2hpbGQpXCI+PGkgY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXJlbW92ZVwiPjwvaT48L2J1dHRvbj4nLFxuXHRcdCcgICAgICAgPGRpdiBjbGFzcz1cImNsZWFyZml4XCI+PC9kaXY+PC9saT4nLFxuXHRcdCcgICA8dWw+Jyxcblx0XHQnPC9kaXY+Jyxcblx0XHQnPGRpdiBjbGFzcz1cImNsZWFyZml4XCI+PC9kaXY+J1xuXHRcdF07XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0cmVzdHJpY3Q6ICdFJyxcblx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5qb2luKCdcXG4nKSxcblx0XHRcdHNjb3BlOiB7XG5cdFx0XHRcdGNoaWxkcmVuOiAnPScsXG5cdFx0XHRcdHRlbXBsYXRlVXJsOiAnQCcsXG5cdFx0XHRcdHByb3BlcnR5OiAnQGRpc3BsYXlhYmxlUHJvcGVydHknLFxuXHRcdFx0XHRuYW1lOiAnQCcsXG5cdFx0XHRcdGNvbnRyb2xsZXI6ICdAJyxcblx0XHRcdFx0b25EZWxldGU6ICcmPycsXG5cdFx0XHRcdG9uVmFsdWVWaXN1YWxpemF0aW9uT3BlbmVkOiAnJj8nLFxuXHRcdFx0XHRvblZhbHVlVmlzdWFsaXphdGlvbkNsb3NlZDogJyY/Jyxcblx0XHRcdFx0bW9kYWxUaXRsZTogJ0AnXG5cdFx0XHR9LFxuXHRcdFx0bGluazogZnVuY3Rpb24gKHNjb3BlLGVsbSxhdHRycykge1xuXHRcdFx0XHR2YXIgZXZlbnRIYW5kbGVyID0ge1xuXHRcdFx0XHRcdHZhbHVlVmlzdWFsaXphdGlvbk9wZW5lZDogKGF0dHJzLm9uVmFsdWVWaXN1YWxpemF0aW9uT3BlbmVkID8gc2NvcGUub25WYWx1ZVZpc3VhbGl6YXRpb25PcGVuZWQgOmFuZ3VsYXIubm9vcCksXG5cdFx0XHRcdFx0dmFsdWVWaXN1YWxpemF0aW9uQ2xvc2VkOiAoYXR0cnMub25WYWx1ZVZpc3VhbGl6YXRpb25DbG9zZWQgPyBzY29wZS5vblZhbHVlVmlzdWFsaXphdGlvbkNsb3NlZCA6YW5ndWxhci5ub29wKSxcblx0XHRcdFx0XHRkZWxldGU6IChhdHRycy5vbkRlbGV0ZSA/IHNjb3BlLm9uRGVsZXRlIDogYW5ndWxhci5ub29wKVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRzY29wZS5uZXdNb2RhbCA9IG5ld01vZGFsO1xuXHRcdFx0XHRzY29wZS5yZW1vdmVGcm9tTGlzdCA9IHJlbW92ZUZyb21MaXN0O1xuXHRcdFx0XHRzY29wZS5nZXRGcm9tTW9kYWwgPSBnZXRGcm9tTW9kYWw7XG5cdFx0XHRcdHZhciBuYW1lID0gYXR0cnMubmFtZSB8fCAnTmV3Jztcblx0XHRcdFx0aWYoIXNjb3BlLmNoaWxkcmVuKSB0aHJvdyAnWW91IG11c3QgcHJvdmlkZSBhIGxpc3QgdG8gR3VtZ2FPbmVUb01hbnknO1xuXHRcdFx0XHRpZighc2NvcGUudGVtcGxhdGVVcmwpIHRocm93ICdZb3UgbXVzdCBwcm92aWRlIGEgdGVtcGxhdGVVcmwgZm9yIHRoZSBtb2RhbCc7XG5cdFx0XHRcdGlmKCFzY29wZS5wcm9wZXJ0eSkgdGhyb3cgJ1lvdSBtdXN0IHByb3ZpZGUgYSBwcm9wZXJ0eSB0byBkaXNwbGF5IGluIEd1bWdhT25lVG9NYW55Jztcblx0XHRcdFx0aWYoIXNjb3BlLmNvbnRyb2xsZXIpIHRocm93ICdZb3UgbXVzdCBwcm92aWRlIGEgY29udHJvbGxlciB0byB0aGUgbW9kYWwnO1xuXHRcdFx0XHRmdW5jdGlvbiBnZXRGcm9tTW9kYWwoc2VsZWN0ZWQpe1xuXHRcdFx0XHRcdGV2ZW50SGFuZGxlci52YWx1ZVZpc3VhbGl6YXRpb25DbG9zZWQoKTtcblx0XHRcdFx0XHRpZihKU09OLnN0cmluZ2lmeShzY29wZS5ldHR5KSAhPT0gJ3t9Jyl7XG5cdFx0XHRcdFx0XHRzY29wZS5jaGlsZHJlbi5zcGxpY2Uoc2NvcGUuY2hpbGRyZW4uaW5kZXhPZihzY29wZS5ldHR5KSwxLHNlbGVjdGVkKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2NvcGUuY2hpbGRyZW4ucHVzaChzZWxlY3RlZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGZ1bmN0aW9uIHJlbW92ZUZyb21MaXN0KG9iail7XG5cdFx0XHRcdFx0ZXZlbnRIYW5kbGVyLmRlbGV0ZSh7JHZhbHVlOiBvYmp9KTtcblx0XHRcdFx0XHRzY29wZS5jaGlsZHJlbi5zcGxpY2Uoc2NvcGUuY2hpbGRyZW4uaW5kZXhPZihvYmopLDEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZ1bmN0aW9uIG5ld01vZGFsKG9iail7XG5cdFx0XHRcdFx0c2NvcGUuZXR0eSA9IHt9O1xuXHRcdFx0XHRcdGlmKG9iail7XG5cdFx0XHRcdFx0XHRzY29wZS5ldHR5PSBvYmo7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGV2ZW50SGFuZGxlci52YWx1ZVZpc3VhbGl6YXRpb25PcGVuZWQoKTtcblx0XHRcdFx0XHR2YXIgbW9kYWxJbnN0YW5jZSA9ICRtb2RhbC5vcGVuKHtcblx0XHRcdFx0XHRcdHRlbXBsYXRlVXJsOiBzY29wZS50ZW1wbGF0ZVVybCxcblx0XHRcdFx0XHRcdGNvbnRyb2xsZXI6IHNjb3BlLmNvbnRyb2xsZXIsXG5cdFx0XHRcdFx0XHRyZXNvbHZlOiB7XG5cdFx0XHRcdFx0XHRcdGVudGl0eTogZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuZXR0eTtcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHNjb3BlLm5hbWU7XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBvcHVsYXRlU2NvcGU6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuICRwb3B1bGF0ZS5wb3B1bGF0ZVNjb3BlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0bW9kYWxJbnN0YW5jZS5yZXN1bHQudGhlbihnZXRGcm9tTW9kYWwpO1xuXHRcdFx0XHR9XG5cblxuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5vbmV0b21hbnknLFsnZ3VtZ2Euc2VydmljZXMucG9wdWxhdGUnXSlcblx0XHQuZGlyZWN0aXZlKCdndW1nYU9uZVRvTWFueScsT25lVG9NYW55KVxuXG5cbn0pKCk7XG4iLCIoZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgUXVlcnkuJGluamVjdD0gW107XG4gIC8qKlxuICAgKiBAbmdkb2MgZGlyZWN0aXZlXG4gICAqIEBuYW1lIGd1bWdhLmNvcmU6Z3VtZ2FRdWVyaWVzXG4gICAqIEByZXN0cmljdCBFXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBcdE8gY29tcG9uZW50ZSBndW1nYVF1ZXJpZXMgcG9kZSBzZXIgdXRpbGl6YWRvIGNvbW8gdW0gY29tcGxlbWVudG8gcGFyYSBhIGRpcmVjdGl2ZSBndW1nYVNlYXJjaCBwYXJhIHF1YW5kbyBlbGEgZm9yIHVtYSBidXNjYSBhdmFuw6dhZGEuIEVsZSB1dGlsaXphIG8gYXJyYXkgc2VhcmNoUXVlcmllcyBxdWUgw6lcbiAgICogXHRleHBvc3RvIHBlbG8gY29tcG9uZW50ZSBkZSBCdXNjYSBBdmFuw6dhZGEuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNhdmUtcXVlcnkgRnVuw6fDo28gcXVlIHNlcsOhIGV4ZWN1dGFkYSBxdWFuZG8gbyBib3TDo28gZGUgc2FsdmFyIGEgcGVzcXVpc2EgZm9yIGNsaWNhZG8uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBTdHJpbmcgcXVlIHNlcsOhIGNvbG9jYWRhIGNvbW8gdMOtdHVsb1xuICAgKiBAcGFyYW0ge1N0cmluZ30gcGxhY2Vob2xkZXIgU3RyaW5nIHF1ZSBzZXLDoSBjb2xvY2FkYSBjb21vIHBsYWNlaG9sZGVyIG8gaW5wdXQuXG4gICAqL1xuICBmdW5jdGlvbiBRdWVyeSgpe1xuICAgIHZhciBfdGVtcGxhdGUgPVxuICAgICc8ZGl2IGNsYXNzPVwiY29sLW1kLTEyXCIgbmctc2hvdz1cImhhc1F1ZXJpZXMgJiYgJHBhcmVudC5zZWFyY2hRdWVyaWVzLmxlbmd0aCA+IDBcIj4nK1xuICAgICcgICA8bGFiZWw+PHNtYWxsPnt7OjpsYWJlbH19PC9zbWFsbD48L2xhYmVsPicrXG4gICAgJyAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtMTJcIj4nK1xuICAgICcgICA8ZGl2IGNsYXNzPVwiY29sLW1kLThcIiAgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6IDA7cGFkZGluZy1yaWdodDogMDtcIj4nK1xuICAgICcgICA8Z3VtZ2EtYWR2YW5jZWQtbGFiZWwgJytcbiAgICAnICAgICAgICAgbmctcmVwZWF0PVwicXVlcnkgaW4gJHBhcmVudC5zZWFyY2hRdWVyaWVzXCInK1xuICAgICcgICAgICAgICBhdHRyPVwie3txdWVyeS5hdHRyaWJ1dGUubmFtZX19XCInK1xuICAgICcgICAgICAgICBocWw9XCJ7e3F1ZXJ5LmhxbC5sYWJlbH19XCInK1xuICAgICcgICAgICAgICB2YWx1ZT1cInF1ZXJ5LnZhbHVlXCInK1xuICAgICcgICAgICAgICBpbmRleD1cIiRpbmRleFwiJytcbiAgICAnICAgICAgICAgZGlzYWJsZWQ9XCJ0cnVlXCInK1xuICAgICcgICAgICAgICBzdHlsZT1cIm1hcmdpbi1yaWdodDogLjUlXCI+JytcbiAgICAnICAgPC9ndW1nYS1hZHZhbmNlZC1sYWJlbD4nK1xuICAgICc8L2Rpdj4nK1xuICAgICcgPGRpdiBjbGFzcz1cImNvbC1tZC00XCIgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6IDA7cGFkZGluZy1yaWdodDogMDtcIj4nK1xuICAgICcgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwIGlucHV0LWdyb3VwLXNtXCIgc3R5bGU9XCJcIj4nK1xuICAgICcgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cIm5hbWVcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIHBsYWNlaG9sZGVyPVwie3twbGFjZWhvbGRlcn19XCIgLz4nK1xuICAgICcgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYnRuXCI+JytcbiAgICAnICAgICAgIDxidXR0b24gbmctZGlzYWJsZWQ9XCIobmFtZS5sZW5ndGggPCAxKVwiIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5XCIgbmctY2xpY2s9XCJzYXZlUXVlcnkoe3F1ZXJ5OiAkcGFyZW50LnNlYXJjaFF1ZXJpZXMsbmFtZTogbmFtZX0pXCIgPicrXG4gICAgJyAgICAgICAgIDxpIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1mbG9wcHktc2F2ZVwiPjwvaT4nK1xuICAgICcgICAgICAgPC9idXR0b24+JytcbiAgICAnICAgICA8L3NwYW4+JytcbiAgICAnIDwvZGl2PicrXG4gICAgJyA8L2Rpdj4nK1xuICAgICc8L2Rpdj4nO1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgc2NvcGU6e1xuICAgICAgICBzYXZlUXVlcnk6ICcmJyxcbiAgICAgICAgcGxhY2Vob2xkZXI6ICdAPydcbiAgICAgIH0sXG4gICAgICB0ZW1wbGF0ZTogX3RlbXBsYXRlLFxuICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLGVsbSxhdHRycykge1xuICAgICAgICBzY29wZS5sYWJlbCA9IGF0dHJzLmxhYmVsIHx8ICdCdXNjYSBhdGl2YTonO1xuICAgICAgICBpZihzY29wZS4kcGFyZW50LnNlYXJjaFF1ZXJpZXMpe1xuICAgICAgICAgIHNjb3BlLmhhc1F1ZXJpZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMucXVlcmllcycsWydndW1nYS5kaXJlY3RpdmVzLnNlYXJjaC5hZHZhbmNlZGxhYmVsJ10pXG4gIC5kaXJlY3RpdmUoJ2d1bWdhUXVlcmllcycsUXVlcnkpO1xufSkoKTtcbiIsIiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cdC8qKlxuXHQgKiBAbmdkb2MgZGlyZWN0aXZlXG5cdCAqIEBuYW1lIGd1bWdhLmNvcmU6Z3VtZ2FTZWFyY2hcblx0ICogQHJlc3RyaWN0IEVcblx0ICogQGRlc2NyaXB0aW9uIEEgZGlyZWN0aXZlIGd1bWdhU2VhcmNoIHBvZGUgc2VyIHV0aWxpemFkYSBwYXJhIGZhemVyIG1vbnRhciBxdWVyaWVzIGRlIGJ1c2NhLCBzZWphbSBlc3NhcyBidXNjYXMgbm9ybWFpcyBvdSBhdmFuw6dhZGFzLiDDiSBwb3Nzw612ZWwgZXNjb2xoZXJcblx0ICogcXVhaXMgY2FtcG9zIG5vIHF1YWwgYSBidXNjYSBzZXLDoSBmZWl0YSwgYXNzaW0gY29tbyBuYSBidXNjYSBhdmFuw6dhZGEuXG5cdCAqICMjIEV4ZW1wbG9cbiAgICAgKiBWZWphIHVtIGV4ZW1wbG8gZW0gZnVuY2lvbmFtZW50byBbYXF1aV0oaHR0cDovL2VtYmVkLnBsbmtyLmNvL2V6WklUaDNaZm13VmFvMFh6MXc2L3ByZXZpZXcpLiAgICBcblx0ICpcblx0ICogTyBjb21wb25lbnRlIHV0aWxpemEtc2UgZGUgdGFncyBxdWUgc8OzIGZ1bmNpb25hbSBkZW50cm8gZGFzIHRhZ3MgZG8gY29tcG9uZW50ZSwgcXVlIHPDo28gYXMgdGFncyBgPGFkdmFuY2VkLWZpZWxkPjwvYWR2YW5jZWQtZmllbGQ+YC4gQSB0YWcgZGUgYWR2YW5jZWQtZmllbGQgXG5cdCAqIFx0cmVjZWJlIGRvaXMgYXRyaWJ1dG9zIGNvbW8gcGFyw6JtZXRybzogYG5hbWVgIGUgYHR5cGVgIHF1ZSByZWNlYmVtICwgcmVzcGVjdGl2YW1lbnRlLCBvIG5vbWUgZG8gYXRyaWJ1dG8gYSBzZXIgcGVzcXVpc2FkbyBlIHF1YWwgc2V1IHRpcG8uXG5cdCAqIFx0PHByZT5cblx0ICogIFx0XHQ8YWR2YW5jZWQtZmllbGQgbmFtZT1cIm5vbWVcIiB0eXBlPVwic3RyaW5nXCI+PC9hZHZhbmNlZC1maWVsZD5cblx0ICogIFx0XHQ8YWR2YW5jZWQtZmllbGQgbmFtZT1cImlkYWRlXCIgdHlwZT1cIm51bWJlclwiPjwvYWR2YW5jZWQtZmllbGQ+XG5cdCAqICA8L3ByZT5cblx0ICogXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGFkdmFuY2VkLW1ldGhvZCBQYXLDom1ldHJvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW1hIGZ1bsOnw6NvIHF1ZSBzZXLDoSB1dGlsaXphZGEgcGFyYSBmYXplciBhIGJ1c2NhIGF2YW7Dp2FkYS5cblx0ICogUGFyYSByZWNlYmVyIGEgcXVlcnkgYXZhbsOnYWRhLCBiYXN0YSBwYXNzYXIgdW0gcGFyw6JtZXRybyBgcGFyYW1gIHBhcmEgYSBmdW7Dp8Ojby4gYGFkdmFuY2VkLW1ldGhvZD1cImZ1bmN0aW9uKHBhcmFtKVwiYFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZWFyY2gtbWV0aG9kIFBhcsOibWV0cm8gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgZnVuw6fDo28gcXVlIHNlcsOhIHV0aWxpemFkYSBwYXJhIGZhemVyIGEgYnVzY2Egc2ltcGxlcy5cblx0ICogUGFyYSByZWNlYmVyIG8gY2FtcG8gZSBhIHBlc3F1aXNhIHF1ZSBmb2kgZmVpdGEsIGJhc3RhIHBhc3NhciBvcyBwYXLDom1ldHJvcyBgZmllbGRgIGUgYHBhcmFtYCBwYXJhIGEgZnVuw6fDo28uIGBzZWFyY2gtbWV0aG9kPVwiZnVuY3Rpb24oZmllbGQscGFyYW0pXCJgLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZmllbGRzIFBhcsOibWV0cm8gb2JyaWdhdMOzcmlvIHF1ZSBpcsOhIGNvbnRlciB1bWEgc2VxdcOqbmNpYSBkZSBjYW1wb3MgY29tIG8gcXVhbCBvIGNvbXBvbmVudGUgaXLDoSBjcmlhciBhIGxpc3RhIGRlIGF0cmlidXRvcyBxdWUgc2Vyw6NvIHBlc3F1aXPDoXZlaXMuXG5cdCAqIEV4ZW1wbG86IGBmaWVsZHM9XCJpZCxuYW1lLGNvbXBhbnksYWdlXCJgXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYWR2YW5jZWQgUGFyw6JtZXRybyBuw6NvIG9icmlnYXTDs3JpbyBxdWUgaXLDoSBjb250ZXIgdW0gdmFsb3IgYm9vbGVhbm8gcGFyYSBjb250cm9sYXIgc2UgbyBjb21wb25lbnRlIGlyw6Egb3UgbsOjbyBmYXplciBidXNjYSBhdmFuw6dhZGFcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gb24tc2VhcmNoIFBhcsOibWV0cm8gbsOjbyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSBmdW7Dp8OjbyBxdWUgc2Vyw6EgY2hhbWFkYSBxdWFuZG8gdW1hIGJ1c2NhIHNpbXBsZXMgZm9yIGZlaXRhLiBcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gb24tYWR2YW5jZWQtc2VhcmNoIFBhcsOibWV0cm8gbsOjbyBvYnJpZ2F0w7NyaW8gcXVlIGlyw6EgY29udGVyIHVtYSBmdW7Dp8OjbyBxdWUgc2Vyw6EgY2hhbWFkYSBxdWFuZG8gdW1hIGJ1c2NhIGF2YW7Dp2FkYSBmb3IgZmVpdGEuIFxuXHQgKlxuXHQgKiBcblx0ICovXG5cdGFuZ3VsYXIubW9kdWxlKCdndW1nYS5kaXJlY3RpdmVzLnNlYXJjaCcsXG5cdFx0W1xuXHRcdCdndW1nYS5kaXJlY3RpdmVzLnNlYXJjaC5zZWFyY2gnLFxuXHRcdCdndW1nYS5kaXJlY3RpdmVzLnNlYXJjaC5ub3JtYWxzZWFyY2gnLFxuXHRcdCdndW1nYS5kaXJlY3RpdmVzLnNlYXJjaC5hZHZhbmNlZHNlYXJjaCcsXG5cdFx0J2d1bWdhLmRpcmVjdGl2ZXMuc2VhcmNoLmFkdmFuY2VkbGFiZWwnLFxuXHRcdCdndW1nYS5kaXJlY3RpdmVzLnNlYXJjaC5zZWFyY2hoZWxwZXInLFxuXHRcdF0pO1xuXG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAgICogQG5hbWUgZ3VtZ2EuY29yZTpndW1nYVRhYmxlXG4gICAqIEByZXN0cmljdCBFXG4gICAqIEBkZXNjcmlwdGlvbiBPIGNvbXBvbmVudGUgKipHdW1nYVRhYmxlKiogc2VydmUgcGFyYSBleHBvciBkYWRvcyBlbSBmb3JtYSBkZSB0YWJlbGEuXG4gICAqIE8gY29tcG9uZW50ZSBleHDDtWUgbm8gJHNjb3BlLnNlbGVjdGVkRW50aXRpZXMgdW0gYXJyYXkgY29udGVuZG8gb3Mgb2JqZXRvcyBkYXMgbGluaGFzIHNlbGVjaW9uYWRhcyBwYXJhIHF1ZSBvIGRlc2Vudm9sdmVkb3IgcG9zc2EgdXNhLWxvcyBlbSBhw6fDtWVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBVbSBleGVtcGxvIGRhIGRpcmVjdGl2ZSBndW1nYVRhYmxlIGZ1bmNpb25hbmRvIHBvZGUgc2VyIGVuY29udHJhZG8gW2FxdWldKGh0dHA6Ly9lbWJlZC5wbG5rci5jby9TQUxrcDViS1JaMWF5d3NycG1FWCkuXG4gICAqICA8cHJlPlxuICAgKiAgICA8Z3VtZ2EtdGFibGUgdmFsdWVzPVwibGlzdFwiIGNvbHVtbnM9XCJuYW1lLGFnZVwiPjwvZ3VtZ2EtdGFibGU+XG4gICAqICAgIDxzY3JpcHQ+XG4gICAqICAgICRzY29wZS5saXN0ID0gW3tuYW1lOiAnR3VpbGhlcm1lJywgYWdlOiAyOH0se25hbWU6ICdJZ29yJywgYWdlOiAxOX1dO1xuICAgKiAgICA8L3NjcmlwdD5cbiAgICogIDwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVzIEF0cmlidXRvIG9icmlnYXTDs3Jpby4gRGV2ZSBzZXIgbyBub21lIGRvIGFycmF5IGV4cG9zdG8gbm8gJHNjb3BlIHBhcmEgcG9wdWxhciBhIHRhYmVsYS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbHVtbnMgQXRyaWJ1dG8gb2JyaWdhdMOzcmlvLiBBcyBwcm9wcmllZGFkZXMgZG8gb2JqZXRvIHF1ZSBzZXLDo28gYXByZXNlbnRhZG9zIGNvbW8gY29sdW5hcyBuYSB0YWJlbGEsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaXplIFBvc3N1ZW0gMyBvcMOnw7VlcyBkZSB0YW1hbmhvcywgKipsYXJnZSoqLCAqKm1lZGl1bSoqIGUgKipzbWFsbCoqLCBxdWUgcmVzcGVjdGl2YW1lbnRlIG9jdXBhbSwgdG9kbyBvIGVzcGHDp28gZGEgcm93LCBkb2lzIHRlcsOnb3MgZVxuICAgKiB1bSB0ZXLDp28uIE8gdmFsb3IgcGFkcsOjbyDDqSBsYXJnZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zbGF0ZS1lbnRpdHkgTm9tZSBkYSBlbnRpZGFkZS5cbiAgICogQHBhcmFtIHtBcnJheX0gcGFnZXMgRGV2ZSBjb250ZXIgb3MgdmFsb3JlcyBwYXJhIGFwcmVzZW50YXIgb3DDp8O1ZXMgZGUgcmVnaXN0cm9zIHBvciBww6FnaW5hLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGFibGUtY2xhc3MgUG9zc3VlbSAzIG9ww6fDtWVzLCAqKmJvcmRlcmVkKiosICoqc3RyaXBlZCoqIGUgKipjb25kZW5zZWQqKiwgcXVlIHJlc3BlY3RpdmFtZW50ZSwgYWRpY2lvbmEgYm9yZGFzIGEgdGFiZWxhLFxuICAgKiBhbHRlcm5hIGNvcmVzIGRhcyBsaW5oYXMgZSBkaW1pbnVpIG8gZXNwYcOnYW1lbnRvIGludGVybm8gZGFzIGxpbmhhcyBlIGNvbHVuYXMuIE8gdmFsb3IgcGFkcsOjbyDDqSBib3JkZXJlZC5cbiAgICogbyBjb21wb25lbnRlIHNlZ3VpcsOhIGEgb3JkZW0gZGUgY29sdW5hcyBhZGljaW9uYWRhIGFvIGF0cmlidXRvLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG11bHRpLXNlbGVjdGlvbiDDiSB0cnVlIHBvciBwYWRyw6NvLCBkZXRlcm1pbmEgYSBwb3NzaWJpbGlkYWRlIGRhIHNlbGXDp8OjbyBkZSB2w6FyaWFzIGVudGlkYWRlcyBvdSBhcGVuYXNcbiAgICogdW1hIHBvciB2ZXouXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNvcnQtZnVuY3Rpb24gTm9tZSBkYSBmdW7Dp8OjbyBhdHJpYnVpZGEgYW8gJHNjb3BlIHBhcmEgbWFuaXB1bGFyIGEgb3JkZW5hw6fDo28sIGEgZnVuw6fDo28gcmVjZWJlIGRvaXNcbiAgICogcGFyw6JtZXRyb3MsICoqZmllbGQqKiBlICoqd2F5KiogcXVlIHNlcsOjbywgYSBjb2x1bmEgZSBhIGRpcmXDp8OjbyBkYSBvcmRlbmHDp8OjbyByZXNwZWN0aXZhbWVudGUsIGV4aXN0ZW0gZHVhcyBkaXJlw6fDtWVzLFxuICAgKiAqKmFzYyoqIG91ICoqZGVzYyoqLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc29ydC1kZWZhdWx0IERldmUgY29udGVyIGEgKipjb2x1bmEqKiBlIGEgKipkaXJlw6fDo28qKiBzZXBhcmFkb3MgcG9yIHZpcmd1bGEsIHNlcsOhIGEgb3JkZW5hw6fDo28gcGFkcsOjbyBuYSBwcmltZWlyYSBleGliacOnw6NvIGRhIHRhYmVsYS5cbiAgICogQHBhcmFtIHtFeHByZXNzaW9ufSByb3ctY2xhc3MgRGV2ZSBjb250ZXIgdW1hIGV4cHJlc3PDo28gY29uZGljaW9uYWwgcGFyYSBtYXJjYXIgZGV0ZXJtaW5hZGFzIGxpbmhhcyBjb3JyZXNwb25kZW50ZXMgY29tb1xuICAgKiB2ZXJkYWRlaXJhcyBwZXJhbnRlIGEgZXhwcmVzc8Ojby5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25TZWxlY3QgTm9tZSBkYSBmdW7Dp8OjbyBxdWUgc2Vyw6EgZXhlY3V0YWRhIGFvIGV2ZW50byBjbGljay5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25Tb3J0IE5vbWUgZGEgZnVuw6fDo28gcXVlIHNlcsOhIGV4ZWN1dGFkYSBhbyBldmVudG8gZGUgc29ydC5cbiAgICovXG4gICBUYWJsZS4kaW5qZWN0ID0gW1wiR3VtZ2FVdGlsc1wiLCBcIiRjb21waWxlXCIsIFwiJHJvb3RTY29wZVwiLCBcIiRzdGF0ZVwiLCBcIkd1bWdhS2V5Ym9hcmRcIiwgXCIkdGltZW91dFwiXTtcbiAgIGZ1bmN0aW9uIFRhYmxlKEd1bWdhVXRpbHMsICRjb21waWxlLCRyb290U2NvcGUsJHN0YXRlLEd1bWdhS2V5Ym9hcmQsJHRpbWVvdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIG11bHRpOiAnPT9tdWx0aVNlbGVjdGlvbicsXG4gICAgICAgIGxpc3Q6ICc9dmFsdWVzJyxcbiAgICAgICAgcGFnZXM6ICc9cGFnZXMnLFxuICAgICAgICBzb3J0OiAnJj9zb3J0RnVuY3Rpb24nLFxuICAgICAgICByb3dDbGFzczogJz0/JyxcbiAgICAgICAgb25TZWxlY3Q6ICcmPycsXG4gICAgICAgIG9uU29ydDogJyY/J1xuICAgICAgfSxcbiAgICAgIGxpbms6IExpbmtGbixcbiAgICAgIHRyYW5zY2x1ZGU6IHRydWVcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gTGlua0ZuKHNjb3BlLCBlbG0sIGF0dHJzLCBjdHJsLCB0cmFuc2NsdWRlRm4pIHtcbiAgICAgIHZhciBldmVudEhhbmRsZXIgPSB7XG4gICAgICAgIHNlbGVjdDogKGF0dHJzLm9uU2VsZWN0ID8gc2NvcGUub25TZWxlY3QgOiBhbmd1bGFyLm5vb3ApLFxuICAgICAgICBzb3J0OiAoYXR0cnMub25Tb3J0ID8gc2NvcGUub25Tb3J0OiBhbmd1bGFyLm5vb3ApXG4gICAgICB9O1xuXG4gICAgICBzY29wZS4kb24oJ19jbGVhbicsZnVuY3Rpb24oKXtcbiAgICAgICBzY29wZS5jbGVhblNlYXJjaCgpO1xuICAgICB9KTtcblxuICAgICAgdmFyIENvbHVtbk9iamVjdCA9IHt9O1xuICAgICAgc2NvcGUuaW5kZXhlcyA9IFtdO1xuICAgICAgc2NvcGUudHJzID0gW107XG4gICAgICBzY29wZS4kcGFyZW50LnNlbGVjdGVkRW50aXRpZXMgPSBbXTtcbiAgICAgIHNjb3BlLm9iamVjdENvbHVtbiA9IFtdO1xuICAgICAgc2NvcGUuY29uZGl0aW9uYWxDb2x1bW5zID0gW107XG4gICAgICB2YXIgcmF3VGFibGVDb25maWcgPSB7XG4gICAgICAgIG11bHRpOiBzY29wZS5tdWx0aSxcbiAgICAgICAgbGlzdDogW10sXG4gICAgICAgIHBhZ2VzOiBzY29wZS5wYWdlcyB8fCBbMTAsIDI1LCA1MF0sXG4gICAgICAgIHNvcnRGbjogYXR0cnMuc29ydD8gc2NvcGUuc29ydCA6IGFuZ3VsYXIubm9vcCxcbiAgICAgICAgc29ydERmOiAhIWF0dHJzLnNvcnREZWZhdWx0PyBhdHRycy5zb3J0RGVmYXVsdC5zcGxpdCgnLCcpIDogZmFsc2UsXG4gICAgICAgIHNpemU6IGF0dHJzLnNpemUgfHwgJ2xhcmdlJyxcbiAgICAgICAgY2xhc3M6IGF0dHJzLnRhYmxlQ2xhc3MgfHwgJ2JvcmRlcmVkJyxcbiAgICAgICAgY29sdW1uczogYXR0cnMuY29sdW1ucy5zcGxpdCgnLCcpLFxuICAgICAgICBoZWFkaW5nczogW10sXG4gICAgICAgIHRyYW5zbGF0ZTogYXR0cnMudHJhbnNsYXRlRW50aXR5LFxuICAgICAgfTtcbiAgICAgIHZhciBpdGVtc1BlclBhZ2UgPSB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnaXRlbXNQZXJQYWdlJykgfHwgcmF3VGFibGVDb25maWcucGFnZXNbMF07XG4gICAgICBzY29wZS5pdGVtc1BlclBhZ2UgPSBpdGVtc1BlclBhZ2U7XG4gICAgICBzY29wZS4kcGFyZW50Lml0ZW1zUGVyUGFnZSA9IGl0ZW1zUGVyUGFnZTtcblxuICAgICAgc2NvcGUuJHdhdGNoKCdsaXN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2NvcGUubGlzdCkge1xuICAgICAgICAgIHNjb3BlLiRwYXJlbnQuc2VsZWN0ZWRFbnRpdGllcyA9IFtdO1xuICAgICAgICAgIHNjb3BlLnRhYmxlY29uZmlnLmxpc3QgPSBzY29wZS5saXN0O1xuICAgICAgICAgIHNjb3BlLmluZGV4ZXMgPSBbXTtcblxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgc2V0Q29sdW1uQ29uZmlnKHJhd1RhYmxlQ29uZmlnKTtcblxuICAgICAgZnVuY3Rpb24gc2V0Q29sdW1uQ29uZmlnKHJhd0NvbmZpZykge1xuICAgICAgICByYXdDb25maWcuY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChlbG0pIHtcbiAgICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgbGFiZWw6IEd1bWdhVXRpbHMuY2FtZWxDYXNlKGVsbSksXG4gICAgICAgICAgICBmaWVsZDogZWxtXG4gICAgICAgICAgfTtcbiAgICAgICAgICByYXdDb25maWcuaGVhZGluZ3MucHVzaCh7bGFiZWw6IG9iai5sYWJlbCwgd2F5OiBudWxsfSk7XG4gICAgICAgICAgcmF3Q29uZmlnLmNvbHVtbnMuc3BsaWNlKHJhd0NvbmZpZy5jb2x1bW5zLmluZGV4T2YoZWxtKSwgMSwgb2JqKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdHJhbnNjbHVkZUZuKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjbG9uZSwgZnVuY3Rpb24gKGNsb25lRWwpIHtcbiAgICAgICAgICAgIGlmIChjbG9uZUVsLm5vZGVOYW1lICE9IFwiI3RleHRcIikge1xuICAgICAgICAgICAgICBzd2l0Y2ggKGNsb25lRWwubm9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdHVU1HQS1CT09MRUFOLU1BU0snOlxuICAgICAgICAgICAgICAgIHJhd0NvbmZpZy5jb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgICAgaWYgKG9iai5maWVsZCA9PSBjbG9uZUVsLmdldEF0dHJpYnV0ZSgnY29sdW1uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQob2JqLCB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJ1ZVZhbHVlOiBjbG9uZUVsLmdldEF0dHJpYnV0ZSgnYm9vbGVhbi10cnVlJyksXG4gICAgICAgICAgICAgICAgICAgICAgZmFsc2VWYWx1ZTogY2xvbmVFbC5nZXRBdHRyaWJ1dGUoJ2Jvb2xlYW4tZmFsc2UnKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdCVVRUT05TLUNPTFVNTic6XG4gICAgICAgICAgICAgICAgc2NvcGUuYnV0dG9uRWxlbWVudHMgPSBjbG9uZUVsLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIHJhd0NvbmZpZy5oZWFkaW5ncy5wdXNoKHtsYWJlbDogJyAnLCB3YXk6IG51bGx9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdFWFRSQS1DT0xVTU4nOlxuICAgICAgICAgICAgICAgIHNjb3BlLmV4dHJhRWxlbWVudHMgPSBjbG9uZUVsLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIHJhd0NvbmZpZy5oZWFkaW5ncy5wdXNoKHtsYWJlbDogJyAnLCB3YXk6IG51bGx9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdPQkpFQ1QtQ09MVU1OJzpcbiAgICAgICAgICAgICAgICBzY29wZS5vYmplY3RDb2x1bW4ucHVzaCh7Y29sdW1uOiBjbG9uZUVsLmdldEF0dHJpYnV0ZSgnY29sdW1uJyksdmFsdWU6IGNsb25lRWwuZ2V0QXR0cmlidXRlKCdwcm9wZXJ0eScpfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnQ09MVU1OLUNMQVNTJzpcbiAgICAgICAgICAgICAgICBzY29wZS5jb25kaXRpb25hbENvbHVtbnMucHVzaCh7Y29sdW1uOiBjbG9uZUVsLmdldEF0dHJpYnV0ZSgnY29sdW1uJyksY29uZGl0aW9uYWw6IGNsb25lRWwuZ2V0QXR0cmlidXRlKCdjb25kaXRpb25hbC1jbGFzcycpfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xufSk7XG5zY29wZS50YWJsZWNvbmZpZyA9IHJhd0NvbmZpZztcbmdlbmVyYXRlVGFibGUoc2NvcGUudGFibGVjb25maWcpO1xufVxuZnVuY3Rpb24gZ2V0Q29uZGl0aW9ucygpe1xuICB2YXIgY29uZGl0aW9uVGV4dCA9IGF0dHJzLnJvd0NsYXNzIHx8ICcnO1xuICByZXR1cm4gY29uZGl0aW9uVGV4dC5yZXBsYWNlKC97LywnJykucmVwbGFjZSgvfS8sJycpLnNwbGl0KCcsJyk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVRhYmxlKGNvbmZpZykge1xuICB2YXIgdGVtcGxhdGUgPSBbXTtcbiAgaWYgKHNjb3BlLnBhZ2VzKSB7XG4gICAgdmFyIHBhZ2luYXRpb24gPVxuICAgICc8c2VsZWN0IG5nLW1vZGVsPVwiaXRlbXNQZXJQYWdlXCIgbmctY2hhbmdlPVwiY2hhbmdlSXRlbXNQZXJQYWdlKGl0ZW1zUGVyUGFnZSlcIj4nICtcbiAgICAnPG9wdGlvbiBuZy1yZXBlYXQ9XCJwIGluIHBhZ2VzXCIgdmFsdWU9XCJ7eyBwIH19XCIgbmctc2VsZWN0ZWQ9XCJwID09IGl0ZW1zUGVyUGFnZVwiPnt7IHAgfX08L29wdGlvbj4nICtcbiAgICAnPC9zZWxlY3Q+JztcbiAgICB0ZW1wbGF0ZS5wdXNoKHBhZ2luYXRpb24pO1xuICB9XG4gIHN3aXRjaCAoY29uZmlnLnNpemUpIHtcbiAgICBjYXNlICdsYXJnZSc6XG4gICAgdGVtcGxhdGUucHVzaChcbiAgICAgICc8ZGl2IGNsYXNzPVwiZnVsbC13aWR0aC13aXRob3V0LXBhZGRpbmdcIiBzdHlsZT1cIm1hcmdpbi10b3A6IDElXCI+JyArXG4gICAgICAnPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdCBidG4teHNcIiBzdHlsZT1cIm1hcmdpbi1ib3R0b206IDAuMjUlXCIgbmctY2xpY2s9XCJzZWxlY3RBbGwoKVwiPlNlbGVjaW9uYXIgdG9kb3M8L2J1dHRvbj4nICtcbiAgICAgICc8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi14c1wiIHN0eWxlPVwibWFyZ2luLWJvdHRvbTogMC4yNSU7bWFyZ2luLWxlZnQ6MC4yNSVcIiBuZy1jbGljaz1cImNsZWFuU2VhcmNoKClcIj4gTGltcGFyIHBlc3F1aXNhPC9idXR0b24+JyArXG4gICAgICAnPHRhYmxlIGNsYXNzPVwidGFibGUgdGFibGUtJyArIGNvbmZpZy5jbGFzcyArICcgXCI+Jyk7XG4gICAgYnJlYWs7XG4gICAgY2FzZSAnbWVkaXVtJzpcbiAgICB0ZW1wbGF0ZS5wdXNoKFxuICAgICAgJzxkaXYgY2xhc3M9XCJjb2wtbWQtOFwiIHN0eWxlPVwicGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDogMDtcIj4nICtcbiAgICAgICc8dGFibGUgY2xhc3M9XCJ0YWJsZSB0YWJsZS0nICsgY29uZmlnLmNsYXNzICsgJ1wiPicpO1xuICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NtYWxsJzpcbiAgICB0ZW1wbGF0ZS5wdXNoKFxuICAgICAgJzxkaXYgY2xhc3M9XCJjb2wtbWQtNFwiIHN0eWxlPVwicGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDogMDtcIj4nICtcbiAgICAgICc8dGFibGUgY2xhc3M9XCJ0YWJsZSB0YWJsZS0nICsgY29uZmlnLmNsYXNzICsgJ1wiPicpO1xuICAgIGJyZWFrO1xuICB9XG4gIHRlbXBsYXRlLnB1c2goJzx0aGVhZD4nKTtcbiAgdGVtcGxhdGUucHVzaCgnPHRyPicpO1xuICBpZiAoYXR0cnMuc29ydEZ1bmN0aW9uKSB7XG4gICAgdGVtcGxhdGUucHVzaCgnIDx0ZCBuZy1yZXBlYXQ9XCJoZWFkIGluIHRhYmxlY29uZmlnLmhlYWRpbmdzIHRyYWNrIGJ5ICRpbmRleFwiIG5nLWNsaWNrPVwiaGVhZC5sYWJlbCAhPT0gXFwnIFxcJyA/IHNvcnRBdXgoaGVhZCkgOiBcXCdcXCdcIicpO1xuICAgIHRlbXBsYXRlLnB1c2goJyAgICAgbmctY2xhc3M9XCJoZWFkLmxhYmVsICE9IFxcJyBcXCcgPyBcXCdjbGlja2FibGUtdGRcXCcgOiBcXCcgXFwnIFwiPicpO1xuICAgIHRlbXBsYXRlLnB1c2goJyAgICAgICAgIDxzbWFsbD57ezo6aGVhZC5sYWJlbH19PGkgbmctY2xhc3M9XCIoaGVhZC53YXkgIT0gbnVsbCAmJiBoZWFkLmxhYmVsICE9PSBcXCcgXFwnKSA/IChoZWFkLndheSA9PT0gdHJ1ZSA/IFxcJ2dseXBoaWNvbiBnbHlwaGljb24tbWVudS11cFxcJyA6IFxcJ2dseXBoaWNvbiBnbHlwaGljb24tbWVudS1kb3duXFwnKSA6IFxcJ1xcJ1wiPjwvaT48L3NtYWxsPjwvdGQ+Jyk7XG4gIH0gZWxzZSB7XG4gICAgdGVtcGxhdGUucHVzaCgnPHRkIG5nLXJlcGVhdD1cImhlYWQgaW4gdGFibGVjb25maWcuaGVhZGluZ3MgdHJhY2sgYnkgJGluZGV4XCI+e3s6OmhlYWQubGFiZWx9fScpO1xuICB9XG4gIHRlbXBsYXRlLnB1c2goJyA8L3RkPicpO1xuICB0ZW1wbGF0ZS5wdXNoKCc8L3RyPicpO1xuICB0ZW1wbGF0ZS5wdXNoKCc8L3RoZWFkPicpO1xuICB0ZW1wbGF0ZS5wdXNoKCc8dGJvZHk+Jyk7XG4gIGlmIChjb25maWcubXVsdGkgPT09IGZhbHNlKSB7XG4gICAgdGVtcGxhdGUucHVzaCgnPHRyIHN0eWxlPVwie3s6OmdldENsYXNzRnJvbUNvbmRpdGlvbmFsUm93KGVudGl0eSl9fVwiIG5nLWNsYXNzPVwicmV0dXJuQ2xhc3MoJGluZGV4KVwiIG5nLXJlcGVhdD1cImVudGl0eSBpbiB0YWJsZWNvbmZpZy5saXN0XCIgY2xhc3M9XCJ1c2VkXCIgbmctY2xpY2s9XCJoYW5kbGVTaW5nbGUoZW50aXR5LCRpbmRleClcIiBuZy1kYmxjbGljaz1cImdvVG9FZGl0KGVudGl0eS5pZClcIj4nICsgZ2VuZXJhdGVUYWJsZUNlbGwoY29uZmlnKSArICc8L3RyPicpO1xuICB9IGVsc2Uge1xuICAgIHRlbXBsYXRlLnB1c2goJzx0ciBzdHlsZT1cInt7OjpnZXRDbGFzc0Zyb21Db25kaXRpb25hbFJvdyhlbnRpdHkpfX1cIiBuZy1jbGFzcz1cInJldHVybkNsYXNzKCRpbmRleClcIiBuZy1yZXBlYXQ9XCJlbnRpdHkgaW4gdGFibGVjb25maWcubGlzdFwiIGNsYXNzPVwidXNlZFwiIG5nLWNsaWNrPVwiaGFuZGxlTXVsdGlwbGUoZW50aXR5LCRpbmRleClcIiBuZy1kYmxjbGljaz1cImdvVG9FZGl0KGVudGl0eS5pZClcIiA+JyArIGdlbmVyYXRlVGFibGVDZWxsKGNvbmZpZykgKyAnPC90cj4nKTtcbiAgfVxuICB0ZW1wbGF0ZS5wdXNoKCc8L3Rib2R5PicpO1xuICB0ZW1wbGF0ZS5wdXNoKCc8L3RhYmxlPjwvZGl2PicpO1xuICBlbG0uYXBwZW5kKCRjb21waWxlKHRlbXBsYXRlLmpvaW4oJ1xcbicpKShzY29wZSkpO1xuXG59XG52YXIgc2VsZWN0ZWQgPSBmYWxzZTtcblxuc2NvcGUuZ29Ub0VkaXQgPSBmdW5jdGlvbihpbmRleCl7XG4gICRzdGF0ZS5nbyhzY29wZS50YWJsZWNvbmZpZy50cmFuc2xhdGUgKyAnLicgKyAnZWRpdCcse2lkOiBpbmRleH0pO1xufTtcbnNjb3BlLmNoYW5nZUl0ZW1zUGVyUGFnZSA9IGZ1bmN0aW9uKGl0ZW1zUGVyUGFnZSl7XG4gIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdpdGVtc1BlclBhZ2UnLCBpdGVtc1BlclBhZ2UpO1xuICBzY29wZS4kcGFyZW50Lml0ZW1zUGVyUGFnZSA9IGl0ZW1zUGVyUGFnZTtcbn07XG5zY29wZS5zZWxlY3RBbGwgPSBmdW5jdGlvbigpe1xuICBpZighc2VsZWN0ZWQpe1xuICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IHNjb3BlLnRhYmxlY29uZmlnLmxpc3QubGVuZ3RoO2kgPCBsZW47aSsrKXtcbiAgICAgIHNjb3BlLmluZGV4ZXMucHVzaChpKTtcbiAgICB9XG4gICAgc2NvcGUuJHBhcmVudC5zZWxlY3RlZEVudGl0aWVzID0gc2NvcGUudGFibGVjb25maWcubGlzdDtcbiAgfSBlbHNlIHtcbiAgICBzY29wZS5pbmRleGVzID0gW107XG4gICAgc2NvcGUuJHBhcmVudC5zZWxlY3RlZEVudGl0aWVzID0gW107XG4gIH1cbiAgc2VsZWN0ZWQgPSAhc2VsZWN0ZWQ7XG59O1xuXG5cbnNjb3BlLmNsZWFuU2VhcmNoID0gZnVuY3Rpb24oKXtcbiAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdub3JtYWwnLHtmaWVsZDpzY29wZS50YWJsZWNvbmZpZy5jb2x1bW5zWzFdLHBhcmFtOiAnJ30pO1xuICBzY29wZS50YWJsZWNvbmZpZy5oZWFkaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKGVsbSl7XG4gICAgZWxtLndheSA9IG51bGw7XG4gIH0pXG59O1xuXG5zY29wZS5nZXRDbGFzc0Zyb21Db25kaXRpb25hbFJvdyA9IGZ1bmN0aW9uIChlbnRpdHkpe1xuICB2YXIgSGVscGVyT2JqZWN0ID0ge307XG4gIHZhciBjb25kaXRpb25zRnJvbVRhZyA9IGdldENvbmRpdGlvbnMoKTtcbiAgY29uZGl0aW9uc0Zyb21UYWcuZm9yRWFjaChmdW5jdGlvbihlbG0pe1xuICAgIEhlbHBlck9iamVjdFtlbG0uc3BsaXQoJzonKVswXV0gPSBldmFsKGVsbS5zcGxpdCgnOicpWzFdKTtcbiAgfSk7XG4gIGZvcih2YXIga2V5IGluIEhlbHBlck9iamVjdCkgaWYoSGVscGVyT2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkgJiYgSGVscGVyT2JqZWN0W2tleV0gPT09IHRydWUpe1xuICAgIHJldHVybiAnYm9yZGVyLWxlZnQ6IDNweCBzb2xpZCAnICsga2V5LnRyaW0oKTtcbiAgfVxuICByZXR1cm4gJyc7XG59O1xuXG5mdW5jdGlvbiBjaGVja09iamVjdChmaWVsZCl7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzY29wZS5vYmplY3RDb2x1bW4ubGVuZ3RoO2krKyl7XG4gICAgaWYoc2NvcGUub2JqZWN0Q29sdW1uW2ldLmNvbHVtbiA9PT0gZmllbGQpe1xuICAgICAgcmV0dXJuICd7ezo6ZW50aXR5LicrICBzY29wZS5vYmplY3RDb2x1bW5baV0udmFsdWUgKyd9fSc7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xhc3NGcm9tQ29uZGl0aW9uYWxDZWxsKGNvbHVtbixlbnRpdHkpe1xuICBzY29wZS5jb25kaXRpb25hbENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbihlbG0pe1xuICAgIGlmKGVsbS5jb2x1bW4udG9Mb3dlckNhc2UoKS50cmltKCkgPT09IGNvbHVtbi50b0xvd2VyQ2FzZSgpLnRyaW0oKSl7XG4gICAgICBDb2x1bW5PYmplY3RbZWxtLmNvbHVtbl0gPSB7fTtcbiAgICAgIGVsbS5jb25kaXRpb25hbC5yZXBsYWNlKC97LywnJykucmVwbGFjZSgvfS8sJycpLnNwbGl0KCcsJylcbiAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGFyZyl7XG4gICAgICAgIHZhciB4ID0gYXJnLnNwbGl0KCc6Jyk7XG4gICAgICAgIENvbHVtbk9iamVjdFtlbG0uY29sdW1uXVt4WzBdLnRyaW0oKS5yZXBsYWNlKC9cIi9nLCcnKV0gPSB4WzFdLnRyaW0oKTtcbiAgICAgIH0pXG4gICAgfVxuICB9KTtcbn1cblxuXG5zY29wZS5nZXRTdHlsZUZyb21DZWxsID0gZnVuY3Rpb24oZW50aXR5LGNvbHVtbil7XG4gIGlmKENvbHVtbk9iamVjdFtjb2x1bW4udHJpbSgpLnRvTG93ZXJDYXNlKCldKXtcbiAgICB2YXIgYXV4T2JqID0gQ29sdW1uT2JqZWN0W2NvbHVtbi50cmltKCkudG9Mb3dlckNhc2UoKV07XG4gICAgZm9yKHZhciBrZXkgaW4gYXV4T2JqKSBpZihhdXhPYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiBldmFsKGF1eE9ialtrZXldKSA9PT0gdHJ1ZSl7XG4gICAgICByZXR1cm4gJ2JvcmRlci1sZWZ0OiAzcHggc29saWQgJyArIGtleS50cmltKCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVRhYmxlQ2VsbChjb25maWcpIHtcbiAgdmFyIHRlbXBsYXRlID0gW107XG4gIGNvbmZpZy5jb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGVsbSkge1xuICAgIGdldENsYXNzRnJvbUNvbmRpdGlvbmFsQ2VsbChlbG0uZmllbGQpO1xuICAgIGlmIChlbG0udHJ1ZVZhbHVlKSB7XG4gICAgICB0ZW1wbGF0ZS5wdXNoKCc8dGQgc3R5bGU9XCJ7ezo6Z2V0U3R5bGVGcm9tQ2VsbChlbnRpdHksXFwnICcrIGVsbS5maWVsZCArICcgXFwnKX19XCI+e3s6OmVudGl0eS4nICsgZWxtLmZpZWxkICsgJyA9PT0gdHJ1ZT8gXFwnJyArIGVsbS50cnVlVmFsdWUgKyAnXFwnIDogXFwnJyArIGVsbS5mYWxzZVZhbHVlICsgJ1xcJ319PC90ZD4nKTtcbiAgICB9IGVsc2UgaWYoY2hlY2tPYmplY3QoZWxtLmZpZWxkKSAhPSAtMSl7XG4gICAgICB0ZW1wbGF0ZS5wdXNoKCc8dGQgc3R5bGU9XCJ7ezo6Z2V0U3R5bGVGcm9tQ2VsbChlbnRpdHksXFwnICcrIGVsbS5maWVsZCArICcgXFwnKX19XCI+JyArIGNoZWNrT2JqZWN0KGVsbS5maWVsZCkgKycgPC90ZD4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGVtcGxhdGUucHVzaCgnPHRkIHN0eWxlPVwie3s6OmdldFN0eWxlRnJvbUNlbGwoZW50aXR5LFxcJyAnKyBlbG0uZmllbGQgKyAnIFxcJyl9fVwiPnt7OjplbnRpdHkuJysgZWxtLmZpZWxkICsgJ319IDwvdGQ+Jyk7XG4gICAgfVxuICB9KTtcbiAgaWYgKHNjb3BlLmJ1dHRvbkVsZW1lbnRzKSB7XG4gICAgdGVtcGxhdGUucHVzaCgnPHRkIHN0eWxlPVwie3s6OmdldFN0eWxlRnJvbUNlbGwoZW50aXR5LFxcJyAnKyBlbG0uZmllbGQgKyAnIFxcJyl9fVwiPicgKyBnZXRTcGVjaWFsKHNjb3BlLmJ1dHRvbkVsZW1lbnRzKSArICc8L3RkPicpO1xuICB9XG4gIGlmIChzY29wZS5leHRyYUVsZW1lbnRzKSB7XG4gICAgdGVtcGxhdGUucHVzaCgnPHRkIHN0eWxlPVwie3s6OmdldFN0eWxlRnJvbUNlbGwoZW50aXR5LFxcJyAnKyBlbG0uZmllbGQgKyAnIFxcJyl9fVwiPicgKyBnZXRTcGVjaWFsKHNjb3BlLmV4dHJhRWxlbWVudHMpICsgJzwvdGQ+Jyk7XG4gIH1cbiAgcmV0dXJuIHRlbXBsYXRlLmpvaW4oJyAnKTtcbn1cblxuXG5mdW5jdGlvbiBnZXRTcGVjaWFsKGFycmF5KSB7XG4gIHZhciB0eHQgPSBbXTtcbiAgYW5ndWxhci5mb3JFYWNoKGFycmF5LCBmdW5jdGlvbiAoZWxtKSB7XG4gICAgdHh0LnB1c2goZWxtLm91dGVySFRNTCk7XG4gIH0pO1xuICByZXR1cm4gdHh0LmpvaW4oJyAnKTtcbn1cblxuICAgICAgICAgICAgLy8gTmVnYcOnw6NvIGR1cGxhIHRyYW5zZm9ybWEgZW0gYm9vbGVhblxuICAgICAgICAgICAgaWYgKCEhcmF3VGFibGVDb25maWcuc29ydERmKSB7XG4gICAgICAgICAgICAgIC8vIFNlIGhvdXZlciBvIGF0cmlidXRvIHNvcnQtZGVmYXVsdCBtb250YSBvIG9iamV0byBlIGRpc3BhcmEgbyBldmVudG9cbiAgICAgICAgICAgICAgdmFyIG9ialNvcnREZWZhdWx0ID0ge1xuICAgICAgICAgICAgICAgIGZpZWxkOiByYXdUYWJsZUNvbmZpZy5zb3J0RGZbMF0sXG4gICAgICAgICAgICAgICAgd2F5OiByYXdUYWJsZUNvbmZpZy5zb3J0RGZbMV1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyLnNvcnQoe2ZpZWxkOiBvYmpTb3J0RGVmYXVsdC5maWVsZH0pO1xuICAgICAgICAgICAgICBzY29wZS5zb3J0KG9ialNvcnREZWZhdWx0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NvcGUuc29ydEF1eCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICAvL1F1YW5kbyBlbGUgY2xpY2EsIGVsZSB2ZXJpZmljYSBzZSBqw6EgZXhpc3RlIGFsZ3VtYSBjb2x1bmEgY29tIHNvcnQsIHNlIGrDoSBleGlzdGlyLCByZXRvcm5hIGVsYSBwYXJhIG51bGxcbiAgICAgICAgICAgICAgICBzY29wZS50YWJsZWNvbmZpZy5oZWFkaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT0gb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkud2F5ID09PSB0cnVlIHx8IGtleS53YXkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAga2V5LndheSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBQZWdhIG8gaW5kZXggZG8gb2JqZXRvXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gc2NvcGUudGFibGVjb25maWcuaGVhZGluZ3MuaW5kZXhPZihvYmopO1xuICAgICAgICAgICAgICAgIC8vU2V0YSBvIHNvcnQgZGVsZSBwcmEgZmFsc2Ugb3UgdHJ1ZVxuICAgICAgICAgICAgICAgIG9iai53YXkgPSAhb2JqLndheTtcbiAgICAgICAgICAgICAgICAvL1JlbW92ZSBkYSBsaXN0YSBhbnRlcmlvciBvIGFudGlnbyBlIGNvbG9jYSBvIG5vdm9cbiAgICAgICAgICAgICAgICBzY29wZS50YWJsZWNvbmZpZy5oZWFkaW5ncy5zcGxpY2UoaW5kZXgsIDEsIG9iaik7XG4gICAgICAgICAgICAgICAgdmFyIGF1eDtcbiAgICAgICAgICAgICAgICAvLyBTZSBmb3IgdHJ1ZSwgw6kgYXNjZW5kZW50ZVxuICAgICAgICAgICAgICAgIGlmIChvYmoud2F5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBhdXggPSAnYXNjJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYXV4ID0gJ2Rlc2MnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBEaXNwYXJhIG8gZXZlbnRvXG4gICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyLnNvcnQoe2ZpZWxkOiBvYmoubGFiZWwudG9Mb3dlckNhc2UoKX0pO1xuICAgICAgICAgICAgICAgIHNjb3BlLnNvcnQoe2ZpZWxkOiBvYmoubGFiZWwudG9Mb3dlckNhc2UoKSwgd2F5OiBhdXh9KTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBzY29wZS5oYW5kbGVNdWx0aXBsZSA9IGZ1bmN0aW9uIChlbnRpdHksIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKEd1bWdhVXRpbHMuYXJlTm90RXF1YWxJbkFycmF5KHNjb3BlLmluZGV4ZXMsIGluZGV4KSB8fCBzY29wZS5pbmRleGVzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgIHNjb3BlLmluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgICBzY29wZS4kcGFyZW50LnNlbGVjdGVkRW50aXRpZXMucHVzaChlbnRpdHkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzY29wZS5pbmRleGVzLnNwbGljZShzY29wZS5pbmRleGVzLmluZGV4T2YoaW5kZXgpLCAxKTtcbiAgICAgICAgICAgICAgICAgIHNjb3BlLiRwYXJlbnQuc2VsZWN0ZWRFbnRpdGllcy5zcGxpY2Uoc2NvcGUuJHBhcmVudC5zZWxlY3RlZEVudGl0aWVzLmluZGV4T2YoZW50aXR5KSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlci5zZWxlY3Qoe3NlbGVjdGVkOiBzY29wZS4kcGFyZW50LnNlbGVjdGVkRW50aXRpZXN9KTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBzY29wZS5oYW5kbGVTaW5nbGUgPSBmdW5jdGlvbiAoZW50aXR5LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChzY29wZS5pbmRleGVzLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICBzY29wZS5pbmRleGVzID0gW107XG4gICAgICAgICAgICAgICAgICBzY29wZS4kcGFyZW50LnNlbGVjdGVkRW50aXRpZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2NvcGUuc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHNjb3BlLmluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgc2NvcGUuJHBhcmVudC5zZWxlY3RlZEVudGl0aWVzLnB1c2goZW50aXR5KTtcbiAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIuc2VsZWN0KHtzZWxlY3RlZDogc2NvcGUuJHBhcmVudC5zZWxlY3RlZEVudGl0aWVzfSk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgc2NvcGUucmV0dXJuQ2xhc3MgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUd1bWdhVXRpbHMuYXJlTm90RXF1YWxJbkFycmF5KHNjb3BlLmluZGV4ZXMsIGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICdpbmZvJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGFuZ3VsYXIubW9kdWxlKCdndW1nYS5kaXJlY3RpdmVzLnRhYmxlJyxbXSlcbiAgICAgICAgICAuZGlyZWN0aXZlKCdndW1nYVRhYmxlJyxUYWJsZSk7XG4gICAgICAgIH0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXHRVcGxvYWQuJGluamVjdCA9IFtcIiRodHRwXCIsIFwiJHBhcnNlXCIsIFwiJHRpbWVvdXRcIl07XG5cdC8qKlxuXHQgKiBAbmdkb2MgZGlyZWN0aXZlXG5cdCAqIEBuYW1lIGd1bWdhLmNvcmU6Z3VtZ2FVcGxvYWRcblx0ICogQHJlc3RyaWN0XG5cdCAqIEBkZXNjcmlwdGlvblxuXHQgKiBcdE8gY29tcG9uZW50ZSBndW1nYVVwbG9hZCBwb2RlIHNlciB1dGlsaXphZG8gcGFyYSBmYXplciB1cGxvYWQgZGUgaW1hZ2Vucy4gTyBmcmFtZXdvcmsgR1VNR0EgdXNhIHVtIG3DqXRvZG8gZGUgdXBsb2FkXG5cdCAqIFx0ZGUgaW1hZ2VucyBxdWUgZmF6IG8gdXBsb2FkIGRvIGFycXVpdm8gcGFyYSB1bWEgcGFzdGEgdGVtcG9yw6FyaWEgZSByZXRvcm5hIHVtIHRva2VuLiBRdWFuZG8gbyByZWdpc3RybyDDqSBzYWx2bywgbyBmcmFtZXdvcmsgZ3VtZ2Fcblx0ICogXHRmYXogbyBiaW5kIGRhIHN0cmluZyBxdWUgZXN0w6Egbm8gYXRyaWJ1dG8gY29tIG8gYXJxdWl2byB0ZW1wb3LDoXJpby5cblx0ICogXHRAcGFyYW0ge09iamV0fSBtb2RlbCBPYmpldG8gcXVlIGlyw6EgY29udGVyIGFzIGluZm9ybWHDp8O1ZXMgZGEgaW1hZ2VtLlxuXHQgKiBcdEBwYXJhbSB7RnVuY3Rpb259IHVwbG9hZC1tZXRob2QgRnVuw6fDo28gcXVlIHNlcsOhIGV4ZWN1dGFkYSBwYXJhIGZhemVyIG8gdXBsb2FkIGRhIGltYWdlbSBwYXJhIG8gYXJxdWl2byB0ZW1wb3LDoXJpby5cblx0ICogXHRAcGFyYW0ge0Z1bmN0aW9ufSBkZWxldGUtbWV0aG9kIEZ1bsOnw6NvIHF1ZSBzZXLDoSBleGVjdXRhZGEgcGFyYSBkZWxldGFyIGEgaW1hZ2VtIGRvIGVzcGHDp28gdGVtcG9yw6FyaW8uXG5cdCAqIFx0QHBhcmFtIHtTdHJpbmd9IHRvb2x0aXAtdGV4dCBNZW5zYWdlbSBxdWUgaXLDoSBhcGFyZWNlciBubyB0b29sdGlwIGRhIGltYWdlbS5cblx0ICovXG5cdGZ1bmN0aW9uIFVwbG9hZCgkaHR0cCwkcGFyc2UsJHRpbWVvdXQpe1xuXG5cdFx0dmFyIGltZyA9XG5cdFx0JzxkaXYgbmctY2xpY2s9XCJmaXJlQ2xpY2soKVwiIG5nLXNob3c9XCJmbGFnXCIgY2xhc3M9XCJjb2wtbWQtMVwiIHRvb2x0aXA9XCJ7ezo6dG9vbHRpcFRleHR9fVwiIHRvb2x0aXAtcGxhY2VtZW50PVwicmlnaHRcIj4nK1xuXHRcdCdcdDxzdmcgdmVyc2lvbj1cIjEuMVwiIGlkPVwiTGF5ZXJfMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4PVwiMHB4XCIgeT1cIjBweFwiIHdpZHRoPVwiMTI4cHhcIiBoZWlnaHQ9XCIxMjhweFwiIHZpZXdCb3g9XCIwIDAgNTEyIDUxMlwiIGVuYWJsZS1iYWNrZ3JvdW5kPVwibmV3IDAgMCA1MTIgNTEyXCIgeG1sOnNwYWNlPVwicHJlc2VydmVcIj4nK1xuXHRcdCdcdFx0PHBhdGggaWQ9XCJhdmF0YXJcIiBmaWxsPVwiI2NjY2NjY1wiIGQ9XCJNNDkwLjU3OSwzODMuMDI5Yy0xNC4xNTItMjIuMDg2LTYxLjc2My0zNS44MjQtMTA4LjgzNS01NS40NTNjLTQ3LjEwMy0xOS42MzMtNTguMjY4LTI2LjQzOS01OC4yNjgtMjYuNDM5Jytcblx0XHQnXHRcdFx0bC0wLjQ0NS00NS4xODJjMCwwLDE3LjY0Ni0xMy41NTcsMjMuMTI3LTU2LjA3NGMxMS4wMSwzLjE5OCwyMi42MTktMTYuNDYxLDIzLjIzNy0yNi44MjRjMC42MjUtOS45OC0xLjUwOC0zNy42NjItMTQuOTgxLTM0Ljg3NycgK1xuXHRcdCdcdFx0XHRjMi43NTQtMjAuODQ1LDQuNzQxLTM5LjU4NiwzLjc2NC00OS41MDVjLTMuNDk1LTM2LjI5NS0zOS4yMy03NC41NzgtOTQuMTgyLTc0LjU3OGMtNTQuOTUsMC05MC43LDM4LjI4My05NC4xOTMsNzQuNTc4JyArXG5cdFx0J1x0XHRcdGMtMC45NzgsOS45MTksMS4wMTksMjguNjYxLDMuNzU4LDQ5LjUwNWMtMTMuNDU1LTIuNzg1LTE1LjU4NywyNC44OTctMTQuOTc5LDM0Ljg3N2MwLjYzNSwxMC4zNjMsMTIuMTk2LDMwLjAyMSwyMy4yNTUsMjYuODI0JyArXG5cdFx0J1x0XHRcdGM1LjQ2Miw0Mi41MTcsMjMuMTIyLDU2LjA3NCwyMy4xMjIsNTYuMDc0bC0wLjQ0MSw0NS4xODJjMCwwLTExLjE3OCw2LjgwNy01OC4yNjgsMjYuNDM5JyArXG5cdFx0J1x0XHRcdGMtNDcuMTA0LDE5LjYyOS05NC42ODMsMzMuMzY3LTEwOC44NTEsNTUuNDUzYy0xMi43LDE5Ljc3Ny04Ljg4MiwxMTQuODc1LTguODgyLDExNC44NzVoNDcwLjk0NicgK1xuXHRcdCdcdFx0XHRDNDk5LjQ2Miw0OTcuOTA0LDUwMy4yODEsNDAyLjgwNiw0OTAuNTc5LDM4My4wMjl6XCIvPicgK1xuXHRcdCdcdDwvc3ZnPicgK1xuXHRcdCc8L2Rpdj4nO1xuXG5cdFx0dmFyIHRlbXBsYXRlID1cblx0XHQnPGRpdiBjbGFzcz1cImZ1bGwtd2lkdGgtd2l0aG91dC1wYWRkaW5nXCI+JyArXG5cdFx0aW1nICtcblx0XHQnICAgPGltZyBzcmM9XCIjXCIgYWx0PVwiVXBsb2FkZWQgSW1hZ2VcIiBuZy1zaG93PVwiIWZsYWdcIiBjbGFzcz1cImltZy1yb3VuZGVkXCIgc3R5bGU9XCJvYmplY3QtZml0OiBjb3ZlclwiLz4nICtcblx0XHQnICAgPGlucHV0IHR5cGU9XCJmaWxlXCIgbmFtZT1cInVwbG9hZFwiIGlkPVwidXBsb2FkXCIgbmctaGlkZT1cInRydWVcIi8+JyArXG5cdFx0JyAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtMTJcIiBzdHlsZT1cInBhZGRpbmctbGVmdDogMFwiPicgK1xuXHRcdCcgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tbGlua1wiIG5nLWhpZGU9XCJmbGFnXCIgbmctY2xpY2s9XCJkZWxldGVJbWFnZSgpXCI+IERlbGV0ZSBJbWFnZSA8c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tdHJhc2hcIj48L3NwYW4+PC9idXR0b24+JyArXG5cdFx0JzwvZGl2PicgK1xuXHRcdCc8L2Rpdj4nO1xuXHRcdHJldHVybiB7XG5cdFx0XHRyZXN0cmljdDogJ0FFJyxcblx0XHRcdHNjb3BlOiB7XG5cdFx0XHRcdG1vZGVsOiAnPWF0dHJpYnV0ZScsXG5cdFx0XHRcdHVwbG9hZE1ldGhvZDogJyYnLFxuXHRcdFx0XHRkZWxldGVNZXRob2Q6ICcmJyxcblx0XHRcdFx0dG9vbHRpcFRleHQ6ICdAJ1xuXHRcdFx0fSxcblx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcblx0XHRcdGxpbms6ZnVuY3Rpb24oc2NvcGUsZWxtLGF0dHJzKXtcblx0XHRcdFx0dmFyIG1vZGVsID0gJHBhcnNlKGF0dHJzLmF0dHJpYnV0ZSksXG5cdFx0XHRcdG1vZGVsU2V0dGVyID0gbW9kZWwuYXNzaWduLFxuXHRcdFx0XHRlbGVtZW50ID0gZWxtLmZpbmQoJ2lucHV0JyksXG5cdFx0XHRcdGltYWdlID0gZWxtLmZpbmQoJ2ltZycpWzBdLFxuXHRcdFx0XHRyZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG5cblx0XHRcdFx0c2NvcGUuZmlyZUNsaWNrID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHQkdGltZW91dChmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3VwbG9hZCcpXG5cdFx0XHRcdFx0XHRcdC5jbGljaygpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUuJHdhdGNoKCdtb2RlbCcsZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRpZihzY29wZS5tb2RlbCl7XG5cdFx0XHRcdFx0XHRpZihzY29wZS5tb2RlbC5ieXRlcyl7XG5cdFx0XHRcdFx0XHRcdHNjb3BlLmZsYWcgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0aW1hZ2Uuc3JjID0gJ2RhdGE6JyArIHNjb3BlLm1vZGVsLm1pbWVUeXBlICsgJztiYXNlNjQsJyArIHNjb3BlLm1vZGVsLmJ5dGVzO1xuXHRcdFx0XHRcdFx0XHRpbWFnZS53aWR0aCA9IDIwMDtcblx0XHRcdFx0XHRcdFx0aW1hZ2UuaGVpZ2h0ID0gMjAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzY29wZS5tb2RlbCA9IHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYoIWF0dHJzLmF0dHJpYnV0ZSl7XG5cdFx0XHRcdFx0dGhyb3cgJ1lvdSBtdXN0IHBhc3MgYW4gYXR0cmlidXRlIHRvIEd1bWdhVXBsb2FkJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLmZsYWcgPSB0cnVlO1xuXG5cdFx0XHRcdGZ1bmN0aW9uIHNjYWxlU2l6ZShtYXhXLCBtYXhILCBjdXJyVywgY3Vyckgpe1xuXHRcdFx0XHRcdHZhciByYXRpbyA9IGN1cnJIIC8gY3Vyclc7XG5cdFx0XHRcdFx0aWYoY3VyclcgPj0gbWF4VyAmJiByYXRpbyA8PSAxKXtcblx0XHRcdFx0XHRcdGN1cnJXID0gbWF4Vztcblx0XHRcdFx0XHRcdGN1cnJIID0gY3VyclcgKiByYXRpbztcblx0XHRcdFx0XHR9IGVsc2UgaWYoY3VyckggPj0gbWF4SCl7XG5cdFx0XHRcdFx0XHRjdXJySCA9IG1heEg7XG5cdFx0XHRcdFx0XHRjdXJyVyA9IGN1cnJIIC8gcmF0aW87XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBbY3VyclcsIGN1cnJIXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLmRlbGV0ZUltYWdlID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRpbWFnZS5zcmMgPSAnJztcblx0XHRcdFx0XHRzY29wZS5mbGFnID0gdHJ1ZTtcblx0XHRcdFx0XHRlbGVtZW50WzBdLmZpbGVzID0gW107XG5cdFx0XHRcdFx0c2NvcGUuZGVsZXRlTWV0aG9kKCk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0ZWxlbWVudC5iaW5kKCdjaGFuZ2UnLGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0c2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHR2YXIgeDtcblx0XHRcdFx0XHRcdG1vZGVsU2V0dGVyKHNjb3BlLGVsZW1lbnRbMF0uZmlsZXNbMF0pO1xuXHRcdFx0XHRcdFx0c2NvcGUuZmxhZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0cmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdGltYWdlLnNyYyA9IHJlYWRlci5yZXN1bHQ7XG5cdFx0XHRcdFx0XHRcdGltYWdlLndpZHRoID0gMjAwO1xuXHRcdFx0XHRcdFx0XHRpbWFnZS5oZWlnaHQgPTIwMDtcblx0XHRcdFx0XHRcdFx0dmFyIHggPSBhdHRycy5hdHRyaWJ1dGUuc3BsaXQoJy4nKTtcblx0XHRcdFx0XHRcdFx0c2NvcGUudXBsb2FkTWV0aG9kKHtpbWFnZTogc2NvcGVbeFswXV1beFsxXV19KVxuXHRcdFx0XHRcdFx0XHQudGhlbihmdW5jdGlvbih2YWwpe1xuXHRcdFx0XHRcdFx0XHRcdHNjb3BlLm1vZGVsLm5hbWUgPSB2YWwuZGF0YTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0cmVhZGVyLnJlYWRBc0RhdGFVUkwoZWxlbWVudFswXS5maWxlc1swXSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy51cGxvYWQnLFtdKVxuXHRcdC5kaXJlY3RpdmUoJ2d1bWdhVXBsb2FkJyxVcGxvYWQpO1xuXG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0Jztcblx0QWRkcmVzc1NlcnZpY2UuJGluamVjdCA9IFtdO1xuXHRmdW5jdGlvbiBBZGRyZXNzU2VydmljZSgpe1xuXHRcdHJldHVybiB7XG5cdFx0XHRldmVyeVVmOiBbJ0FDJywgJ0FMJywgJ0FNJywgJ0FQJywgJ0JBJywgJ0NFJywgJ0RGJywgJ0VTJywgJ0dPJywgJ01BJywgJ01HJywgJ01TJywgJ01UJywgJ1BBJywgJ1BCJywgJ1BFJywgJ1BJJywgJ1BSJyxcblx0XHRcdCdSSicsICdSTicsICdSUicsICdSUycsICdTQycsICdTRScsICdTUCcsICdUTyddLFxuXHRcdFx0ZXZlcnlMb2dyYWRvdXJvOiBbXHQnT3V0cm9zJywgJ0Flcm9wb3J0bycsICdBbGFtZWRhJywgJ8OBcmVhJywgJ0F2ZW5pZGEnLCAnQ2FtcG8nLCAnQ2jDoWNhcmEnLCAnQ29sw7RuaWEnLCAnQ29uZG9tw61uaW8nLCAnQ29uanVudG8nLCAnRGlzdHJpdG8nLFxuXHRcdFx0J0VzcGxhbmFkYScsICdFc3Rhw6fDo28nLCAnRXN0cmFkYScsICdGYXZlbGEnLCAnRmF6ZW5kYScsICdGZWlyYScsICdKYXJkaW0nLCAnTGFkZWlyYScsICdMYXJnbycsICdMYWdvJywgJ0xhZ29hJywgJ0xvdGVhbWVudG8nLFxuXHRcdFx0J07DumNsZW8nLCAnUGFycXVlJywgJ1Bhc3NhcmVsYScsICdQw6F0aW8nLCAnUHJhw6dhJywgJ1F1YWRyYScsICdSZWNhbnRvJywgJ1Jlc2lkZW5jaWFsJywgJ1JvZG92aWEnLCAnUnVhJywgJ1NldG9yJywgJ1PDrXRpbycsXG5cdFx0XHQnVHJhdmVzc2EnLCAnVHJldm8nLCAnVHJlY2hvJywgJ1ZhbGUnLCAnVmVyZWRhJywgJ1ZpYScsICdWaWFkdXRvJywgJ1ZpZWxhJywgJ1ZpYSddLFxuXHRcdFx0YXZhaWxhYmxlQ291bnRyaWVzOiBbJ0JyYXNpbCddLFxuXHRcdFx0cmV0dXJuRm9ybWF0dGVkT2JqZWN0OiBmdW5jdGlvbigpe1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHppcENvZGUgOiBudWxsLFxuXHRcdFx0XHRcdHByZW1pc3NlVHlwZTogbnVsbCxcblx0XHRcdFx0XHRwcmVtaXNzZTogbnVsbCxcblx0XHRcdFx0XHRudW1iZXI6IG51bGwsXG5cdFx0XHRcdFx0aW5mb3JtYXRpb246IG51bGwsXG5cdFx0XHRcdFx0bmVpZ2hib3VyaG9vZDogbnVsbCxcblx0XHRcdFx0XHRsb2NhbGl6YXRpb246IG51bGwsXG5cdFx0XHRcdFx0c3RhdGU6IG51bGwsXG5cdFx0XHRcdFx0Y291bnRyeTogbnVsbFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0XHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2Euc2VydmljZXMuYWRkcmVzcycsW10pXG5cdFx0LmZhY3RvcnkoJ0d1bWdhQWRkcmVzc1NlcnZpY2UnLEFkZHJlc3NTZXJ2aWNlKTtcblxuXHR9KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRBbGVydC4kaW5qZWN0ID0gW11cblx0LyoqXG5cdCAqIEBuZ2RvYyBzZXJ2aWNlXG5cdCAqIEBuYW1lIGd1bWdhLmNvcmU6R3VtZ2FBbGVydFxuXHQgKiBAZGVzY3JpcHRpb24gTyBzZXJ2aWNlIEd1bWdhQWxlcnQgw6kgdW1hIG5vdmEgdmVyc8OjbyBkYSBkaXJlY3RpdmUge0BsaW5rIGd1bWdhLmNvcmU6Z3VtZ2FBbGVydH0gZSDDqSB1dGlsaXphZG8gcGFyYSBjcmlhclxuXHQgKiBub3RpZmljYcOnw7VlcyBncm93bC1saWtlLiBQYXJhIHV0aWxpemFyIG8gc2VydmljZSwgYmFzdGEgaW5jbHVpciBHdW1nYUFsZXJ0IGNvbW8gZGVwZW5kw6puY2lhLlxuXHQgKiBcblx0ICogKk9ic2VydmHDp8OjbzogUGFyYSB1dGlsaXphw6fDo28gZG8gc2VydmljZSBubyBjb25maWcgZG8gbcOzZHVsbywgdXRpbGl6YXIgYEd1bWdhQWxlcnRQcm92aWRlcmAqXG5cdCAqXG5cdCAqXG5cdCAqICMjIE3DqXRvZG9zXG5cdCAqXG5cdCAqIE8gc2VydmljZSBHdW1nYUFsZXJ0IHBvc3N1aSBxdWF0cm8gbcOpdG9kb3MgZGUgY3JpYcOnw6NvIGRlIGFsZXJ0YSwgcG9yw6ltIHRvZG9zIHJlY2ViZW0gbyBtZXNtbyBwYXLDom1ldHJvLiBGb2kgb3B0YWRvIHBvciBjcmlhciBxdWF0cm9cblx0ICogbcOpdG9kb3MgZGlmZXJlbnRlcyBwYXJhIGF1bWVudGFyIGEgbGVnaWJpbGlkYWRlLlxuXHQgKiAtIGNyZWF0ZVdhcm5pbmdNZXNzYWdlKHRpdGxlLG1lc3NhZ2Usb3B0aW9ucylcblx0ICogLSBjcmVhdGVEYW5nZXJNZXNzYWdlKHRpdGxlLG1lc3NhZ2Usb3B0aW9ucylcblx0ICogLSBjcmVhdGVTdWNjZXNzTWVzc2FnZSh0aXRsZSxtZXNzYWdlLG9wdGlvbnMpXG5cdCAqIC0gY3JlYXRlSW5mb21lc3NhZ2UodGl0bGUsbWVzc2FnZSxvcHRpb25zKVxuXHQgKlxuXHQgKiAgIyMjIFBhcsOibWV0cm9zXG5cdCAqICAtIGB0aXRsZWA6IFVtYSBzdHJpbmcgcXVlIGlyw6EgY29udGVyIG8gdMOtdHVsbyBkYSBtZW5zYWdlbSBxdWUgc2Vyw6EgY3JpYWRhLlxuXHQgKiAgLSBgbWVzc2FnZWA6IFVtYSBzdHJpbmcgcXVlIGlyw6EgY29udGVyIG8gY29ycG8gZGEgbWVuc2FnZW0gcXVlIHNlcsOhIGNyaWFkYS5cblx0ICogIC0gYG9wdGlvbnNgOiBVbSBvYmpldG8gY29tIG9ww6fDtWVzIGFkaWNpb25haXMgcGFyYSBvIGFsZXJ0YS4gT3MgYXRyaWJ1dG9zIHF1ZSBwb2RlbSBzZXIgcGFzc2Fkb3MgcGFyYSBlc3RlIG9iamV0byBzw6NvOlxuXHQgKiAgXHQ8cHJlPlxuXHQgKiAgIFx0XHR2YXIgY29uZmlnID0ge1xuXHQgKiAgIFx0XHQgb2Zmc2V0OiA1MCwgLy9UYW1hbmhvIGRhIGRpc3TDom5jaWEgZW50cmUgbyBhbGVydGEgZSB0ZWxhLlxuXHQgKiAgIFx0XHQgdGltZXI6IDEwMCwgLy9UZW1wbyBxdWUgaXLDoSBkZW1vcmFyIHBhcmEgYSBtZW5zYWdlbSBhcGFyZWNlciBhcMOzc1xuXHQgKiAgIFx0XHQgZGVsYXk6IDM1MDAsXG5cdCAqICAgXHRcdCBhbG93RGlzbWlzczp0cnVlLFxuXHQgKiAgIFx0XHQgYW5pbWF0aW9uRW50ZXI6ICdhbmltYXRlZCBib3VuY2VJblJpZ2h0Jyxcblx0ICogICBcdFx0IGFuaW1hdGlvbkV4aXQ6ICdhbmltYXRlZCBib3VuY2VPdXRSaWdodCdcblx0ICogICBcdFx0fVxuXHQgKiBcdFx0PC9wcmU+ICpPYmpldG8gY29tIG9zIHZhbG9yZXMgcGFkcsO1ZXMgZG8gYWxlcnRhKlxuXHQgKiBcdFx0XG5cdCAqL1xuXHRmdW5jdGlvbiBBbGVydCgpe1xuXHRcdHJldHVybiB7XG5cdFx0XHQkZ2V0OiBmdW5jdGlvbigpe1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRfX2NvbmZpZzoge1xuXHRcdFx0XHR3YXJuOiB7XG5cdFx0XHRcdFx0aWNvbjogJ2dseXBoaWNvbiBnbHlwaGljb24td2FybmluZy1zaWduJyxcblx0XHRcdFx0XHR0eXBlOiAnd2FybmluZydcblx0XHRcdFx0fSxcblx0XHRcdFx0ZGFuZ2VyOiB7XG5cdFx0XHRcdFx0aWNvbjogJ2dseXBoaWNvbiBnbHlwaGljb24tZXhjbGFtYXRpb24tc2lnbicsXG5cdFx0XHRcdFx0dHlwZTogJ2RhbmdlcicgXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHN1Y2Nlc3M6IHtcblx0XHRcdFx0XHRpY29uOidnbHlwaGljb24gZ2x5cGhpY29uLW9rJyxcblx0XHRcdFx0XHR0eXBlOiAnc3VjY2Vzcydcblx0XHRcdFx0fSxcblx0XHRcdFx0aW5mbzoge1xuXHRcdFx0XHRcdGljb246ICdnbHlwaGljb24gZ2x5cGhpY29uLWluZm8tc2lnbicsXG5cdFx0XHRcdFx0dHlwZTogJ2luZm8nXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfbm90aWZ5OiBmdW5jdGlvbih0eXBlLHRpdGxlLG1lc3NhZ2Usb3B0aW9ucyl7XG5cdFx0XHRcdHZhciBjb25maWcgPSB0aGlzLl9fY29uZmlnW3R5cGVdXG5cdFx0XHRcdCxcdFx0b2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQgfHwgNTBcblx0XHRcdFx0LFx0XHR0aW1lciA9IG9wdGlvbnMudGltZXIgfHwgMTAwXG5cdFx0XHRcdCxcdFx0ZGVsYXkgPSBvcHRpb25zLmRlbGF5IHx8IDM1MDBcblx0XHRcdFx0LFx0XHRhbG93RGlzbWlzcyA9IG9wdGlvbnMuYWxvd0Rpc21pc3MgfHwgdHJ1ZVxuXHRcdFx0XHQsXHRcdGFuaW1hdGlvbkVudGVyID0gb3B0aW9ucy5hbmltYXRpb25FbnRlciB8fCAnYW5pbWF0ZWQgYm91bmNlSW5SaWdodCdcblx0XHRcdFx0LFx0XHRhbmltYXRpb25FeGl0ID0gb3B0aW9ucy5hbmltYXRpb25FeGl0IHx8ICdhbmltYXRlZCBib3VuY2VPdXRSaWdodCc7XG5cdFx0XHRcdCQubm90aWZ5KHtcblx0XHRcdFx0XHRpY29uOiBjb25maWcuaWNvbixcblx0XHRcdFx0XHR0aXRsZTogdGl0bGUsXG5cdFx0XHRcdFx0bWVzc2FnZTogbWVzc2FnZVxuXHRcdFx0XHR9LHtcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG9mZnNldDogb2Zmc2V0LFxuXHRcdFx0XHRcdHRpbWVyOiB0aW1lcixcblx0XHRcdFx0XHRkZWxheTogZGVsYXksXG5cdFx0XHRcdFx0YWxvd19kaXNtaXNzOiBhbG93RGlzbWlzcyxcblx0XHRcdFx0XHRhbmltYXRlOiB7XG5cdFx0XHRcdFx0XHRcdGVudGVyOiBhbmltYXRpb25FbnRlcixcblx0XHRcdFx0XHRcdFx0ZXhpdDogYW5pbWF0aW9uRXhpdFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR0ZW1wbGF0ZTogJzxkaXYgZGF0YS1ub3RpZnk9XCJjb250YWluZXJcIiBjbGFzcz1cImNvbC14cy05IGNvbC1zbS0zIGFsZXJ0IGFsZXJ0LXswfVwiIHJvbGU9XCJhbGVydFwiPicgK1xuXHRcdFx0XHRcdFx0JzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzPVwiY2xvc2VcIiBkYXRhLW5vdGlmeT1cImRpc21pc3NcIj7DlzwvYnV0dG9uPicgK1xuXHRcdFx0XHRcdFx0JzxzcGFuIGRhdGEtbm90aWZ5PVwiaWNvblwiPjwvc3Bhbj4gJyArXG5cdFx0XHRcdFx0XHQnPHNwYW4gZGF0YS1ub3RpZnk9XCJ0aXRsZVwiPjxiPnsxfTwvYj48L3NwYW4+PGJyPiAnICtcblx0XHRcdFx0XHRcdCc8c3BhbiBkYXRhLW5vdGlmeT1cIm1lc3NhZ2VcIj57Mn08L3NwYW4+JyArXG5cdFx0XHRcdFx0XHQnPC9kaXY+J1xuXHRcdFx0XHR9KVxuXHRcdFx0fSxcblx0XHRcdGNyZWF0ZVdhcm5pbmdNZXNzYWdlOiBmdW5jdGlvbih0aXRsZSxtZXNzYWdlLG9wdGlvbnMpe1xuXHRcdFx0XHRpZighb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuXHRcdFx0XHR0aGlzLl9ub3RpZnkoJ3dhcm5pbmcnLHRpdGxlLG1lc3NhZ2Usb3B0aW9ucyk7XG5cdFx0XHR9LFxuXHRcdFx0Y3JlYXRlRGFuZ2VyTWVzc2FnZTogZnVuY3Rpb24odGl0bGUsbWVzc2FnZSxvcHRpb25zKXtcblx0XHRcdFx0aWYoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcblx0XHRcdFx0dGhpcy5fbm90aWZ5KCdkYW5nZXInLHRpdGxlLG1lc3NhZ2Usb3B0aW9ucyk7XG5cdFx0XHR9LFxuXHRcdFx0Y3JlYXRlU3VjY2Vzc01lc3NhZ2U6IGZ1bmN0aW9uKHRpdGxlLG1lc3NhZ2Usb3B0aW9ucyl7XG5cdFx0XHRcdGlmKCFvcHRpb25zKSBvcHRpb25zID0ge307XG5cdFx0XHRcdHRoaXMuX25vdGlmeSgnc3VjY2VzcycsdGl0bGUsbWVzc2FnZSxvcHRpb25zKTtcblx0XHRcdH0sXG5cdFx0XHRjcmVhdGVJbmZvTWVzc2FnZTogZnVuY3Rpb24odGl0bGUsbWVzc2FnZSxvcHRpb25zKXtcblx0XHRcdFx0aWYoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcblx0XHRcdFx0dGhpcy5fbm90aWZ5KCdpbmZvJyx0aXRsZSxtZXNzYWdlLG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGFuZ3VsYXIubW9kdWxlKCdndW1nYS5zZXJ2aWNlcy5hbGVydCcsW10pXG5cdFx0LnByb3ZpZGVyKCdHdW1nYUFsZXJ0JyxBbGVydCk7XG59KSgpOyIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cblx0QmFzZS4kaW5qZWN0ID0gW1wiJGh0dHBcIiwgXCIkcVwiXTtcblx0LyoqXG5cdCAqIEBuZ2RvYyBzZXJ2aWNlXG5cdCAqIEBuYW1lIGd1bWdhLmNvcmU6R3VtZ2FCYXNlXG5cdCAqIEBkZXNjcmlwdGlvblxuXHQgKiBcdE8gc2VydmljZSBHdW1nYUJhc2UgcG9kZSBzZXIgdXRpbGl6YWRvIGNvbW8gaGVscGVyIHBhcmEgZmF6ZXIgY2hhbWFkYXMgSFRUUC4gRWxlIHBlcm1pdGUgcXVlIG8gcHJvZ3JhbWFkb3IgbsOjbyBwcmVjaXNlIGluY2x1aXIgbyBzZXJ2aWNlICRodHRwXG5cdCAqIFx0ZG8gQW5ndWxhckpTIGUgasOhIHZlbSBjb20gYWxndW1hcyBmdW7Dp8O1ZXMgaW5jbHXDrWRhcy4gUGFyYSB1dGlsaXphciBvIEd1bWdhQmFzZSwgYmFzdGEgw61uY2x1w60tbG8gY29tbyBkZXBlbmTDqm5jaWEuXG5cdCAqXG5cdCAqXG5cdCAqICAjIE3DqXRvZG9zXG5cdCAqICBgR3VtZ2FCYXNlLmdldCh1cmwscGFyYW1zKWBcblx0ICpcblx0ICogIE8gbcOpdG9kbyBnZXQgYWNlaXRhIGRvaXMgcGFyw6JtZXRyb3MgYHVybGAgZSBgcGFyYW1zYCBlIHJldG9ybmEgdW1hIHByb21pc2UgZGUgdW1hIGNoYW1hZGEgSFRUUCBkbyB0aXBvIEdFVC5cblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+dXJsPC9sYWJlbD4gIEVuZGVyZcOnbyBubyBxdWFsIGEgY2hhbWFkYSBodHRwIHNlcsOhIGZlaXRhLlxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+T2JqZWN0PC9sYWJlbD4gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPnBhcmFtczwvbGFiZWw+IFBhcsOibWV0cm9zIGRhIHF1ZXJ5IHF1ZSBzZXLDoSBmZWl0YS5cblx0ICogICMjIyBSZXRvcm5vXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5IdHRwUHJvbWlzZTwvbGFiZWw+IFJldG9uYSB1bWEgcHJvbWlzZSBkYSBjaGFtYWRhIEhUVFAgR0VULlxuXHQgKiAgLS0tXG4gXHQgKiAgYEd1bWdhQmFzZS5nZXRCeUlkKHVybCxpZClgXG5cdCAqXG5cdCAqICBPIG3DqXRvZG8gZ2V0QnlJZCBhY2VpdGEgZG9pcyBwYXLDom1ldHJvcyBgdXJsYCBlIGBpZGAgZSByZXRvcm5hIHVtYSBwcm9taXNlIGRlIHVtYSBjaGFtYWRhIEhUVFAgZG8gdGlwbyBHRVQuXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPnVybDwvbGFiZWw+ICBFbmRlcmXDp28gbm8gcXVhbCBhIGNoYW1hZGEgaHR0cCBzZXLDoSBmZWl0YS5cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPltTdHJpbmd8TnVtYmVyXTwvbGFiZWw+IDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5pZDwvbGFiZWw+IElkZW50aWZpY2Fkb3IgZG8gcmVnaXN0cm8gcXVlIHNlcsOhIGJ1c2NhZG8uXG5cdCAqICAjIyMgUmV0b3Jub1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+SHR0cFByb21pc2U8L2xhYmVsPiBSZXRvbmEgdW1hIHByb21pc2UgZGEgY2hhbWFkYSBIVFRQIEdFVC5cblx0ICogIC0tLVxuXHQgKiAgYEd1bWdhQmFzZS5nZXROZXcodXJsKWBcblx0ICpcblx0ICogIE8gbcOpdG9kbyBnZXRCeUlkIGFjZWl0YSB1bSBwYXLDom1ldHJvIGB1cmxgIGUgcmV0b3JuYSB1bWEgcHJvbWlzZSBkZSB1bWEgY2hhbWFkYSBIVFRQIGRvIHRpcG8gR0VULlxuXHQgKiAgIyMjIFBhcsOibWV0cm9zXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj51cmw8L2xhYmVsPiAgRW5kZXJlw6dvIG5vIHF1YWwgYSBjaGFtYWRhIGh0dHAgc2Vyw6EgZmVpdGEgZSBuYSBxdWFsXG5cdCAqICAgc2Vyw6EgZmVpdGEgYSBjaGFtYWRhIHBhcmEgdW0gbm92byByZWdpc3Ryby5cblx0ICogICMjIyBSZXRvcm5vXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5IdHRwUHJvbWlzZTwvbGFiZWw+IFJldG9ybmEgdW1hIHByb21pc2UgZGEgY2hhbWFkYSBIVFRQIEdFVC5cblx0ICogIC0tLVxuIFx0ICogIGBHdW1nYUJhc2UuZGVsZXRlQWxsKHVybCxhcnJheSlgXG5cdCAqXG5cdCAqICBPIG3DqXRvZG8gZGVsZXRlQWxsIGFjZWl0YSBkb2lzIHBhcsOibWV0cm9zIGB1cmxgIGUgYGFycmF5YCBlIHJldG9ybmEgdW1hIHByb21pc2UgZGUgdW1hIHPDqXJpZSBkZSBjaGFtYWRhcyBodHRwIGRvIHRpcG8gREVMRVRFIHF1ZSBzZXLDo28gcmVzb2x2aWRhcyBhbyBtZXNtbyB0ZW1wby5cblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+dXJsPC9sYWJlbD4gIEVuZGVyZcOnbyBubyBxdWFsIGEgY2hhbWFkYSBodHRwIHNlcsOhIGZlaXRhLlxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+QXJyYXk8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5hcnJheTwvbGFiZWw+IEFycmF5IGNvbSB0b2RhcyBvcyByZWdpc3Ryb3MgcXVlIHNlcsOjbyBkZWxldGFkb3Ncblx0ICogICMjIyBSZXRvcm5vXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5IdHRwUHJvbWlzZTwvbGFiZWw+IFJldG9ybmEgdW1hIHByb21pc2UgYXDDs3MgdG9kYXMgYXMgY2hhbWFkYXMgdGVyZW0gc2lkbyByZXNvbHZpZGFzLlxuXHQgKiAgLS0tXG5cdCAqICBgR3VtZ2FCYXNlLnNhdmUodXJsLGRhdGEpYFxuXHQgKlxuXHQgKiAgTyBtw6l0b2RvIHNhdmUgYWNlaXRhIGRvaXMgcGFyw6JtZXRyb3MgYHVybGAgZSBgZGF0YWAgZSByZXRvcm5hIHVtYSBwcm9taXNlIGRlIGRlIHVtYSBjaGFtYWRhIEhUVFAgUE9TVC5cblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+dXJsPC9sYWJlbD4gIEVuZGVyZcOnbyBubyBxdWFsIGEgY2hhbWFkYSBodHRwIHNlcsOhIGZlaXRhLlxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+T2JqZWN0PC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+ZGF0YTwvbGFiZWw+IE9iamV0byBxdWUgZGVzZWphIHNlciBzYWx2by5cblx0ICogICMjIyBSZXRvcm5vXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5IdHRwUHJvbWlzZTwvbGFiZWw+IFJldG9ybmEgdW1hIHByb21pc2UgZGEgY2hhbWFkYSBIVFRQIFBPU1QuXG5cdCAqICAtLS1cbiBcdCAqICBgR3VtZ2FCYXNlLnVwZGF0ZSh1cmwsZGF0YSlgXG5cdCAqXG5cdCAqICBPIG3DqXRvZG8gZGVsZXRlQWxsIGFjZWl0YSBkb2lzIHBhcsOibWV0cm9zIGB1cmxgIGUgYGRhdGFgIGUgcmV0b3JuYSB1bWEgcHJvbWlzZSBkZSBkZSB1bWEgY2hhbWFkYSBIVFRQIFBVVC5cblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+dXJsPC9sYWJlbD4gIEVuZGVyZcOnbyBubyBxdWFsIGEgY2hhbWFkYSBodHRwIHNlcsOhIGZlaXRhLlxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+T2JqZWN0PC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+ZGF0YTwvbGFiZWw+IE9iamV0byBxdWUgZGVzZWphIHNlciBhdHVhbGl6YWRvLlxuXHQgKiAgIyMjIFJldG9ybm9cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPkh0dHBQcm9taXNlPC9sYWJlbD4gUmV0b3JuYSB1bWEgcHJvbWlzZSBkYSBjaGFtYWRhIEhUVFAgUE9TVC5cblx0ICogIC0tLVxuIFx0ICogIGBHdW1nYUJhc2UuZGVsKHVybCxkYXRhKWBcblx0ICpcblx0ICogIE8gbcOpdG9kbyBkZWwgYWNlaXRhIGRvaXMgcGFyw6JtZXRyb3MgYHVybGAgZSBgZGF0YWAgZSByZXRvcm5hIHVtYSBwcm9taXNlIGRlIGRlIHVtYSBjaGFtYWRhIEhUVFAgREVMRVRFLiBFc3RhIGZ1bsOnw6NvIMOpIGNoYW1hZGEgcGFyYSBjYWRhIHJlZ2lzdHJvIHBhc3NhZG8gZGVudHJvIGRvIEFycmF5XG5cdCAqICBuYSBmdW7Dp8OjbyBkZWxldGVBbGwuXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPnVybDwvbGFiZWw+ICBFbmRlcmXDp28gbm8gcXVhbCBhIGNoYW1hZGEgaHR0cCBzZXLDoSBmZWl0YS5cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPk9iamVjdDwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmRhdGE8L2xhYmVsPiBPYmpldG8gcXVlIGRlc2VqYSBzZXIgZGVsZXRhZG8uXG5cdCAqICAjIyMgUmV0b3Jub1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+SHR0cFByb21pc2U8L2xhYmVsPiBSZXRvcm5hIHVtYSBwcm9taXNlIGRhIGNoYW1hZGEgSFRUUCBERUxFVEUuXG5cdCAqICAtLS1cblx0ICogIGBHdW1nYUJhc2UucG9zdEltYWdlKHVybCxhdHRyaWJ1dGUsZGF0YSlgXG5cdCAqXG5cdCAqICBPIG3DqXRvZG8gcG9zdEltYWdlIGFjZWl0YSB0csOqcyBwYXLDom1ldHJvcyBgdXJsYCxgYXR0cmlidXRlYCBlIGBkYXRhYCBlIHJldG9ybmEgdW1hIHByb21pc2UgZGUgZGUgdW1hIGNoYW1hZGEgSFRUUCBQT1NUIEZPUk0tREFUQS5cblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+dXJsPC9sYWJlbD4gIEVuZGVyZcOnbyBubyBxdWFsIGEgY2hhbWFkYSBodHRwIHNlcsOhIGZlaXRhLlxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+YXR0cmlidXRlPC9sYWJlbD4gQXRyaWJ1dG8gbm8gcXVhbCBhIGltYWdlbSBzZXLDoSBmZWl0byBvXG5cdCAqICBiaW5kIGFww7NzIG8gZm9ybSB0ZXIgc2lkbyBlbnZpYWRvIGNvbXBsZXRvLlxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+T2JqZWN0PC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+ZGF0YTwvbGFiZWw+IERhZG9zIGRhIGltYWdlbSBxdWUgZm9pIHNlbGVjaW9uYWRhLi5cblx0ICogICMjIyBSZXRvcm5vXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5IdHRwUHJvbWlzZTwvbGFiZWw+IFJldG9ybmEgdW1hIHByb21pc2UgZGEgY2hhbWFkYSBIVFRQIFBPU1QuIE5lc3RhIHByb21pc2UsIHNlcsOhIHJldG9ybmFkbyBvIHZhbG9yIGRlIHVtYSBTdHJpbmcgcXVlIGRldmVyw6Egc2VyIGF0cmlidcOtZGEgYW8gYXRyaWJ1dG9cblx0ICogIG9uZGUgZXN0YXZhIGEgaW1hZ2VtLiBFc3RhIHN0cmluZyDDqSB1bSBpZGVudGlmaWNhZG9yIHBhcmEgcXVhbmRvIG8gcmVnaXN0cm8gZm9yIGVudmlhZG8gYXRyYXbDqXMgZGUgdW0gcG9zdC5cblx0ICogIC0tLVxuIFx0ICogIGBHdW1nYUJhc2UuZGVsZXRlSW1hZ2UodXJsLGF0dHJpYnV0ZSxkYXRhKWBcblx0ICpcblx0ICogIE8gbcOpdG9kbyBkZWwgYWNlaXRhIHRyw6pzIHBhcsOibWV0cm9zIGB1cmxgLCBgYXR0cmlidXRlYCBlIGBkYXRhYCBlIHJldG9ybmEgdW1hIHByb21pc2UgZGUgdW1hIGNoYW1hZGEgSFRUUCBERUxFVEUgRk9STS1EQVRBLlxuXHQgKiAgIyMjIFBhcsOibWV0cm9zXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj51cmw8L2xhYmVsPiBFbmRlcmXDp28gbm8gcXVhbCBhIGNoYW1hZGEgaHR0cCBzZXLDoSBmZWl0YS5cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmF0dHJpYnV0ZTwvbGFiZWw+IEF0cmlidXRvIG5vIHF1YWwgYSBpbWFnZW0gc2Vyw6EgZmVpdG8gb1xuXHQgKiAgYmluZCBhcMOzcyBvIGZvcm0gdGVyIHNpZG8gZW52aWFkbyBjb21wbGV0by5cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPk9iamVjdDwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmRhdGE8L2xhYmVsPiBEYWRvcyBkYSBpbWFnZW0gcXVlIGZvaSBzZWxlY2lvbmFkYS5cblx0ICogICMjIyBSZXRvcm5vXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5IdHRwUHJvbWlzZTwvbGFiZWw+IFJldG9ybmEgdW1hIHByb21pc2UgZGEgY2hhbWFkYSBIVFRQIERFTEVURS5cblx0ICogIC0tLVxuXHQgKi9cblx0ZnVuY3Rpb24gQmFzZSgkaHR0cCwkcSl7XG5cdFx0dmFyIGRlZmF1bHRQYXJhbXMgPSB7fTtcblx0XHR0aGlzLmdldCA9IGdldDtcblx0XHR0aGlzLmdldEJ5SWQgPSBnZXRCeUlkO1xuXHRcdHRoaXMuZ2V0TmV3ID0gZ2V0TmV3O1xuXHRcdHRoaXMuZGVsZXRlQWxsID0gZGVsZXRlQWxsO1xuXHRcdHRoaXMuc2F2ZSA9IHNhdmU7XG5cdFx0dGhpcy51cGRhdGUgPSB1cGRhdGU7XG5cdFx0dGhpcy5kZWwgPSBkZWw7XG5cdFx0dGhpcy5wb3N0SW1hZ2UgPSBwb3N0SW1hZ2U7XG5cdFx0dGhpcy5kZWxldGVJbWFnZSA9IGRlbGV0ZUltYWdlO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0KHVybCxwYXJhbXMpIHtcblx0XHRcdGlmICghcGFyYW1zKSB7XG5cdFx0XHRcdHBhcmFtcyA9IGRlZmF1bHRQYXJhbXM7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJGh0dHAuZ2V0KHVybCwgcGFyYW1zKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRCeUlkKHVybCxpZCkge1xuXHRcdFx0cmV0dXJuICRodHRwLmdldCh1cmwgKyAnLycgKyBpZCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0TmV3KHVybCl7XG5cdFx0XHRyZXR1cm4gJGh0dHAuZ2V0KHVybCsnL25ldycpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRlbGV0ZUFsbCh1cmwsZW50aXRpZXMpIHtcblx0XHRcdHZhciBwcm9taXNlcyA9IGVudGl0aWVzLm1hcChmdW5jdGlvbihlbnRpdHkpe1xuXHRcdFx0XHRyZXR1cm4gZGVsKHVybCxlbnRpdHkpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gJHEuYWxsKHByb21pc2VzKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzYXZlKHVybCxlbnRpdHkpIHtcblx0XHRcdHJldHVybiAkaHR0cC5wb3N0KHVybCwgZW50aXR5KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGRhdGUodXJsLGVudGl0eSkge1xuXHRcdFx0cmV0dXJuICRodHRwLnB1dCh1cmwgKyAnLycgKyBlbnRpdHkuaWQsIGVudGl0eSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGVsKHVybCxlbnRpdHkpIHtcblx0XHRcdHJldHVybiAkaHR0cC5kZWxldGUodXJsICsgJy8nICsgZW50aXR5LmlkKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwb3N0SW1hZ2UodXJsLCBhdHRyaWJ1dGUsIG1vZGVsKSB7XG5cdFx0XHR2YXIgZmQgPSBuZXcgRm9ybURhdGEoKTtcblx0XHRcdGZkLmFwcGVuZChhdHRyaWJ1dGUsIG1vZGVsKTtcblx0XHRcdHJldHVybiAkaHR0cC5wb3N0KHVybCArICcvJyArIGF0dHJpYnV0ZSArICcvJywgZmQsIHtcblx0XHRcdFx0dHJhbnNmb3JtUmVxdWVzdDogYW5ndWxhci5pZGVudGl0eSxcblx0XHRcdFx0aGVhZGVyczogeydDb250ZW50LVR5cGUnOiB1bmRlZmluZWR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkZWxldGVJbWFnZSh1cmwsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcblx0XHRcdHJldHVybiAkaHR0cC5kZWxldGUodXJsICsgJy8nICsgYXR0cmlidXRlICsgJy8nICsgdmFsdWUsIHtcblx0XHRcdFx0dHJhbnNmb3JtUmVxdWVzdDogYW5ndWxhci5pZGVudGl0eSxcblx0XHRcdFx0aGVhZGVyczogeydDb250ZW50LVR5cGUnOiB1bmRlZmluZWR9XG5cdFx0XHR9KTtcblxuXHRcdH1cblx0fVxuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2Euc2VydmljZXMuYmFzZScsW10pXG5cdC5zZXJ2aWNlKCdHdW1nYUJhc2UnLEJhc2UpO1xufSkoKTtcbiIsIiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cdERhdGVTZXJ2aWNlLiRpbmplY3QgPSBbXTtcblx0ZnVuY3Rpb24gRGF0ZVNlcnZpY2UoKXtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Zm9ybWF0czoge1xuXHRcdFx0XHRETVk6IC9eKFxcZHsxLDJ9KVxcLShcXGR7MSwyfSlcXC0oXFxkezR9KSQvLFxuXHRcdFx0XHRZTUQ6IC9eKFxcZHs0fSlcXC0oXFxkezEsMn0pXFwtKFxcZHsxLDJ9KSQvXG5cdFx0XHR9LFxuXHRcdFx0dmFsaWRhdGVGb3JtYXQ6IGZ1bmN0aW9uKGZvcm1hdCwgZGF0ZSkge1xuXHRcdFx0XHRpZiAoIXRoaXMuZm9ybWF0cy5oYXNPd25Qcm9wZXJ0eShmb3JtYXQpKSB7XG5cdFx0XHRcdFx0dGhyb3cgJ0Zvcm1hdG8gbsOjbyBzdXBvcnRhZG8nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciByZWdleCA9IG5ldyBSZWdFeHAodGhpcy5mb3JtYXRzW2Zvcm1hdF0pO1xuXHRcdFx0XHRpZiAoIXJlZ2V4LnRlc3QoZGF0ZSkpIHtcblx0XHRcdFx0XHR0aHJvdyAnQSBkYXRhICcgKyBkYXRlICsgJyBuw6NvIGNvbmZlcmUgY29tIG8gZm9ybWF0byAnICsgZm9ybWF0ICsgJy4nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZWdleC50ZXN0KGRhdGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2Euc2VydmljZXMuZGF0ZScsW10pXG5cdC5mYWN0b3J5KCdHdW1nYURhdGVTZXJ2aWNlJyxEYXRlU2VydmljZSk7XG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRLZXlib2FyZC4kaW5qZWN0ID0gW107XG5cdC8qKlxuXHQgKiBAbmdkb2Mgc2VydmljZVxuXHQgKiBAbmFtZSBndW1nYS5jb3JlOkd1bWdhS2V5Ym9hcmRcblx0ICogQGRlc2NyaXB0aW9uIFxuXHQgKiBcdEEgZGlyZWN0aXZlIEd1bWdhS2V5Ym9hcmQgw6kgdW0gV3JhcHBlciBkZSB1bWEgYmlibGlvdGVjYSBjaGFtYWRhIFtNb3VzZXRyYXBdKGh0dHBzOi8vY3JhaWcuaXMva2lsbGluZy9taWNlKSBcblx0ICogXHRxdWUgw6kgdXRpbGl6YWRhIHBhcmEgYWRpY2lvbmFyIGZ1bmNpb25hbGlkYWRlcyBxdWFuZG8gZGV0ZXJtaW5hZGFzIHRlY2xhcyBzw6NvIHByZXNzaW9uYWRhcy5cblx0ICpcblx0ICogXHQjIE3DqXRvZG9zXG5cdCAqXG5cdCAqICBgR3VtZ2FLZXlib2FyZC5hZGRCaW5kKGtleSxmdW5jdGlvbixldmVudClgXG5cdCAqICBcblx0ICogXHRPIG3DqXRvZG8gYGFkZEJpbmRgIGFkaWNpb25hIHVtYSBmdW7Dp8OjbyBhIGNvbWJpbmHDp8OjbyBkZSB0ZWNsYXMgcGFzc2FkYSBjb21vIHBhcsOibWV0cm8uIEVsZSByZWNlYmUgdHLDqnMgcGFyw6JtZXRyb3MsIGBrZXlgIGUgYGZ1bmN0aW9uYCBlIGBldmVudGAuXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmtleTwvbGFiZWw+IFF1YWlzIHRlY2xhcyBzZXLDo28gY2xpY2FkYXMgcGFyYSBxdWUgYSBmdW7Dp8OjbyBzZWphIGV4ZWN1dGFkYS5cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPk9iamVjdDwvbGFiZWw+IDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5mdW5jdGlvbjwvbGFiZWw+IEZ1bsOnw6NvIHF1ZSBzZXLDoSBleGVjdXRhZGEgcXVhbmRvIHNlcXXDqm5jaWEgZGUgdGVjbGFzIGVzcGVjaWZpY2FkYXMgZm9yIGRpZ2l0YWRhIHBlbG8gdXN1w6FyaW8uXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5ldmVudDwvbGFiZWw+IEVtIHF1YWwgZXZlbnRvIGRlIHRlY2xhZG8gc2Vyw6EgZGlzcGFyYWRvLCBjb21vIHBvciBleGVtcGxvIGBrZXlwcmVzc2Agb3Vga2V5ZG93bmBcblx0ICogICMjIyBSZXRvcm5vXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIj5Cb29sZWFuPC9sYWJlbD4gUmV0b25hIHVtIGJvb2xlYW4uIFNlIG8gYmluZCBmb2kgZmVpdG8sIHJldG9ybmEgdHJ1ZSwgY2FzbyBhbyBjb250csOhcmlvIHJldG9ybmEgZmFsc2UuXG5cdCAqICAtLS1cbiBcdCAqICBgR3VtZ2FLZXlib2FyZC5yZW1vdmVCaW5kKGtleSlgXG5cdCAqICBcblx0ICogXHRPIG3DqXRvZG8gYHJlbW92ZUJpbmRgIHJlbW92ZSBhcyBmdW7Dp8O1ZXMgcXVlIGVzdMOjbyBhdHJpYnXDrWRhcyBhIGBrZXlgIHF1ZSBmb2kgcGFzc2FkYSAuIEVsZSByZWNlYmUgdW0gcGFyw6JtZXRybyBga2V5YC5cblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+a2V5PC9sYWJlbD4gUXVhaXMgdGVjbGFzIHF1ZSBvIGRlc2Vudm9sdmVkb3IgZGVzZWphIHJlbW92ZXIgbyBiaW5kLlxuXHQgKiAgXG5cdCAqICAtLS1cblx0ICogIFxuIFx0ICogIGBHdW1nYUtleWJvYXJkLnRyaWdnZXJCb3VuZGVkRXZlbnQoa2V5KWBcblx0ICogIFxuXHQgKiBcdE8gbcOpdG9kbyBgdHJpZ2dlckJvdW5kZWRFdmVudGAgZGlzcGFyYSBvIGV2ZW50byBhdHJpYnXDrWRvIGEgYGtleWAgcXVlIGZvaSBwYXNzYWRhLlxuXHQgKiBcdFxuXHQgKiAgIyMjUGFyw6JtZXRyb3Ncblx0ICogIFxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+a2V5PC9sYWJlbD4gUXVhaXMgdGVjbGFzIHF1ZSBvIGRlc2Vudm9sdmVkb3IgZGVzZWphIHJlbW92ZXIgbyBiaW5kLlxuXHQgKiAgXG5cdCAqICAtLS1cblx0ICpcblx0ICogXHRgR3VtZ2FLZXlib2FyZC5iaW5kVG9FbGVtZW50KGVsZW1lbnQsa2V5LGZ1bmN0aW9uLGV2ZW50KWBcbiBcdCAqICBcblx0ICogXHRPIG3DqXRvZG8gYGJpbmRUb0VsZW1lbnRgIGFkaWNpb25hIHVtYSBmdW7Dp8OjbyBhIGNvbWJpbmHDp8OjbyBkZSB0ZWNsYXMgcGFzc2FkYSBjb21vIHBhcsOibWV0cm8gZW0gdW0gZWxlbWVudG8gZXNwZWPDrWZpY28uIEVsZSByZWNlYmUgcXVhdHJvIHBhcsOibWV0cm9zLGBlbGVtZW50YCwgYGtleWAgZSBgZnVuY3Rpb25gIGUgYGV2ZW50YC5cblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+RWxlbWVudDwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmVsZW1lbnQ8L2xhYmVsPiBFbGVtZW50byBubyBxdWFsIGEgc2VxdcOqbmNpYSBkZSB0ZWNsYXMgZGV2ZSBzZXIgZXhlY3V0YWRhIHBhcmEgZGlzcGFyYXIgbyBldmVudG8uXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5rZXk8L2xhYmVsPiBRdWFpcyB0ZWNsYXMgc2Vyw6NvIGNsaWNhZGFzIHBhcmEgcXVlIGEgZnVuw6fDo28gc2VqYSBleGVjdXRhZGEuXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5PYmplY3Q8L2xhYmVsPiA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+ZnVuY3Rpb248L2xhYmVsPiBGdW7Dp8OjbyBxdWUgc2Vyw6EgZXhlY3V0YWRhIHF1YW5kbyBzZXF1w6puY2lhIGRlIHRlY2xhcyBlc3BlY2lmaWNhZGFzIGZvciBkaWdpdGFkYSBwZWxvIHVzdcOhcmlvLlxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+ZXZlbnQ8L2xhYmVsPiBFbSBxdWFsIGV2ZW50byBkZSB0ZWNsYWRvIHNlcsOhIGRpc3BhcmFkbywgY29tbyBwb3IgZXhlbXBsbyBga2V5cHJlc3NgIG91YGtleWRvd25gXG5cdCAqICAjIyMgUmV0b3Jub1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCI+Qm9vbGVhbjwvbGFiZWw+IFJldG9uYSB1bSBib29sZWFuLiBTZSBvIGJpbmQgZm9pIGZlaXRvLCByZXRvcm5hIHRydWUsIGNhc28gYW8gY29udHLDoXJpbyByZXRvcm5hIGZhbHNlLlxuXHQgKiAgLS0tXG5cdCAqXG4gXHQgKiBcdGBHdW1nYUtleWJvYXJkLnVuYmluZEZyb21FbGVtZW50KGVsZW1lbnQsa2V5KWBcbiBcdCAqICBcblx0ICogXHRPIG3DqXRvZG8gYHVuYmluZEZyb21FbGVtZW50YCByZW1vdmUgYXMgdGVjbGFzIGRvIGVsZW1lbnRvIHBhc3NhZG8gY29tbyBwYXLDom1ldHJvLiBFbGUgcmVjZWJlIGRvaXMgcGFyw6JtZXRyb3MsYGVsZW1lbnRgIGUgYGtleWAuXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPkVsZW1lbnQ8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5lbGVtZW50PC9sYWJlbD4gRWxlbWVudG8gbm8gcXVhbCBhIHNlcXXDqm5jaWEgZGUgdGVjbGFzIHZhaSBzZXIgcmV0aXJhZGEuXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5rZXk8L2xhYmVsPiBRdWFpcyB0ZWNsYXMgc2Vyw6NvIHJlbW92aWRhcyBkbyBlbGVtZW50LlxuXHQgKiAgLS0tXG5cdCAqICBcblx0ICogXHRgR3VtZ2FLZXlib2FyZC5iaW5kVG9NdWx0aXBsZUVsZW1lbnQoYXJyYXksa2V5LGZ1bmN0aW9uLGV2ZW50KWBcbiBcdCAqICBcblx0ICogXHRPIG3DqXRvZG8gYGJpbmRUb0VsZW1lbnRgIGFkaWNpb25hIHVtYSBmdW7Dp8OjbyBhIGNvbWJpbmHDp8OjbyBkZSB0ZWNsYXMgcGFzc2FkYSBjb21vIHBhcsOibWV0cm8gZW0gdW0gZWxlbWVudG8gZXNwZWPDrWZpY28uIEVsZSByZWNlYmUgcXVhdHJvIHBhcsOibWV0cm9zLGBlbGVtZW50YCwgYGtleWAgZSBgZnVuY3Rpb25gIGUgYGV2ZW50YC5cblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+QXJyYXk8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5hcnJheTwvbGFiZWw+IExpc3RhIGRvcyBlbGVtZW50b3MgcXVlIHNlcsOjbyBhZGljaW9uYWRvcyBhIHNlcXXDqm5jaWEgZGUgdGVjbGFzLlxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+a2V5PC9sYWJlbD4gUXVhaXMgdGVjbGFzIHNlcsOjbyBjbGljYWRhcyBwYXJhIHF1ZSBhIGZ1bsOnw6NvIHNlamEgZXhlY3V0YWRhLlxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+T2JqZWN0PC9sYWJlbD4gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmZ1bmN0aW9uPC9sYWJlbD4gRnVuw6fDo28gcXVlIHNlcsOhIGV4ZWN1dGFkYSBxdWFuZG8gc2VxdcOqbmNpYSBkZSB0ZWNsYXMgZXNwZWNpZmljYWRhcyBmb3IgZGlnaXRhZGEgcGVsbyB1c3XDoXJpby5cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmV2ZW50PC9sYWJlbD4gRW0gcXVhbCBldmVudG8gZGUgdGVjbGFkbyBzZXLDoSBkaXNwYXJhZG8sIGNvbW8gcG9yIGV4ZW1wbG8gYGtleXByZXNzYCBvdWBrZXlkb3duYFxuXHQgKiAgIyMjIFJldG9ybm9cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiPkJvb2xlYW48L2xhYmVsPiBSZXRvbmEgdW0gYm9vbGVhbi4gU2UgbyBiaW5kIGZvaSBmZWl0bywgcmV0b3JuYSB0cnVlLCBjYXNvIGFvIGNvbnRyw6FyaW8gcmV0b3JuYSBmYWxzZS5cblx0ICogIC0tLVxuXHQgKlxuIFx0ICogXHRgR3VtZ2FLZXlib2FyZC5nZXRCaW5kcygpYFxuIFx0ICogIFxuXHQgKiBcdE8gbcOpdG9kbyBgZ2V0QmluZHNgIHJldG9ybmEgdG9kb3Mgb3MgYmluZHMgcXVlIGZvcmFtIGFkaWNpb25hZG9zLlxuXHQgKlxuXHQgKiBcblx0ICogICMjIyBSZXRvcm5vXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIj5BcnJheTwvbGFiZWw+IFJldG9ybmEgdW1hIGxpc3RhIGRlIHRvZG9zIG9zIGJpbmRzIGrDoSBmZWl0b3MuXG5cdCAqICBcblx0ICogIC0tLVxuXHQgKi9cblx0ZnVuY3Rpb24gS2V5Ym9hcmQoKXtcblx0XHRyZXR1cm4ge1xuXHRcdFx0YWRkQmluZDogZnVuY3Rpb24oa2V5LGZuLGV2ZW50KXtcblx0XHRcdFx0aWYoa2V5ICYmIGZuKXtcblx0XHRcdFx0XHRNb3VzZXRyYXAuYmluZChrZXksZm4sZXZlbnQ/IGV2ZW50IDogJycpO1xuXHRcdFx0XHRcdHRoaXMuX19iaW5kcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxyZW1vdmVCaW5kOiBmdW5jdGlvbihrZXkpe1xuXHRcdFx0XHRpZihrZXkpe1xuXHRcdFx0XHRcdE1vdXNldHJhcC51bmJpbmQoa2V5KTtcblx0XHRcdFx0XHR0aGlzLl9fYmluZHMuc3BsaWNlKHRoaXMuX19iaW5kcy5pbmRleE9mKGtleSksMSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR0cmlnZ2VyQm91bmRlZEV2ZW50OiBmdW5jdGlvbihrZXkpe1xuXHRcdFx0XHRpZihrZXkpe1xuXHRcdFx0XHRcdE1vdXNldHJhcC50cmlnZ2VyKGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRiaW5kVG9FbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LGtleSxmbixldmVudCl7XG5cdFx0XHRcdGlmKGVsZW1lbnQgJiYga2V5ICYmIGZuKXtcblx0XHRcdFx0XHRNb3VzZXRyYXAoZWxlbWVudCkuYmluZChrZXksZm4sZXZlbnQgPyBldmVudDogJycpO1xuXHRcdFx0XHRcdHRoaXMuX19iaW5kcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZEZyb21FbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LGtleSl7XG5cdFx0XHRcdGlmKGVsZW1lbnQgJiYga2V5KSB7XG5cdFx0XHRcdFx0TW91c2V0cmFwKGVsZW1lbnQpLnVuYmluZChrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0YmluZFRvTXVsdGlwbGVFbGVtZW50czogZnVuY3Rpb24oYXJyYXlPZkVsZW1lbnRzLGtleSxmbixldmVudCl7XG5cdFx0XHRcdGZvcih2YXIgaSA9IDAsIGxlbiA9IGFycmF5T2ZFbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykgaWYoa2V5ICYmIGZuKXtcblx0XHRcdFx0XHRNb3VzZXRyYXAoYXJyYXlPZkVsZW1lbnRzW2ldKS5iaW5kKGtleSxmbixldmVudD8gZXZlbnQ6ICcnKTtcblx0XHRcdFx0XHR0aGlzLl9fYmluZHMucHVzaChrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Z2V0QmluZHM6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9fYmluZHM7XG5cdFx0XHR9LFxuXHRcdFx0X19iaW5kczogW11cblx0XHR9XG5cdH1cblx0YW5ndWxhci5tb2R1bGUoJ2d1bWdhLnNlcnZpY2VzLmtleWJvYXJkJyxbXSlcblx0XHQuZmFjdG9yeSgnR3VtZ2FLZXlib2FyZCcsS2V5Ym9hcmQpO1xufSkoKTsiLCIoZnVuY3Rpb24oKXtcblxuICBmdW5jdGlvbiBMaXN0SGVscGVyKCl7XG4gICAgcmV0dXJuIHtcbiAgICAgICdhdXgnOiBbXSxcbiAgICAgICdyZXR1cm5Db2x1bW5Db25maWcnOiBmdW5jdGlvbihpdGVtLGNvbmZpZyl7XG4gICAgICAgIHZhciBpdGVtQ29uZmlnID0gY29uZmlnLmZpbHRlcihmdW5jdGlvbih2YWwpeyByZXR1cm4gdmFsLm5hbWUudG9Mb3dlckNhc2UoKS50cmltKCkgPT0gaXRlbS50b0xvd2VyQ2FzZSgpLnRyaW0oKX0pWzBdIHx8IHt9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRpdGxlOiBpdGVtQ29uZmlnLnRpdGxlIHx8IGl0ZW0udG9VcHBlckNhc2UoKSxcbiAgICAgICAgICBzaXplOiBpdGVtQ29uZmlnLnNpemUgfHwgJycsXG4gICAgICAgICAgbmFtZTogaXRlbUNvbmZpZy5uYW1lIHx8IGl0ZW0sXG4gICAgICAgICAgY29udGVudDogdGhpcy5jb250ZW50V2l0aG91dFBhcmVudChpdGVtQ29uZmlnLmNvbnRlbnQsaXRlbSksXG4gICAgICAgICAgc29ydEZpZWxkOiBpdGVtQ29uZmlnLnNvcnRGaWVsZCB8fCBudWxsLFxuICAgICAgICAgIGNvbmRpdGlvbmFsOiBpdGVtQ29uZmlnLmNvbmRpdGlvbmFsIHx8IGFuZ3VsYXIubm9vcFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ2NvbnRlbnRXaXRob3V0UGFyZW50JzpmdW5jdGlvbihjb250ZW50LGl0ZW0pe1xuICAgICAgICBpZihjb250ZW50ICYmIGNvbnRlbnQuaW5kZXhPZigndHlwZT1cImJ1dHRvblwiJykgIT0gLTEgJiYgY29udGVudC5pbmRleE9mKCduZy1jbGljaz1cIicpICE9IC0xKXtcbiAgICAgICAgICByZXR1cm4gY29udGVudC5yZXBsYWNlKC9uZy1jbGljaz1cIi9naSwnbmctY2xpY2s9XCIkcGFyZW50LiRwYXJlbnQuJyk7O1xuICAgICAgICB9XG4gICAgICAgIGlmKGNvbnRlbnQpe1xuICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAne3skdmFsdWUuJytpdGVtKyd9fSc7XG4gICAgICB9LFxuICAgICAgJ2Vuc3VyZURlZmF1bHRWYWx1ZXMnOiBmdW5jdGlvbihhcnIsY29uZmlnKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gYXJyLm1hcChmdW5jdGlvbihpdGVtLCRpbmRleCl7XG4gICAgICAgICAgcmV0dXJuIHNlbGYucmV0dXJuQ29sdW1uQ29uZmlnKGl0ZW0sY29uZmlnKTtcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICAnbG9hZERlZmF1bHRDb2x1bW5zJzogZnVuY3Rpb24oZmlyc3RPYmplY3Qpe1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoZmlyc3RPYmplY3QpLm1hcChmdW5jdGlvbihrZXksJGluZGV4KXtcbiAgICAgICAgICBpZihrZXkgIT0gJ19fY2hlY2tlZCcpe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdGl0bGU6IGtleS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgICBzaXplOiAnJyxcbiAgICAgICAgICAgICAgbmFtZTogJ2tleScsXG4gICAgICAgICAgICAgIGNvbnRlbnQ6ICd7eyR2YWx1ZS4nICsga2V5ICsgJ319JyxcbiAgICAgICAgICAgICAgc29ydEZpZWxkOiBudWxsLFxuICAgICAgICAgICAgICBjb25kaXRpb25hbDogYW5ndWxhci5ub29wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgICdzb3J0Q29sdW1ucyc6IGZ1bmN0aW9uKGF1eCxjb2x1bW5zKXtcbiAgICAgICAgcmV0dXJuIGNvbHVtbnMuc29ydChmdW5jdGlvbih2YWx1ZTEsdmFsdWUyKXtcbiAgICAgICAgICAoYXV4LmluZGV4T2YodmFsdWUxLm5hbWUpIC0gYXV4LmluZGV4T2YodmFsdWUyLm5hbWUpKVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgICdhZGRDaGVja2JveCc6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGl0bGU6ICc8bGFiZWw+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5nLW1vZGVsPVwidm0uY2hlY2tBbGxcIiBuZy1jaGFuZ2U9XCJ2bS5zZWxlY3RBbGwodm0uY2hlY2tBbGwpXCIvPjxzdHJvbmcgPjxzbWFsbD5TZWxlY2lvbmFyIFRvZG9zPC9zbWFsbD48L3N0cm9uZz48L2xhYmVsPicsXG4gICAgICAgICAgc2l6ZTogJ2NvbC1tZC0xJyxcbiAgICAgICAgICBuYW1lOidfX2NoZWNrYm94JyxcbiAgICAgICAgICBjb250ZW50OiAnPGlucHV0IG5hbWU9XCJfX2NoZWNrYm94XCIgdHlwZT1cImNoZWNrYm94XCIgbmctbW9kZWw9XCIkdmFsdWUuX19jaGVja2VkXCIvPicsXG4gICAgICAgICAgc29ydEZpZWxkOiBudWxsLFxuICAgICAgICAgIGNvbmRpdGlvbmFsOiBhbmd1bGFyLm5vb3BcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICAnbW91bnRUYWJsZSc6ZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgZnVuY3Rpb24gcmV0dXJuRm9ybWF0dGFibGVHbHlwaGljb24oc3RyaW5nKXtcbiAgICAgICAgICByZXR1cm4gJzxpIG5nLWNsYXNzPVwidm0uc2VsZWN0ZWRJdGVtID09IFxcJycgKyBzdHJpbmcgKydcXCcgPyAodm0uc2VsZWN0ZWRJdGVtRGlyID09IFxcJ2FzY1xcJyA/IFxcJ2dseXBoaWNvbiBnbHlwaGljb24tbWVudS11cFxcJyA6IFxcJ2dseXBoaWNvbiBnbHlwaGljb24tbWVudS1kb3duXFwnICk6IFxcJ1xcJ1wiPjwvaT4nO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJldHVybkZvcm1hdHRhYmxlVGFibGVIZWFkZXIoYm9vbCxzdHJpbmcsc2Ype1xuICAgICAgICAgIGlmKGJvb2wpe1xuICAgICAgICAgICAgcmV0dXJuICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIiBidG4gYnRuLWxpbmsgYnRuLXNtXCIgbmctY2xpY2s9XCJ2bS5zb3J0UHJveHkoXFwnJysgc2YgKydcXCcsJyArICdcXCcnLmNvbmNhdChzZikuY29uY2F0KCdcXCcnKSArJylcIj4nICsgc3RyaW5nICsgcmV0dXJuRm9ybWF0dGFibGVHbHlwaGljb24oc2YpICsgJzwvYnV0dG9uPic7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbW91bnRIZWFkZXIocHJldiwgbmV4dCl7XG4gICAgICAgICAgcmV0dXJuIHByZXYrPSAnXFx0XFx0PHRkIGNsYXNzPVwiJysgbmV4dC5zaXplICsnXCIgPicgKyByZXR1cm5Gb3JtYXR0YWJsZVRhYmxlSGVhZGVyKCEhbmV4dC5zb3J0RmllbGQsbmV4dC50aXRsZSxuZXh0LnNvcnRGaWVsZCkgKyAnPC90ZD5cXG4nO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1vdW50QWxsVGFibGVDZWxsKHByZXYsbmV4dCl7XG4gICAgICAgICAgcmV0dXJuIHByZXYgKz0gJzx0ZCBuZy1zdHlsZT1cIntib3JkZXJMZWZ0OiB7ezo6dm0uY29uZGl0aW9uYWxUYWJsZUNlbGwoJHZhbHVlLFxcJycrIG5leHQubmFtZSArJ1xcJyl9fSB9XCI+JyArIG5leHQuY29udGVudCArJzwvdGQ+JztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ3VyYXRpb24uY29sdW1ucy51bnNoaWZ0KHRoaXMuYWRkQ2hlY2tib3goKSk7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24uY29sdW1ucyA9IHRoaXMuc29ydENvbHVtbnMoY29uZmlndXJhdGlvbi5hdXhDb2x1bW5zVG9Tb3J0LCBjb25maWd1cmF0aW9uLmNvbHVtbnMpO1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICc8c2VsZWN0IG5nLW9wdGlvbnM9XCJpdGVtIGZvciBpdGVtIGluIHZtLmNvbmZpZy5pdGVtc1BlclBhZ2VcIiBuZy1tb2RlbD1cInZtLiRwYXJlbnQuaXRlbXNQZXJQYWdlXCI+PC9zZWxlY3Q+JztcbiAgICAgICAgbWVzc2FnZSArPSAnPHRhYmxlIGNsYXNzPVwiJysgY29uZmlndXJhdGlvbi5jbGFzcyArJ1wiPlxcbic7XG4gICAgICAgIG1lc3NhZ2UgKz0gJzx0aGVhZD4nO1xuICAgICAgICBtZXNzYWdlICs9ICdcXHQ8dHI+XFxuJztcbiAgICAgICAgbWVzc2FnZSA9IGNvbmZpZ3VyYXRpb24uY29sdW1ucy5yZWR1Y2UobW91bnRIZWFkZXIuYmluZCh0aGlzKSxtZXNzYWdlKTtcbiAgICAgICAgbWVzc2FnZSArPSAnXFx0PC90cj5cXG4nO1xuICAgICAgICBtZXNzYWdlICs9ICc8L3RoZWFkPic7XG4gICAgICAgIG1lc3NhZ2UgKz0gJzx0Ym9keT4nO1xuICAgICAgICBtZXNzYWdlICs9ICc8dHIgbmctc3R5bGU9XCJ7Ym9yZGVyTGVmdDoge3s6OnZtLmNvbmRpdGlvbmFsKCR2YWx1ZSl9fSB9XCIgIG5nLWRibGNsaWNrPVwidm0uZG91YmxlKCR2YWx1ZSlcIiBuZy1jbGFzcz1cIiR2YWx1ZS5fX2NoZWNrZWQgPyBcXCdhY3RpdmVcXCcgOiBcXCdcXCdcIiBuZy1yZXBlYXQ9XCIkdmFsdWUgaW4gdm0uZGF0YSB0cmFjayBieSAkaW5kZXhcIiBuZy1jbGljaz1cInZtLnNlbGVjdFJvdygkaW5kZXgsJHZhbHVlLCRldmVudClcIiA+JztcbiAgICAgICAgbWVzc2FnZSArPSBjb25maWd1cmF0aW9uLmNvbHVtbnMucmVkdWNlKG1vdW50QWxsVGFibGVDZWxsLCcnKTtcbiAgICAgICAgbWVzc2FnZSArPSAnPC90cj4nO1xuICAgICAgICBtZXNzYWdlICs9ICc8L3Rib2R5Pic7XG4gICAgICAgIG1lc3NhZ2UgKz0gJzwvdGFibGU+XFxuJztcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYW5ndWxhci5tb2R1bGUoJ2d1bWdhLnNlcnZpY2VzLmxpc3RoZWxwZXInLFtdKVxuICAuZmFjdG9yeSgnR3VtZ2FMaXN0SGVscGVyJyxMaXN0SGVscGVyKTtcblxufSkoKTtcbiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cblx0Tm90aWZpY2F0aW9uLiRpbmplY3QgPSBbXCIkaHR0cFwiLCBcIiRxXCJdO1xuXHQvKipcblx0ICogQG5nZG9jIHNlcnZpY2Vcblx0ICogQG5hbWUgZ3VtZ2EuY29yZTpHdW1nYU5vdGlmaWNhdGlvblxuXHQgKiBAZGVzY3JpcHRpb25cblx0ICovXG5cdGZ1bmN0aW9uIE5vdGlmaWNhdGlvbigkaHR0cCwkcSl7XG5cdFx0dmFyIHRva2VuID0gd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ3Rva2VuJyk7XG5cdFx0dmFyIHVybCA9ICdodHRwOi8vMTkyLjE2OC4yNS4yMDEvc2VjdXJpdHktYXBpL25vdGlmaWNhdGlvbnMvc291cmNlP2d1bWdhVG9rZW49JyArIHRva2VuO1xuXHRcdHZhciBldmVudFNvdXJjZTtcblxuXHRcdHRoaXMuZ2V0RXZlbnQgPSBnZXRFdmVudDtcblx0XHR0aGlzLm5ld01lc3NhZ2VzID0gbmV3TWVzc2FnZXM7XG5cdFx0dGhpcy5uZXdNZXNzYWdlc0NvdW50ID0gbmV3TWVzc2FnZXNDb3VudDtcblxuXHRcdGZ1bmN0aW9uIHNldFVybCh1cmwpIHtcblx0XHRcdHVybCA9IHVybDtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gc2V0VG9rZW4odG9rZW4pIHtcblx0XHRcdHRva2VuID0gdG9rZW47XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGdldEV2ZW50KCkge1xuXHRcdFx0aWYgKHRva2VuKSB1cmwuY29uY2F0KCc/Z3VtZ2FUb2tlbj0nICsgdG9rZW4pO1xuXHRcdFx0cmV0dXJuIG5ldyBFdmVudFNvdXJjZSh1cmwpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBuZXdNZXNzYWdlcygpIHtcblx0XHRcdGdldEV2ZW50KCkuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdHZhciBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcblx0XHRcdFx0Y29uc29sZS5sb2coZGF0YS5uZXdNZXNzYWdlcyk7XG5cdFx0XHRcdHJldHVybiBkYXRhLm5ld01lc3NhZ2VzO1xuXHRcdFx0fSwgZmFsc2UpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBuZXdNZXNzYWdlc0NvdW50KCkge1xuXHRcdFx0Z2V0RXZlbnQoKS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuXHRcdFx0XHRjb25zb2xlLmxvZyhkYXRhLm5ld01lc3NhZ2VzQ291bnQpO1xuXHRcdFx0XHRyZXR1cm4gZGF0YS5uZXdNZXNzYWdlc0NvdW50O1xuXHRcdFx0fSwgZmFsc2UpO1xuXHRcdH1cblx0fVxuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2Euc2VydmljZXMubm90aWZpY2F0aW9uJyxbXSlcblx0LnNlcnZpY2UoJ0d1bWdhTm90aWZpY2F0aW9uJyxOb3RpZmljYXRpb24pO1xufSkoKTtcbiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cblx0UG9wdWxhdGUuJGluamVjdCA9IFtdO1xuXHQvKipcblx0ICogQG5nZG9jIHNlcnZpY2Vcblx0ICogQG5hbWUgZ3VtZ2EuY29yZTokcG9wdWxhdGVQcm92aWRlclxuXHQgKiBAZGVzY3JpcHRpb24gTyBzZXJ2aWNlICoqJHBvcHVsYXRlKiogw6kgdXRpbGl6YWRvIHBhcmEgYWRpY2lvbmFyIGZ1bsOnw7VlcyBiw6FzaWNhcyBkZSBDUlVELCBxdWUgasOhIGZhemVtIGEgY29uZXjDo28gY29tIG8gU2VydmljZVxuXHQgKiAgKCpNZWxob3IgdXRpbGl6YWRvIGNvbSBvIHNlcnZpY2UgR3VtZ2FSZXN0KiksIHBvc3NpYmlsaXRhbmRvIGFzc2ltIHF1ZSBvICRzY29wZSBmaXF1ZSBsaW1wby4gw4kgcG9zc8OtdmVsIHRhbWLDqW0gY3JpYXIgdW1hIGNvbmZpZ3VyYcOnw6NvXG5cdCAqICBub3ZhIHBhcmEgc2VyIHV0aWxpemFkYSwgZXh0ZW5kZXIgYXMgasOhIGNyaWFkYXMgZSByZWN1cGVyYXIgbyBvYmpldG8gZGUgY29udHJvbGUgZGEgY29uZmlndXJhw6fDo28uXG5cdCAqXG5cdCAqIFx0QXMgZnVuw6fDtWVzIGNyaWFtIHVtIG9iamV0byBjb20gbyBub21lIGRvIElEIHBhc3NhZG8gcGFyYSBhcm1hemVuYXIgb3MgZGFkb3MuIEFsw6ltIGRpc3NvLCBvIGlkZW50aWZpY2Fkb3Igw6kgdXRpbGl6YWRvIHBhcmEgbm9tZWFyIGFzIGZ1bsOnw7Vlcy4gQ2FzbyBvIElkZW50aWZpY2Fkb3Jcblx0ICogXHRwYXNzYWRvIHNlamEgYFVzZXJgIGUgYSBmdW7Dp8OjbyBzZWphIGBnZXRgLCBvIG5vbWUgZGEgZnVuw6fDo28gc2Vyw6EgYHVzZXJHZXRgLCBwYXJhIGV2aXRhciBjb2xpc8OjbyBkZSBub21lcy5cblx0ICogXHRUb2RhcyBhcyBmdW7Dp8O1ZXMgcG9zc3VlbSBldmVudG9zIHF1ZSBzw6NvIGRpc3BhcmFkb3MgYW50ZXMgZSBkZXBvaXMgZGEgZXhlY3XDp8OjbyBkYSBmdW7Dp8OjbywgcGFyYSBhanVkYXIgbyBkZXNlbnZvbHZlZG9yIGEgZXh0ZW5kZXIgYXMgZnVuY2lvbmFsaWRhZGVzXG5cdCAqIFx0ZGFzIGZ1bsOnw7VlcyBzZW0gcHJlY2lzYXIgc29icmVzY3JldmVyLWxhcy4gUGFyYSB1dGlsaXphciBlc3RlcyBldmVudG9zLCBiYXN0YSBhZGljaW9uYXIgdW0gbGlzdGVuZXIgbm8gJHNjb3BlLCBjb21vIHBvciBleGVtcGxvOlxuXHQgKiAgPHByZT5cblx0ICogIFx0JHNjb3BlLiRvbignYmVmb3JlR2V0JyxmdW5jdGlvbigpe1xuXHQgKiAgICBhbGVydCgnQW50ZXMgZG8gR2V0IScpO1xuXHQgKiAgXHR9KVxuXHQgKlxuXHQgKiBcdFx0JHNjb3BlLiRvbignYWZ0ZXJHZXQnLGZ1bmN0aW9uKHZhbHVlcyl7XG5cdCAqXHRcdCAgLy8gdmFsdWVzIMOpIHJldG9ybm8gZGEgZnVuw6fDo28gYXPDrW5jcm9uYS5cblx0ICogXHRcdH0pXG5cdCAqIFx0PC9wcmU+XG5cdCAqXG5cdCAqXG5cdCAqICMgQ29tbyB1dGlsaXphcjpcblx0ICpcblx0ICogXHRQYXJhIHV0aWxpemFyIG8gYXNzaXN0ZW50ZSwgw6kgbmVjZXNzw6FyaW8gaW5qZXRhciBjb21vIGRlcGVuZMOqbmNpYSBubyBibG9jbyBkZSBjb25maWd1cmHDp8OjbyBkbyBtw7NkdWxvOlxuXHQgKiBcdDxwcmU+XG5cdCAqICBcdGFuZ3VsYXIubW9kdWxlKCdzYW1wbGUnLFsnZ3VtZ2EuY29yZSddKVxuXHQgKiAgXHQuY29uZmlnKGZ1bmN0aW9uKCRwb3B1bGF0ZVByb3ZpZGVyKXtcblx0ICogICAgICRzdGF0ZVByb3ZpZGVyXG4gICAqICAgXHQgLnN0YXRlKCdjcnVkLmxpc3QnLCB7XG4gICAqICAgICAgdXJsOiAnL2xpc3QnLFxuXHQgKiAgICAgIHRlbXBsYXRlVXJsOiAnYXBwL21vZHVsZXMvY3J1ZC92aWV3cy9saXN0Lmh0bWwnLFxuXHQgKiAgICAgIGNvbnRyb2xsZXI6ICdDcnVkQ29udHJvbGxlcicsXG4gICAqICAgICAgcmVzb2x2ZTogIHtcbiAgICogICAgICAgcG9wdWxhdGVTY29wZTogZnVuY3Rpb24oKXtcbiAgICogICAgICAgIHJldHVybiAkcG9wdWxhdGVQcm92aWRlci5wb3B1bGF0ZVNjb3BlO1xuICAgKiAgICAgICB9XG4gICAqICAgICB9XG4gICAqICAgfSlcblx0ICogICB9KVxuXHQgKiAgPC9wcmU+XG5cdCAqXG5cdCAqIFx0RSBkZXBvaXMgbm8gY29udHJvbGxlciwgdXRpbGl6YXIgZWxlIGV4ZWN1dGFuZG8gYSBmdW7Dp8OjbyBwb3B1bGF0ZVNjb3BlIHF1ZSBmb2kgcGFzc2FkYSBhdHJhdsOpcyBkbyByZXNvbHZlOlxuXHQgKiBcdDxwcmU+XG5cdCAqIFx0XHRhbmd1bGFyLm1vZHVsZSgnc2FtcGxlJylcblx0ICogXHRcdC5jb250cm9sbGVyKCdTYW1wbGVDb250cm9sbGVyJyxcblx0ICogXHQgICBbJyRzY29wZScsJ3BvcHVsYXRlU2NvcGUnLCdVc2VyU2VydmljZScsZnVuY3Rpb24oJHNjb3BlLHBvcHVsYXRlU2NvcGUsVXNlclNlcnZpY2Upe1xuXHQgKiBcdFx0ICAgcG9wdWxhdGVTY29wZSgkc2NvcGUsVXNlclNlcnZpY2UsJ1VzZXInLCdiYXNlLWxpc3QnKTtcblx0ICogXHQgICB9XSlcblx0ICogXHQ8L3ByZT5cblx0ICpcblx0ICogXHRQb2RlLXNlIG9wdGFyIHRhbWLDqW0gcG9yIG7Do28gaW5jbHVpciBubyBtw7NkdWxvIGRlIGNvbmZpZ3VyYcOnw6NvLCBtYXMgZGlyZXRvIG5vIGNvbnRyb2xsZXI6XG5cdCAqIFx0PHByZT5cblx0ICogXHRcdGFuZ3VsYXIubW9kdWxlKCdzYW1wbGUnKVxuXHQgKiBcdFx0LmNvbnRyb2xsZXIoJ1NhbXBsZUNvbnRyb2xsZXInLFxuXHQgKiBcdCAgIFsnJHNjb3BlJywnJHBvcHVsYXRlJywnVXNlclNlcnZpY2UnLGZ1bmN0aW9uKCRzY29wZSwkcG9wdWxhdGUsVXNlclNlcnZpY2Upe1xuXHQgKiBcdFx0ICAgJHBvcHVsYXRlLnBvcHVsYXRlU2NvcGUoJHNjb3BlLFVzZXJTZXJ2aWNlLCdVc2VyJywnYmFzZS1saXN0Jyk7XG5cdCAqIFx0ICAgfV0pXG5cdCAqIFx0PC9wcmU+XG5cdCAqXG5cdCAqICMgQ29uZmlndXJhw6fDtWVzOlxuXHQgKlxuXHQgKiBcdC0gYGJhc2UtbGlzdGA6IEEgY29uZmlndXJhw6fDo28gYGJhc2UtbGlzdGAgc2VydmUgcGFyYSBpbmNsdWlyIGZ1bsOnw7VlcyBnZXJhaXMgcXVlIHPDo28gbmVjZXNzw6FyaWFzIGVtIHDDoWdpbmFzIGRlIGxpc3RhZ2VtLCBxdWUgc8Ojbzpcblx0ICogXHRcdC0gYGdldGBcblx0ICogXHRcdC0gYHJlc2V0QW5kR2V0YFxuXHQgKiBcdFx0LSBgZ2V0QnlJZGBcblx0ICogXHRcdC0gYHVwZGF0ZWBcblx0ICogXHRcdC0gYHNhdmVRdWVyeWBcblx0ICogXHRcdC0gYGdldFF1ZXJ5YFxuXHQgKiBcdFx0LSBgZGVsZXRlYFxuXHQgKlxuXHQgKiAgICAtIGBzb3J0YFxuXHQgKiAgICAtIGBzZWFyY2hgXG5cdCAqICAgIC0gYGFkdmFuY2VkU2VhcmNoYFxuXHQgKlxuXHQgKlxuXHQgKiBcdC0gYGJhc2UtZm9ybWA6IEEgY29uZmlndXJhw6fDo28gYGJhc2UtZm9ybWAgc2VydmUgcGFyYSBpbmNsdWlyIGZ1bsOnw7VlcyBnZXJhaXMgcXVlIHPDo28gbmVjZXNzw6FyaWFzIGVtIHDDoWdpbmFzIGRlIGZvcm11bMOhcmlvLCBxdWUgc8Ojbzpcblx0ICogXHRcdC0gYGdldE5ld2Bcblx0ICogXHRcdC0gYGdldEJ5SWRgXG5cdCAqIFx0XHQtIGBzYXZlYFxuXHQgKiBcdFx0LSBgdXBkYXRlYFxuXHQgKiBcdFx0LSBgc2F2ZUltYWdlYFxuXHQgKlxuXHQgKiAgICAtIGBkZWxldGVJbWFnZWBcblx0ICpcblx0ICpcblx0ICogXHQtIGBtYW55LXRvLW1hbnlgOiBBIGNvbmZpZ3VyYcOnw6NvIGBtYW55LXRvLW1hbnlgIHNlcnZlIHBhcmEgaW5jbHVpciBmdW7Dp8O1ZXMgcXVlIGNvbXVtZW50ZSBzw6NvIHV0aWxpemFkYXMgZW0gcmVsYcOnw7VlcyBtdWl0b3MgcGFyYSBtdWl0b3MsIHF1ZSBzw6NvOlxuXHQgKiBcdFx0LSBgc2VhcmNoYFxuXHQgKiBcdFx0LSBgc2F2ZWBcblx0ICogXHRcdC0gYHNlYXJjaEFzeW5jYFxuXHQgKiBcdFx0LSBgc2F2ZUFzeW5jYFxuXHQgKlxuXHQgKiBcdC0gYG1hbnktdG8tb25lYDogQSBjb25maWd1cmHDp8OjbyBgbWFueS10by1vbmVgIHNlcnZlIHBhcmEgaW5jbHVpciBmdW7Dp8O1ZXMgcXVlIGNvbXVtZW50ZSBzw6NvIHV0aWxpemFkYXMgZW0gcmVsYcOnw7VlcyBtdWl0b3MgcGFyYSB1bSwgcXVlIHPDo286XG5cdCAqIFx0XHQtIGBzZWFyY2hgXG5cdCAqIFx0XHQtIGBzYXZlYFxuXHQgKiBcdFx0LSBgc2F2ZUFzeW5jYFxuXHQgKlxuXHQgKlx0IyMgSW1wbGVtZW50YcOnw7Vlczpcblx0ICpcdFx0UGFyYSB2ZXIgYXMgaW1wbGVtZW50YcOnw7VlcyBkYXMgZnVuw6fDtWVzIGFjaW1hLCBjbGlxdWUgW2FxdWldKCkuXG5cdCAqXG5cdCAqXHQjIE3DqXRvZG9zXG5cdCAqICBgJHBvcHVsYXRlLnNldENvbmZpZyhuYW1lLHZhbHVlKWBcblx0ICpcblx0ICogIE8gbcOpdG9kbyBzZXRDb25maWcgYWNlaXRhIGRvaXMgcGFyw6JtZXRyb3MgYG5hbWVgIGUgYHZhbHVlYCwgbyBub21lIGRhIGNvbmZpZ3VyYcOnw6NvIGUgbyBvYmpldG8gcXVlIGlyw6EgZmF6ZXIgYSBjb25maWd1cmHDp8Ojby5cblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+bmFtZTwvbGFiZWw+IFN0cmluZyBxdWUgc2Vyw6EgdXNhZGEgcGFyYSBpZGVudGlmaWNhciBvIG9iamV0byBxdWUgc2Vyw6EgY3JpYWRvLlxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+T2JqZWN0PC9sYWJlbD4gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPnZhbHVlPC9sYWJlbD4gT2JqZXRvIGRlIGNvbmZpZ3VyYcOnw6NvIHF1ZSBzZXLDoSB1c2Fkby5cblx0ICogICBQYXJhIGFkaWNpb25hciBhIGZ1bsOnw6NvLCBjb2xvcXVlIG8gbm9tZSBkYSBmdW7Dp8OjbyBlIG8gdmFsb3IgZGVsZSBjb21vIGB0cnVlYFxuXHQgKlxuXHQgKiAgLS0tXG5cdCAqXG5cdCAqICBgJHBvcHVsYXRlLmdldENvbmZpZyhuYW1lKWBcblx0ICpcblx0ICogIE8gbcOpdG9kbyBnZXRDb25maWcgYWNlaXRhIHVtIHBhcsOibWV0cm8gYG5hbWVgLCBxdWUgw6kgbyBub21lIGRhIGNvbmZpZ3VyYcOnw6NvIGRlc2VqYWRhLlxuXHQgKiAgIyMjIFBhcsOibWV0cm9zXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5uYW1lPC9sYWJlbD4gU3RyaW5nIHF1ZSBzZXLDoSB1c2FkYSBwYXJhIGlkZW50aWZpY2FyIG8gb2JqZXRvIHF1ZSBzZXLDoSByZWN1cGVyYWRvLlxuXHQgKiAgIFBhcmEgYWRpY2lvbmFyIGEgZnVuw6fDo28sIGNvbG9xdWUgbyBub21lIGRhIGZ1bsOnw6NvIGUgbyB2YWxvciBkZWxlIGNvbW8gYHRydWVgXG5cdCAqXG5cdCAqIFx0IyMjIFJldG9ybm9cblx0ICpcblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPk9iamVjdDwvbGFiZWw+IENvbmZpZ3VyYcOnw6NvIHF1ZSBzZXLDoSByZWN1cGVyYWRhIGRhIGZ1bsOnw6NvLlxuXHQgKlxuXHQgKlxuXHQgKiAgLS0tXG5cdCAqXG5cdCAqICBgJHBvcHVsYXRlLnNldE1ldGhvZChuYW1lLGNvbmZpZyxmdW5jdGlvbilgXG5cdCAqXG5cdCAqICBPIG3DqXRvZG8gc2V0TWV0aG9kIGFjZWl0YSB0csOqcyBwYXLDom1ldHJvczogYG5hbWVgLGBjb25maWdgLCBgZnVuY3Rpb25gLiBFc3RlIG3DqXRvZG8gw6kgdXRpbGl6YWRvIHBhcmEgZXh0ZW5kZXIgYXMgZnVuY2lvbmFsaWRhZGVzIGRlIHVtYSBjb25maWd1cmHDp8Ojby5cblx0ICpcblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+bmFtZTwvbGFiZWw+IFN0cmluZyBxdWUgc2Vyw6EgdXNhZGEgcGFyYSBpZGVudGlmaWNhciBjb21vIHNlcsOhIG8gbm9tZSBkYSBmdW7Dp8OjbyBhIHNlciBhZGljaW9uYWRhLlxuXHQgKiAgIFBhcmEgYWRpY2lvbmFyIGEgZnVuw6fDo28sIGNvbG9xdWUgbyBub21lIGRhIGZ1bsOnw6NvIGUgbyB2YWxvciBkZWxlIGNvbW8gYHRydWVgXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5jb25maWc8L2xhYmVsPiBTdHJpbmcgcXVlIHNlcsOhIHVzYWRhIHBhcmEgaWRlbnRpZmljYXIgcXVhbCBvYmpldG8gZGUgY29uZmlndXJhw6fDo28gZXN0YSBmdW7Dp8OjbyBzZXLDoSBhZGljaW9uYWRhLlxuXHQgKiAgIFBhcmEgYWRpY2lvbmFyIGEgZnVuw6fDo28sIGNvbG9xdWUgbyBub21lIGRhIGZ1bsOnw6NvIGUgbyB2YWxvciBkZWxlIGNvbW8gYHRydWVgXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5GdW5jdGlvbjwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmZ1bmN0aW9uPC9sYWJlbD4gRnVuw6fDo28gcXVlIHNlcsOhIGFkaWNpb25hZGEgYW8gJHNjb3BlLiAqQW8gcGFzc2FyIGEgZnVuw6fDo28sIG8gZGVzZW52b2x2ZWRvclxuXHQgKiAgdGVtIGFjZXNzbyBhIDQgcGFyw6JtZXRyb3MgcXVlIHNlcsOjbyB1dGlsaXphZG9zIHBhcmEgZGVmaW5pciBhIGZ1bsOnw6NvIG5vIHNjb3BlOiBgU2NvcGVgLCBgU2VydmljZWAsYElkYCouXG5cdCAqXG5cdCAqICAtLS1cblx0ICpcbiBcdCAqXG5cdCAqICBgJHBvcHVsYXRlLnBvcHVsYXRlU2NvcGUoc2NvcGUsc2VydmljZSxpZCxjb25maWcpYFxuXHQgKlxuXHQgKiAgTyBtw6l0b2RvIHBvcHVsYXRlU2NvcGUgYWNlaXRhIHF1YXRybyBwYXLDom1ldHJvczogYHNjb3BlYCxgc2VydmljZWAsIGBpZGAgZSBgY29uZmlnYC4gRXN0ZSBtw6l0b2RvIMOpIHV0aWxpemFkbyBwYXJhIHBvcHVsYXIgbyAkc2NvcGUgZG8gY29udHJvbGFkb3IgY29tIGFzIGZ1bsOnw7VlcyBkYSBjb25maWd1cmHDp8Ojby5cblx0ICpcblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+T2JqZWN0PC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+c2NvcGU8L2xhYmVsPiBPYmpldG8gb25kZSBhcyBmdW7Dp8O1ZXMgc8OjbyBjb2xvY2FkYXMsIGNhc28gc2VqYW0gbnVtIGNvbnRyb2xhZG9yLCBubyAqJHNjb3BlKi5cblx0ICogICBQYXJhIGFkaWNpb25hciBhIGZ1bsOnw6NvLCBjb2xvcXVlIG8gbm9tZSBkYSBmdW7Dp8OjbyBlIG8gdmFsb3IgZGVsZSBjb21vIGB0cnVlYFxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+aWQ8L2xhYmVsPiBJZGVudGlmaWNhZG9yIHF1ZSBzZXLDoSB1dGlsaXphZG8gcGFyYSBhcm1hemVuYXIgb3MgZGFkb3Mgbm8gJHNjb3BlLCBhbMOpbSBkZSBub21lYXJcblx0ICogIGFzIGZ1bsOnw7Vlcy5cbiBcdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5jb25maWc8L2xhYmVsPiBTdHJpbmcgcXVlIHNlcsOhIHV0aWxpemFkYSBwYXJhIGRlZmluaXIgcXVhbCBjb25maWd1cmHDp8OjbyBzZXLDoSB1dGlsaXphZGEuXG5cdCAqICAtLS1cblx0ICovXG5cblx0ZnVuY3Rpb24gUG9wdWxhdGUoKXtcblx0XHR2YXIgaGVscGVycyA9IHt9LCBjb25maWdzID0ge30sIG1ldGhvZHMgPSB7fTtcblx0XHRoZWxwZXJzLmd1YXJhbnRlZVN0cmluZyA9IGZ1bmN0aW9uKHMpeyByZXR1cm4gKHMgJiYgYW5ndWxhci5pc1N0cmluZyhzKSl9O1xuXHRcdGhlbHBlcnMuZ3VhcmFudGVlQXJyYXkgPSBmdW5jdGlvbihhKXsgcmV0dXJuIChhICYmIGFuZ3VsYXIuaXNBcnJheShhKSl9O1xuXHRcdGhlbHBlcnMuZ3VhcmFudGVlSXNEZWZpbmVkID0gZnVuY3Rpb24oZCl7IHJldHVybiBhbmd1bGFyLmlzRGVmaW5lZChkKX07XG5cdFx0aGVscGVycy5ndWFyYW50ZWVCYXNpY0xpc3QgPSBmdW5jdGlvbihzKXsgcmV0dXJuIChzICYmIHRoaXMuZ3VhcmFudGVlU3RyaW5nKHMpICYmIHMgPT0gJ2Jhc2ljLWxpc3QnKX07XG5cdFx0Y29uZmlnc1snYmFzZS1saXN0J109IHtcblx0XHRcdGdldDogdHJ1ZSxcblx0XHRcdHJlc2V0QW5kR2V0OiB0cnVlLFxuXHRcdFx0Z2V0QnlJZDogdHJ1ZSxcblx0XHRcdHVwZGF0ZTogdHJ1ZSxcblx0XHRcdGRlbGV0ZTogdHJ1ZSxcblx0XHRcdHNvcnQ6IHRydWUsXG5cdFx0XHRzZWFyY2g6IHRydWUsXG5cdFx0XHRhZHZhbmNlZFNlYXJjaDogdHJ1ZSxcblx0XHRcdHNhdmVRdWVyeTogdHJ1ZSxcblx0XHRcdGdldFF1ZXJ5OiB0cnVlLFxuXHRcdFx0cmVzZXRRdWVyeTogdHJ1ZVxuXHRcdH07XG5cdFx0Y29uZmlnc1snYmFzZS1mb3JtJ10gPSB7XG5cdFx0XHRnZXROZXc6IHRydWUsXG5cdFx0XHRnZXRCeUlkOiB0cnVlLFxuXHRcdFx0c2F2ZTogdHJ1ZSxcblx0XHRcdHVwZGF0ZTogdHJ1ZSxcblx0XHRcdHNhdmVJbWFnZTogdHJ1ZSxcblx0XHRcdGRlbGV0ZUltYWdlOiB0cnVlXG5cdFx0fTtcblxuXHRcdGNvbmZpZ3NbJ21hbnktdG8tbWFueSddID0ge1xuXHRcdFx0c2VhcmNoOiB0cnVlLFxuXHRcdFx0c2F2ZTogdHJ1ZSxcblx0XHRcdHNlYXJjaEFzeW5jOiB0cnVlLFxuXHRcdFx0c2F2ZUFzeW5jOiB0cnVlXG5cdFx0fVxuXG5cdFx0Y29uZmlnc1snbWFueS10by1vbmUnXT17XG5cdFx0XHRzYXZlOiB0cnVlLFxuXHRcdFx0c2VhcmNoQXN5bmM6IHRydWUsXG5cdFx0XHRzYXZlQXN5bmM6IHRydWVcblx0XHR9XG5cblxuXHRcdG1ldGhvZHMuc2VhcmNoQXN5bmMgPSBmdW5jdGlvbihTY29wZSxTZXJ2aWNlLElkKXtcblx0XHRcdFNjb3BlW0lkLnRvTG93ZXJDYXNlKCkgKyAnQXN5bmNTZWFyY2gnXSA9IGZ1bmN0aW9uKGZpZWxkLHZhbHVlKXtcblx0XHRcdFx0cmV0dXJuIFNlcnZpY2UuZ2V0U2VhcmNoKGZpZWxkLCB2YWx1ZSlcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YS5kYXRhLnZhbHVlcztcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWV0aG9kcy5nZXRRdWVyeSA9IGZ1bmN0aW9uKFNjb3BlLFNlcnZpY2UsSWQpe1xuXHRcdFx0U2NvcGVbSWQudG9Mb3dlckNhc2UoKSArICdHZXRRdWVyeSddID0gZnVuY3Rpb24ocGFnZSl7XG5cdFx0XHRcdHJldHVybiBTZXJ2aWNlLmdldFF1ZXJ5KHBhZ2UpXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uKGRhdGEpe1xuXHRcdFx0XHRcdHJldHVybiBkYXRhLmRhdGEudmFsdWVzO1xuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1ldGhvZHMuc2F2ZVF1ZXJ5ID0gZnVuY3Rpb24oU2NvcGUsU2VydmljZSxJZCl7XG5cdFx0XHRcdFNjb3BlW0lkLnRvTG93ZXJDYXNlKCkgKyAnU2F2ZVF1ZXJ5J10gPSBmdW5jdGlvbihxdWVyeSxuYW1lKXtcblx0XHRcdFx0XHRTY29wZS4kYnJvYWRjYXN0KCdiZWZvcmVTYXZlUXVlcnknLHtxdWVyeTogcXVlcnksIG5hbWU6IG5hbWV9KTtcblx0XHRcdFx0XHRTZXJ2aWNlLnNhdmVRdWVyeSh7cXVlcnk6IHF1ZXJ5LCBuYW1lOiBuYW1lfSlcblx0XHRcdFx0XHQudGhlbihmdW5jdGlvbihkYXRhKXtcblx0XHRcdFx0XHRcdFNjb3BlLiRicm9hZGNhc3QoJ2FmdGVyU2F2ZVF1ZXJ5JyxkYXRhKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWV0aG9kcy5zYXZlQXN5bmMgPSBmdW5jdGlvbihTY29wZSxTZXJ2aWNlLElkKXtcblx0XHRcdFNjb3BlW0lkLnRvTG93ZXJDYXNlKCkgKyAnQXN5bmNTYXZlJ10gPSBmdW5jdGlvbih2YWx1ZSxwYXJhbSl7XG5cdFx0XHRcdHZhciBvYmogPSB7fTtcblx0XHRcdFx0b2JqW3BhcmFtXSA9IHZhbHVlO1xuXHRcdFx0XHRyZXR1cm4gU2VydmljZS51cGRhdGUob2JqKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0bWV0aG9kcy5nZXQgPSBmdW5jdGlvbihTY29wZSxTZXJ2aWNlLElkKXtcblx0XHRcdFNjb3BlW0lkXT0ge307XG5cdFx0XHRTY29wZS5wYWdlID0gMDtcblx0XHRcdFNjb3BlW0lkLnRvTG93ZXJDYXNlKCkgKyAnR2V0J109IGZ1bmN0aW9uKHBhZ2UpIHtcblx0XHRcdFx0U2NvcGUuJGJyb2FkY2FzdCgnYmVmb3JlR2V0Jyk7XG5cdFx0XHRcdFNlcnZpY2UuZ2V0KHBhZ2UpXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcblx0XHRcdFx0XHRTY29wZVtJZF0uY29udGVudCA9IHZhbHVlcztcblx0XHRcdFx0XHRTY29wZS4kYnJvYWRjYXN0KCdhZnRlckdldCcsdmFsdWVzKTtcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHRcdFNjb3BlW0lkLnRvTG93ZXJDYXNlKCkgKyAnR2V0J10oKTtcblx0XHR9O1xuXHRcdG1ldGhvZHMucmVzZXRBbmRHZXQgPSBmdW5jdGlvbihTY29wZSxTZXJ2aWNlLElkKXtcblx0XHRcdFNjb3BlW0lkLnRvTG93ZXJDYXNlKCkgKyAnUmVzZXRBbmRHZXQnXSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFNjb3BlLnBhZ2UgPSAwO1xuXHRcdFx0XHRTY29wZS4kYnJvYWRjYXN0KCdiZWZvcmVSZXNldEFuZEdldCcpO1xuXHRcdFx0XHRTZXJ2aWNlLnJlc2V0QW5kR2V0KClcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcblx0XHRcdFx0XHRTY29wZVtJZF0uY29udGVudCA9IHZhbHVlcztcblx0XHRcdFx0XHRTY29wZS4kYnJvYWRjYXN0KCdhZnRlclJlc2V0QW5kR2V0Jyx2YWx1ZXMpO1xuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0bWV0aG9kcy5nZXROZXcgPSBmdW5jdGlvbihTY29wZSxTZXJ2aWNlLElkKXtcblx0XHRcdFNjb3BlW0lkXSA9IFNjb3BlW0lkXSB8fCB7fTtcblx0XHRcdFNjb3BlW0lkLnRvTG93ZXJDYXNlKCkgKyAnR2V0TmV3J10gPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRTY29wZS4kYnJvYWRjYXN0KCdiZWZvcmVHZXROZXcnKTtcblx0XHRcdFx0U2VydmljZS5nZXROZXcoKVxuXHRcdFx0XHQudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuXHRcdFx0XHRcdFNjb3BlLiRicm9hZGNhc3QoJ2FmdGVyR2V0TmV3Jyx2YWx1ZXMpO1xuXHRcdFx0XHRcdFNjb3BlW0lkXVsnbmV3JyArIElkXSA9IHZhbHVlcztcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHR9O1xuXHRcdG1ldGhvZHMuZ2V0QnlJZCA9IGZ1bmN0aW9uKFNjb3BlLFNlcnZpY2UsSWQpe1xuXHRcdFx0U2NvcGVbSWQudG9Mb3dlckNhc2UoKSArICdHZXRCeUlkJ10gPSBmdW5jdGlvbihpZCl7XG5cdFx0XHRcdFNjb3BlLiRicm9hZGNhc3QoJ2JlZm9yZUdldEJ5SWQnKTtcblx0XHRcdFx0U2VydmljZS5nZXRCeUlkKGlkKVxuXHRcdFx0XHQudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuXHRcdFx0XHRcdFNjb3BlW0lkXVsnaWQnICsgaWRdID0gdmFsdWVzO1xuXHRcdFx0XHRcdFNjb3BlLiRicm9hZGNhc3QoJ2FmdGVyR2V0QnlJZCcsdmFsdWVzKTtcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHR9O1xuXHRcdG1ldGhvZHMuc2F2ZSA9IGZ1bmN0aW9uKFNjb3BlLFNlcnZpY2UsSWQpe1xuXHRcdFx0U2NvcGVbSWQudG9Mb3dlckNhc2UoKSArICdTYXZlJ10gPSBmdW5jdGlvbih2YWx1ZSxwYXJhbSl7XG5cdFx0XHRcdFNjb3BlLiRicm9hZGNhc3QoJ2JlZm9yZVNhdmUnLHZhbHVlKTtcblx0XHRcdFx0dmFyIG9iaiA9IHt9O1xuXHRcdFx0XHRvYmpbcGFyYW1dID0gdmFsdWU7XG5cdFx0XHRcdFNlcnZpY2UudXBkYXRlKG9iailcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcblx0XHRcdFx0XHRTY29wZS4kYnJvYWRjYXN0KCdhZnRlclNhdmUnLHZhbHVlcyk7XG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0fTtcblx0XHRtZXRob2RzLnVwZGF0ZSA9IGZ1bmN0aW9uKFNjb3BlLFNlcnZpY2UsSWQpe1xuXHRcdFx0U2NvcGVbSWQudG9Mb3dlckNhc2UoKSsnVXBkYXRlJ10gPSBmdW5jdGlvbih2YWx1ZSl7XG5cdFx0XHRcdFNjb3BlLiRicm9hZGNhc3QoJ2JlZm9yZVVwZGF0ZScsdmFsdWUpO1xuXHRcdFx0XHRTZXJ2aWNlLnVwZGF0ZSh2YWx1ZSlcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcblx0XHRcdFx0XHRTY29wZS4kYnJvYWRjYXN0KCdhZnRlclVwZGF0ZScsdmFsdWVzKTtcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHR9O1xuXHRcdG1ldGhvZHMuZGVsZXRlID0gZnVuY3Rpb24oU2NvcGUsU2VydmljZSxJZCl7XG5cdFx0XHRTY29wZVtJZC50b0xvd2VyQ2FzZSgpICsgJ0RlbGV0ZSddID0gZnVuY3Rpb24odmFsdWUpe1xuXHRcdFx0XHRTY29wZS4kYnJvYWRjYXN0KCdiZWZvcmVEZWxldGUnKTtcblx0XHRcdFx0U2VydmljZS5kZWxldGVDb2xsZWN0aW9uKHZhbHVlKVxuXHRcdFx0XHQudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuXHRcdFx0XHRcdFNjb3BlLiRicm9hZGNhc3QoJ2FmdGVyRGVsZXRlJyx2YWx1ZXMpO1xuXHRcdFx0XHRcdFNjb3BlW0lkLnRvTG93ZXJDYXNlKCkgKyAnR2V0J10oKTtcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHR9O1xuXHRcdG1ldGhvZHMuc29ydCA9IGZ1bmN0aW9uKFNjb3BlLFNlcnZpY2UsSWQpe1xuXHRcdFx0U2NvcGVbSWQudG9Mb3dlckNhc2UoKSsnU29ydCddID0gZnVuY3Rpb24oZmllbGQsd2F5KXtcblx0XHRcdFx0U2NvcGUuJGJyb2FkY2FzdCgnYmVmb3JlU29ydCcpO1xuXHRcdFx0XHRTZXJ2aWNlLnNvcnQoZmllbGQsd2F5KVxuXHRcdFx0XHQudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuXHRcdFx0XHRcdFNjb3BlW0lkXS5jb250ZW50ID0gdmFsdWVzO1xuXHRcdFx0XHRcdFNjb3BlLiRicm9hZGNhc3QoJ2FmdGVyU29ydCcsdmFsdWVzKTtcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHR9O1xuXHRcdG1ldGhvZHMuc2F2ZUltYWdlID0gZnVuY3Rpb24oU2NvcGUsU2VydmljZSxJZCl7XG5cdFx0XHRTY29wZVtJZC50b0xvd2VyQ2FzZSgpICsgJ1NhdmVJbWFnZSddID0gZnVuY3Rpb24oYXR0cmlidXRlLG1vZGVsKXtcblx0XHRcdFx0U2NvcGUuJGJyb2FkY2FzdCgnYmVmb3JlU2F2ZUltYWdlJyk7XG5cdFx0XHRcdHJldHVybiBTZXJ2aWNlLnNhdmVJbWFnZShhdHRyaWJ1dGUsbW9kZWwpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0bWV0aG9kcy5kZWxldGVJbWFnZSA9IGZ1bmN0aW9uKFNjb3BlLFNlcnZpY2UsSWQpe1xuXHRcdFx0U2NvcGVbSWQudG9Mb3dlckNhc2UoKSArICdEZWxldGVJbWFnZSddID0gZnVuY3Rpb24oYXR0cmlidXRlLG1vZGVsKXtcblx0XHRcdFx0U2NvcGUuJGJyb2FkY2FzdCgnYmVmb3JlRGVsZXRlSW1hZ2UnKTtcblx0XHRcdFx0U2VydmljZS5kZWxldGVJbWFnZShhdHRyaWJ1dGUsbW9kZWwpXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG5cdFx0XHRcdFx0U2NvcGUuJGJyb2FkY2FzdCgnYWZ0ZXJEZWxldGVJbWFnZScsdmFsdWVzKTtcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHR9O1xuXHRcdG1ldGhvZHMuc2VhcmNoID0gZnVuY3Rpb24oU2NvcGUsU2VydmljZSxJZCl7XG5cdFx0XHRTY29wZVtJZC50b0xvd2VyQ2FzZSgpICsgJ1NlYXJjaCddID0gZnVuY3Rpb24oZmllbGQscGFyYW0pe1xuXHRcdFx0XHRTY29wZS4kYnJvYWRjYXN0KCdiZWZvcmVTZWFyY2gnKTtcblx0XHRcdFx0U2VydmljZS5nZXRTZWFyY2goZmllbGQscGFyYW0pXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG5cdFx0XHRcdFx0U2NvcGVbSWRdLmNvbnRlbnQgPSB2YWx1ZXM7XG5cdFx0XHRcdFx0U2NvcGUuJGJyb2FkY2FzdCgnYWZ0ZXJTZWFyY2gnLHZhbHVlcyk7XG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdG1ldGhvZHMuYWR2YW5jZWRTZWFyY2ggPSBmdW5jdGlvbihTY29wZSxTZXJ2aWNlLElkKXtcblx0XHRcdFNjb3BlW0lkLnRvTG93ZXJDYXNlKCkgKyAnQWR2YW5jZWRTZWFyY2gnXSA9IGZ1bmN0aW9uKHBhcmFtKXtcblx0XHRcdFx0U2NvcGUuJGJyb2FkY2FzdCgnYmVmb3JlQWR2YW5jZWRTZWFyY2gnLHBhcmFtKVxuXHRcdFx0XHRTZXJ2aWNlLmdldEFkdmFuY2VkU2VhcmNoKHBhcmFtKVxuXHRcdFx0XHQudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuXHRcdFx0XHRcdFNjb3BlW0lkXS5jb250ZW50ID0gdmFsdWVzO1xuXHRcdFx0XHRcdFNjb3BlLiRicm9hZGNhc3QoJ2FmdGVyQWR2YW5jZWRTZWFyY2gnLHZhbHVlcylcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHR9XG5cdFx0bWV0aG9kcy5yZXNldFF1ZXJ5ID0gZnVuY3Rpb24oU2NvcGUsU2VydmljZSxpZCl7XG5cdFx0XHRTY29wZVtpZC50b0xvd2VyQ2FzZSgpICsgJ1Jlc2V0UXVlcnknXSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFNjb3BlLnBhZ2UgPSAwO1xuXHRcdFx0XHRTZXJ2aWNlLnJlc2V0UXVlcnkoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0bWV0aG9kc1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZXRDb25maWc6IGZ1bmN0aW9uKG4sdil7XG5cdFx0XHRcdGhlbHBlcnMuZ3VhcmFudGVlU3RyaW5nKG4pICYmIGhlbHBlcnMuZ3VhcmFudGVlSXNEZWZpbmVkKHYpID8gKGNvbmZpZ3Nbbl0gPSB2KSA6IGFuZ3VsYXIubm9vcDtcblx0XHRcdH0sXG5cdFx0XHRnZXRDb25maWc6IGZ1bmN0aW9uKHN0cmluZyl7XG5cdFx0XHRcdHJldHVybiBjb25maWdzW3N0cmluZ107XG5cdFx0XHR9LFxuXHRcdFx0c2V0TWV0aG9kOiBmdW5jdGlvbihuYW1lLGNvbmZpZyxmbil7XG5cdFx0XHRcdGlmKCEoaGVscGVycy5ndWFyYW50ZWVTdHJpbmcobmFtZSkgJiYgaGVscGVycy5ndWFyYW50ZWVTdHJpbmcoY29uZmlnKSkpXG5cdFx0XHRcdFx0dGhyb3cgJ09uZSBvZiAkcG9wdWxhdGVQcm92aWRlci5zZXRNZXRob2QgYXJndW1lbnRzIGlzIHdyb25nLic7XG5cdFx0XHRcdGNvbmZpZ3NbY29uZmlnXVtuYW1lXSA9IHRydWU7XG5cdFx0XHRcdG1ldGhvZHNbbmFtZV0gPSBmbjtcblx0XHRcdH0sXG5cdFx0XHRwb3B1bGF0ZVNjb3BlOiBmdW5jdGlvbihzY3Asc3ZjLGlkLGNvbmZpZyl7XG5cdFx0XHRcdGlmKCFoZWxwZXJzLmd1YXJhbnRlZUlzRGVmaW5lZChzY3ApKSB0aHJvdyAnVGhlICRzY29wZSBwYXNzZWQgZm9yIHBvcHVsYXRlU2NvcGUgd2FzblxcJ3QgZGVmaW5lZCc7XG5cdFx0XHRcdGlmKCFoZWxwZXJzLmd1YXJhbnRlZUlzRGVmaW5lZChpZCkpIHRocm93ICdUaGUgaWRlbnRpZmllciBmb3IgcG9wdWxhdGVTY29wZSBtdXN0IGJlIHBhc3NlZCc7XG5cdFx0XHRcdGlmKCFoZWxwZXJzLmd1YXJhbnRlZUlzRGVmaW5lZChjb25maWcpKSB0aHJvdyAnVGhlIGNvbmZpZ3VyYXRpb24gZm9yIHBvcHVsYXRlU2NvcGUgbXVzdCBiZSBwYXNzZWQnO1xuXHRcdFx0XHRpZighaGVscGVycy5ndWFyYW50ZWVJc0RlZmluZWQoc3ZjKSkgdGhyb3cgJ1RoZSBzZXJ2aWNlIGZvciBwb3B1bGF0ZVNjb3BlIG11c3QgYmUgcGFzc2VkJztcblx0XHRcdFx0aWYoY29uZmlnc1tjb25maWddKXtcblx0XHRcdFx0XHRzY3BbaWRdID0ge307XG5cdFx0XHRcdFx0c2NwW2lkXS5jb250ZW50ID0ge307XG5cdFx0XHRcdFx0dmFyIGNvbmZpZ3VyYXRpb24gPSBjb25maWdzW2NvbmZpZ107XG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGNvbmZpZ3VyYXRpb24pIGlmKGNvbmZpZ3VyYXRpb24uaGFzT3duUHJvcGVydHkoa2V5KSl7XG5cdFx0XHRcdFx0XHRtZXRob2RzW2tleV0oc2NwLHN2YyxpZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0JGdldDogZnVuY3Rpb24oKXtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGFuZ3VsYXIubW9kdWxlKCdndW1nYS5zZXJ2aWNlcy5wb3B1bGF0ZScsW10pXG5cdC5wcm92aWRlcignJHBvcHVsYXRlJyxQb3B1bGF0ZSlcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdEJhc2UuJGluamVjdCA9IFtcIiRodHRwXCIsIFwiJHFcIl07XG5cdC8qKlxuXHQgKiBAbmdkb2Mgc2VydmljZVxuXHQgKiBAbmFtZSBndW1nYS5jb3JlOkd1bWdhUmVzdFxuXHQgKiBAZGVzY3JpcHRpb25cblx0ICogXHRPIHNlcnZpY2UgR3VtZ2FSZXN0IMOpIHVtYSBldm9sdcOnw6NvIGRvIHNlcnZpY2Uge0BsaW5rIGd1bWdhLmNvcmU6R3VtZ2FCYXNlfSwgcG9pcyBzdWEgY29uZmlndXJhw6fDo28gbsOjbyBuZWNlc3NpdGFcblx0ICogXHRkZSBuZW5odW1hIG91dHJhIGNvbmZpZ3VyYcOnw6NvIGFkaWNpb25hbCBubyBzZXJ2aWNlIHF1ZSBpcsOhIGNoYW3DoS1sby5cblx0ICpcblx0ICogIyMgRXhlbXBsb1xuXHQgKiA8cHJlPlxuXHQgKiBhbmd1bGFyLm1vZHVsZSgnc2FtcGxlJyxbJ2d1bWdhLmNvcmUnXSlcblx0ICogLnNlcnZpY2UoJ0d1bWdhUmVzdCcsZnVuY3Rpb24oR3VtZ2FSZXN0KXtcblx0ICogXHQgICAvL0V4ZW1wbG8gZGUgdXRpbGl6YcOnw6NvLlxuXHQgKiBcdCAgIHZhciBzZXJ2aWNlID0gbmV3IEd1bWdhUmVzdCgnaHR0cDovL3d3dy5ndW1nYS5jb20uYnIvYXBpJyk7XG5cdCAqICAgICAvLyBPdSwgY2FzbyBuw6NvIHF1ZWlyYSBhZGljaW9uYXIgbmVuaHVtIG3DqXRvZG8sIHV0aWxpemFyOlxuXHQgKiAgICAgLy8gcmV0dXJuIG5ldyBHdW1nYVJlc3QoJ2h0dHA6Ly93d3cuZ3VtZ2EuY29tLmJyL2FwaScpO1xuXHQgKlxuXHQgKlx0ICAgc2VydmljZS5nZXQgPSBmdW5jdGlvbihwYWdlKXtcblx0ICpcdCAgICAgICBhbGVydCgnTW9kaWZpcXVlaSB1bSBtw6l0b2RvIGRhIHNlcnZpY2UgZSBjaGFtZWkgbyBwYWRyw6NvIScpO1xuXHQgKlx0XHQgICAgIHJldHVybiBHdW1nYVJlc3QucHJvdG90eXBlLmdldC5jYWxsKHRoaXMscGFnZSk7XG5cdCAqXHQgICB9XG5cdCAqIFx0ICAgcmV0dXJuIHNlcnZpY2U7XG5cdCAqIH0pXG5cdCAqIDwvcHJlPlxuXHQgKlxuXHQgKiAjIE3DqXRvZG9zXG5cdCAqXG5cdCAqICBgR3VtZ2FSZXN0LmdldChwYXJhbXMpYFxuXHQgKlxuXHQgKiAgTyBtw6l0b2RvIGdldCBhY2VpdGEgdW0gcGFyw6JtZXRybyBgdXJsYCBlIHJldG9ybmEgdW1hIHByb21pc2UgZGUgdW1hIGNoYW1hZGEgSFRUUCBkbyB0aXBvIEdFVC5cblx0ICpcblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+T2JqZWN0PC9sYWJlbD4gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPnBhcmFtczwvbGFiZWw+IFBhcsOibWV0cm9zIGRhIHF1ZXJ5IHF1ZSBzZXLDoSBmZWl0YS5cblx0ICogICMjIyBSZXRvcm5vXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5IdHRwUHJvbWlzZTwvbGFiZWw+IFJldG9uYSB1bWEgcHJvbWlzZSBkYSBjaGFtYWRhIEhUVFAgR0VULlxuXHQgKiAgLS0tXG5cdCAqICBgR3VtZ2FSZXN0LnJlc2V0QW5kR2V0KClgXG5cdCAqXG5cdCAqICBPIG3DqXRvZG8gcmVzZXRBbmRHZXQgcmVzZXRhIGEgcXVlcnkgYXR1YWwgZSBwZXJmb3JtYSB1bWEgY2hhbWFkYSBIVFRQIGRvIHRpcG8gR0VULlxuXHQgKlxuXHQgKiAgIyMjIFJldG9ybm9cblx0ICpcblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPkh0dHBQcm9taXNlPC9sYWJlbD4gUmV0b3JuYSB1bWEgcHJvbWlzZSBkYSBjaGFtYWRhIEhUVFAgR0VULlxuXHQgKlxuXHQgKiBcdC0tLVxuXHQgKlxuIFx0ICogIGBHdW1nYVJlc3QuZ2V0QnlJZChpZClgXG5cdCAqXG5cdCAqICBPIG3DqXRvZG8gZ2V0QnlJZCBhY2VpdGEgdW0gcGFyw6JtZXRybyBgaWRgIGUgcmV0b3JuYSB1bWEgcHJvbWlzZSBkZSB1bWEgY2hhbWFkYSBIVFRQIGRvIHRpcG8gR0VULlxuXHQgKiAgIyMjIFBhcsOibWV0cm9zXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5bU3RyaW5nfE51bWJlcl08L2xhYmVsPiA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+aWQ8L2xhYmVsPiBJZGVudGlmaWNhZG9yIGRvIHJlZ2lzdHJvIHF1ZSBzZXLDoSBidXNjYWRvLlxuXHQgKiAgIyMjIFJldG9ybm9cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPkh0dHBQcm9taXNlPC9sYWJlbD4gUmV0b25hIHVtYSBwcm9taXNlIGRhIGNoYW1hZGEgSFRUUCBHRVQuXG5cdCAqICAtLS1cblx0ICogIGBHdW1nYVJlc3QuZ2V0TmV3KClgXG5cdCAqXG5cdCAqICBPIG3DqXRvZG8gZ2V0QnlJZCAgcmV0b3JuYSB1bWEgcHJvbWlzZSBkZSB1bWEgY2hhbWFkYSBIVFRQIGRvIHRpcG8gR0VULlxuXHQgKiAgIyMjIFJldG9ybm9cblx0ICpcblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPkh0dHBQcm9taXNlPC9sYWJlbD4gUmV0b3JuYSB1bWEgcHJvbWlzZSBkYSBjaGFtYWRhIEhUVFAgR0VULlxuXHQgKlxuXHQgKiAgLS0tXG4gXHQgKiAgYEd1bWdhUmVzdC5kZWxldGUoZGF0YSlgXG5cdCAqXG5cdCAqICBPIG3DqXRvZG8gZGVsZXRlIHJlY2ViZSBjb21vIHBhcsOibWV0cm8gdW0gb2JqZXRvIHF1ZSBzZXLDoSBkZWxldGFkby4gTyBvYmpldG8gZGV2ZSB0ZXIgdW0gcGFyw6JtZXRybyBJRCxcblx0ICogIHF1ZSBzZXLDoSBwYXNzYWRvIHBhcmEgYSB1cmwgZGEgY2hhbWFkYS5cblx0ICpcbiBcdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPk9iamVjdDwvbGFiZWw+IDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5kYXRhPC9sYWJlbD4gUmVnaXN0cm8gcXVlIHNlcsOhIGRlbGV0YWRvLlxuXHQgKlxuXHQgKiAgIyMjIFJldG9ybm9cblx0ICpcblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPkh0dHBQcm9taXNlPC9sYWJlbD4gUmV0b3JuYSB1bWEgcHJvbWlzZSBkYSBjaGFtYWRhIEhUVFAgREVMRVRFLlxuXHQgKlxuXHQgKiAgLS0tXG5cdCAqXG4gXHQgKiAgYEd1bWdhUmVzdC5zb3J0KGZpZWxkLHdheSlgXG5cdCAqXG5cdCAqIE8gbcOpdG9kbyBzb3J0IHJlY2ViZSBkb2lzIHBhcsOibWV0cm9zIHBhcmEgZmF6ZXIgYSBvcmRlbmHDp8OjbzogYGZpZWxkYCBlIGB3YXlgLCBxdWUgZGV0ZXJtaW5hcsOjbyBxdWFsIGNhbXBvIHNlcsOhIG9yZGVuYWRvXG5cdCAqIGUgc2Ugc2Vyw6EgJ2FzYycgb3UgJ2Rlc2MnLlxuXHQgKlxuIFx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD4gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmZpZWxkPC9sYWJlbD4gUXVhbCBjYW1wbyBzZXLDoSBmZWl0YSBhIG9yZGVuYcOnw6NvXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPiA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+d2F5PC9sYWJlbD4gRW0gcXVlIHNlbnRpZG8gYSBvcmRlbmHDp8OjbyBzZXLDoSBmZWl0YSwgc2Ugc2Vyw6EgYXNjZW5kZW50ZSBgYXNjYCBvdSBkZXNjZW5kZW50ZSBgZGVzY2AuXG5cdCAqICAjIyMgUmV0b3Jub1xuXHQgKlxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+SHR0cFByb21pc2U8L2xhYmVsPiBSZXRvcm5hIHVtYSBwcm9taXNlIGRhIGNoYW1hZGEgSFRUUCBHRVQuXG5cdCAqXG5cdCAqICAtLS1cblx0ICpcblx0ICogIGBHdW1nYVJlc3QuZGVsZXRlQ29sbGVjdGlvbihhcnJheSlgXG5cdCAqXG5cdCAqICBPIG3DqXRvZG8gZGVsZXRlQWxsIGFjZWl0YSB1bSBwYXLDom1ldHJvIGB1cmxgICBlIHJldG9ybmEgdW1hIHByb21pc2UgZGUgdW1hIHPDqXJpZSBkZSBjaGFtYWRhcyBodHRwIGRvIHRpcG8gREVMRVRFIHF1ZSBzZXLDo28gcmVzb2x2aWRhcyBhbyBtZXNtbyB0ZW1wby5cblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+QXJyYXk8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5hcnJheTwvbGFiZWw+IEFycmF5IGNvbSB0b2RhcyBvcyByZWdpc3Ryb3MgcXVlIHNlcsOjbyBkZWxldGFkb3Ncblx0ICogICMjIyBSZXRvcm5vXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5IdHRwUHJvbWlzZTwvbGFiZWw+IFJldG9ybmEgdW1hIHByb21pc2UgYXDDs3MgdG9kYXMgYXMgY2hhbWFkYXMgdGVyZW0gc2lkbyByZXNvbHZpZGFzLlxuXHQgKiAgLS0tXG5cdCAqXG4gXHQgKiAgYEd1bWdhUmVzdC5zYXZlSW1hZ2UoYXR0cmlidXRlLGRhdGEpYFxuXHQgKlxuXHQgKiAgTyBtw6l0b2RvIHNhdmVJbWFnZSBhY2VpdGEgZG9pcyBwYXLDom1ldHJvcyBgYXR0cmlidXRlYCBlIGBkYXRhYCBlIHJldG9ybmEgdW1hIHByb21pc2UgZGUgZGUgdW1hIGNoYW1hZGEgSFRUUCBQT1NUIEZPUk0tREFUQS5cblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+YXR0cmlidXRlPC9sYWJlbD4gQXRyaWJ1dG8gbm8gcXVhbCBhIGltYWdlbSBzZXLDoSBmZWl0byBvXG5cdCAqICBiaW5kIGFww7NzIG8gZm9ybSB0ZXIgc2lkbyBlbnZpYWRvIGNvbXBsZXRvLlxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+T2JqZWN0PC9sYWJlbD48bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+ZGF0YTwvbGFiZWw+IERhZG9zIGRhIGltYWdlbSBxdWUgZm9pIHNlbGVjaW9uYWRhLi5cblx0ICogICMjIyBSZXRvcm5vXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5IdHRwUHJvbWlzZTwvbGFiZWw+IFJldG9ybmEgdW1hIHByb21pc2UgZGEgY2hhbWFkYSBIVFRQIFBPU1QuIE5lc3RhIHByb21pc2UsIHNlcsOhIHJldG9ybmFkbyBvIHZhbG9yIGRlIHVtYSBTdHJpbmcgcXVlIGRldmVyw6Egc2VyIGF0cmlidcOtZGEgYW8gYXRyaWJ1dG9cblx0ICogIG9uZGUgZXN0YXZhIGEgaW1hZ2VtLiBFc3RhIHN0cmluZyDDqSB1bSBpZGVudGlmaWNhZG9yIHBhcmEgcXVhbmRvIG8gcmVnaXN0cm8gZm9yIGVudmlhZG8gYXRyYXbDqXMgZGUgdW0gcG9zdC5cblx0ICogIC0tLVxuIFx0ICogIGBHdW1nYVJlc3QuZGVsZXRlSW1hZ2UoYXR0cmlidXRlLGRhdGEpYFxuXHQgKlxuXHQgKiAgTyBtw6l0b2RvIGRlbGV0ZUltYWdlIGFjZWl0YSBkb2lzIHBhcsOibWV0cm9zIGB1cmxgIGUgYGRhdGFgIGUgcmV0b3JuYSB1bWEgcHJvbWlzZSBkZSBkZSB1bWEgY2hhbWFkYSBIVFRQIERFTEVURSBGT1JNLURBVEEuXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmF0dHJpYnV0ZTwvbGFiZWw+IEF0cmlidXRvIG5vIHF1YWwgYSBpbWFnZW0gc2Vyw6EgZmVpdG8gb1xuXHQgKiAgYmluZCBhcMOzcyBvIGZvcm0gdGVyIHNpZG8gZW52aWFkbyBjb21wbGV0by5cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPk9iamVjdDwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmRhdGE8L2xhYmVsPiBEYWRvcyBkYSBpbWFnZW0gcXVlIGZvaSBzZWxlY2lvbmFkYS5cblx0ICogICMjIyBSZXRvcm5vXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5IdHRwUHJvbWlzZTwvbGFiZWw+IFJldG9ybmEgdW1hIHByb21pc2UgZGEgY2hhbWFkYSBIVFRQIERFTEVURS5cblx0ICogIC0tLVxuIFx0ICpcbiBcdCAqICBgR3VtZ2FSZXN0LmdldFNlYXJjaChmaWVsZCxwYXJhbSlgXG5cdCAqXG5cdCAqICBPIG3DqXRvZG8gZ2V0U2VhcmNoIGFjZWl0YSBkb2lzIHBhcsOibWV0cm9zIGBmaWVsZGAgZSBgcGFyYW1gIGUgcmV0b3JuYSB1bWEgcHJvbWlzZSBkZSB1bWEgY2hhbWFkYSBIVFRQIGRvIHRpcG8gR0VULlxuXHQgKiAgIyMjIFBhcsOibWV0cm9zXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5bU3RyaW5nXTwvbGFiZWw+IDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5maWVsZDwvbGFiZWw+IFF1YWwgY2FtcG8gYSBidXNjYSBzZXLDoSBmZWl0YS4gQ2Fzb1xuXHQgKiAgcXVlaXJhIGZhemVyIGEgYnVzY2EgZW0gbWFpcyBkZSB1bSBjYW1wbywgcGFzc2FyIHVtYSBzdHJpbmcgY29tIG9zIG5vbWVzIHNlcGFyYWRvcyBwb3IgdsOtcmd1bGEuXG4gXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+W09iamVjdF08L2xhYmVsPiA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+cGFyYW08L2xhYmVsPiBPYmpldG8gcXVlIGlyw6EgY29udGVyIG9zIHBhcsOibWV0cm9zXG4gXHQgKiAgZGEgYnVzY2EuXG5cdCAqICAjIyMgUmV0b3Jub1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+SHR0cFByb21pc2U8L2xhYmVsPiBSZXRvbmEgdW1hIHByb21pc2UgZGEgY2hhbWFkYSBIVFRQIEdFVC5cblx0ICogIC0tLVxuXHQgKlxuIFx0ICogIGBHdW1nYVJlc3QuZ2V0QWR2YW5jZWRTZWFyY2gocGFyYW0pYFxuXHQgKlxuXHQgKiAgTyBtw6l0b2RvIGdldEFkdmFuY2VkU2VhcmNoIGFjZWl0YSB1bSBwYXLDom1ldHJvIGBwYXJhbWAgZSByZXRvcm5hIHVtYSBwcm9taXNlIGRlIHVtYSBjaGFtYWRhIEhUVFAgZG8gdGlwbyBHRVQuXG5cdCAqICAjIyMgUGFyw6JtZXRyb3NcbiBcdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5bT2JqZWN0XTwvbGFiZWw+IDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5wYXJhbTwvbGFiZWw+IE9iamV0byBxdWUgaXLDoSBjb250ZXIgb3MgcGFyw6JtZXRyb3NcbiBcdCAqICBkYSBidXNjYS5cblx0ICogICMjIyBSZXRvcm5vXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5IdHRwUHJvbWlzZTwvbGFiZWw+IFJldG9uYSB1bWEgcHJvbWlzZSBkYSBjaGFtYWRhIEhUVFAgR0VULlxuXHQgKiAgLS0tXG4gICAqXG4gXHQgKiAgYEd1bWdhUmVzdC5yZXNldERlZmF1bHRTdGF0ZSgpYFxuXHQgKlxuXHQgKiAgTyBtw6l0b2RvIHJlc2V0RGVmYXVsdFN0YXRlIHJldG9ybmEgbyBvYmpldG8gZGUgcXVlcnkgYW8gc2V1IGVzdGFkbyBwYWRyw6NvLlxuXHQgKlxuXHQgKiAgLS0tXG5cdCAqXG5cdCAqICBgR3VtZ2FSZXN0LnNhdmVRdWVyeShxdWVyeSlgXG5cdCAqXG5cdCAqICBPIG3DqXRvZG8gc2F2ZVF1ZXJ5IGFjZWl0YSB1bSBwYXLDom1ldHJvIGBxdWVyeWAgZSByZXRvcm5hIHVtYSBwcm9taXNlIGRlIHVtYSBjaGFtYWRhIEhUVFAgZG8gdGlwbyBQT1NULlxuXHQgKiAgIyMjIFBhcsOibWV0cm9zXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5bT2JqZWN0XTwvbGFiZWw+IDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5xdWVyeTwvbGFiZWw+IE9iamV0byBxdWUgaXLDoSBjb250ZXIgdHLDqnMgYXRyaWJ1dG9zIG5lY2Vzc8Ohcmlvc1xuXHQgKiAgcGFyYSBzYWx2YXIgYSBxdWVyeS4gT3MgYXRyaWJ1dG9zIHPDo286IGBwYWdlYCwgYGRhdGFgIGUgYG5hbWVgLiBPbmRlIGBwYWdlYCDDqSBvIG5vbWUgZGEgcMOhZ2luYSBhdHVhbCwgYGRhdGFgIMOpIGEgYnVzY2EgZSBgbmFtZWAgw6kgbyBub21lIGRhIHF1ZXJ5IGEgc2VyIHNhbHZhLlxuXHQgKiAgIyMjIFJldG9ybm9cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPkh0dHBQcm9taXNlPC9sYWJlbD4gUmV0b25hIHVtYSBwcm9taXNlIGRhIGNoYW1hZGEgSFRUUCBQT1NULlxuXHQgKiAgLS0tXG5cdCAqXG5cdCAqICBgR3VtZ2FSZXN0LmdldFF1ZXJ5KHBhZ2UpYFxuXHQgKlxuXHQgKiAgTyBtw6l0b2RvIGdldFF1ZXJ5IGFjZWl0YSB1bSBwYXLDom1ldHJvIGBwYWdlYCBlIHJldG9ybmEgdW1hIHByb21pc2UgZGUgdW1hIGNoYW1hZGEgSFRUUCBkbyB0aXBvIEdFVC4gRXN0ZSBQYXLDom1ldHJvIGBwYWdlYCDDqSBvIHZhbG9yIGRlIHJldG9ybm8gZG8gb2JqZXRvIGBsb2NhdGlvbi5oYXNoYCBkaXNwb27DrXZlbFxuXHQgKiAgYXRyYXbDqXMgZG8gYnJvd3Nlci4gRXhlbXBsbzogYEd1bWdhUmVzdC5nZXRRdWVyeShsb2NhdGlvbi5oYXNoKTtgLiDDiSBuZWNlc3PDoXJpbyBlc3RlIGF0cmlidXRvIHBhcmEgcGVnYXIgYXBlbmFzIGFzIHF1ZXJpZXMgcmVsYWNpb25hZGFzIGEgcMOhZ2luYS4gQXMgaW5mb3JtYcOnw7VlcyBkbyB1c3XDoXJpbyBqw6Egc8Ojb1xuXHQgKiAgcGFzc2FkYXMgYXRyYXbDqXMgZG8gdG9rZW4uXG5cdCAqICAjIyMgUGFyw6JtZXRyb3Ncblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPltTdHJpbmddPC9sYWJlbD4gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPnBhZ2U8L2xhYmVsPiBTdHJpbmcgcXVlIHNlcsOhIHV0aWxpemFkYSBwYXJhIGZhemVyIGEgcGVzcXVpc2EgZGFzXG5cdCAqICBxdWVyaWVzIHJlbGFjaW9uYWRhcyBjb20gYSBww6FnaW5hLlxuXHQgKiAgIyMjIFJldG9ybm9cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPkh0dHBQcm9taXNlPC9sYWJlbD4gUmV0b25hIHVtYSBwcm9taXNlIGRhIGNoYW1hZGEgSFRUUCBHRVQuXG5cdCAqICAtLS1cblx0ICovXG5cdGZ1bmN0aW9uIEJhc2UoJGh0dHAsJHEpe1xuXHRcdGZ1bmN0aW9uIFJlc3RQcm90b3R5cGUodXJsKXtcblx0XHRcdHRoaXMuX3VybCA9IHVybDtcblx0XHRcdHRoaXMuX3F1ZXJ5ID0ge3BhcmFtczoge3N0YXJ0OiAwLHBhZ2VTaXplOiAxMH19O1xuXHRcdH1cblx0XHRSZXN0UHJvdG90eXBlLnByb3RvdHlwZS5nZXQgPSBfZ2V0O1xuXHRcdFJlc3RQcm90b3R5cGUucHJvdG90eXBlLnJlc2V0QW5kR2V0ID0gX3Jlc2V0QW5kR2V0O1xuXHRcdFJlc3RQcm90b3R5cGUucHJvdG90eXBlLmdldE5ldyA9IF9nZXROZXc7XG5cdFx0UmVzdFByb3RvdHlwZS5wcm90b3R5cGUuZ2V0QnlJZCA9IF9nZXRCeUlkO1xuXHRcdFJlc3RQcm90b3R5cGUucHJvdG90eXBlLnNhdmUgPSBfc2F2ZTtcblx0XHRSZXN0UHJvdG90eXBlLnByb3RvdHlwZS51cGRhdGU9IF91cGRhdGU7XG5cdFx0UmVzdFByb3RvdHlwZS5wcm90b3R5cGUuZGVsZXRlID0gX2RlbGV0ZTtcblx0XHRSZXN0UHJvdG90eXBlLnByb3RvdHlwZS5zb3J0ID0gX3NvcnQ7XG5cdFx0UmVzdFByb3RvdHlwZS5wcm90b3R5cGUuZGVsZXRlQ29sbGVjdGlvbiA9IF9kZWxldGVDb2xsZWN0aW9uO1xuXHRcdFJlc3RQcm90b3R5cGUucHJvdG90eXBlLnNhdmVJbWFnZSA9IF9zYXZlSW1hZ2U7XG5cdFx0UmVzdFByb3RvdHlwZS5wcm90b3R5cGUuZGVsZXRlSW1hZ2UgPSBfZGVsZXRlSW1hZ2U7XG5cdFx0UmVzdFByb3RvdHlwZS5wcm90b3R5cGUuZ2V0U2VhcmNoID0gX2dldFNlYXJjaDtcblx0XHRSZXN0UHJvdG90eXBlLnByb3RvdHlwZS5nZXRBZHZhbmNlZFNlYXJjaCA9IF9nZXRBZHZhbmNlZFNlYXJjaDtcblx0XHRSZXN0UHJvdG90eXBlLnByb3RvdHlwZS5yZXNldERlZmF1bHRTdGF0ZSA9IF9yZXNldFF1ZXJ5O1xuXHRcdFJlc3RQcm90b3R5cGUucHJvdG90eXBlLnNhdmVRdWVyeSA9IF9zYXZlUXVlcnk7XG5cdFx0UmVzdFByb3RvdHlwZS5wcm90b3R5cGUuZ2V0UXVlcnkgPSBfZ2V0UXVlcnk7XG5cdFx0ZnVuY3Rpb24gX2dldChwYWdlKXtcblx0XHRcdGlmIChwYWdlKSB7XG5cdFx0XHRcdHRoaXMuX3F1ZXJ5LnBhcmFtcy5zdGFydCA9IChwYWdlIC0gMSkgKiB0aGlzLl9xdWVyeS5wYXJhbXMucGFnZVNpemU7XG5cdFx0XHRcdGlmIChwYWdlIDwgMSkgdGhyb3cgJ0ludmFsaWQgcGFnZSc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJGh0dHAuZ2V0KHRoaXMuX3VybCx0aGlzLl9xdWVyeSk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIF9nZXROZXcgKCkge3JldHVybiAkaHR0cC5nZXQodGhpcy5fdXJsICsgJy9uZXcnKX1cblx0XHRmdW5jdGlvbiBfZ2V0QnlJZChpZCl7cmV0dXJuICRodHRwLmdldCh0aGlzLl91cmwgKyAnLycgKyBpZCk7fVxuXHRcdGZ1bmN0aW9uIF9zYXZlICh2KXtyZXR1cm4gJGh0dHAucG9zdCh0aGlzLl91cmwsdik7fVxuXHRcdGZ1bmN0aW9uIF91cGRhdGUgKHYpe1xuXHRcdFx0aWYodi5pZCl7XG5cdFx0XHRcdHJldHVybiAkaHR0cC5wdXQodGhpcy5fdXJsICsgJy8nICsgdi5pZCAsdik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5zYXZlKHYpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBfZGVsZXRlKHYpe3JldHVybiAkaHR0cC5kZWxldGUodGhpcy5fdXJsICsgJy8nICsgdi5pZCk7fVxuXHRcdGZ1bmN0aW9uIF9yZXNldFF1ZXJ5KCl7dGhpcy5fcXVlcnkgPSB7cGFyYW1zOiB7c3RhcnQ6IDAscGFnZVNpemU6IDEwfX07fVxuXG5cdFx0ZnVuY3Rpb24gX3Jlc2V0QW5kR2V0KCl7XG5cdFx0XHR0aGlzLnJlc2V0RGVmYXVsdFN0YXRlKCk7XG5cdFx0XHRyZXR1cm4gJGh0dHAuZ2V0KHRoaXMuX3VybCx0aGlzLl9xdWVyeSk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIF9zb3J0KGYsdyl7XG5cdFx0XHR0aGlzLnJlc2V0RGVmYXVsdFN0YXRlKCk7XG5cdFx0XHR0aGlzLl9xdWVyeS5wYXJhbXMuc29ydEZpZWxkID0gZjtcblx0XHRcdHRoaXMuX3F1ZXJ5LnBhcmFtcy5zb3J0RGlyID0gdztcblx0XHRcdHJldHVybiAkaHR0cC5nZXQodGhpcy5fdXJsLHRoaXMuX3F1ZXJ5KTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gX2RlbGV0ZUNvbGxlY3Rpb24oYXJyKXtcblx0XHRcdHZhciB1cmwgPSB0aGlzLl91cmw7XG5cdFx0XHRyZXR1cm4gJHEuYWxsKGFyci5tYXAoZnVuY3Rpb24odil7XG5cdFx0XHRcdHJldHVybiAkaHR0cC5kZWxldGUodXJsICsgJy8nICsgdi5pZCk7XG5cdFx0XHR9KSlcblx0XHR9XG5cdFx0ZnVuY3Rpb24gX3NhdmVJbWFnZShhLG0pe1xuXHRcdFx0dmFyIGZkID0gbmV3IEZvcm1EYXRhKCk7XG5cdFx0XHRmZC5hcHBlbmQoYSxtKTtcblx0XHRcdHJldHVybiAkaHR0cC5wb3N0KHRoaXMuX3VybCArICcvJyArYSArICcvJyxmZCx7XG5cdFx0XHRcdHRyYW5zZm9ybVJlcXVlc3Q6IGFuZ3VsYXIuaWRlbnRpdHksXG5cdFx0XHRcdGhlYWRlcnM6IHsnQ29udGVudC1UeXBlJzogdW5kZWZpbmVkfVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIF9kZWxldGVJbWFnZShhKXtcblx0XHRcdHZhciBmZCA9IG5ldyBGb3JtRGF0YSgpO1xuXHRcdFx0ZmQuYXBwZW5kKGEse30pO1xuXHRcdFx0cmV0dXJuICRodHRwLmRlbGV0ZSh0aGlzLl91cmwgKyAnLycgK2EsZmQse1xuXHRcdFx0XHR0cmFuc2Zvcm1SZXF1ZXN0OiBhbmd1bGFyLmlkZW50aXR5LFxuXHRcdFx0XHRoZWFkZXJzOiB7J0NvbnRlbnQtVHlwZSc6IHVuZGVmaW5lZH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBfZ2V0U2VhcmNoKGYscCl7XG5cdFx0XHR0aGlzLnJlc2V0RGVmYXVsdFN0YXRlKCk7XG5cdFx0XHQoIXApID8gIHAgPSAnJyA6IGFuZ3VsYXIubm9vcDtcblx0XHRcdHRoaXMuX3F1ZXJ5LnBhcmFtcy5xID0gcDtcblx0XHRcdHRoaXMuX3F1ZXJ5LnBhcmFtcy5zZWFyY2hGaWVsZHMgPSBmO1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIF9nZXRBZHZhbmNlZFNlYXJjaChwKXtcblx0XHRcdGlmKHR5cGVvZiBwID09PSAnc3RyaW5nJyl7XG5cdFx0XHRcdHRoaXMuX3F1ZXJ5LnBhcmFtcyA9IHt9XG5cdFx0XHRcdHRoaXMuX3F1ZXJ5LnBhcmFtcy5hcSA9IHA7XG5cdFx0XHRcdHJldHVybiAkaHR0cC5nZXQodGhpcy5fdXJsLHRoaXMuX3F1ZXJ5KTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3F1ZXJ5LnBhcmFtcyA9IHt9O1xuXHRcdFx0dGhpcy5fcXVlcnkucGFyYW1zLmFxID0gcC5ocWw7XG5cdFx0XHR0aGlzLl9xdWVyeS5wYXJhbXMuYXFvID0gSlNPTi5zdHJpbmdpZnkocC5zb3VyY2UpO1xuXHRcdFx0cmV0dXJuICRodHRwLmdldCh0aGlzLl91cmwsdGhpcy5fcXVlcnkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIF9zYXZlUXVlcnkocSl7XG5cdFx0XHR2YXIgX2F1eCA9IHtcblx0XHRcdFx0cGFnZTogbG9jYXRpb24uaGFzaC5yZXBsYWNlKCcjJywnJykucmVwbGFjZSgvXFwvL2dpLCdfJyksXG5cdFx0XHRcdGRhdGE6IEpTT04uc3RyaW5naWZ5KHEucXVlcnkpLFxuXHRcdFx0XHRuYW1lOiBxLm5hbWVcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gJGh0dHAucG9zdCh0aGlzLl91cmwgKyAnL3NhcScsX2F1eCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gX2dldFF1ZXJ5KHBhZ2Upe1xuXHRcdFx0XHRyZXR1cm4gJGh0dHAuZ2V0KHRoaXMuX3VybCArICcvZ3VtZ2F1c2VyZGF0YS9hcTsnICsgcGFnZS5yZXBsYWNlKCcjJywnJykucmVwbGFjZSgvXFwvL2dpLCdfJykpO1xuXHRcdH1cblx0XHRyZXR1cm4gUmVzdFByb3RvdHlwZTtcblx0fVxuXG5cdGFuZ3VsYXIubW9kdWxlKCdndW1nYS5zZXJ2aWNlcy5yZXN0JyxbXSlcblx0LnNlcnZpY2UoJ0d1bWdhUmVzdCcsQmFzZSk7XG5cbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXG5cblx0XHRUcmFuc2xhdGUuJGluamVjdD0gW107XG5cdFx0ZnVuY3Rpb24gVHJhbnNsYXRlKCl7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHQkZ2V0OiBbXCIkaHR0cFwiLCBmdW5jdGlvbigkaHR0cCl7XG5cdFx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0XHRcdCRodHRwLmdldCgnL2kxOG4vJytzZWxmLl9sYW5ndWFnZSArICcuanNvbicpXG5cdFx0XHRcdFx0XHQuc3VjY2VzcyhmdW5jdGlvbiBTdWNjZXNzR2V0KHZhbHVlcyl7XG5cdFx0XHRcdFx0XHRcdGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdHVU1HQScrIHNlbGYuX2xhbmd1YWdlLEpTT04uc3RyaW5naWZ5KHZhbHVlcykpO1xuXHRcdFx0XHRcdFx0XHRsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnR1VNR0FDdXJyZW50JyxzZWxmLl9sYW5ndWFnZSk7XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdHJldHVybiBzZWxmO1xuXHRcdFx0XHR9XSxcblx0XHRcdFx0c2V0TGFuZ3VhZ2U6IGZ1bmN0aW9uKGxhbmd1YWdlKXtcblx0XHRcdFx0XHRpZighbGFuZ3VhZ2UpIHRocm93ICdZb3UgbXVzdCBwYXNzIGEgbGFuZ3VhZ2UgdG8gR3VtZ2FUcmFuc2xhdGUnO1xuXHRcdFx0XHRcdHRoaXMuX2xhbmd1YWdlLnRvTG93ZXJDYXNlKCkgIT09IGxhbmd1YWdlLnRvTG93ZXJDYXNlKCkgPyB0aGlzLl9sYW5ndWFnZSA9IGxhbmd1YWdlIDogZnVuY3Rpb24oKXt9O1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRfbGFuZ3VhZ2U6ICdwdC1icidcblx0XHRcdH1cblx0XHR9XG5cblx0XHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2Euc2VydmljZXMudHJhbnNsYXRlJyxbJ2d1bWdhLnNlcnZpY2VzLnRyYW5zbGF0ZS5oZWxwZXInXSlcblx0XHQucHJvdmlkZXIoJyRndW1nYVRyYW5zbGF0ZScsVHJhbnNsYXRlKVxufSkoKTsiLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdFRyYW5zbGF0ZUhlbHBlci4kaW5qZWN0ID0gW107XG5cblx0ZnVuY3Rpb24gVHJhbnNsYXRlSGVscGVyKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRfdHJhbnNsYXRpb246IHt9LFxuXHRcdFx0X19nZXRGcm9tTG9jYWxTdG9yYWdlOiBmdW5jdGlvbigpe1xuXHRcdFx0XHR2YXIgbGFuZ3VhZ2UgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnR1VNR0FDdXJyZW50Jylcblx0XHRcdFx0LFx0XHRzZWxmID0gdGhpcztcblx0XHRcdFx0ZnVuY3Rpb24gaXRlcmF0ZShvYmosc3RyaW5nKXtcblx0XHRcdFx0XHRmb3IodmFyIGtleSBpbiBvYmopIGlmKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKXtcblx0XHRcdFx0XHRcdCh0eXBlb2Ygb2JqW2tleV0gPT0gJ29iamVjdCcpID8gXG5cdFx0XHRcdFx0XHRcdGl0ZXJhdGUob2JqW2tleV0sIHN0cmluZyArICcuJyArIGtleSkgOiBzZWxmLl90cmFuc2xhdGlvblsoc3RyaW5nICsgJy4nICsga2V5KS5zdWJzdHJpbmcoMSldID0gb2JqW2tleV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGxhbmd1YWdlICYmIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdHVU1HQScgKyBsYW5ndWFnZSkpe1xuXHRcdFx0XHRcdGl0ZXJhdGUoSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnR1VNR0EnICsgbGFuZ3VhZ2UpKSwnJyk7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VHJhbnNsYXRlOiBmdW5jdGlvbih0b1RyYW5zbGF0ZSl7XG5cdFx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNlbGYuX3RyYW5zbGF0aW9uKS5sZW5ndGggPT09IDApXG5cdFx0XHRcdFx0c2VsZi5fX2dldEZyb21Mb2NhbFN0b3JhZ2UoKTtcblx0XHRcdFx0aWYoIXRvVHJhbnNsYXRlIHx8IHR5cGVvZiB0b1RyYW5zbGF0ZSAhPSAnc3RyaW5nJykgIFxuXHRcdFx0XHRcdHRocm93ICdUaGUgdmFsdWUgcGFzc2VkIHRvIEd1bWdhVHJhbnNsYXRlIGlzIFdyb25nISc7XG5cdFx0XHRcdGlmKHNlbGYuX3RyYW5zbGF0aW9uW3RvVHJhbnNsYXRlXSlcblx0XHRcdFx0XHRyZXR1cm4gc2VsZi5fdHJhbnNsYXRpb25bdG9UcmFuc2xhdGVdO1xuXHRcdFx0XHRyZXR1cm4gdG9UcmFuc2xhdGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0YW5ndWxhci5tb2R1bGUoJ2d1bWdhLnNlcnZpY2VzLnRyYW5zbGF0ZS5oZWxwZXInLFtdKVxuXHQuZmFjdG9yeSgnR3VtZ2FUcmFuc2xhdGVIZWxwZXInLFRyYW5zbGF0ZUhlbHBlcilcblxufSkoKTsiLCIoZnVuY3Rpb24oKXtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIFV0aWxzLiRpbmplY3QgPSBbXTtcblxuICBmdW5jdGlvbiBVdGlscygpe1xuICAgIHJldHVybiB7XG4gICAgICBhcmVOb3RFcXVhbEluQXJyYXk6IGZ1bmN0aW9uIChhcnJheSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGF1eCA9IGFycmF5LmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50ID09IGluZGV4O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChhdXgubGVuZ3RoIDwgMSk7XG4gICAgICB9LFxuICAgICAgY2FtZWxDYXNlOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgMSkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxLCBzdHJpbmcubGVuZ3RoKTtcbiAgICAgIH0sXG4gICAgICBvYmpJbkFycmF5OiBmdW5jdGlvbiAoYXJyYXksIGZpZWxkKSB7XG4gICAgICAgIHZhciBhcnJheUF1eCA9IGFycmF5LmZpbHRlcihmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgcmV0dXJuIG9iai5maWVsZCA9PSBmaWVsZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhcnJheUF1eC5sZW5ndGggPiAwO1xuICAgICAgfSxcbiAgICAgIGNoZWNrSW5kZXg6IGZ1bmN0aW9uIChhcnJheSwgdHh0KSB7XG4gICAgICAgIHZhciBmbGFnID0gLTE7XG4gICAgICAgIGFycmF5LmZvckVhY2goZnVuY3Rpb24gKG9iaiwgaW5kZXgpIHtcbiAgICAgICAgICBpZiAob2JqLmZpZWxkID09IHR4dCkge1xuICAgICAgICAgICAgZmxhZyA9IGluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmbGFnO1xuICAgICAgfSxcbiAgICAgIGVycm9yTWVzc2FnZXM6IHtcbiAgICAgICAgbWF4OiBcIllvdSd2ZSB0eXBlZCBtb3JlIHRoYW4gdGhlIG1heGltdW0hXCIsXG4gICAgICAgIG1pbjogXCJZb3UndmUgdHlwZWQgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIVwiLFxuICAgICAgICByZXE6IFwiVGhpcyBmaWVsZCBpcyByZXF1aXJlZFwiXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFuZ3VsYXIubW9kdWxlKCdndW1nYS5zZXJ2aWNlcy51dGlscycsW10pXG4gIC5mYWN0b3J5KCdHdW1nYVV0aWxzJyxVdGlscyk7XG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRXZWJTdG9yYWdlLiRpbmplY3QgPSBbXTtcblx0LyoqXG5cdCAqIEBuZ2RvYyBzZXJ2aWNlXG5cdCAqIEBuYW1lIGd1bWdhLmNvcmU6R3VtZ2FXZWJTdG9yYWdlXG5cdCAqIEBkZXNjcmlwdGlvbiBcblx0ICogXG5cdCAqIFx0TyBzZXJ2aWNlIEd1bWdhV2ViU3RvcmFnZSDDqSB1dGlsaXphZG8gcGFyYSBhanVkYXIgbyBkZXNlbnZvbHZlZG9yIGEgdHJhYmFsaGFyIGNvbSBvIHN0b3JhZ2UgZG8gQnJvd3Nlci5cblx0ICpcblx0ICogXHQjTcOpdG9kb3Ncblx0ICpcblx0ICpcdC0tLVxuXHQgKiBcblx0ICogIGBHdW1nYVdlYlN0b3JhZ2Uuc2V0U2Vzc2lvblN0b3JhZ2VJdGVtKGtleSx2YWx1ZSlgXG5cdCAqICBcblx0ICogIE8gbcOpdG9kbyBzZXRTZXNzaW9uU3RvcmFnZUl0ZW0gYWNlaXRhIGRvaXMgcGFyw6JtZXRyb3MgYGtleWAgZSBgdmFsdWVgLlxuIFx0ICogIFxuXHQgKiAgIyMjIFBhcsOibWV0cm9zXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPiA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+a2V5PC9sYWJlbD4gUXVhbCBvIGlkZW50aWZpY2Fkb3IgZG8gdmFsb3IgcXVlIHNlcsOhIHNhbHZvLlxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+W1N0cmluZ3xOdW1iZXJ8T2JqZWN0XTwvbGFiZWw+IDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj52YWx1ZTwvbGFiZWw+IFZhbG9yIHF1ZSBzZXLDoSBzYWx2byBubyBzZXNzaW9uU3RvcmFnZS5cblx0ICogIC0tLVxuIFx0ICogXG5cdCAqICBgR3VtZ2FXZWJTdG9yYWdlLmdldFNlc3Npb25TdG9yYWdlSXRlbShrZXkpYFxuXHQgKiAgXG5cdCAqICBPIG3DqXRvZG8gc2V0U2Vzc2lvblN0b3JhZ2VJdGVtIGFjZWl0YSB1bSBwYXLDom1ldHJvIGBrZXlgLlxuIFx0ICogIFxuXHQgKiAgIyMjIFBhcsOibWV0cm9zXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPiA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+a2V5PC9sYWJlbD4gUXVhbCBvIGlkZW50aWZpY2Fkb3IgZG8gdmFsb3IgcXVlIHNlcsOhIHNhbHZvLlxuXHQgKlxuXHQgKiAgIyMjIFJldG9ybm9cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPltTdHJpbmd8TnVtYmVyfE9iamVjdF08L2xhYmVsPiA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+a2V5PC9sYWJlbD4gUmV0b3JuYSBvIHZhbG9yIHF1ZSBlc3RpdmVyIG5hIHNlc3Npb25TdG9yYWdlIGRhcXVlbGEga2V5IGVzcGVjw61maWNhLiBDYXNvIG7Do28gZW5jb250cmUsXG5cdCAqICBvIHZhbG9yIHJldG9ybmFkbyDDqSBudWxsLlxuXHQgKiAgLS0tXG5cdCAqXG4gXHQgKiAgYEd1bWdhV2ViU3RvcmFnZS5yZW1vdmVTZXNzaW9uU3RvcmFnZUl0ZW0oa2V5KWBcblx0ICogIFxuXHQgKiAgTyBtw6l0b2RvIHJlbW92ZVNlc3Npb25TdG9yYWdlSXRlbSBhY2VpdGEgdW0gcGFyw6JtZXRybyBga2V5YC5cbiBcdCAqICBcblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD4gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmtleTwvbGFiZWw+IFF1YWwgbyBpZGVudGlmaWNhZG9yIGRvIHZhbG9yIHF1ZSBzZXLDoSByZW1vdmlkbyBkYSBzZXNzaW9uU3RvcmFnZS5cblx0ICpcblx0ICogIC0tLSBcblx0ICpcblx0ICogIGBHdW1nYVdlYlN0b3JhZ2UuY2xlYXJTZXNzaW9uU3RvcmFnZSgpYFxuXHQgKiAgXG5cdCAqICBPIG3DqXRvZG8gY2xlYXJTZXNzaW9uU3RvcmFnZSBuw6NvIGFjZWl0YSBuZW5odW0gcGFyw6JtZXRybyBlIGxpbXBhIGEgc2Vzc2lvblN0b3JhZ2UuXG4gXHQgKiAgXG5cdCAqICAtLS0gXG5cdCAqXG4gXHQgKlxuXHQgKiAgYEd1bWdhV2ViU3RvcmFnZS5nZXROdW1iZXJPZkl0ZW1zSW5TZXNzaW9uU3RvcmFnZSgpYFxuXHQgKiAgXG5cdCAqICBPIG3DqXRvZG8gZ2V0TnVtYmVyT2ZJdGVtc0luU2Vzc2lvblN0b3JhZ2UgbsOjbyBhY2VpdGEgbmVuaHVtIHBhcsOibWV0cm8sIGUgcmV0b3JuYSBvIG7Dum1lcm8gZGUgaXRlbnMgbm8gbG9jYWxTdG9yYWdlLlxuIFx0ICogIFxuXHQgKiAgLS0tIFxuXHQgKlxuIFx0ICogXG5cdCAqICBgR3VtZ2FXZWJTdG9yYWdlLnNldExvY2FsU3RvcmFnZUl0ZW0oa2V5LHZhbHVlKWBcblx0ICogIFxuXHQgKiAgTyBtw6l0b2RvIHNldExvY2FsU3RvcmFnZUl0ZW0gYWNlaXRhIGRvaXMgcGFyw6JtZXRyb3MgYGtleWAgZSBgdmFsdWVgLlxuIFx0ICogIFxuXHQgKiAgIyMjIFBhcsOibWV0cm9zXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPiA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+a2V5PC9sYWJlbD4gUXVhbCBvIGlkZW50aWZpY2Fkb3IgZG8gdmFsb3IgcXVlIHNlcsOhIHNhbHZvLlxuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+W1N0cmluZ3xOdW1iZXJ8T2JqZWN0XTwvbGFiZWw+IDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj52YWx1ZTwvbGFiZWw+IFZhbG9yIHF1ZSBzZXLDoSBzYWx2byBubyBMb2NhbFN0b3JhZ2UuXG5cdCAqICAtLS1cbiBcdCAqIFxuXHQgKiAgYEd1bWdhV2ViU3RvcmFnZS5nZXRMb2NhbFN0b3JhZ2VJdGVtKGtleSlgXG5cdCAqICBcblx0ICogIE8gbcOpdG9kbyBzZXRMb2NhbFN0b3JhZ2VJdGVtIGFjZWl0YSB1bSBwYXLDom1ldHJvIGBrZXlgLlxuIFx0ICogIFxuXHQgKiAgIyMjIFBhcsOibWV0cm9zXG5cdCAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPiA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+a2V5PC9sYWJlbD4gUXVhbCBvIGlkZW50aWZpY2Fkb3IgZG8gdmFsb3IgcXVlIHNlcsOhIHNhbHZvLlxuXHQgKlxuXHQgKiAgIyMjIFJldG9ybm9cblx0ICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPltTdHJpbmd8TnVtYmVyfE9iamVjdF08L2xhYmVsPiA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC1pbmZvXCI+a2V5PC9sYWJlbD4gUmV0b3JuYSBvIHZhbG9yIHF1ZSBlc3RpdmVyIG5hIExvY2FsU3RvcmFnZSBkYXF1ZWxhIGtleSBlc3BlY8OtZmljYS4gQ2FzbyBuw6NvIGVuY29udHJlLFxuXHQgKiAgbyB2YWxvciByZXRvcm5hZG8gw6kgbnVsbC5cblx0ICogIC0tLVxuXHQgKlxuIFx0ICogIGBHdW1nYVdlYlN0b3JhZ2UucmVtb3ZlTG9jYWxTdG9yYWdlSXRlbShrZXkpYFxuXHQgKiAgXG5cdCAqICBPIG3DqXRvZG8gcmVtb3ZlTG9jYWxTdG9yYWdlSXRlbSBhY2VpdGEgdW0gcGFyw6JtZXRybyBga2V5YC5cbiBcdCAqICBcblx0ICogICMjIyBQYXLDom1ldHJvc1xuXHQgKiAgLSA8bGFiZWwgY2xhc3M9XCJsYWJlbCBsYWJlbC13YXJuaW5nXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDElXCI+U3RyaW5nPC9sYWJlbD4gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmtleTwvbGFiZWw+IFF1YWwgbyBpZGVudGlmaWNhZG9yIGRvIHZhbG9yIHF1ZSBzZXLDoSByZW1vdmlkbyBkYSBMb2NhbFN0b3JhZ2UuXG5cdCAqXG5cdCAqICAtLS0gXG5cdCAqXG5cdCAqICBgR3VtZ2FXZWJTdG9yYWdlLmNsZWFyTG9jYWxTdG9yYWdlKClgXG5cdCAqICBcblx0ICogIE8gbcOpdG9kbyBjbGVhckxvY2FsU3RvcmFnZSBuw6NvIGFjZWl0YSBuZW5odW0gcGFyw6JtZXRybyBlIGxpbXBhIG8gbG9jYWxTdG9yYWdlLlxuIFx0ICogIFxuXHQgKiAgLS0tIFxuIFx0ICpcblx0ICogIGBHdW1nYVdlYlN0b3JhZ2UuZ2V0TnVtYmVyT2ZJdGVtc0luTG9jYWxTdG9yYWdlKClgXG5cdCAqICBcblx0ICogIE8gbcOpdG9kbyBnZXROdW1iZXJPZkl0ZW1zSW5Mb2NhbFN0b3JhZ2UgbsOjbyBhY2VpdGEgbmVuaHVtIHBhcsOibWV0cm8sIGUgcmV0b3JuYSBvIG7Dum1lcm8gZGUgaXRlbnMgbm8gbG9jYWxTdG9yYWdlLlxuIFx0ICogIFxuXHQgKiAgLS0tIFxuXHQgKi9cblx0ZnVuY3Rpb24gV2ViU3RvcmFnZSgpe1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZXRTZXNzaW9uU3RvcmFnZUl0ZW06IGZ1bmN0aW9uKGtleSx2YWx1ZSl7XG5cdFx0XHRcdHZhciBfdmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0aWYodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKXtcblx0XHRcdFx0XHRfdmFsdWUgPSBhbmd1bGFyLnRvSnNvbih2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0d2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oa2V5LF92YWx1ZSk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0U2Vzc2lvblN0b3JhZ2VJdGVtOiBmdW5jdGlvbihrZXkpe1xuXHRcdFx0XHR2YXIgZyA9IHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKGtleSk7XG5cdFx0XHRcdGlmKCFnKXtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGFuZ3VsYXIuZnJvbUpzb24oZyk7XG5cdFx0XHRcdH1jYXRjaChlKXtcblx0XHRcdFx0XHRyZXR1cm4gZztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gYW5ndWxhci5mcm9tSnNvbihnKTtcblx0XHRcdH0sXG5cdFx0XHRyZW1vdmVTZXNzaW9uU3RvcmFnZUl0ZW06IGZ1bmN0aW9uKGtleSl7XG5cdFx0XHRcdHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG5cdFx0XHR9LFxuXHRcdFx0Y2xlYXJTZXNzaW9uU3RvcmFnZTogZnVuY3Rpb24oKXtcblx0XHRcdFx0d2luZG93LnNlc3Npb25TdG9yYWdlLmNsZWFyKCk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0TnVtYmVyT2ZJdGVtc0luU2Vzc2lvblN0b3JhZ2U6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHJldHVybiB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UubGVuZ3RoO1xuXHRcdFx0fSxcblx0XHRcdHNldExvY2FsU3RvcmFnZUl0ZW06IGZ1bmN0aW9uKGtleSx2YWx1ZSl7XG5cdFx0XHRcdHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksYW5ndWxhci50b0pzb24odmFsdWUpKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRMb2NhbFN0b3JhZ2VJdGVtOiBmdW5jdGlvbihrZXkpe1xuXHRcdFx0XHR2YXIgZyA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGFuZ3VsYXIuZnJvbUpzb24oZyk7XG5cdFx0XHRcdH1jYXRjaChlKXtcblx0XHRcdFx0XHRyZXR1cm4gZztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gYW5ndWxhci5mcm9tSnNvbihnKTtcblx0XHRcdH0sXG5cdFx0XHRyZW1vdmVMb2NhbFN0b3JhZ2VJdGVtOiBmdW5jdGlvbihrZXkpe1xuXHRcdFx0XHR3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcblx0XHRcdH0sXG5cdFx0XHRjbGVhckxvY2FsU3RvcmFnZTogZnVuY3Rpb24oKXtcblx0XHRcdFx0d2luZG93LmxvY2FsU3RvcmFnZS5jbGVhcigpO1xuXHRcdFx0fSxcblx0XHRcdGdldE51bWJlck9mSXRlbXNJbkxvY2FsU3RvcmFnZTogZnVuY3Rpb24oKXtcblx0XHRcdFx0cmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2UubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGFuZ3VsYXIubW9kdWxlKCdndW1nYS5zZXJ2aWNlcy53ZWJzdG9yYWdlJyxbXSlcblx0LmZhY3RvcnkoJ0d1bWdhV2ViU3RvcmFnZScsV2ViU3RvcmFnZSlcbn0pKCk7IiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0JztcbiAgIC8qKlxuICAgICogQG5nZG9jIGRpcmVjdGl2ZVxuICAgICogQG5hbWUgZ3VtZ2EuY29yZTpndW1nYUVycm9yXG4gICAgKiBAZWxlbWVudCBpbnB1dFxuICAgICogQHJlc3RyaWN0IEFcbiAgICAqIEBkZXNjcmlwdGlvbiBPIGNvbXBvbmVudGUgZ3VtZ2FFcnJvciBzZXJ2ZSBwYXJhIG1vc3RyYXIgbWVuc2FnZW5zIGRlIHZhbGlkYcOnw7VlcyBhYmFpeG8gZG8gaW5wdXQgcmVzcG9uc8OhdmVsIHBlbG8gZXJyby5cbiAgICAqXG4gICAgKiBAZXhhbXBsZVxuICAgICogIFVtIGV4ZW1wbG8gZGEgZGlyZWN0aXZlIGd1bWdhRXJyb3IgZnVuY2lvbmFuZG8gcG9kZSBzZXIgZW5jb250cmFkbyBbYXF1aV0oaHR0cDovL2VtYmVkLnBsbmtyLmNvL0FjanFjZ3ZnR2hkSnFEaDcyZUhBKS5cbiAgICAqICA8cHJlPlxuICAgICogICAgPGZvcm0gbmFtZT1cIm15Rm9ybVwiPlxuICAgICogICAgICA8aW5wdXQgdHlwZT1cIm51bWJlclwiIG5hbWU9XCJtaW5OdW1iZXJcIiBuZy1tb2RlbD1cIm1pbk51bWJlclwiIGd1bWdhLWVycm9yIGd1bWdhLW1pbi1udW1iZXI9XCIyMFwiPlxuICAgICogICAgPC9mb3JtPlxuICAgICogIDwvcHJlPlxuICAgKi9cbiAgRXJyb3IuJGluamVjdCA9IFtcIiRjb21waWxlXCJdO1xuICBmdW5jdGlvbiBFcnJvcigkY29tcGlsZSkge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0EnLFxuXHRcdFx0c2NvcGU6IHt9LFxuICAgICAgcmVxdWlyZTogJ15mb3JtJyxcbiAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxtLCBhdHRycywgY3RybCkge1xuXHRcdFx0XHRzY29wZS5lcnJvcnMgPSBbXTtcblxuXHRcdFx0XHRzY29wZS5lcnJvcnNDb250YWlucyA9IGZ1bmN0aW9uKGVycm9ycywgZXJyb3IpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBrIGluIGVycm9ycykge1xuXHRcdFx0XHRcdFx0aWYgKGFuZ3VsYXIuZXF1YWxzKGVycm9yc1trXSwgZXJyb3IpKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5hZGRFcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7XG5cdFx0XHRcdFx0aWYgKCFzY29wZS5lcnJvcnNDb250YWlucyhzY29wZS5lcnJvcnMsIGVycm9yKSkge1xuXHRcdFx0XHRcdFx0c2NvcGUuZXJyb3JzLnB1c2goZXJyb3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLnJlbW92ZUVycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcblx0XHRcdFx0XHR2YXIgZXJyb3JDb3B5ID0gYW5ndWxhci5jb3B5KGVycm9yKTtcblx0XHRcdFx0XHRlcnJvckNvcHkudmFsaWQgPSAhZXJyb3JDb3B5LnZhbGlkO1xuXHRcdFx0XHRcdHZhciBleGlzdCA9IHNjb3BlLmVycm9yc0NvbnRhaW5zKHNjb3BlLmVycm9ycywgZXJyb3JDb3B5KTtcblx0XHRcdFx0XHRpZiAoZXhpc3QpIHtcblx0XHRcdFx0XHRcdHNjb3BlLmVycm9ycy5zcGxpY2UoZXhpc3QsIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzY29wZS4kb24oJyRlcnJvck1lc3NhZ2UnLCBmdW5jdGlvbihldmVudCwgZGF0YSkge1xuICAgICAgICAgIGlmIChlbG1bMF0ubmFtZSA9PSBkYXRhLm5hbWUpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnZhbGlkID09IGZhbHNlKSB7XG4gIFx0XHRcdFx0XHRcdHNjb3BlLmFkZEVycm9yKGRhdGEpO1xuICBcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0c2NvcGUucmVtb3ZlRXJyb3IoZGF0YSk7XG4gIFx0XHRcdFx0XHR9XG4gICAgICAgICAgfVxuXHRcdFx0XHR9KTtcblxuICAgICAgICB2YXIgdGVtcGxhdGUgPSAnPG9sIGNsYXNzPVwibGlzdC1lcnJvcnMgdGV4dC1kYW5nZXJcIj48bGkgbmctcmVwZWF0PVwiZXJyb3IgaW4gZXJyb3JzXCIgPnt7IGVycm9yLmZpZWxkTWVzc2FnZSB9fTwvbGk+PC9vbD4nO1xuICAgICAgICBlbG0uYWZ0ZXIoJGNvbXBpbGUodGVtcGxhdGUpKHNjb3BlKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cdGFuZ3VsYXIubW9kdWxlKCdndW1nYS5kaXJlY3RpdmVzLmZvcm0uZXJyb3InLFtdKVxuXHQuZGlyZWN0aXZlKCdndW1nYUVycm9yJyxFcnJvcik7XG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0Jztcblx0LyoqXG5cdCAqIEBuZ2RvYyBkaXJlY3RpdmVcblx0ICogQG5hbWUgZ3VtZ2EuY29yZTpndW1nYUVycm9yc1xuXHQgKiBAcmVzdHJpY3QgRVxuXHQgKiBAZGVzY3JpcHRpb24gTyBjb21wb25lbnRlIGd1bWdhRXJyb3JzIHNlcnZlIHBhcmEgbW9zdHJhciB0b2RhcyBtZW5zYWdlbnMgZGUgdmFsaWRhw6fDtWVzIGRvIGZvcm11bMOhcmlvIGRlIGZvcm1hIGFncnVwYWRhLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcGxhY2VtZW50IE9uZGUgaXLDoSBhcGFyZWNlciwgbyBwYWRyw6NvIMOpIHRvcCwgbWFzIHRhbWLDqW0gYWNlaXRhIHJpZ2h0LCBib3R0b20gZSBsZWZ0LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWNvbiDDjWNvbmUgZG8gYm90w6NvLCBwb3IgcGFkcsOjbyDDqSBnbHlwaGljb24gZ2x5cGhpY29uLWluZm8tc2lnblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbGFiZWwgVGV4dG8gZG8gYm90w6NvXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0aXRsZSBUw610dWxvIGRvIHBvcG92ZXIgZGUgZXJyb3Ncblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogIFVtIGV4ZW1wbG8gZGEgZGlyZWN0aXZlIGd1bWdhRXJyb3JzIGZ1bmNpb25hbmRvIHBvZGUgc2VyIGVuY29udHJhZG8gW2FxdWldKGh0dHA6Ly9lbWJlZC5wbG5rci5jby9BY2pxY2d2Z0doZEpxRGg3MmVIQSkuXG5cdCAqICA8cHJlPlxuXHQgKiAgICA8Zm9ybSBuYW1lPVwibXlGb3JtXCI+XG5cdCAqICAgICAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiBuYW1lPVwibWluTnVtYmVyXCIgbmctbW9kZWw9XCJtaW5OdW1iZXJcIiBndW1nYS1taW4tbnVtYmVyPVwiMjBcIj5cblx0ICogICAgICA8Z3VtZ2EtZXJyb3JzIHBsYWNlbWVudD1cInJpZ2h0XCIgaWNvbj1cImdseXBoaWNvbiBnbHlwaGljb24taW5mby1zaWduXCIgbGFiZWw9XCJDYW1wb3MgaW52w6FsaWRvc1wiIHRpdGxlPVwiQ2FtcG9zIGludsOhbGlkb3NcIj48L2d1bWdhLWVycm9ycz5cblx0ICogICAgPC9mb3JtPlxuXHQgKiAgPC9wcmU+XG5cdCovXG5cdEVycm9ycy4kaW5qZWN0ID0gW1wiJGNvbXBpbGVcIl07XG4gIGZ1bmN0aW9uIEVycm9ycygkY29tcGlsZSkge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0UnLFxuXHRcdFx0c2NvcGU6IHtcblx0XHRcdFx0ZXJyb3JzOiAnPSdcblx0XHRcdH0sXG4gICAgICByZXF1aXJlOiAnXmZvcm0nLFxuICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbG0sIGF0dHJzLCBjdHJsKSB7XG5cdFx0XHRcdHNjb3BlLmVycm9ycyA9IFtdO1xuXG5cdFx0XHRcdHNjb3BlLmVycm9yc0NvbnRhaW5zID0gZnVuY3Rpb24oZXJyb3JzLCBlcnJvcikge1xuXHRcdFx0XHRcdGZvciAodmFyIGsgaW4gZXJyb3JzKSB7XG5cdFx0XHRcdFx0XHRpZiAoYW5ndWxhci5lcXVhbHMoZXJyb3JzW2tdLCBlcnJvcikpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLmFkZEVycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcblx0XHRcdFx0XHRpZiAoIXNjb3BlLmVycm9yc0NvbnRhaW5zKHNjb3BlLmVycm9ycywgZXJyb3IpKSB7XG5cdFx0XHRcdFx0XHRzY29wZS5lcnJvcnMucHVzaChlcnJvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUucmVtb3ZlRXJyb3IgPSBmdW5jdGlvbihlcnJvcikge1xuXHRcdFx0XHRcdC8vIGVycm9yLnZhbGlkID0gIWVycm9yLnZhbGlkO1xuXHRcdFx0XHRcdHZhciBlcnJvckNvcHkgPSBhbmd1bGFyLmNvcHkoZXJyb3IpO1xuXHRcdFx0XHRcdGVycm9yQ29weS52YWxpZCA9ICFlcnJvckNvcHkudmFsaWQ7XG5cdFx0XHRcdFx0dmFyIGV4aXN0ID0gc2NvcGUuZXJyb3JzQ29udGFpbnMoc2NvcGUuZXJyb3JzLCBlcnJvckNvcHkpO1xuXHRcdFx0XHRcdGlmIChleGlzdCkge1xuXHRcdFx0XHRcdFx0c2NvcGUuZXJyb3JzLnNwbGljZShleGlzdCwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNjb3BlLiRvbignJGVycm9yTWVzc2FnZScsIGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG5cdFx0XHRcdFx0aWYgKGRhdGEudmFsaWQgPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdHNjb3BlLmFkZEVycm9yKGRhdGEpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzY29wZS5yZW1vdmVFcnJvcihkYXRhKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHZhciB0aXRsZSA9IGF0dHJzLnRpdGxlIHx8ICdFcnJvcyc7XG5cdFx0XHRcdHZhciBwbGFjZW1lbnQgPSBhdHRycy5wbGFjZW1lbnQgfHwgJ3RvcCc7XG5cdFx0XHRcdHZhciBpY29uID0gYXR0cnMuaWNvbiB8fCAnZ2x5cGhpY29uIGdseXBoaWNvbi1pbmZvLXNpZ24nO1xuXG5cdFx0XHRcdHZhciB0ZW1wbGF0ZSA9IFtcblx0XHRcdFx0XHQnPGJ1dHRvbiBwb3BvdmVyLXBsYWNlbWVudD1cIicrcGxhY2VtZW50KydcIiBwb3BvdmVyLXRlbXBsYXRlPVwiXFwndGVtcGxhdGUuaHRtbFxcJ1wiIHBvcG92ZXItdGl0bGU9XCInK3RpdGxlKydcIiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1kYW5nZXJcIj4nXG5cdFx0XHRcdCxcdCc8aSBjbGFzcz1cIicraWNvbisnXCI+PC9pPidcblx0XHRcdFx0LCBhdHRycy5sYWJlbFxuXHRcdFx0XHQsXHQnPC9idXR0b24+J1xuXHRcdFx0XHQsXHQnPHNjcmlwdCBpZD1cInRlbXBsYXRlLmh0bWxcIiB0eXBlPVwidGV4dC9uZy10ZW1wbGF0ZVwiPidcblx0XHRcdFx0LFx0JzxvbCBjbGFzcz1cImxpc3QtZXJyb3JzIHRleHQtZGFuZ2VyXCI+PGxpIG5nLXJlcGVhdD1cImVycm9yIGluIGVycm9yc1wiID57eyBlcnJvci5tZXNzYWdlIH19PC9saT48L29sPidcblx0XHRcdFx0LFx0Jzwvc2NyaXB0Pidcblx0XHRcdFx0XS5qb2luKFwiXFxuXCIpO1xuXHRcdFx0XHRlbG0uYXBwZW5kKCRjb21waWxlKHRlbXBsYXRlKShzY29wZSkpO1xuXG4gICAgICB9XG4gICAgfVxuICB9XG5cdGFuZ3VsYXIubW9kdWxlKCdndW1nYS5kaXJlY3RpdmVzLmZvcm0uZXJyb3JzJyxbJ3VpLmJvb3RzdHJhcCddKVxuXHQuZGlyZWN0aXZlKCdndW1nYUVycm9ycycsRXJyb3JzKTtcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXHRGb3JtLiRpbmplY3QgPSBbXCIkdGltZW91dFwiLCBcIiRyb290U2NvcGVcIl07XG5cdC8qKlxuXHQqIEBuZ2RvYyBkaXJlY3RpdmVcblx0KiBAbmFtZSBndW1nYS5jb3JlOmd1bWdhRm9ybVxuXHQqIEByZXN0cmljdCBBXG5cdCogQGVsZW1lbnQgZm9ybVxuXHQqIEBkZXNjcmlwdGlvbiBBIGRpcmVjdGl2ZSBndW1nYUZvcm0gw6kgdXRpbGl6YWRhIGVtIGNvbmp1bnRvIGNvbSBhcyBkaXJlY3RpdmVzIGRlIHZhbGlkYcOnw6NvIGRlIGlucHV0LiBFbGEgY29udMOpbSBmdW7Dp8O1ZXMgcXVlIHNlcsOjb1xuXHQqIHVzYWRhcyBwYXJhIG1hbmlwdWxhciBvIGZvcm11bMOhcmlvLiBFbGEgZXhww7VlIG5vICRzY29wZSB1bSBvYmpldG8gR3VtZ2FGb3JtIHBhcmEgYWdydXBhciBhcyBmdW7Dp8O1ZXMgZW0gdW0gbHVnYXIgc8OzLlxuXHQqXG5cdCpcdCMgQ29tbyB1dGlsaXphclxuXHQqXG5cdCogTyBjb21wb25lbnRlIEd1bWdhRm9ybSBkZXZlIHNlciBpbmNsdcOtZG8gbm8gZWxlbWVudG8gYGZvcm1gLCBxdWUgbmVjZXNzaXRhIHRlciB1bSBhdHJpYnV0byBuYW1lLiDDiSBuZWNlc3PDoXJpbyB0YW1iw6ltIHF1ZSBvcyBpbnB1dHMgcXVlIHNlcsOjbyB1dGlsaXphZG9zIHRlbmhhbSB1bSBhdHJpYnV0byBuYW1lLFxuXHQqIHBvaXMgbyBjb250cm9sZSBkZWxlcyDDqSBmZWl0byBhIHBhcnRpciBkZXN0ZSBhdHJpYnV0by5cblx0KlxuXHQqXHQ8cHJlPlxuXHQqICA8Zm9ybSBuYW1lPVwiVXNlckZvcm1cIiBndW1nYS1mb3JtPlxuXHQqXHQgICAuLi5cblx0KiAgPC9mb3JtPlxuXHQqIDwvcHJlPlxuXHQqXG5cdCpcdCMgTcOpdG9kb3Ncblx0KlxuXHQqYCRzY29wZS5HdW1nYUZvcm0uZ2V0TWVzc2FnZXMobmFtZSxlcnJvcilgXG4gICpcbiAgKiAgTyBtw6l0b2RvIGBnZXRNZXNzYWdlc2AgYWNlaXRhIGRvaXMgcGFyw6JtZXRyb3MgYG5hbWVgIGUgYGVycm9yYCwgb25kZSBuYW1lIMOpIG8gbm9tZSBkbyBpbnB1dCBxdWUgZGVzZWphZGFcbiAgKiAgcmVjdXBlcmFyIGEgbWVuc2FnZW0gZSBvIGVycm8uIENhc28gbyBwYXLDom1ldHJvIGVycm9yIG7Do28gc2VqYSBwYXNzYWRvLCDDqSByZXRvcm5hZG8gbyBvYmpldG8gY29tIHRvZGFzIGFzIG1lbnNhZ2VucyBkbyBjYW1wby5cbiAgKiAgIyMjIFBhcsOibWV0cm9zXG4gICogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPm5hbWU8L2xhYmVsPiBTdHJpbmcgcXVlIHRlcsOhIG8gbm9tZSBkbyBpbiBwdXQgcGFyYSByZXRvcm5hciBvcyBlcnJvcnMuXG4gICogICBQYXJhIGFkaWNpb25hciBhIGZ1bsOnw6NvLCBjb2xvcXVlIG8gbm9tZSBkYSBmdW7Dp8OjbyBlIG8gdmFsb3IgZGVsZSBjb21vIGB0cnVlYFxuXHQqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLXdhcm5pbmdcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIj5TdHJpbmc8L2xhYmVsPjxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5lcnJvcjwvbGFiZWw+IFN0cmluZyBxdWUgc2Vyw6EgdGVyw6EgbyBub21lIGRvIGVycm8gcXVlIHNlcsOhIHJldG9ybmFkby4gQ2Fzb1xuXHQqICBuw6NvIHNlamEgcGFzc2FkbyBlc3RlIHBhcsOibWV0cm8sIHNlcsOhIHJldG9ybmFkbyB1bSBvYmpldG8gY29tIHRvZG9zIG9zIGVycm9zLlxuICAqIFx0IyMjIFJldG9ybm9cbiAgKlxuICAqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5bT2JqZWN0fFN0cmluZ108L2xhYmVsPiBTdHJpbmcgcXVlIGNvbnRlcsOhIGEgbWVuc2FnZW0gZGUgZXJybyBvdSBvIG9iamV0byBjb20gdG9kYXMgYXMgbWVuc2FnZW5zIGRlIGVycm8uXG5cdCpcblx0KiAtLS0tXG5cdCpcblx0KmAkc2NvcGUuR3VtZ2FGb3JtLmNoYW5nZU1lc3NhZ2UobmFtZSxlcnJvcixtZXNzYWdlKWBcblx0KlxuXHQqICBPIG3DqXRvZG8gYGNoYW5nZU1lc3NhZ2VgIGFjZWl0YSB0csOqcyBwYXLDom1ldHJvcywgYG5hbWVgLGBlcnJvcmAgZSBgbWVzc2FnZWAsIG9uZGUgYG5hbWVgIMOpIG8gbm9tZSBkbyBpbnB1dCBxdWUgZGVzZWphZGFcblx0KiAgcmVjdXBlcmFyIGEgbWVuc2FnZW0sIGBlcnJvcmAgw6kgcXVhbCBlcnJvIHF1ZSBhIG1lbnNhZ2VtIHNlcsOhIGFsdGVyYWRhIGUgYG1lc3NhZ2VgIHF1YWwgc2Vyw6EgYSBub3ZhIG1lbnNhZ2VtIC5cblx0KiAgIyMjIFBhcsOibWV0cm9zXG5cdCogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPm5hbWU8L2xhYmVsPiBTdHJpbmcgcXVlIHRlcsOhIG8gbm9tZSBkbyBpbnB1dCBwYXJhIHJldG9ybmFyIG9zIGVycm9ycy5cblx0KiAgIFBhcmEgYWRpY2lvbmFyIGEgZnVuw6fDo28sIGNvbG9xdWUgbyBub21lIGRhIGZ1bsOnw6NvIGUgbyB2YWxvciBkZWxlIGNvbW8gYHRydWVgXG5cdCogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPmVycm9yPC9sYWJlbD4gU3RyaW5nIHF1ZSBzZXLDoSB0ZXLDoSBvIG5vbWUgZG8gZXJybyBxdWUgc2Vyw6EgcmV0b3JuYWRvLiBDYXNvXG5cdCogIG7Do28gc2VqYSBwYXNzYWRvIGVzdGUgcGFyw6JtZXRybywgc2Vyw6EgcmV0b3JuYWRvIHVtIG9iamV0byBjb20gdG9kb3Mgb3MgZXJyb3MuXG5cdCogIC0gPGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtd2FybmluZ1wiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPlN0cmluZzwvbGFiZWw+PGxhYmVsIGNsYXNzPVwibGFiZWwgbGFiZWwtaW5mb1wiPm1lc3NhZ2U8L2xhYmVsPiBTdHJpbmcgcXVlIHNlcsOhIHVzYWRhIGNvbW8gbWVuc2FnZW0gZGUgZXJybyBwYXJhIGEgZGlyZWN0aXZlLlxuXHQqIFx0IyMjIFJldG9ybm9cblx0KlxuXHQqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5Cb29sZWFuPC9sYWJlbD4gVHJ1ZSBjYXNvIGEgbWVuc2FnZW0gdGVuaGEgc2lkbyBhbHRlcmFkYSwgRmFsc2UgY2FzbyBuw6NvLlxuXHQqXG5cdCogLS0tLVxuXHQqXG5cdCpgJHNjb3BlLkd1bWdhRm9ybS5zZXRGb3JtVmFsaWQoKWBcblx0KlxuXHQqICBPIG3DqXRvZG8gYHNldEZvcm1WYWxpZGAgw6kgdXRpbGl6YWRvIHBhcmEgbGltcGFyIHRvZG9zIG9zIGVycm9zIHF1ZSBlc3RpdmVyZW0gYXRpdm9zIG5vIGZvcm11bMOhcmlvLiBFbGUgcGVyY29ycmUgbyBvYmpldG8gZGUgZXJybyBxdWUgbyBBbmd1bGFyLmpzIGNyaWEgYXV0b21hdGljYW1lbnRlIGUgdmFsaWRhIHRvZG9zIG9zIGNhbXBvc1xuXHQqICBxdWUgZXN0aXZlcmVtIGNvbSBlcnJvLlxuXHQqXG5cdCogLS0tLVxuICAqXG5cdCpgJHNjb3BlLkd1bWdhRm9ybS5zZXRGb3JtUHJpc3RpbmUoKWBcblx0KlxuXHQqICBPIG3DqXRvZG8gYHNldEZvcm1QcmlzdGluZWAgw6kgdXRpbGl6YWRvIHBhcmEgY29sb2NhciB0b2RvcyBvcyBjYW1wb3MgZW0gdW0gZXN0YWRvIGRlICRwcmlzdGluZSwgb3Ugc2VqYSwgcXVhbmRvIGFpbmRhIG7Do28gZm9yYW0gYXR1YWxpemFkb3MgcGVsbyB1c3XDoXJpby5cblx0KlxuXHQqIC0tLS1cblx0KlxuXHQqYCRzY29wZS5HdW1nYUZvcm0uY2xlYXJGb3JtKClgXG5cdCpcblx0KiAgTyBtw6l0b2RvIGBjbGVhckZvcm1gIMOpIHV0aWxpemFkbyBwYXJhIGxpbXBhciB0b2RvcyBvcyBjYW1wb3MgZG8gZm9ybXVsw6FyaW8gZSwgYWzDqW0gZGlzc28sIGNvbG9jYXIgZWxlcyBlbSB1bSBlc3RhZG8gZGUgJHByaXN0aW5lLlxuXHQqXG5cdCogLS0tLVxuXHQqXG5cdCpgJHNjb3BlLkd1bWdhRm9ybS5nZXRGb3JtRXJyb3JzKClgXG5cdCpcblx0KiAgTyBtw6l0b2RvIGBnZXRGb3JtRXJyb3JzYCDDqSB1dGlsaXphZG8gcGFyYSBxdWFuZG8gZGVzZWphLXNlIG9idGVyIHRvZG9zIG9zIGVycm9zIHF1ZSBlc3TDo28gcHJlc2VudGVzIG5vIGZvcm11bMOhcmlvLlxuXHQqXG5cdCogIyMjIFJldG9ybm9cblx0KlxuXHQqICAtIDxsYWJlbCBjbGFzcz1cImxhYmVsIGxhYmVsLWluZm9cIj5bQXJyYXldPC9sYWJlbD4gTGlzdGEgcXVlIGlyw6EgY29udGVyIHRvZG9zIG9zIGVycm9zIHF1ZSBlc3TDo28gbm8gZm9ybXVsw6FyaW8uXG5cdCpcblx0KiAtLS0tXG5cdCovXG5cdGZ1bmN0aW9uIEZvcm0oJHRpbWVvdXQsJHJvb3RTY29wZSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRyZXN0cmljdDogJ0EnLFxuXHRcdFx0cmVxdWlyZTogJ15mb3JtJyxcblx0XHRcdHNjb3BlOiBmYWxzZSxcblx0XHRcdGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbG0sIGF0dHJzLCBjdHJsKSB7XG5cdFx0XHRcdGlmKCFhdHRycy5uYW1lKSB0aHJvdyAnw4kgbmVjZXNzw6FyaW8gcGFzc2FyIHVtIHZhbG9yIHBhcmEgbyBhdHJpYnV0byBcIm5hbWVcIiBkbyBlbGVtZW50IDxmb3JtPic7XG5cdFx0XHRcdHNjb3BlLkd1bWdhRm9ybSA9IHt9O1xuXHRcdFx0XHR2YXIgX2Zvcm0gPSBzY29wZVthdHRycy5uYW1lXTtcblx0XHRcdFx0dmFyIF9mb3JtQ29udHJvbGxlcnMgPSBbXTtcblx0XHRcdFx0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGFuZ3VsYXIuZm9yRWFjaChlbG0uZmluZCgnaW5wdXQnKSxmdW5jdGlvbihpbnB1dCl7XG5cdFx0XHRcdFx0XHRfZm9ybUNvbnRyb2xsZXJzLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRuYW1lOiBhbmd1bGFyLmVsZW1lbnQoaW5wdXQpLmNvbnRyb2xsZXIoJ25nTW9kZWwnKS4kbmFtZSxcblx0XHRcdFx0XHRcdFx0Y29udHJvbGxlcjogYW5ndWxhci5lbGVtZW50KGlucHV0KS5jb250cm9sbGVyKCduZ01vZGVsJyksXG5cdFx0XHRcdFx0XHRcdGVycm9yTWVzc2FnZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRtYXhkYXRlOiAnQSBkYXRhIGVzcGVjaWZpY2FkYSBubyBjYW1wbyB7MH0gbsOjbyBkZXZlIHVsdHJhcGFzc2FyIG8gbGltaXRlIGRlOiB7MX0uJyxcblx0XHRcdFx0XHRcdFx0XHRtYXhsZW5ndGg6ICdPIHRleHRvIGVzcGVjaWZpY2FkbyBubyBjYW1wbyB7MH0gbsOjbyBkZXZlIHVsdHJhcGFzc2FyIG8gbGltaXRlIGRlOiB7MX0uJyxcblx0XHRcdFx0XHRcdFx0XHRtYXhudW1iZXI6ICdPIG7Dum1lcm8gZXNwZWNpZmljYWRvIG5vIGNhbXBvIHswfSBuw6NvIGRldmUgdWx0cmFwYXNzYXIgbyBsaW1pdGUgZGU6IHsxfS4nLFxuXHRcdFx0XHRcdFx0XHRcdG1pbmRhdGU6ICdBIGRhdGEgZXNwZWNpZmljYWRhIG5vIGNhbXBvIHswfSBuw6NvIGRldmUgc2VyIG1lbm9yIHF1ZSBvIGxpbWl0ZSBtw61uaW1vIGRlOiB7MX0uJyxcblx0XHRcdFx0XHRcdFx0XHRtaW5sZW5ndGg6ICdPIHRleHRvIGVzcGVjaWZpY2FkbyBubyBjYW1wbyB7MH0gbsOjbyBkZXZlIHNlciBtZW5vciBxdWUgbyBsaW1pdGUgbcOtbmltbyBkZTogezF9LicsXG5cdFx0XHRcdFx0XHRcdFx0bWlubnVtYmVyOiAnTyBuw7ptZXJvIGVzcGVjaWZpY2FkbyBubyBjYW1wbyB7MH0gbsOjbyBkZXZlIHNlciBtZW5vciBxdWUgbyBsaW1pdGUgbcOtbmltbyBkZTogezF9LicsXG5cdFx0XHRcdFx0XHRcdFx0cGF0dGVybjogJ08gdGV4dG8gZXNwZWNpZmljYWRvIG5vIGNhbXBvIHswfSBkZXZlIGVzdGFyIGRlbnRybyBkbyBwYWRyw6NvOiB7MX0uJyxcblx0XHRcdFx0XHRcdFx0XHRyYW5nZWRhdGU6J0EgZGF0YSBlc3BlY2lmaWNhZGEgbm8gY2FtcG8gezB9IGRldmUgZXN0YXIgZGVudHJvIGRvIGludGVydmFsbzogezF9LicsXG5cdFx0XHRcdFx0XHRcdFx0cmFuZ2VudW1iZXI6ICdPIG7Dum1lcm8gZXNwZWNpZmljYWRvIG5vIGNhbXBvIHswfSBkZXZlIGVzdGFyIGRlbnRybyBkbyBpbnRlcnZhbG86IHsxfS4nLFxuXHRcdFx0XHRcdFx0XHRcdHJlcXVpcmVkOiAnTyBjYW1wbyB7MH0gw6kgb2JyaWdhdMOzcmlvLidcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9KSgpO1xuXG5cdFx0XHRcdGZ1bmN0aW9uIHJldHVybk9iamVjdChuYW1lKXtcblx0XHRcdFx0XHRyZXR1cm4gX2Zvcm1Db250cm9sbGVycy5maWx0ZXIoZnVuY3Rpb24oJHYpe1xuXHRcdFx0XHRcdFx0cmV0dXJuICR2Lm5hbWUudHJpbSgpLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0fSlbMF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS4kb24oJyRlcnJvcicsZnVuY3Rpb24oZXYsZGF0YSl7XG5cdFx0XHRcdFx0JHRpbWVvdXQoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdGlmIChkYXRhLmVycm9yLnN1YnN0cmluZygwLDUpID09ICdyYW5nZScpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGF1eFZhbHVlID0gc2NvcGUuJGV2YWwoZGF0YS52YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdGRhdGEudmFsdWUgPSAnbcOtbmltbyBkZSAnICsgYXV4VmFsdWUubWluICsgJyBlIG3DoXhpbW8gZGUgJyArIGF1eFZhbHVlLm1heDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHZhciBfYXV4ID0gcmV0dXJuT2JqZWN0KGRhdGEubmFtZSlcblx0XHRcdFx0XHRcdCxcdFx0bWVzc2FnZSA9IF9hdXguZXJyb3JNZXNzYWdlc1tkYXRhLmVycm9yXS5yZXBsYWNlKCd7MX0nLGRhdGEudmFsdWUpXG5cdFx0XHRcdFx0XHQsXHRcdGF1eE1lc3NhZ2UgPSBtZXNzYWdlO1xuXHRcdFx0XHRcdFx0aWYgKGRhdGEuZXJyb3IgIT0gJ3JlcXVpcmVkJykge1xuXHRcdFx0XHRcdFx0XHRhdXhNZXNzYWdlID0gYXV4TWVzc2FnZS5yZXBsYWNlKCdubyBjYW1wbyB7MH0nLCcnKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGF1eE1lc3NhZ2UgPSBhdXhNZXNzYWdlLnJlcGxhY2UoJ3swfScsJycpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZSgnezB9JyxkYXRhLmxhYmVsKTtcblx0XHRcdFx0XHRcdCRyb290U2NvcGUuJGJyb2FkY2FzdCgnJGVycm9yTWVzc2FnZScse1xuXHRcdFx0XHRcdFx0XHRuYW1lOiBkYXRhLm5hbWUsXG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2U6IG1lc3NhZ2UsXG5cdFx0XHRcdFx0XHRcdGZpZWxkTWVzc2FnZTogYXV4TWVzc2FnZSxcblx0XHRcdFx0XHRcdFx0dmFsaWQ6IGRhdGEudmFsaWQsXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHNjb3BlLkd1bWdhRm9ybS5nZXRNZXNzYWdlcyA9IGZ1bmN0aW9uKG5hbWUsZXJyb3Ipe1xuXHRcdFx0XHRcdGlmKCFlcnJvcil7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmV0dXJuT2JqZWN0KG5hbWUpLmVycm9yTWVzc2FnZXM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHJldHVybk9iamVjdChuYW1lKS5lcnJvck1lc3NhZ2VzKXtcblx0XHRcdFx0XHRcdHJldHVybiByZXR1cm5PYmplY3QobmFtZSkuZXJyb3JNZXNzYWdlc1tlcnJvcl0gfHwgbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c2NvcGUuR3VtZ2FGb3JtLmNoYW5nZU1lc3NhZ2UgPSBmdW5jdGlvbihpbnB1dCx3aGljaCxtZXNzYWdlKXtcblx0XHRcdFx0XHRpZighaW5wdXQgfHwgIXdoaWNoIHx8ICFtZXNzYWdlKSB0aHJvdyAnVmFsb3JlcyBwYXNzYWRvcyBlcnJhZG9zIHBhcmEgYSBmdW7Dp8OjbyBHdW1nYUZvcm0uY2hhbmdlTWVzc2FnZShpbnB1dCxtZXNzYWdlKSdcblx0XHRcdFx0XHR2YXIgYXV4ID0gX2Zvcm1Db250cm9sbGVycy5maWx0ZXIoZnVuY3Rpb24odmFsdWUpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIGlucHV0ID09IHZhbHVlLm5hbWU7XG5cdFx0XHRcdFx0fSlbMF07XG5cdFx0XHRcdFx0aWYoYXV4LmVycm9yTWVzc2FnZXMgJiYgYXV4LmVycm9yTWVzc2FnZXNbd2hpY2hdKXtcblx0XHRcdFx0XHRcdGF1eC5lcnJvck1lc3NhZ2VzW3doaWNoXSA9IG1lc3NhZ2U7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNjb3BlLkd1bWdhRm9ybS5zZXRGb3JtVmFsaWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0Zm9yKHZhciBrZXkgaW4gX2Zvcm0uJGVycm9yKSBpZihfZm9ybS4kZXJyb3IuaGFzT3duUHJvcGVydHkoa2V5KSl7XG5cdFx0XHRcdFx0XHRfZm9ybS4kZXJyb3Jba2V5XS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZS4kc2V0VmFsaWRpdHkoa2V5LHRydWUpO1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2NvcGUuJGFwcGx5KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2NvcGUuR3VtZ2FGb3JtLmNsZWFyRm9ybSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0X2Zvcm1Db250cm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGNvbnRyb2xsZXIpe1xuXHRcdFx0XHRcdFx0Y29udHJvbGxlci5jb250cm9sbGVyLiRzZXRWaWV3VmFsdWUoJycpO1xuXHRcdFx0XHRcdFx0Y29udHJvbGxlci5jb250cm9sbGVyLiRzZXRQcmlzdGluZSgpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0c2NvcGUuJGFwcGx5KCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5HdW1nYUZvcm0uc2V0Rm9ybVByaXN0aW5lID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdF9mb3JtQ29udHJvbGxlcnMuZm9yRWFjaChmdW5jdGlvbihjb250cm9sbGVyKXtcblx0XHRcdFx0XHRcdGNvbnRyb2xsZXIuY29udHJvbGxlci4kc2V0UHJpc3RpbmUoKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdHNjb3BlLiRhcHBseSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUuR3VtZ2FGb3JtLmdldEZvcm1FcnJvcnMgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHZhciBfYXJyID0gW11cblx0XHRcdFx0XHQsXHRcdG5hbWVcblx0XHRcdFx0XHQsXHRcdGF1eCA9IFtdO1xuXHRcdFx0XHRcdGZvcih2YXIga2V5IGluIF9mb3JtLiRlcnJvcikgaWYoX2Zvcm0uJGVycm9yLmhhc093blByb3BlcnR5KGtleSkpe1xuXHRcdFx0XHRcdFx0X2Zvcm0uJGVycm9yW2tleV0uZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0YXV4LnB1c2godmFsdWUuJG5hbWUpO1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdF9hcnIucHVzaCh7dHlwZToga2V5LGZpZWxkczogYXV4fSk7XG5cdFx0XHRcdFx0XHRhdXggPSBbXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIF9hcnI7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtLmZvcm0nLFtdKVxuXHQuZGlyZWN0aXZlKCdndW1nYUZvcm0nLEZvcm0pO1xufSkoKTtcbiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBAbmdkb2MgZGlyZWN0aXZlXG4gICAqIEBuYW1lIGd1bWdhLmNvcmU6Z3VtZ2FNYXhEYXRlXG4gICAqIEBlbGVtZW50IGlucHV0XG4gICAqIEByZXN0cmljdCBBXG4gICAqIEBzY29wZSBmYWxzZVxuICAgKiBAZGVzY3JpcHRpb24gTyBjb21wb25lbnRlIEd1bWdhTWF4RGF0ZSBzZXJ2ZSBwYXJhIHZhbGlkYXIgZGF0YXMgbcOheGltYXMgZW0gZW50cmFkYXMgZGUgZm9ybXVsw6FyaW9zLlxuICAgKlxuICAgKiAjIyBOb3RhXG4gICAqIEVzdGEgZGlyZXRpdmEgc3Vwb3J0YSBhcGVuYXMgKippbnB1dHMqKiBkbyB0aXBvICoqZGF0ZSoqLiBPIHZhbG9yIGRvIGF0cmlidXRvL2RpcmV0aXZhIMOpICoqb2JyaWdhdMOzcmlvKiogZSBkZXZlIHNlciB1bWEgKipkYXRhKiouXG4gICAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBVc2FkbyBuYSBpbnRlZ3Jhw6fDo28gY29tIHtAbGluayBndW1nYS5jb3JlOmd1bWdhRXJyb3JzfSBwYXJhIGluZGljYXIgZW0gcXVhbCBjYW1wbyBzZSBlbmNvbnRyYSBvIGVycm8uXG5cdCAqIFNlIG8gYXRyaWJ1dG8gZm9yIG9taXRpZG8sIGEgZGlyZXRpdmEgdXNhcsOhIG8gYXRyaWJ1dG8gbmFtZSBkbyBpbnB1dC5cblx0ICpcbiAgICogQGV4YW1wbGVcbiAgICogIFVtIGV4ZW1wbG8gZGEgZGlyZWN0aXZlIGd1bWdhTWF4RGF0ZSBmdW5jaW9uYW5kbyBwb2RlIHNlciBlbmNvbnRyYWRvIFthcXVpXShodHRwOi8vZW1iZWQucGxua3IuY28vQWNqcWNndmdHaGRKcURoNzJlSEEpLlxuICAgKiAgPHByZT5cbiAgICogICAgPGZvcm0gbmFtZT1cIm15Rm9ybVwiPlxuICAgKiAgICAgIDxpbnB1dCB0eXBlPVwiZGF0ZVwiIG5hbWU9XCJtYXhEYXRlXCIgbmctbW9kZWw9XCJtYXhEYXRlXCIgZ3VtZ2EtbWF4LWRhdGU9XCIyMDE1LTA3LTIwXCI+XG4gICAqICAgICAgPHAgbmctc2hvdz1cIm15Rm9ybS5tYXhEYXRlLiRlcnJvci5tYXhkYXRlXCIgY2xhc3M9XCJ0ZXh0LWRhbmdlclwiPkRhdGEgc3VwZXJpb3IgYSBlc3BlcmFkYTwvcD5cbiAgICogICAgPC9mb3JtPlxuICAgKiAgPC9wcmU+XG4gICAqL1xuICAgTWF4RGF0ZS4kaW5qZWN0ID0gW1wiJGZpbHRlclwiXTtcbiAgIGZ1bmN0aW9uIE1heERhdGUoJGZpbHRlcikge1xuICAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcbiAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxtLCBhdHRycywgY3RybCkge1xuXHQgICAgICBpZiAoYXR0cnMudHlwZSAhPSAnZGF0ZScpIHtcblx0ICAgICAgICB0aHJvdyAnRXN0YSBkaXJldGl2YSBzdXBvcnRhIGFwZW5hcyBpbnB1dHMgZG8gdGlwbyBkYXRlJztcblx0ICAgICAgfVxuXHQgICAgICBpZiAoIWF0dHJzLmd1bWdhTWF4RGF0ZSkge1xuXHQgICAgICAgIHRocm93IFwiTyB2YWxvciBkYSBkaXJldGl2YSBndW1nYS1tYXgtZGF0ZSBuw6NvIGZvaSBpbmZvcm1hZG8uXCI7XG5cdCAgICAgIH1cbiAgICAgICAgdmFyIHZhbGlkYXRlTWF4RGF0ZSA9IGZ1bmN0aW9uIChpbnB1dFZhbHVlKSB7XG5cdFx0XHRcdFx0dmFyIGVycm9yID0gJ21heGRhdGUnO1xuICAgICAgICBcdHZhciBmb3JtYXQgPSAneXl5eS1NTS1kZCc7XG4gICAgICAgIFx0dmFyIGlucHV0ID0gJGZpbHRlcignZGF0ZScpKGlucHV0VmFsdWUsIGZvcm1hdCk7XG4gICAgICAgIFx0dmFyIG1heCA9ICRmaWx0ZXIoJ2RhdGUnKShhdHRycy5ndW1nYU1heERhdGUsIGZvcm1hdCk7XG4gICAgICAgIFx0dmFyIGlzVmFsaWQgPSBpbnB1dCA8PSBtYXg7XG4gICAgICAgIFx0Y3RybC4kc2V0VmFsaWRpdHkoZXJyb3IsIGlzVmFsaWQpO1xuXHRcdFx0XHRcdHNjb3BlLiRicm9hZGNhc3QoJyRlcnJvcicsIHtcblx0XHRcdFx0XHRcdG5hbWU6IGF0dHJzLm5hbWUsXG5cdFx0XHRcdFx0XHRsYWJlbDogYXR0cnMubGFiZWwgfHwgYXR0cnMubmFtZSxcblx0XHRcdFx0XHRcdHZhbGlkOiBpc1ZhbGlkLFxuXHRcdFx0XHRcdFx0ZXJyb3I6IGVycm9yLFxuXHRcdFx0XHRcdFx0dmFsdWU6IGF0dHJzLmd1bWdhTWF4RGF0ZVxuXHRcdFx0XHRcdH0pO1xuICAgICAgICBcdHJldHVybiBpbnB1dFZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBjdHJsLiRwYXJzZXJzLnVuc2hpZnQodmFsaWRhdGVNYXhEYXRlKTtcbiAgICAgICAgY3RybC4kZm9ybWF0dGVycy5wdXNoKHZhbGlkYXRlTWF4RGF0ZSk7XG4gICAgICAgIGF0dHJzLiRvYnNlcnZlKCdndW1nYU1heERhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFx0dmFsaWRhdGVNYXhEYXRlKGN0cmwuJHZpZXdWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtLm1heC5kYXRlJyxbXSlcbiAgLmRpcmVjdGl2ZSgnZ3VtZ2FNYXhEYXRlJyxNYXhEYXRlKTtcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogQG5nZG9jIGRpcmVjdGl2ZVxuICAgKiBAbmFtZSBndW1nYS5jb3JlOmd1bWdhTWF4TGVuZ3RoXG4gICAqIEBlbGVtZW50IGlucHV0XG4gICAqIEByZXN0cmljdCBBXG4gICAqIEBzY29wZSBmYWxzZVxuICAgKiBAZGVzY3JpcHRpb24gTyBjb21wb25lbnRlIEd1bWdhTWF4TGVuZ3RoIHNlcnZlIHBhcmEgdmFsaWRhciBxdWFudGlkYWRlcyBtw6F4aW1hcyBkZSBjYXJhY3RlcmVzIGVtIGVudHJhZGFzIGRlIGZvcm11bMOhcmlvcy5cbiAgICpcbiAgICogIyMgTm90YVxuICAgKiBPIHZhbG9yIGRvIGF0cmlidXRvL2RpcmV0aXZhIMOpICoqb2JyaWdhdMOzcmlvKiogZSBkZXZlIHNlciB1bSAqKm7Dum1lcm8qKi5cbiAgICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGxhYmVsIFVzYWRvIG5hIGludGVncmHDp8OjbyBjb20ge0BsaW5rIGd1bWdhLmNvcmU6Z3VtZ2FFcnJvcnN9IHBhcmEgaW5kaWNhciBlbSBxdWFsIGNhbXBvIHNlIGVuY29udHJhIG8gZXJyby5cblx0ICogU2UgbyBhdHJpYnV0byBmb3Igb21pdGlkbywgYSBkaXJldGl2YSB1c2Fyw6EgbyBhdHJpYnV0byBuYW1lIGRvIGlucHV0LlxuXHQgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgVW0gZXhlbXBsbyBkYSBkaXJlY3RpdmUgR3VtZ2FNYXhMZW5ndGggZnVuY2lvbmFuZG8gcG9kZSBzZXIgZW5jb250cmFkbyBbYXF1aV0oaHR0cDovL2VtYmVkLnBsbmtyLmNvL0FjanFjZ3ZnR2hkSnFEaDcyZUhBKS5cbiAgICogIDxwcmU+XG4gICAqICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIj5cbiAgICogICAgICA8aW5wdXQgdHlwZT1cImRhdGVcIiBuYW1lPVwibWF4TGVuZ3RoXCIgbmctbW9kZWw9XCJtYXhMZW5ndGhcIiBndW1nYS1tYXgtbGVuZ3RoPVwiMjBcIiBpZD1cIm1heExlbmd0aFwiPlxuICAgKiAgICAgIDxwIG5nLXNob3c9XCJteUZvcm0ubWF4TGVuZ3RoLiRlcnJvci5tYXhsZW5ndGhcIiBjbGFzcz1cInRleHQtZGFuZ2VyXCI+VGFtYW5obyBzdXBlcmlvciBhbyBlc3BlcmFkbzwvcD5cbiAgICogICAgPC9mb3JtPlxuICAgKiAgPC9wcmU+XG4gICAqL1xuICAgTWF4TGVuZ3RoLiRpbmplY3QgPSBbXTtcbiAgIGZ1bmN0aW9uIE1heExlbmd0aCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcbiAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxtLCBhdHRycywgY3RybCkge1xuICAgICAgICBpZiAoIWF0dHJzLmd1bWdhTWF4TGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgXCJPIHZhbG9yIGRhIGRpcmV0aXZhIGd1bWdhLW1heC1sZW5ndGggbsOjbyBmb2kgaW5mb3JtYWRvLlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWxpZGF0ZU1heExlbmd0aCA9IGZ1bmN0aW9uIChpbnB1dFZhbHVlKSB7XG5cdFx0XHRcdFx0dmFyIGVycm9yID0gJ21heGxlbmd0aCc7XG4gICAgICAgICAgdmFyIGlucHV0ID0gKGlucHV0VmFsdWUgPT0gdW5kZWZpbmVkKSA/IC0xIDogaW5wdXRWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgdmFyIG1heCA9IGF0dHJzLmd1bWdhTWF4TGVuZ3RoO1xuICAgICAgICAgIHZhciBpc1ZhbGlkID0gaW5wdXQgPD0gbWF4ICYmIGlucHV0ICE9IC0xO1xuICAgICAgICAgIGN0cmwuJHNldFZhbGlkaXR5KGVycm9yLCBpc1ZhbGlkKTtcblx0XHRcdFx0XHRzY29wZS4kYnJvYWRjYXN0KCckZXJyb3InLCB7XG5cdFx0XHRcdFx0XHRuYW1lOiBhdHRycy5uYW1lLFxuXHRcdFx0XHRcdFx0bGFiZWw6IGF0dHJzLmxhYmVsIHx8IGF0dHJzLm5hbWUsXG5cdFx0XHRcdFx0XHR2YWxpZDogaXNWYWxpZCxcblx0XHRcdFx0XHRcdGVycm9yOiBlcnJvcixcblx0XHRcdFx0XHRcdHZhbHVlOiBhdHRycy5ndW1nYU1heExlbmd0aFxuXHRcdFx0XHRcdH0pO1xuICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBjdHJsLiRwYXJzZXJzLnVuc2hpZnQodmFsaWRhdGVNYXhMZW5ndGgpO1xuICAgICAgICBjdHJsLiRmb3JtYXR0ZXJzLnB1c2godmFsaWRhdGVNYXhMZW5ndGgpO1xuICAgICAgICBhdHRycy4kb2JzZXJ2ZSgnZ3VtZ2FNYXhMZW5ndGgnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFsaWRhdGVNYXhMZW5ndGgoY3RybC4kdmlld1ZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFuZ3VsYXIubW9kdWxlKCdndW1nYS5kaXJlY3RpdmVzLmZvcm0ubWF4Lmxlbmd0aCcsW10pXG4gIC5kaXJlY3RpdmUoJ2d1bWdhTWF4TGVuZ3RoJyxNYXhMZW5ndGgpO1xufSkoKTtcbiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBAbmdkb2MgZGlyZWN0aXZlXG4gICAqIEBuYW1lIGd1bWdhLmNvcmU6Z3VtZ2FNYXhOdW1iZXJcbiAgICogQGVsZW1lbnQgaW5wdXRcbiAgICogQHJlc3RyaWN0IEFcbiAgICogQHNjb3BlIGZhbHNlXG4gICAqIEBkZXNjcmlwdGlvbiBPIGNvbXBvbmVudGUgR3VtZ2FNYXhOdW1iZXIgc2VydmUgcGFyYSB2YWxpZGFyIG7Dum1lcm9zIG3DoXhpbW9zIGVtIGVudHJhZGFzIGRlIGZvcm11bMOhcmlvcy5cbiAgICpcbiAgICogIyMgTm90YVxuICAgKiBFc3RhIGRpcmV0aXZhIHN1cG9ydGEgYXBlbmFzICoqaW5wdXRzKiogZG8gdGlwbyAqKm51bWJlcioqLiBPIHZhbG9yIGRvIGF0cmlidXRvL2RpcmV0aXZhIMOpICoqb2JyaWdhdMOzcmlvKiogZSBkZXZlIHNlciB1bSAqKm7Dum1lcm8qKi5cbiAgICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGxhYmVsIFVzYWRvIG5hIGludGVncmHDp8OjbyBjb20ge0BsaW5rIGd1bWdhLmNvcmU6Z3VtZ2FFcnJvcnN9IHBhcmEgaW5kaWNhciBlbSBxdWFsIGNhbXBvIHNlIGVuY29udHJhIG8gZXJyby5cblx0ICogU2UgbyBhdHJpYnV0byBmb3Igb21pdGlkbywgYSBkaXJldGl2YSB1c2Fyw6EgbyBhdHJpYnV0byBuYW1lIGRvIGlucHV0LlxuXHQgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgVW0gZXhlbXBsbyBkYSBkaXJlY3RpdmUgR3VtZ2FNYXhOdW1iZXIgZnVuY2lvbmFuZG8gcG9kZSBzZXIgZW5jb250cmFkbyBbYXF1aV0oaHR0cDovL2VtYmVkLnBsbmtyLmNvL0FjanFjZ3ZnR2hkSnFEaDcyZUhBKS5cbiAgICogIDxwcmU+XG4gICAqICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIj5cbiAgICogICAgICA8aW5wdXQgdHlwZT1cIm51bWJlclwiIG5hbWU9XCJtYXhOdW1iZXJcIiBuZy1tb2RlbD1cIm1heE51bWJlclwiIGd1bWdhLW1heC1udW1iZXI9XCIyMFwiPlxuICAgKiAgICAgIDxwIG5nLXNob3c9XCJteUZvcm0ubWF4TnVtYmVyLiRlcnJvci5tYXhudW1iZXJcIiBjbGFzcz1cInRleHQtZGFuZ2VyXCI+TsO6bWVybyBzdXBlcmlvciBhbyBlc3BlcmFkbzwvcD5cbiAgICogICAgPC9mb3JtPlxuICAgKiAgPC9wcmU+XG4gICAqL1xuICAgTWF4TnVtYmVyLiRpbmplY3QgPSBbXTtcbiAgIGZ1bmN0aW9uIE1heE51bWJlcigpIHtcbiAgICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICByZXF1aXJlOiAnbmdNb2RlbCcsXG4gICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsbSwgYXR0cnMsIGN0cmwpIHtcbiAgICAgICBpZiAoYXR0cnMudHlwZSAhPSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyAnRXN0YSBkaXJldGl2YSBzdXBvcnRhIGFwZW5hcyBpbnB1dHMgZG8gdGlwbyBudW1iZXInO1xuICAgICAgfVxuICAgICAgaWYgKCFhdHRycy5ndW1nYU1heE51bWJlcikge1xuICAgICAgICB0aHJvdyBcIk8gdmFsb3IgZGEgZGlyZXRpdmEgZ3VtZ2EtbWF4LW51bWJlciBuw6NvIGZvaSBpbmZvcm1hZG8uXCI7XG4gICAgICB9XG4gICAgICB2YXIgdmFsaWRhdGVNYXhOdW1iZXIgPSBmdW5jdGlvbiAoaW5wdXRWYWx1ZSkge1xuXHRcdFx0XHR2YXIgZXJyb3IgPSAnbWF4bnVtYmVyJztcbiAgICAgICAgdmFyIGlucHV0ID0gcGFyc2VJbnQoaW5wdXRWYWx1ZSk7XG4gICAgICAgIHZhciBtYXggPSBwYXJzZUludChhdHRycy5ndW1nYU1heE51bWJlcik7XG4gICAgICAgIHZhciBpc1ZhbGlkID0gaW5wdXQgPD0gbWF4O1xuICAgICAgICBjdHJsLiRzZXRWYWxpZGl0eShlcnJvciwgaXNWYWxpZCk7XG5cdFx0XHRcdHNjb3BlLiRicm9hZGNhc3QoJyRlcnJvcicsIHtcblx0XHRcdFx0XHRuYW1lOiBhdHRycy5uYW1lLFxuXHRcdFx0XHRcdGxhYmVsOiBhdHRycy5sYWJlbCB8fCBhdHRycy5uYW1lLFxuXHRcdFx0XHRcdHZhbGlkOiBpc1ZhbGlkLFxuXHRcdFx0XHRcdGVycm9yOiBlcnJvcixcblx0XHRcdFx0XHR2YWx1ZTogYXR0cnMuZ3VtZ2FNYXhOdW1iZXJcblx0XHRcdFx0fSk7XG4gICAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xuICAgICAgfTtcbiAgICAgIGN0cmwuJHBhcnNlcnMudW5zaGlmdCh2YWxpZGF0ZU1heE51bWJlcik7XG4gICAgICBjdHJsLiRmb3JtYXR0ZXJzLnB1c2godmFsaWRhdGVNYXhOdW1iZXIpO1xuICAgICAgYXR0cnMuJG9ic2VydmUoJ2d1bWdhTWF4TnVtYmVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YWxpZGF0ZU1heE51bWJlcihjdHJsLiR2aWV3VmFsdWUpO1xuICAgICAgfSk7XG5cbiAgICAgIHNjb3BlLiRvbignY2xlYXJGaWVsZHMnLGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgY3RybC4kbW9kZWxWYWx1ZSA9IG51bGw7XG4gICAgICAgY29uc29sZS5sb2coJ2RpcmVjdGl2ZSBkYXRlIGNsZWFyJyk7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coZWxtKTtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZygpO1xuXHRcdFx0XHR9KTtcbiAgICB9XG4gIH1cbn1cbmFuZ3VsYXIubW9kdWxlKCdndW1nYS5kaXJlY3RpdmVzLmZvcm0ubWF4Lm51bWJlcicsW10pXG4uZGlyZWN0aXZlKCdndW1nYU1heE51bWJlcicsTWF4TnVtYmVyKTtcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogQG5nZG9jIGRpcmVjdGl2ZVxuICAgKiBAbmFtZSBndW1nYS5jb3JlOmd1bWdhTWluRGF0ZVxuICAgKiBAZWxlbWVudCBpbnB1dFxuICAgKiBAcmVzdHJpY3QgQVxuICAgKiBAZGVzY3JpcHRpb24gTyBjb21wb25lbnRlIEd1bWdhTWluRGF0ZSBzZXJ2ZSBwYXJhIHZhbGlkYXIgZGF0YXMgbcOtbmltYXMgZW0gZW50cmFkYXMgZGUgZm9ybXVsw6FyaW9zLlxuICAgKlxuICAgKiAjIyBOb3RhXG4gICAqIEVzdGEgZGlyZXRpdmEgc3Vwb3J0YSBhcGVuYXMgKippbnB1dHMqKiBkbyB0aXBvICoqZGF0ZSoqLiBPIHZhbG9yIGRvIGF0cmlidXRvL2RpcmV0aXZhIMOpICoqb2JyaWdhdMOzcmlvKiogZSBkZXZlIHNlciB1bWEgKipkYXRhKiouXG4gICAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBVc2FkbyBuYSBpbnRlZ3Jhw6fDo28gY29tIHtAbGluayBndW1nYS5jb3JlOmd1bWdhRXJyb3JzfSBwYXJhIGluZGljYXIgZW0gcXVhbCBjYW1wbyBzZSBlbmNvbnRyYSBvIGVycm8uXG5cdCAqIFNlIG8gYXRyaWJ1dG8gZm9yIG9taXRpZG8sIGEgZGlyZXRpdmEgdXNhcsOhIG8gYXRyaWJ1dG8gbmFtZSBkbyBpbnB1dC5cblx0ICpcbiAgICogQGV4YW1wbGVcbiAgICogIFVtIGV4ZW1wbG8gZGEgZGlyZWN0aXZlIEd1bWdhTWluRGF0ZSBmdW5jaW9uYW5kbyBwb2RlIHNlciBlbmNvbnRyYWRvIFthcXVpXShodHRwOi8vZW1iZWQucGxua3IuY28vQWNqcWNndmdHaGRKcURoNzJlSEEpLlxuICAgKiAgPHByZT5cbiAgICogICAgPGZvcm0gbmFtZT1cIm15Rm9ybVwiPlxuICAgKiAgICAgIDxpbnB1dCB0eXBlPVwiZGF0ZVwiIG5hbWU9XCJtaW5EYXRlXCIgbmctbW9kZWw9XCJtaW5EYXRlXCIgZ3VtZ2EtbWluLWRhdGU9XCIyMDE1LTA3LTIwXCI+XG4gICAqICAgICAgPHAgbmctc2hvdz1cIm15Rm9ybS5taW5EYXRlLiRlcnJvci5taW5kYXRlXCIgY2xhc3M9XCJ0ZXh0LWRhbmdlclwiPkRhdGEgaW5mZXJpb3IgYSBlc3BlcmFkYTwvcD5cbiAgICogICAgPC9mb3JtPlxuICAgKiAgPC9wcmU+XG4gICovXG5cdCBNaW5EYXRlLiRpbmplY3QgPSBbXCIkZmlsdGVyXCJdO1xuXHQgZnVuY3Rpb24gTWluRGF0ZSgkZmlsdGVyKSB7XG5cdCBcdHJldHVybiB7XG5cdCBcdFx0cmVzdHJpY3Q6ICdBJyxcblx0IFx0XHRyZXF1aXJlOiAnbmdNb2RlbCcsXG5cdCBcdFx0bGluazogZnVuY3Rpb24gKHNjb3BlLCBlbG0sIGF0dHJzLCBjdHJsKSB7XG5cdCBcdFx0XHRpZiAoYXR0cnMudHlwZSAhPSAnZGF0ZScpIHtcblx0IFx0XHRcdFx0dGhyb3cgJ0VzdGEgZGlyZXRpdmEgc3Vwb3J0YSBhcGVuYXMgaW5wdXRzIGRvIHRpcG8gZGF0ZSc7XG5cdCBcdFx0XHR9XG5cdCBcdFx0XHRpZiAoIWF0dHJzLmd1bWdhTWluRGF0ZSkge1xuXHQgXHRcdFx0XHR0aHJvdyBcIk8gdmFsb3IgZGEgZGlyZXRpdmEgZ3VtZ2EtbWluLWRhdGUgbsOjbyBmb2kgaW5mb3JtYWRvLlwiO1xuXHQgXHRcdFx0fVxuICAgICAgICAvLyBpZiAoIUd1bWdhRGF0ZVNlcnZpY2UudmFsaWRhdGVGb3JtYXQoJ1lNRCcsIGF0dHJzLmd1bWdhTWluRGF0ZSkpIHtcbiAgICAgICAgLy8gICB0aHJvdyAnTyB2YWxvciBkYSBkaXJldGl2YSBuw6NvIGNvcnJlc3BvbmRlIGFvIGZvcm1hdG8geXl5eS1tbS1kZCc7XG4gICAgICAgIC8vIH1cbiAgICAgICAgdmFyIHZhbGlkYXRlTWluRGF0ZSA9IGZ1bmN0aW9uIChpbnB1dFZhbHVlKSB7XG5cdFx0XHRcdFx0dmFyIGVycm9yID0gJ21pbmRhdGUnO1xuXHRcdFx0XHRcdHZhciBmb3JtYXQgPSAneXl5eS1NTS1kZCc7XG5cdFx0XHRcdFx0dmFyIGlucHV0ID0gJGZpbHRlcignZGF0ZScpKGlucHV0VmFsdWUsIGZvcm1hdCk7XG5cdFx0XHRcdFx0dmFyIG1pbiA9ICRmaWx0ZXIoJ2RhdGUnKShhdHRycy5ndW1nYU1pbkRhdGUsIGZvcm1hdCk7XG5cdFx0XHRcdFx0dmFyIGlzVmFsaWQgPSBpbnB1dCA+PSBtaW47XG5cdFx0XHRcdFx0Y3RybC4kc2V0VmFsaWRpdHkoZXJyb3IsIGlzVmFsaWQpO1xuXHRcdFx0XHRcdHNjb3BlLiRicm9hZGNhc3QoJyRlcnJvcicsIHtcblx0XHRcdFx0XHRcdG5hbWU6IGF0dHJzLm5hbWUsXG5cdFx0XHRcdFx0XHRsYWJlbDogYXR0cnMubGFiZWwgfHwgYXR0cnMubmFtZSxcblx0XHRcdFx0XHRcdHZhbGlkOiBpc1ZhbGlkLFxuXHRcdFx0XHRcdFx0ZXJyb3I6IGVycm9yLFxuXHRcdFx0XHRcdFx0dmFsdWU6IGF0dHJzLmd1bWdhTWluRGF0ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJldHVybiBpbnB1dFZhbHVlO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRjdHJsLiRwYXJzZXJzLnVuc2hpZnQodmFsaWRhdGVNaW5EYXRlKTtcblx0XHRcdFx0Y3RybC4kZm9ybWF0dGVycy5wdXNoKHZhbGlkYXRlTWluRGF0ZSk7XG5cdFx0XHRcdGF0dHJzLiRvYnNlcnZlKCdndW1nYU1pbkRhdGUnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFsaWRhdGVNaW5EYXRlKGN0cmwuJHZpZXdWYWx1ZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtLm1pbi5kYXRlJyxbXSlcblx0LmRpcmVjdGl2ZSgnZ3VtZ2FNaW5EYXRlJyxNaW5EYXRlKTtcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogQG5nZG9jIGRpcmVjdGl2ZVxuICAgKiBAbmFtZSBndW1nYS5jb3JlOmd1bWdhTWluTGVuZ3RoXG4gICAqIEBlbGVtZW50IGlucHV0XG4gICAqIEByZXN0cmljdCBBXG4gICAqIEBkZXNjcmlwdGlvbiBPIGNvbXBvbmVudGUgR3VtZ2FNaW5MZW5ndGggc2VydmUgcGFyYSB2YWxpZGFyIHF1YW50aWRhZGVzIG3DrW5pbWFzIGRlIGNhcmFjdGVyZXMgZW0gZW50cmFkYXMgZGUgZm9ybXVsw6FyaW9zLlxuICAgKlxuICAgKiAjIyBOb3RhXG4gICAqIE8gdmFsb3IgZG8gYXRyaWJ1dG8vZGlyZXRpdmEgw6kgKipvYnJpZ2F0w7NyaW8qKiBlIGRldmUgc2VyIHVtICoqbsO6bWVybyoqLlxuICAgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbGFiZWwgVXNhZG8gbmEgaW50ZWdyYcOnw6NvIGNvbSB7QGxpbmsgZ3VtZ2EuY29yZTpndW1nYUVycm9yc30gcGFyYSBpbmRpY2FyIGVtIHF1YWwgY2FtcG8gc2UgZW5jb250cmEgbyBlcnJvLlxuXHQgKiBTZSBvIGF0cmlidXRvIGZvciBvbWl0aWRvLCBhIGRpcmV0aXZhIHVzYXLDoSBvIGF0cmlidXRvIG5hbWUgZG8gaW5wdXQuXG5cdCAqXG4gICAqIEBleGFtcGxlXG4gICAqICBVbSBleGVtcGxvIGRhIGRpcmVjdGl2ZSBHdW1nYU1pbkxlbmd0aCBmdW5jaW9uYW5kbyBwb2RlIHNlciBlbmNvbnRyYWRvIFthcXVpXShodHRwOi8vZW1iZWQucGxua3IuY28vQWNqcWNndmdHaGRKcURoNzJlSEEpLlxuICAgKiAgPHByZT5cbiAgICogICAgPGZvcm0gbmFtZT1cIm15Rm9ybVwiPlxuICAgKiAgICAgIDxpbnB1dCB0eXBlPVwiZGF0ZVwiIG5hbWU9XCJtaW5MZW5ndGhcIiBuZy1tb2RlbD1cIm1pbkxlbmd0aFwiIGd1bWdhLW1pbi1sZW5ndGg9XCIyMFwiIGlkPVwibWluTGVuZ3RoXCI+XG4gICAqICAgICAgPHAgbmctc2hvdz1cIm15Rm9ybS5taW5MZW5ndGguJGVycm9yLm1pbmxlbmd0aFwiIGNsYXNzPVwidGV4dC1kYW5nZXJcIj5UYW1hbmhvIGluZmVyaW9yIGFvIGVzcGVyYWRvPC9wPlxuICAgKiAgICA8L2Zvcm0+XG4gICAqICA8L3ByZT5cbiAgKi9cblx0TWluTGVuZ3RoLiRpbmplY3QgPSBbXTtcblx0ZnVuY3Rpb24gTWluTGVuZ3RoKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgcmVxdWlyZTogJ25nTW9kZWwnLFxuICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbG0sIGF0dHJzLCBjdHJsKSB7XG4gICAgICAgIGlmICghYXR0cnMuZ3VtZ2FNaW5MZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBcIk8gdmFsb3IgZGEgZGlyZXRpdmEgZ3VtZ2EtbWluLWxlbmd0aCBuw6NvIGZvaSBpbmZvcm1hZG8uXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbGlkYXRlTWluTGVuZ3RoID0gZnVuY3Rpb24gKGlucHV0VmFsdWUpIHtcblx0XHRcdFx0XHR2YXIgZXJyb3IgPSAnbWlubGVuZ3RoJztcbiAgICAgICAgICB2YXIgaW5wdXQgPSAoaW5wdXRWYWx1ZSA9PSB1bmRlZmluZWQpID8gLTEgOiBpbnB1dFZhbHVlLmxlbmd0aDtcbiAgICAgICAgICB2YXIgbWluID0gYXR0cnMuZ3VtZ2FNaW5MZW5ndGg7XG4gICAgICAgICAgdmFyIGlzVmFsaWQgPSBpbnB1dCA+PSBtaW47XG4gICAgICAgICAgY3RybC4kc2V0VmFsaWRpdHkoZXJyb3IsIGlzVmFsaWQpO1xuXHRcdFx0XHRcdHNjb3BlLiRicm9hZGNhc3QoJyRlcnJvcicsIHtcblx0XHRcdFx0XHRcdG5hbWU6IGF0dHJzLm5hbWUsXG5cdFx0XHRcdFx0XHRsYWJlbDogYXR0cnMubGFiZWwgfHwgYXR0cnMubmFtZSxcblx0XHRcdFx0XHRcdHZhbGlkOiBpc1ZhbGlkLFxuXHRcdFx0XHRcdFx0ZXJyb3I6IGVycm9yLFxuXHRcdFx0XHRcdFx0dmFsdWU6IGF0dHJzLmd1bWdhTWluTGVuZ3RoXG5cdFx0XHRcdFx0fSk7XG4gICAgICAgICAgcmV0dXJuIGlucHV0VmFsdWU7XG4gICAgICAgIH07XG5cdCBcdFx0XHRjdHJsLiRwYXJzZXJzLnVuc2hpZnQodmFsaWRhdGVNaW5MZW5ndGgpO1xuXHQgXHRcdFx0Y3RybC4kZm9ybWF0dGVycy5wdXNoKHZhbGlkYXRlTWluTGVuZ3RoKTtcblx0IFx0XHRcdGF0dHJzLiRvYnNlcnZlKCdndW1nYU1pbkxlbmd0aCcsIGZ1bmN0aW9uICgpIHtcblx0IFx0XHRcdFx0dmFsaWRhdGVNaW5MZW5ndGgoY3RybC4kdmlld1ZhbHVlKTtcblx0IFx0XHRcdH0pO1xuXHQgXHRcdH1cblx0IFx0fVxuXHQgfVxuXHQgYW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMuZm9ybS5taW4ubGVuZ3RoJyxbXSlcblx0IC5kaXJlY3RpdmUoJ2d1bWdhTWluTGVuZ3RoJyxNaW5MZW5ndGgpO1xuXHR9KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAgICogQG5hbWUgZ3VtZ2EuY29yZTpndW1nYU1pbk51bWJlclxuICAgKiBAZWxlbWVudCBpbnB1dFxuICAgKiBAcmVzdHJpY3QgQVxuICAgKiBAZGVzY3JpcHRpb24gTyBjb21wb25lbnRlIEd1bWdhTWluTnVtYmVyIHNlcnZlIHBhcmEgdmFsaWRhciBuw7ptZXJvcyBtw61uaW1vcyBwYXJhIGVudHJhZGFzIGVtIGZvcm11bMOhcmlvcy5cbiAgICpcbiAgICogIyMgTm90YVxuICAgKiBFc3RhIGRpcmV0aXZhIHN1cG9ydGEgYXBlbmFzICoqaW5wdXRzKiogZG8gdGlwbyAqKm51bWJlcioqLiBPIHZhbG9yIGRvIGF0cmlidXRvL2RpcmV0aXZhIMOpICoqb2JyaWdhdMOzcmlvKiogZSBkZXZlIHNlciB1bSAqKm7Dum1lcm8qKi5cbiAgICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGxhYmVsIFVzYWRvIG5hIGludGVncmHDp8OjbyBjb20ge0BsaW5rIGd1bWdhLmNvcmU6Z3VtZ2FFcnJvcnN9IHBhcmEgaW5kaWNhciBlbSBxdWFsIGNhbXBvIHNlIGVuY29udHJhIG8gZXJyby5cblx0ICogU2UgbyBhdHJpYnV0byBmb3Igb21pdGlkbywgYSBkaXJldGl2YSB1c2Fyw6EgbyBhdHJpYnV0byBuYW1lIGRvIGlucHV0LlxuXHQgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgVW0gZXhlbXBsbyBkYSBkaXJlY3RpdmUgR3VtZ2FNaW5OdW1iZXIgZnVuY2lvbmFuZG8gcG9kZSBzZXIgZW5jb250cmFkbyBbYXF1aV0oaHR0cDovL2VtYmVkLnBsbmtyLmNvL0FjanFjZ3ZnR2hkSnFEaDcyZUhBKS5cbiAgICogIDxwcmU+XG4gICAqICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIj5cbiAgICogICAgICA8aW5wdXQgdHlwZT1cIm51bWJlclwiIG5hbWU9XCJtaW5OdW1iZXJcIiBuZy1tb2RlbD1cIm1pbk51bWJlclwiIGd1bWdhLW1pbi1udW1iZXI9XCIyMFwiPlxuICAgKiAgICAgIDxwIG5nLXNob3c9XCJteUZvcm0ubWluTnVtYmVyLiRlcnJvci5taW5udW1iZXJcIiBjbGFzcz1cInRleHQtZGFuZ2VyXCI+TsO6bWVybyBpbmZlcmlvciBhbyBlc3BlcmFkbzwvcD5cbiAgICogICAgPC9mb3JtPlxuICAgKiAgPC9wcmU+XG4gICovXG5cdCBNaW5OdW1iZXIuJGluamVjdCA9IFtdO1xuXHQgZnVuY3Rpb24gTWluTnVtYmVyKCkge1xuXHQgXHRyZXR1cm4ge1xuXHQgXHRcdHJlc3RyaWN0OiAnQScsXG5cdCBcdFx0cmVxdWlyZTogJ25nTW9kZWwnLFxuXHQgXHRcdGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxtLCBhdHRycywgY3RybCkge1xuXHQgXHRcdFx0aWYgKGF0dHJzLnR5cGUgIT0gJ251bWJlcicpIHtcblx0IFx0XHRcdFx0dGhyb3cgJ0VzdGEgZGlyZXRpdmEgc3Vwb3J0YSBhcGVuYXMgaW5wdXRzIGRvIHRpcG8gbnVtYmVyJztcblx0IFx0XHRcdH1cblx0IFx0XHRcdGlmICghYXR0cnMuZ3VtZ2FNaW5OdW1iZXIpIHtcblx0IFx0XHRcdFx0dGhyb3cgXCJPIHZhbG9yIGRhIGRpcmV0aXZhIGd1bWdhLW1pbi1udW1iZXIgbsOjbyBmb2kgaW5mb3JtYWRvLlwiO1xuXHQgXHRcdFx0fVxuXHQgXHRcdFx0dmFyIHZhbGlkYXRlTWluTnVtYmVyID0gZnVuY3Rpb24gKGlucHV0VmFsdWUpIHtcblx0XHRcdFx0XHR2YXIgZXJyb3IgPSAnbWlubnVtYmVyJztcblx0IFx0XHRcdFx0dmFyIGlucHV0ID0gcGFyc2VJbnQoaW5wdXRWYWx1ZSk7XG5cdCBcdFx0XHRcdHZhciBtaW4gPSBwYXJzZUludChhdHRycy5ndW1nYU1pbk51bWJlcik7XG5cdCBcdFx0XHRcdHZhciBpc1ZhbGlkID0gaW5wdXQgPj0gbWluO1xuXHQgXHRcdFx0XHRjdHJsLiRzZXRWYWxpZGl0eShlcnJvciwgaXNWYWxpZCk7XG5cdFx0XHRcdFx0c2NvcGUuJGJyb2FkY2FzdCgnJGVycm9yJywge1xuXHRcdFx0XHRcdFx0bmFtZTogYXR0cnMubmFtZSxcblx0XHRcdFx0XHRcdGxhYmVsOiBhdHRycy5sYWJlbCB8fCBhdHRycy5uYW1lLFxuXHRcdFx0XHRcdFx0dmFsaWQ6IGlzVmFsaWQsXG5cdFx0XHRcdFx0XHRlcnJvcjogZXJyb3IsXG5cdFx0XHRcdFx0XHR2YWx1ZTogYXR0cnMuZ3VtZ2FNaW5OdW1iZXJcblx0XHRcdFx0XHR9KTtcblx0IFx0XHRcdFx0cmV0dXJuIGlucHV0VmFsdWU7XG5cdCBcdFx0XHR9O1xuXHQgXHRcdFx0Y3RybC4kcGFyc2Vycy51bnNoaWZ0KHZhbGlkYXRlTWluTnVtYmVyKTtcblx0IFx0XHRcdGN0cmwuJGZvcm1hdHRlcnMucHVzaCh2YWxpZGF0ZU1pbk51bWJlcik7XG5cdCBcdFx0XHRhdHRycy4kb2JzZXJ2ZSgnZ3VtZ2FNaW5OdW1iZXInLCBmdW5jdGlvbiAoKSB7XG5cdCBcdFx0XHRcdHZhbGlkYXRlTWluTnVtYmVyKGN0cmwuJHZpZXdWYWx1ZSk7XG5cdCBcdFx0XHR9KTtcblx0IFx0XHR9XG5cdCBcdH1cblx0IH1cblx0IGFuZ3VsYXIubW9kdWxlKCdndW1nYS5kaXJlY3RpdmVzLmZvcm0ubWluLm51bWJlcicsW10pXG5cdCAuZGlyZWN0aXZlKCdndW1nYU1pbk51bWJlcicsTWluTnVtYmVyKTtcblx0fSkoKTtcbiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBAbmdkb2MgZGlyZWN0aXZlXG4gICAqIEBuYW1lIGd1bWdhLmNvcmU6Z3VtZ2FQYXR0ZXJuXG4gICAqIEBlbGVtZW50IGlucHV0XG4gICAqIEByZXN0cmljdCBBXG4gICAqIEBkZXNjcmlwdGlvbiBPIGNvbXBvbmVudGUgR3VtZ2FQYXR0ZXJuIHNlcnZlIHBhcmEgdmFsaWRhciBleHByZXNzw7VlcyByZWd1bGFyZXMgZGUgZm9ybXVsw6FyaW9zLlxuICAgKlxuICAgKiAjIyBOb3RhXG4gICAqIE8gdmFsb3IgZG8gYXRyaWJ1dG8vZGlyZXRpdmEgw6kgKipvYnJpZ2F0w7NyaW8qKiBlIGRldmUgc2VyIHVtYSAqKmV4cHJlc3PDo28gcmVndWxhcioqLlxuICAgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbGFiZWwgVXNhZG8gbmEgaW50ZWdyYcOnw6NvIGNvbSB7QGxpbmsgZ3VtZ2EuY29yZTpndW1nYUVycm9yc30gcGFyYSBpbmRpY2FyIGVtIHF1YWwgY2FtcG8gc2UgZW5jb250cmEgbyBlcnJvLlxuXHQgKiBTZSBvIGF0cmlidXRvIGZvciBvbWl0aWRvLCBhIGRpcmV0aXZhIHVzYXLDoSBvIGF0cmlidXRvIG5hbWUgZG8gaW5wdXQuXG5cdCAqXG4gICAqIEBleGFtcGxlXG4gICAqICBVbSBleGVtcGxvIGRhIGRpcmVjdGl2ZSBHdW1nYVBhdHRlcm4gZnVuY2lvbmFuZG8gcG9kZSBzZXIgZW5jb250cmFkbyBbYXF1aV0oaHR0cDovL2VtYmVkLnBsbmtyLmNvL0FjanFjZ3ZnR2hkSnFEaDcyZUhBKS5cbiAgICogIDxwcmU+XG4gICAqICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIj5cbiAgICogICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwiY2VwXCIgbmctbW9kZWw9XCJjZXBcIiBndW1nYS1wYXR0ZXJuPVwiKFxcZHs1fSlcXC0oXFxkezN9KVwiIGlkPVwiY2VwXCIgcGxhY2Vob2xkZXI9XCI5OTk5OS05OTlcIj5cbiAgICogICAgICA8cCBuZy1zaG93PVwibXlGb3JtLmNlcC4kZXJyb3IucGF0dGVyblwiIGNsYXNzPVwidGV4dC1kYW5nZXJcIj5FeHByZXNzw6NvIG7Do28gY29ycmVzcG9uZGUgY29tIG8gZm9ybWF0byBlc3BlcmFkbzwvcD5cbiAgICogICAgPC9mb3JtPlxuICAgKiAgPC9wcmU+XG4gICovXG5cdFBhdHRlcm4uJGluamVjdCA9IFtdO1xuICBmdW5jdGlvbiBQYXR0ZXJuKCkge1xuICAgIHJldHVybiB7XG5cdFx0XHRyZXN0cmljdDogJ0EnLFxuXHQgXHRcdHJlcXVpcmU6ICduZ01vZGVsJyxcbiAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxtLCBhdHRycywgY3RybCkge1xuXHRcdFx0XHRpZiAoIWF0dHJzLmd1bWdhUGF0dGVybikge1xuXHRcdFx0XHRcdHRocm93IFwiTyB2YWxvciBkYSBkaXJldGl2YSBndW1nYS1wYXR0ZXJuIG7Do28gZm9pIGluZm9ybWFkby5cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgdmFsaWRhdGVQYXR0ZXJuID0gZnVuY3Rpb24gKGlucHV0VmFsdWUpIHtcblx0XHRcdFx0XHR2YXIgZXJyb3IgPSAncGF0dGVybic7XG5cdFx0XHRcdFx0dmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnXicgKyBhdHRycy5ndW1nYVBhdHRlcm4gKyAnJCcpO1xuXHRcdFx0XHRcdHZhciBpc1ZhbGlkID0gcmVnZXgudGVzdChpbnB1dFZhbHVlKTtcblx0XHRcdFx0XHRjdHJsLiRzZXRWYWxpZGl0eShlcnJvciwgaXNWYWxpZCk7XG5cdFx0XHRcdFx0c2NvcGUuJGJyb2FkY2FzdCgnJGVycm9yJywge1xuXHRcdFx0XHRcdFx0bmFtZTogYXR0cnMubmFtZSxcblx0XHRcdFx0XHRcdGxhYmVsOiBhdHRycy5sYWJlbCB8fCBhdHRycy5uYW1lLFxuXHRcdFx0XHRcdFx0dmFsaWQ6IGlzVmFsaWQsXG5cdFx0XHRcdFx0XHRlcnJvcjogZXJyb3IsXG5cdFx0XHRcdFx0XHR2YWx1ZTogYXR0cnMucGF0dGVybkFsaWFzIHx8IGF0dHJzLmd1bWdhUGF0dGVyblxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJldHVybiBpbnB1dFZhbHVlO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRjdHJsLiRwYXJzZXJzLnVuc2hpZnQodmFsaWRhdGVQYXR0ZXJuKTtcblx0XHRcdFx0Y3RybC4kZm9ybWF0dGVycy5wdXNoKHZhbGlkYXRlUGF0dGVybik7XG5cdFx0XHRcdGF0dHJzLiRvYnNlcnZlKCdndW1nYVBhdHRlcm4nLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFsaWRhdGVQYXR0ZXJuKGN0cmwuJHZpZXdWYWx1ZSk7XG5cdFx0XHRcdH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtLnBhdHRlcm4nLFtdKVxuICAuZGlyZWN0aXZlKCdndW1nYVBhdHRlcm4nLFBhdHRlcm4pO1xufSkoKTtcbiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBAbmdkb2MgZGlyZWN0aXZlXG4gICAqIEBuYW1lIGd1bWdhLmNvcmU6Z3VtZ2FSYW5nZURhdGVcbiAgICogQHJlc3RyaWN0IEFcbiAgICogQGVsZW1lbnQgaW5wdXRcbiAgICogQGRlc2NyaXB0aW9uXG5cdCAqIE8gY29tcG9uZW50ZSBHdW1nYVJhbmdlRGF0ZSBzZXJ2ZSBwYXJhIHZhbGlkYXIgZGF0YXMgbcOtbmltYXMgZSBtw6F4aW1hcyBwYXJhIGVudHJhZGFzIGVtIGZvcm11bMOhcmlvcyBjb20gY2FtcG9zIGRvIHRpcG8gZGF0ZS5cbiAgICpcbiAgICogIyMgTm90YVxuICAgKiBPIHZhbG9yIGRvIGF0cmlidXRvL2RpcmV0aXZhIMOpICoqb2JyaWdhdMOzcmlvKiogZSBkZXZlIHNlciB1bSAqKm9iamV0byoqIGNvbnRlbmRvIGR1YXMgcHJvcHJpZWRhZGVzLCAqKm1pbioqIGUgKiptYXgqKlxuICAgKiBjb20gb3MgdmFsb3JlcyBkZSBzdWFzIHJlc3BlY3RpdmFzIGRhdGFzIHBhcmEgZXhlY3XDp8OjbyBkYSB2YWxpZGHDp8OjbyByYW5nZS5cbiAgICpcbiAgICogIyMgRXhlbXBsb1xuICAgKiBVbSBleGVtcGxvIGRhIGRpcmVjdGl2ZSBHdW1nYVJhbmdlRGF0ZSBmdW5jaW9uYW5kbyBwb2RlIHNlciBlbmNvbnRyYWRvIFthcXVpXShodHRwOi8vZW1iZWQucGxua3IuY28vQWNqcWNndmdHaGRKcURoNzJlSEEpLlxuICAgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbGFiZWwgVXNhZG8gbmEgaW50ZWdyYcOnw6NvIGNvbSB7QGxpbmsgZ3VtZ2EuY29yZTpndW1nYUVycm9yc30gcGFyYSBpbmRpY2FyIGVtIHF1YWwgY2FtcG8gc2UgZW5jb250cmEgbyBlcnJvLlxuXHQgKiBTZSBvIGF0cmlidXRvIGZvciBvbWl0aWRvLCBhIGRpcmV0aXZhIHVzYXLDoSBvIGF0cmlidXRvIG5hbWUgZG8gaW5wdXQuXG5cdCAqXG4gICAqIEBleGFtcGxlXG4gICAqICA8cHJlPlxuICAgKiAgICA8Zm9ybSBuYW1lPVwibXlGb3JtXCI+XG4gICAqICAgICAgPGlucHV0IHR5cGU9XCJkYXRlXCIgbmFtZT1cInJhbmdlRGF0ZVwiIG5nLW1vZGVsPVwicmFuZ2VEYXRlXCIgZ3VtZ2EtcmFuZ2UtZGF0ZT1cInttaW46ICcxOTg2LTEyLTI5JywgbWF4OiAnMjAxNS0wNy0yMCd9XCIgaWQ9XCJyYW5nZWRhdGVcIj5cbiAgICogICAgICA8cCBuZy1zaG93PVwibXlGb3JtLmNlcC4kZXJyb3IucmFuZ2VkYXRlXCIgY2xhc3M9XCJ0ZXh0LWRhbmdlclwiPkEgZGF0YSBpbmZvcm1hZGEgbsOjbyBlc3TDoSBlbnRyZSBvcyB2YWxvcmVzIGVzcGVyYWRvczwvcD5cbiAgICogICAgPC9mb3JtPlxuICAgKiAgPC9wcmU+XG5cdCAqL1xuXHQgUmFuZ2VEYXRlLiRpbmplY3QgPSBbXCIkZmlsdGVyXCJdO1xuXHQgZnVuY3Rpb24gUmFuZ2VEYXRlKCRmaWx0ZXIpIHtcblx0IFx0cmV0dXJuIHtcblx0IFx0XHRyZXN0cmljdDogJ0EnLFxuXHQgXHRcdHJlcXVpcmU6ICduZ01vZGVsJyxcblx0IFx0XHRsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsbSwgYXR0cnMsIGN0cmwpIHtcblx0IFx0XHRcdGlmIChhdHRycy50eXBlICE9ICdkYXRlJykge1xuXHQgXHRcdFx0XHR0aHJvdyAnRXN0YSBkaXJldGl2YSBzdXBvcnRhIGFwZW5hcyBpbnB1dHMgZG8gdGlwbyBkYXRlJztcblx0IFx0XHRcdH1cblx0IFx0XHRcdGlmICghYXR0cnMuZ3VtZ2FSYW5nZURhdGUpIHtcblx0IFx0XHRcdFx0dGhyb3cgXCJPIHZhbG9yIGRhIGRpcmV0aXZhIGd1bWdhLXJhbmdlLWRhdGUgbsOjbyBmb2kgaW5mb3JtYWRvLlwiO1xuXHQgXHRcdFx0fVxuICAgICAgICB2YXIgdmFsaWRhdGVSYW5nZURhdGUgPSBmdW5jdGlvbiAoaW5wdXRWYWx1ZSkge1xuXHRcdFx0XHRcdHZhciBlcnJvciA9ICdyYW5nZWRhdGUnO1xuICAgICAgICAgIHZhciBmb3JtYXQgPSAneXl5eS1NTS1kZCc7XG4gICAgICAgICAgdmFyIHJhbmdlID0gc2NvcGUuJGV2YWwoYXR0cnMuZ3VtZ2FSYW5nZURhdGUpO1xuICAgICAgICBcdHZhciBpbnB1dCA9ICRmaWx0ZXIoJ2RhdGUnKShpbnB1dFZhbHVlLCBmb3JtYXQpO1xuICAgICAgICAgIHZhciBtaW4gPSAkZmlsdGVyKCdkYXRlJykocmFuZ2UubWluLCBmb3JtYXQpO1xuICAgICAgICBcdHZhciBtYXggPSAkZmlsdGVyKCdkYXRlJykocmFuZ2UubWF4LCBmb3JtYXQpO1xuICAgICAgICBcdHZhciBpc1ZhbGlkID0gaW5wdXQgPj0gbWluICYmIGlucHV0IDw9IG1heDtcbiAgICAgICAgXHRjdHJsLiRzZXRWYWxpZGl0eShlcnJvciwgaXNWYWxpZCk7XG5cdFx0XHRcdFx0c2NvcGUuJGJyb2FkY2FzdCgnJGVycm9yJywge1xuXHRcdFx0XHRcdFx0bmFtZTogYXR0cnMubmFtZSxcblx0XHRcdFx0XHRcdGxhYmVsOiBhdHRycy5sYWJlbCB8fCBhdHRycy5uYW1lLFxuXHRcdFx0XHRcdFx0dmFsaWQ6IGlzVmFsaWQsXG5cdFx0XHRcdFx0XHRlcnJvcjogZXJyb3IsXG5cdFx0XHRcdFx0XHR2YWx1ZTogYXR0cnMuZ3VtZ2FSYW5nZURhdGVcblx0XHRcdFx0XHR9KTtcbiAgICAgICAgXHRyZXR1cm4gaW5wdXRWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgY3RybC4kcGFyc2Vycy51bnNoaWZ0KHZhbGlkYXRlUmFuZ2VEYXRlKTtcbiAgICAgICAgY3RybC4kZm9ybWF0dGVycy5wdXNoKHZhbGlkYXRlUmFuZ2VEYXRlKTtcbiAgICAgICAgYXR0cnMuJG9ic2VydmUoJ2d1bWdhUmFuZ2VEYXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBcdHZhbGlkYXRlUmFuZ2VEYXRlKGN0cmwuJHZpZXdWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtLnJhbmdlLmRhdGUnLFtdKVxuICAuZGlyZWN0aXZlKCdndW1nYVJhbmdlRGF0ZScsUmFuZ2VEYXRlKTtcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogQG5nZG9jIGRpcmVjdGl2ZVxuICAgKiBAbmFtZSBndW1nYS5jb3JlOmd1bWdhUmFuZ2VOdW1iZXJcbiAgICogQHJlc3RyaWN0IEFcbiAgICogQGVsZW1lbnQgaW5wdXRcbiAgICogQGRlc2NyaXB0aW9uXG5cdCAqIE8gY29tcG9uZW50ZSBHdW1nYVJhbmdlTnVtYmVyIHNlcnZlIHBhcmEgdmFsaWRhciBuw7ptZXJvcyBtw61uaW1vcyBlIG3DoXhpbW9zIGVtIGVudHJhZGFzIGRlIGZvcm11bMOhcmlvcyBjb20gY2FtcG9zIGRvIHRpcG8gbnVtYmVyLlxuICAgKlxuICAgKiAjIyBOb3RhXG4gICAqIE8gdmFsb3IgZG8gYXRyaWJ1dG8vZGlyZXRpdmEgw6kgKipvYnJpZ2F0w7NyaW8qKiBlIGRldmUgc2VyIHVtICoqb2JqZXRvKiogY29udGVuZG8gZHVhcyBwcm9wcmllZGFkZXMsICoqbWluKiogZSAqKm1heCoqXG4gICAqIGNvbSBvcyB2YWxvcmVzIGRlIHN1YXMgcmVzcGVjdGl2YXMgZGF0YXMgcGFyYSBleGVjdcOnw6NvIGRhIHZhbGlkYcOnw6NvIHJhbmdlLlxuICAgKlxuICAgKiAjIyBFeGVtcGxvXG4gICAqIFVtIGV4ZW1wbG8gZGEgZGlyZWN0aXZlIEd1bWdhUmFuZ2VOdW1iZXIgZnVuY2lvbmFuZG8gcG9kZSBzZXIgZW5jb250cmFkbyBbYXF1aV0oaHR0cDovL2VtYmVkLnBsbmtyLmNvL0FjanFjZ3ZnR2hkSnFEaDcyZUhBKS5cbiAgICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGxhYmVsIFVzYWRvIG5hIGludGVncmHDp8OjbyBjb20ge0BsaW5rIGd1bWdhLmNvcmU6Z3VtZ2FFcnJvcnN9IHBhcmEgaW5kaWNhciBlbSBxdWFsIGNhbXBvIHNlIGVuY29udHJhIG8gZXJyby5cblx0ICogU2UgbyBhdHJpYnV0byBmb3Igb21pdGlkbywgYSBkaXJldGl2YSB1c2Fyw6EgbyBhdHJpYnV0byBuYW1lIGRvIGlucHV0LlxuXHQgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgPHByZT5cbiAgICogICAgPGZvcm0gbmFtZT1cIm15Rm9ybVwiPlxuICAgKiAgICAgIDxpbnB1dCB0eXBlPVwiZGF0ZVwiIG5hbWU9XCJyYW5nZU51bWJlclwiIG5nLW1vZGVsPVwicmFuZ2VOdW1iZXJcIiBndW1nYS1udW1iZXItZGF0ZT1cInttaW46IDAsIG1heDogMjB9XCI+XG4gICAqICAgICAgPHAgbmctc2hvdz1cIm15Rm9ybS5yYW5nZU51bWJlci4kZXJyb3IucmFuZ2VudW1iZXJcIiBjbGFzcz1cInRleHQtZGFuZ2VyXCI+TyBuw7ptZXJvIGluZm9ybWFkbyBuw6NvIGVzdMOhIGVudHJlIG9zIHZhbG9yZXMgZXNwZXJhZG9zPC9wPlxuICAgKiAgICA8L2Zvcm0+XG4gICAqICA8L3ByZT5cblx0ICovXG5cdCBSYW5nZU51bWJlci4kaW5qZWN0ID0gW107XG5cdCBmdW5jdGlvbiBSYW5nZU51bWJlcigpIHtcblx0IFx0cmV0dXJuIHtcblx0IFx0XHRyZXN0cmljdDogJ0EnLFxuXHQgXHRcdHJlcXVpcmU6ICduZ01vZGVsJyxcblx0IFx0XHRsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsbSwgYXR0cnMsIGN0cmwpIHtcblx0IFx0XHRcdGlmIChhdHRycy50eXBlICE9ICdudW1iZXInKSB7XG5cdCBcdFx0XHRcdHRocm93ICdFc3RhIGRpcmV0aXZhIHN1cG9ydGEgYXBlbmFzIGlucHV0cyBkbyB0aXBvIG51bWJlcic7XG5cdCBcdFx0XHR9XG5cdCBcdFx0XHRpZiAoIWF0dHJzLmd1bWdhUmFuZ2VOdW1iZXIpIHtcblx0IFx0XHRcdFx0dGhyb3cgXCJPIHZhbG9yIGRhIGRpcmV0aXZhIGd1bWdhLXJhbmdlLW51bWJlciBuw6NvIGZvaSBpbmZvcm1hZG8uXCI7XG5cdCBcdFx0XHR9XG5cdCBcdFx0XHR2YXIgdmFsaWRhdGVSYW5nZU51bWJlciA9IGZ1bmN0aW9uIChpbnB1dFZhbHVlKSB7XG5cdFx0XHRcdFx0dmFyIGVycm9yID0gJ3JhbmdlbnVtYmVyJztcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBzY29wZS4kZXZhbChhdHRycy5ndW1nYVJhbmdlTnVtYmVyKTtcbiAgICAgICAgICB2YXIgaW5wdXQgPSBwYXJzZUludChpbnB1dFZhbHVlKTtcbiAgICAgICAgICB2YXIgaXNWYWxpZCA9IGlucHV0ID49IHJhbmdlLm1pbiAmJiBpbnB1dCA8PSByYW5nZS5tYXg7XG4gICAgICAgICAgY3RybC4kc2V0VmFsaWRpdHkoZXJyb3IsIGlzVmFsaWQpO1xuXHRcdFx0XHRcdHNjb3BlLiRicm9hZGNhc3QoJyRlcnJvcicsIHtcblx0XHRcdFx0XHRcdG5hbWU6IGF0dHJzLm5hbWUsXG5cdFx0XHRcdFx0XHRsYWJlbDogYXR0cnMubGFiZWwgfHwgYXR0cnMubmFtZSxcblx0XHRcdFx0XHRcdHZhbGlkOiBpc1ZhbGlkLFxuXHRcdFx0XHRcdFx0ZXJyb3I6IGVycm9yLFxuXHRcdFx0XHRcdFx0dmFsdWU6IGF0dHJzLmd1bWdhUmFuZ2VOdW1iZXJcblx0XHRcdFx0XHR9KTtcblx0IFx0XHRcdFx0cmV0dXJuIGlucHV0VmFsdWU7XG5cdCBcdFx0XHR9O1xuXHQgXHRcdFx0Y3RybC4kcGFyc2Vycy51bnNoaWZ0KHZhbGlkYXRlUmFuZ2VOdW1iZXIpO1xuXHQgXHRcdFx0Y3RybC4kZm9ybWF0dGVycy5wdXNoKHZhbGlkYXRlUmFuZ2VOdW1iZXIpO1xuXHQgXHRcdFx0YXR0cnMuJG9ic2VydmUoJ2d1bWdhUmFuZ2VOdW1iZXInLCBmdW5jdGlvbiAoKSB7XG5cdCBcdFx0XHRcdHZhbGlkYXRlUmFuZ2VOdW1iZXIoY3RybC4kdmlld1ZhbHVlKTtcblx0IFx0XHRcdH0pO1xuXHQgXHRcdH1cblx0IFx0fVxuXHQgfVxuXHQgYW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMuZm9ybS5yYW5nZS5udW1iZXInLFtdKVxuXHQgLmRpcmVjdGl2ZSgnZ3VtZ2FSYW5nZU51bWJlcicsUmFuZ2VOdW1iZXIpO1xuXHR9KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAgICogQG5hbWUgZ3VtZ2EuY29yZTpndW1nYVJlcXVpcmVkXG4gICAqIEByZXN0cmljdCBBXG4gICAqIEBlbGVtZW50IEFOWVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogTyBjb21wb25lbnRlIEd1bWdhUmVxdWlyZWQgc2VydmUgcGFyYSB2YWxpZGFyIGNhbXBvcyBvYnJpZ2F0w7NyaW9zLlxuICAgKlxuICAgKiAjIyBFeGVtcGxvXG4gICAqIFVtIGV4ZW1wbG8gZGEgZGlyZWN0aXZlIEd1bWdhUmVxdWlyZWQgZnVuY2lvbmFuZG8gcG9kZSBzZXIgZW5jb250cmFkbyBbYXF1aV0oaHR0cDovL2VtYmVkLnBsbmtyLmNvL0FjanFjZ3ZnR2hkSnFEaDcyZUhBKS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGxhYmVsIFVzYWRvIG5hIGludGVncmHDp8OjbyBjb20ge0BsaW5rIGd1bWdhLmNvcmU6Z3VtZ2FFcnJvcnN9IHBhcmEgaW5kaWNhciBlbSBxdWFsIGNhbXBvIHNlIGVuY29udHJhIG8gZXJyby5cbiAgICogU2UgbyBhdHJpYnV0byBmb3Igb21pdGlkbywgYSBkaXJldGl2YSB1c2Fyw6EgbyBhdHJpYnV0byBuYW1lIGRvIGlucHV0LlxuXHQgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgPHByZT5cbiAgICogICAgPGZvcm0gbmFtZT1cIm15Rm9ybVwiPlxuICAgKiAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJyZXF1aXJlZFwiIG5nLW1vZGVsPVwicmVxdWlyZWRcIiBndW1nYS1yZXF1aXJlZD5cbiAgICogICAgICA8cCBuZy1zaG93PVwibXlGb3JtLnJlcXVpcmVkLiRlcnJvci5yZXF1aXJlZFwiIGNsYXNzPVwidGV4dC1kYW5nZXJcIj5DYW1wbyBvYnJpZ2F0w7NyaW88L3A+XG4gICAqICAgIDwvZm9ybT5cbiAgICogIDwvcHJlPlxuICAgKi9cbiAgUmVxdWlyZWQuJGluamVjdCA9IFtdO1xuICBmdW5jdGlvbiBSZXF1aXJlZCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcbiAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxtLCBhdHRycywgY3RybCkge1xuICAgICAgICBhdHRycy5yZXF1aXJlZCA9IHRydWU7XG4gICAgICAgIHZhciB2YWxpZGF0ZVJlcXVpcmVkID0gZnVuY3Rpb24gKGlucHV0VmFsdWUpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSAncmVxdWlyZWQnO1xuICAgICAgICAgIHZhciBpc1ZhbGlkID0gIWF0dHJzLnJlcXVpcmVkIHx8ICFjdHJsLiRpc0VtcHR5KGlucHV0VmFsdWUpO1xuICAgICAgICAgIGN0cmwuJHNldFZhbGlkaXR5KGVycm9yLCBpc1ZhbGlkKTtcbiAgICAgICAgICBzY29wZS4kYnJvYWRjYXN0KCckZXJyb3InLCB7XG4gICAgICAgICAgICBuYW1lOiBhdHRycy5uYW1lLFxuICAgICAgICAgICAgbGFiZWw6IGF0dHJzLmxhYmVsIHx8IGF0dHJzLm5hbWUsXG4gICAgICAgICAgICB2YWxpZDogaXNWYWxpZCxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIHZhbHVlOiBhdHRycy5ndW1nYVJlcXVpcmVkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGlucHV0VmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIGN0cmwuJHBhcnNlcnMudW5zaGlmdCh2YWxpZGF0ZVJlcXVpcmVkKTtcbiAgICAgICAgY3RybC4kZm9ybWF0dGVycy5wdXNoKHZhbGlkYXRlUmVxdWlyZWQpO1xuICAgICAgICBhdHRycy4kb2JzZXJ2ZSgnZ3VtZ2FSZXF1aXJlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YWxpZGF0ZVJlcXVpcmVkKGN0cmwuJHZpZXdWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5mb3JtLnJlcXVpcmVkJyxbXSlcbiAgLmRpcmVjdGl2ZSgnZ3VtZ2FSZXF1aXJlZCcsUmVxdWlyZWQpO1xufSkoKTtcbiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cblx0QWR2YW5jZWRMYWJlbC4kaW5qZWN0ID0gW107XG5cdGZ1bmN0aW9uIEFkdmFuY2VkTGFiZWwoKXtcblx0XHR2YXIgdGVtcGxhdGUgPVxuXHRcdCc8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwXCI+JyArXG5cdFx0JyAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLWRlZmF1bHQgYnRuLXhzXCIgbmctZGlzYWJsZWQ9XCJkaXNhYmxlZFwiIGlkPVwiYnRue3thdHRyfX1cIiBuZy1jbGljaz1cIm9yT3JBbmQodmFsdWUpXCI+PHN0cm9uZz57e2F0dHJ9fTwvc3Ryb25nPiB7e2hxbH19IDxzdHJvbmc+e3t2YWx1ZX19PC9zdHJvbmc+PC9idXR0b24+JyArXG5cdFx0JyAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLWRlZmF1bHQgYnRuLXhzXCIgbmctZGlzYWJsZWQ9XCJkaXNhYmxlZFwiIG5nLWNsaWNrPVwiZW1pdERlbGV0ZSgpXCIgbmctaWY9XCJnZXRWaXNpYmlsaXR5KHZhbHVlKVwiPjxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L3NwYW4+PC9idXR0b24+JyArXG5cdFx0JzwvZGl2Pic7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0cmVzdHJpY3Q6ICdFJyxcblx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcblx0XHRcdHNjb3BlOiB7XG5cdFx0XHRcdGF0dHI6ICdAJyxcblx0XHRcdFx0aHFsOiAnQCcsXG5cdFx0XHRcdHZhbHVlOiAnPScsXG5cdFx0XHRcdGluZGV4OiAnPScsXG5cdFx0XHRcdGRpc2FibGVkOiAnPSdcblx0XHRcdH0sXG5cdFx0XHRsaW5rOiBmdW5jdGlvbihzY29wZSwkZWxtLCRhdHRycyl7XG5cdFx0XHRcdGlmKCEkYXR0cnMuZGlzYWJsZWQpIHNjb3BlLmRpc2FibGVkID0gZmFsc2U7XG5cdFx0XHRcdHNjb3BlLmJvbCA9IGZhbHNlO1xuXG5cdFx0XHRcdHNjb3BlLm9yT3JBbmQgPSBmdW5jdGlvbigpe1xuXG5cdFx0XHRcdFx0aWYodHlwZW9mIHNjb3BlLnZhbHVlID09PSAnc3RyaW5nJyAmJiBzY29wZS52YWx1ZS50b1VwcGVyQ2FzZSgpID09PSAnT1InICYmICFzY29wZS5ocWwpe1xuXHRcdFx0XHRcdFx0c2NvcGUudmFsdWUgPSAnQU5EJztcblx0XHRcdFx0XHR9ICAgZWxzZSAgaWYoc2NvcGUudmFsdWUudG9VcHBlckNhc2UoKSA9PT0gJ0FORCcgJiYgIXNjb3BlLmhxbCl7XG5cdFx0XHRcdFx0XHRzY29wZS52YWx1ZSA9ICdPUic7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHNjb3BlLmVtaXREZWxldGUgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHNjb3BlLiRlbWl0KCdkZWxldGVwbHMnLHNjb3BlLmluZGV4KTtcblx0XHRcdFx0fTtcblxuXG5cdFx0XHRcdHNjb3BlLmdldFZpc2liaWxpdHkgPSBmdW5jdGlvbih2YWwpe1xuXHRcdFx0XHRcdHJldHVybiAhKHZhbCA9PSAnQU5EJyB8fCB2YWwgPT0gJ09SJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cdGFuZ3VsYXIubW9kdWxlKCdndW1nYS5kaXJlY3RpdmVzLnNlYXJjaC5hZHZhbmNlZGxhYmVsJyxbXSlcblx0LmRpcmVjdGl2ZSgnZ3VtZ2FBZHZhbmNlZExhYmVsJyxBZHZhbmNlZExhYmVsKVxufSkoKTtcbiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cblx0QWR2YW5jZWRTZWFyY2guJGluamVjdCA9IFtcIkd1bWdhU2VhcmNoSGVscGVyXCJdO1xuXHRmdW5jdGlvbiBBZHZhbmNlZFNlYXJjaChHdW1nYVNlYXJjaEhlbHBlcil7XG5cdFx0dmFyIHRlbXBsYXRlID1cblx0XHQnICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwXCI+JyArXG5cdFx0JyAgICAgICBcdDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYnRuXCIgZHJvcGRvd24gaXMtb3Blbj1cInN0YXR1cy5pc29wZW5cIj4nK1xuXHRcdCdcdFx0XHRcdFx0XHQ8c3BhbiBkcm9wZG93biBvbi10b2dnbGU9XCJ0b2dnbGVkKG9wZW4pXCI+Jytcblx0XHQnXHRcdFx0XHRcdFx0XHQ8YSBocmVmIGlkPVwic2ltcGxlLWRyb3Bkb3duXCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHRcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDotM3B4O1wiIGRyb3Bkb3duLXRvZ2dsZT4nK1xuXHRcdCdcdFx0XHRcdFx0XHRcdFx0PGkgY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLWhvdXJnbGFzc1wiPjwvaT5cdCcrXG5cdFx0J1x0XHRcdFx0XHRcdFx0PC9hPicrXG5cdFx0J1x0XHRcdFx0XHRcdFx0PHVsIGNsYXNzPVwiZHJvcGRvd24tbWVudVwiIGFyaWEtbGFiZWxsZWRieT1cInNpbXBsZS1kcm9wZG93blwiIHN0eWxlPVwid2lkdGg6IGF1dG87XCI+Jytcblx0XHQnXHRcdFx0XHRcdFx0XHRcdDxsaSBuZy1yZXBlYXQ9XCJjaG9pY2UgaW4gJHBhcmVudC5hdmFpbGFibGVRdWVyaWVzXCI+Jytcblx0XHQnXHRcdFx0XHRcdFx0XHRcdFx0PGEgaHJlZiBuZy1jbGljaz1cImRvUXVlcnkoY2hvaWNlKVwiPnt7Y2hvaWNlLmRlc2NyaXB0aW9ufX08L2E+Jytcblx0XHQnXHRcdFx0XHRcdFx0XHRcdDwvbGk+Jytcblx0XHQnXHRcdFx0XHRcdFx0XHQ8L3VsPicrXG5cdFx0J1x0XHRcdFx0XHRcdDwvc3Bhbj4nK1xuXHRcdCcgICAgICAgXHQ8L3NwYW4+JyArXG5cdFx0JyAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cInNlYXJjaElucHV0VGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgbmctZGlzYWJsZWQ9XCJpc1BhbmVsT3BlblwiIGlkPVwidGV4dE1haW5cIi8+ICcgK1xuXHRcdCcgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1idG5cIj4nICtcblx0XHQnICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwibXktYnV0dG9uIGJ0bi1kZWZhdWx0XCIgbmctY2xpY2s9XCJzaG93TGl0dGxlUGFuZWwgPSAhc2hvd0xpdHRsZVBhbmVsXCI+PHNwYW4gY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tZG93blwiPjwvc3Bhbj48L2J1dHRvbj4nICtcblx0XHQnICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwibXktYnV0dG9uIGJ0bi1kZWZhdWx0XCIgdHlwZT1cImJ1dHRvblwiIG5nLWNsaWNrPVwiaXNQYW5lbE9wZW4gPSAhaXNQYW5lbE9wZW5cIj48c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tZmlsdGVyXCI+PC9zcGFuPicgK1xuXHRcdCcgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJteS1idXR0b24gYnRuLXByaW1hcnkgbGFzdFwiIHR5cGU9XCJidXR0b25cIiBuZy1kaXNhYmxlZD1cImlzUGFuZWxPcGVuXCIgbmctY2xpY2s9XCJkb1NlYXJjaChzZWFyY2hJbnB1dFRleHQpXCI+U2VhcmNoIDxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1zZWFyY2hcIj48L3NwYW4+JyArXG5cdFx0JyAgICAgICA8L3NwYW4+JyArXG5cdFx0JyAgIDwvZGl2PicgK1xuXHRcdCcgICA8ZGl2IGNsYXNzPVwicGFuZWwtYWR2YW5jZWRcIiBuZy1zaG93PVwiaXNQYW5lbE9wZW5cIj4nICtcblx0XHQnICAgICAgIDxkaXYgY2xhc3M9XCJwYW5lbC1ib2R5XCI+JyArXG5cdFx0JyAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC0zXCI+JyArXG5cdFx0JyAgICAgICAgICAgPGgzIHN0eWxlPVwibWFyZ2luLXRvcDogMDttYXJnaW4tYm90dG9tOiAwXCI+PHNtYWxsPkFkdmFuY2VkIFNlYXJjaDwvc21hbGw+PC9oMz4nICtcblx0XHQnICAgICAgICAgICA8L2Rpdj4nICtcblx0XHQnICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1pbmxpbmUgY29sLW1kLTlcIj4nICtcblx0XHQnICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj4nICtcblx0XHQnICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsaXN0LWhvbGRlclwiPicgK1xuXHRcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XCJsaXN0LXNlbGVjdGFibGVcIiBuZy1zaG93PVwic2VsZWN0QXR0cmlidXRlXCI+XFxuJyArXG5cdFx0JyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkgbmctcmVwZWF0PVwiYXR0ciBpbiBhdHRyaWJ1dGVzXCIgbmctY2xpY2s9XCJhdHRyaWJ1dGVIYXNDaGFuZ2VkKGF0dHIpXCIgY2xhc3M9XCJob3Zlci1saXN0XCI+PGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tbGlua1wiPnt7YXR0ci5uYW1lfX08L2J1dHRvbj48L2xpPlxcbicgK1xuXHRcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxcbicgK1xuXHRcdCcgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PicgK1xuXHRcdCcgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1idXR0b24gY2xhc3M9XCJidG4gYnRuLWRlZmF1bHRcIiBuZy1jbGljaz1cInNlbGVjdEF0dHJpYnV0ZSA9ICFzZWxlY3RBdHRyaWJ1dGVcIiA+e3txdWVyeS5hdHRyaWJ1dGUubmFtZSB8fCBcXCdBdHRyaWJ1dGVcXCd9fTxzcGFuIGNsYXNzPVwiY2FyZXRcIj48L3NwYW4+PC9idXR0b24+JyArXG5cdFx0JyAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibGlzdC1ob2xkZXJcIj4nICtcblx0XHQnICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzPVwibGlzdC1zZWxlY3RhYmxlXCIgbmctc2hvdz1cInNlbGVjdEhRTFwiPlxcbicgK1xuXHRcdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIG5nLXJlcGVhdD1cIm9wdCBpbiBocWxPcHRzXCIgY2xhc3M9XCJob3Zlci1saXN0XCIgbmctY2xpY2s9XCJoYW5kbGVIcWxPcHRpb24ob3B0KVwiPjxidXR0b24gY2xhc3M9XCJidG4gYnRuLWxpbmtcIiA+e3tvcHQubGFiZWx9fTwvYnV0dG9uPjwvbGk+XFxuJyArXG5cdFx0JyAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XFxuJyArXG5cdFx0JyAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+JyArXG5cdFx0JyAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHRcIiBuZy1jbGljaz1cInNlbGVjdEhRTCA9ICFzZWxlY3RIUUxcIj4ge3sgcXVlcnkuaHFsLmxhYmVsIHx8IFxcJ0hRTFxcJyAgfX0gPHNwYW4gY2xhc3M9XCJjYXJldFwiPjwvc3Bhbj48L2J1dHRvbj4gICcrXG5cdFx0JyAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInt7dHlwZUlucHV0fX1cIiBjbGFzcz1cImZvcm0tY29udHJvbCBjb2wteC0zXCIgbmctbW9kZWw9XCJxdWVyeS52YWx1ZVwiIGlkPVwic2VsZWN0YWJsZUFkdmFuY2VkVmFsdWVcIiBuZy1pbml0PVwiaW5wdXQgPSB0aGlzXCIvPicgK1xuXHRcdCcgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHRcIiBuZy1jbGljaz1cImFkZFF1ZXJ5KHF1ZXJ5KVwiIG5nLWRpc2FibGVkPVwicXVlcnkudmFsdWUubGVuZ3RoID4gMCA/IGZhbHNlIDogdHJ1ZVwiPjxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1wbHVzXCI+PC9zcGFuPjwvYnV0dG9uPicgK1xuXHRcdCcgICAgICAgICAgICAgICA8L2Rpdj4nICtcblx0XHQnICAgICAgICAgICA8L2Rpdj4nICtcblx0XHQnICAgICAgIDwvZGl2PicrXG5cdFx0JyAgICAgICAgICAgPGhyLz4nICtcblx0XHQnICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtMTJcIiBzdHlsZT1cInBhZGRpbmctYm90dG9tOiAyJVwiPicgK1xuXHRcdCcgICAgICAgPGd1bWdhLWFkdmFuY2VkLWxhYmVsIG5nLXJlcGVhdD1cInF1ZXJ5IGluIHF1ZXJpZXNcIiBhdHRyPVwie3txdWVyeS5hdHRyaWJ1dGUubmFtZX19XCIgaHFsPVwie3txdWVyeS5ocWwubGFiZWx9fVwiIHZhbHVlPVwicXVlcnkudmFsdWVcIiBpbmRleD1cIiRpbmRleFwiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxJVwiPjwvZ3VtZ2EtYWR2YW5jZWQtbGFiZWw+JyArXG5cdFx0JyAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTEyXCIgc3R5bGU9XCJtYXJnaW4tdG9wOiAxJTtcIj4nICtcblx0XHQnICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgcHVsbC1yaWdodFwiIHR5cGU9XCJidXR0b25cIiBuZy1kaXNhYmxlZD1cInF1ZXJpZXMubGVuZ3RoID09IDBcIiBuZy1jbGljaz1cInNob3dBcnJheShxdWVyaWVzKVwiPkFkdmFuY2VkIFNlYXJjaDxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1zZWFyY2hcIj48L3NwYW4+JyArXG5cdFx0JyAgICAgICA8L2Rpdj4nICtcblx0XHQnICAgICAgIDwvZGl2PicgK1xuXHRcdCcgICAgICAgPGRpdiBjbGFzcz1cImNsZWFyZml4XCIgc3R5bGU9XCJtYXJnaW4tYm90dG9tOiAyJVwiPjwvZGl2PicgK1xuXHRcdCcgICA8L2Rpdj4nICtcblx0XHQnPGRpdiBjbGFzcz1cImxpdHRsZS1wYW5lbFwiIG5nLXNob3c9XCJzaG93TGl0dGxlUGFuZWxcIj4nICtcblx0XHQnICAgPGRpdiBjbGFzcz1cInBhbmVsLWJvZHlcIj4nICtcblx0XHQnICAgICAgIDxsYWJlbCBuZy1yZXBlYXQ9XCJmaWVsZCBpbiBub3JtYWxGaWVsZHNcIiBzdHlsZT1cImRpc3BsYXk6IGJsb2NrXCIgPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cIm1vZGVsc1tmaWVsZC52YWx1ZV1cIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIiA+PHNwYW4+e3tmaWVsZC52YWx1ZX19PC9zcGFuPjwvbGFiZWw+JyArXG5cdFx0JyAgIDwvZGl2PicgK1xuXHRcdCc8L2Rpdj4nO1xuXHRcdHJldHVybiB7XG5cdFx0XHRyZXN0cmljdDogJ0UnLFxuXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuXHRcdFx0c2NvcGU6IGZhbHNlLFxuXHRcdFx0cmVxdWlyZTogJ14/Z3VtZ2FTZWFyY2gnLFxuXHRcdFx0bGluazogZnVuY3Rpb24oc2NvcGUsZWxtLGF0dHJzLGN0cmwpe1xuXHRcdFx0XHRzY29wZS5pc1BhbmVsT3BlbiA9IGZhbHNlO1xuXHRcdFx0XHRzY29wZS5zZWxlY3RIUUwgPSBmYWxzZTtcblx0XHRcdFx0c2NvcGUubW9kZWxzID0ge307XG5cdFx0XHRcdHNjb3BlLnNlYXJjaEZpZWxkID0gJyc7XG5cdFx0XHRcdHNjb3BlLnRyYW5zbGF0ZSA9IHNjb3BlLiRwYXJlbnQuZW50aXR5VG9UcmFuc2xhdGU7XG5cblx0XHRcdFx0c2NvcGUuZG9RdWVyeSA9IGZ1bmN0aW9uIChjaG9pY2UpIHtcblx0XHRcdFx0XHR2YXIgcXVlcnkgPSBKU09OLnBhcnNlKGNob2ljZS52YWx1ZSk7XG5cdFx0XHRcdFx0c2NvcGUuJGVtaXQoJ2FkdmFuY2VkJywge2hxbDogR3VtZ2FTZWFyY2hIZWxwZXIudHJhbnNsYXRlQXJyYXlUb0hRTChxdWVyeSksIHNvdXJjZTogcXVlcnl9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLiRvbignX2RvU2VhcmNoJyxmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGlmKHNjb3BlLnF1ZXJpZXMubGVuZ3RoICE9IDApe1xuXHRcdFx0XHRcdFx0c2NvcGUuc2hvd0FycmF5KHNjb3BlLnF1ZXJpZXMpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZihzY29wZS5zZWFyY2hJbnB1dFRleHQpe1xuXHRcdFx0XHRcdFx0XHRzY29wZS5kb1NlYXJjaChzY29wZS5zZWFyY2hJbnB1dFRleHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0c2NvcGUuJG9uKCdfZm9jdXMnLGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0aWYoc2NvcGUuaXNQYW5lbE9wZW4pe1xuXHRcdFx0XHRcdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlbGVjdGFibGVBZHZhbmNlZFZhbHVlJykuZm9jdXMoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RleHRNYWluJykuZm9jdXMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmKCFzY29wZS4kcGFyZW50Lm5vcm1hbEZpZWxkcy5sZW5ndGggPiAwIHx8ICFzY29wZS4kcGFyZW50LmVudGl0eVRvVHJhbnNsYXRlKXtcblx0XHRcdFx0XHR0aHJvdyAnTWlzc2luZyBzb21lIHBhcmFtZXRlcnMgaW4gR3VtZ2FTZWFyY2gnO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUubm9ybWFsRmllbGRzID0gc2NvcGUuJHBhcmVudC5ub3JtYWxGaWVsZHMubWFwKGZ1bmN0aW9uKGVsbSwkaW5kZXgpe1xuXHRcdFx0XHRcdHNjb3BlLm1vZGVsc1tlbG1dID0gZmFsc2U7XG5cdFx0XHRcdFx0JGluZGV4ID09IDAgJiYgKHNjb3BlLm1vZGVsc1tlbG1dID0gdHJ1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdG5hbWU6IGVsbS5zbGljZSgwLDEpLnRvVXBwZXJDYXNlKCkgKyBlbG0uc2xpY2UoMSxlbG0ubGVuZ3RoKS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dmFsdWU6IGVsbVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0pO1xuXG5cblx0XHRcdFx0c2NvcGUuJG9uKCdzaG93UGFuZWwnLGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0c2NvcGUuaXNQYW5lbE9wZW4gPSAhc2NvcGUuaXNQYW5lbE9wZW47XG5cdFx0XHRcdFx0c2NvcGUuJGFwcGx5KCk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHNjb3BlLm1vZGVscy5yZXR1cm5TdHJpbmcgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHZhciB0eHQgPSAnJztcblx0XHRcdFx0XHRmb3IodmFyIGtleSBpbiB0aGlzKSBpZih0aGlzLmhhc093blByb3BlcnR5KGtleSkgJiYga2V5ICE9ICdyZXR1cm5TdHJpbmcnICYmIHRoaXNba2V5XSl7XG5cdFx0XHRcdFx0XHR0eHQgKz0ga2V5ICsgJywnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZih0eHQubGVuZ3RoID09IDApe1xuXHRcdFx0XHRcdFx0cmV0dXJuIHNjb3BlLm5vcm1hbEZpZWxkc1swXS52YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHR4dC5zbGljZSgwLC0xKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRzY29wZS4kd2F0Y2goJ2lzUGFuZWxPcGVuJyxmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGlmKHNjb3BlLmlzUGFuZWxPcGVuID09PSB0cnVlKXtcblx0XHRcdFx0XHRcdHNjb3BlLnNlbGVjdEF0dHJpYnV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNjb3BlLnF1ZXJpZXMgPSBbXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2NvcGUucXVlcnkgPSB7fTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNjb3BlLmF0dHJpYnV0ZXMgPSBzY29wZS4kcGFyZW50LmF0dHJpYnV0ZXM7XG5cdFx0XHRcdHNjb3BlLmhxbE9wdHMgPSBbXTtcblx0XHRcdFx0c2NvcGUucXVlcmllcyA9IFtdO1xuXG5cdFx0XHRcdHNjb3BlLmF0dHJpYnV0ZUhhc0NoYW5nZWQgPSBmdW5jdGlvbihhdHRyaWJ1dGUpIHtcblx0XHRcdFx0XHRzY29wZS5xdWVyeS5hdHRyaWJ1dGUgPSBhdHRyaWJ1dGU7XG5cdFx0XHRcdFx0aWYoYXR0cmlidXRlLnR5cGUgPT09ICdkYXRlJyl7XG5cdFx0XHRcdFx0XHRzY29wZS50eXBlSW5wdXQgPSAnZGF0ZSc7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNjb3BlLnR5cGVJbnB1dCA9ICd0ZXh0Jztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2NvcGUuaHFsT3B0cyA9IEd1bWdhU2VhcmNoSGVscGVyLmdldFR5cGVMaXN0T2ZIUUxQb3NzaWJpbGl0aWVzKGF0dHJpYnV0ZS50eXBlKTtcblx0XHRcdFx0XHRzY29wZS5zZWxlY3RIUUwgPSB0cnVlIDtcblx0XHRcdFx0XHRzY29wZS5zZWxlY3RBdHRyaWJ1dGUgPSBmYWxzZTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRzY29wZS5oYW5kbGVIcWxPcHRpb24gPSBmdW5jdGlvbihocSl7XG5cdFx0XHRcdFx0c2NvcGUucXVlcnkuaHFsID0gaHE7XG5cdFx0XHRcdFx0c2NvcGUuc2VsZWN0SFFMID0gZmFsc2U7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0YW5ndWxhci5lbGVtZW50KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWxlY3RhYmxlQWR2YW5jZWRWYWx1ZScpKVxuXHRcdFx0XHQub24oJ2tleWRvd24nLGZ1bmN0aW9uKGV2KXtcblx0XHRcdFx0XHRpZihldi5rZXlDb2RlID09IDEzICYmIGV2LnRhcmdldC52YWx1ZS5sZW5ndGggPiAwKXtcblx0XHRcdFx0XHRcdHNjb3BlLmFkZFF1ZXJ5KHNjb3BlLnF1ZXJ5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2NvcGUuJGFwcGx5KCk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGFuZ3VsYXIuZWxlbWVudChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGV4dE1haW4nKSlcblx0XHRcdFx0Lm9uKCdrZXlkb3duJyxmdW5jdGlvbihldil7XG5cdFx0XHRcdFx0aWYoZXYua2V5Q29kZSA9PSAxMyAmJiBldi50YXJnZXQudmFsdWUubGVuZ3RoID4gMCl7XG5cdFx0XHRcdFx0XHRzY29wZS4kZW1pdCgnbm9ybWFsJyx7ZmllbGQ6IHNjb3BlLm1vZGVscy5yZXR1cm5TdHJpbmcoKSxwYXJhbTpzY29wZS5zZWFyY2hJbnB1dFRleHQgfHwgJyd9KTtcblx0XHRcdFx0XHRcdGlmKHNjb3BlLnNob3dMaXR0bGVQYW5lbCl7XG5cdFx0XHRcdFx0XHRcdHNjb3BlLnNob3dMaXR0bGVQYW5lbCA9ICFzY29wZS5zaG93TGl0dGxlUGFuZWw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRzY29wZS5hZGRRdWVyeSA9IGZ1bmN0aW9uKHF1ZXJ5KXtcblx0XHRcdFx0XHRpZihzY29wZS5xdWVyaWVzLmxlbmd0aCA9PT0gMCl7XG5cdFx0XHRcdFx0XHRzY29wZS5xdWVyaWVzLnB1c2gocXVlcnkpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZihzY29wZS5xdWVyaWVzLmxlbmd0aCA+PSAxKXtcblx0XHRcdFx0XHRcdHNjb3BlLnF1ZXJpZXMuc3BsaWNlKHNjb3BlLnF1ZXJpZXMubGVuZ3RoLDEse3ZhbHVlOiAnQU5EJ30scXVlcnkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzY29wZS5xdWVyeSA9IHt9O1xuXHRcdFx0XHRcdHNjb3BlLnR5cGVJbnB1dCA9ICd0ZXh0Jztcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRzY29wZS4kb24oJ2RlbGV0ZXBscycsZnVuY3Rpb24oZXYsZGF0YSl7XG5cdFx0XHRcdFx0c2NvcGUucXVlcmllcy5zcGxpY2UoZGF0YSwxKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0c2NvcGUuc2hvd0FycmF5ID0gZnVuY3Rpb24oYXJyYXkpe1xuXHRcdFx0XHRcdHNjb3BlLmlzUGFuZWxPcGVuID0gZmFsc2U7XG5cdFx0XHRcdFx0c2NvcGUuJGVtaXQoJ2FkdmFuY2VkJyx7aHFsOiBHdW1nYVNlYXJjaEhlbHBlci50cmFuc2xhdGVBcnJheVRvSFFMKGFycmF5KSxzb3VyY2U6IGFycmF5fSk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0c2NvcGUuZG9TZWFyY2ggPSBmdW5jdGlvbih0eHQpe1xuXHRcdFx0XHRcdHNjb3BlLiRlbWl0KCdub3JtYWwnLHtmaWVsZDogc2NvcGUubW9kZWxzLnJldHVyblN0cmluZygpLHBhcmFtOnR4dCB8fCAnJ30pO1xuXHRcdFx0XHRcdHNjb3BlLnNlYXJjaElucHV0VGV4dCA9ICcnO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblx0YW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMuc2VhcmNoLmFkdmFuY2Vkc2VhcmNoJyxbJ2d1bWdhLmRpcmVjdGl2ZXMuc2VhcmNoLnNlYXJjaGhlbHBlciddKVxuXHQuZGlyZWN0aXZlKCdndW1nYUFkdmFuY2VkU2VhcmNoJyxBZHZhbmNlZFNlYXJjaClcbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0Tm9ybWFsU2VhcmNoLiRpbmplY3QgPSBbXTtcblx0ZnVuY3Rpb24gTm9ybWFsU2VhcmNoKCl7XG5cdFx0dmFyIHRlbXBsYXRlID1cblx0XHQnPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwXCI+JyArXG5cdFx0JyAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgbmctbW9kZWw9XCJzZWFyY2hGaWVsZFwiIHBsYWNlaG9sZGVyPVwiU2VhcmNoXCIvPicgK1xuXHRcdCcgICA8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLWJ0blwiPicgK1xuXHRcdCcgICAgICAgPGJ1dHRvbiBjbGFzcz1cIm15LWJ1dHRvbiBidG4tZGVmYXVsdFwiIG5nLWNsaWNrPVwic2hvd0xpdHRsZVBhbmVsID0gIXNob3dMaXR0bGVQYW5lbFwiPjxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWRvd25cIj48L3NwYW4+PC9idXR0b24+JyArXG5cdFx0JyAgICAgICA8YnV0dG9uIGNsYXNzPVwibXktYnV0dG9uIGJ0bi1wcmltYXJ5IGxhc3RcIiB0eXBlPVwiYnV0dG9uXCIgbmctZGlzYWJsZWQ9XCIhc2VhcmNoRmllbGRcIiBuZy1jbGljaz1cImRvU2VhcmNoKHNlYXJjaEZpZWxkKVwiID5TZWFyY2ggPHNwYW4gY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXNlYXJjaFwiPjwvc3Bhbj48L2J1dHRvbj4nICtcblx0XHQnICAgPC9zcGFuPicgK1xuXHRcdCc8L2Rpdj4nICtcblx0XHQnPGRpdiBjbGFzcz1cImxpdHRsZS1wYW5lbFwiIG5nLXNob3c9XCJzaG93TGl0dGxlUGFuZWxcIj4nICtcblx0XHQnICAgPGRpdiBjbGFzcz1cInBhbmVsLWJvZHlcIj4nICtcblx0XHQnICAgICAgIDxsYWJlbCBuZy1yZXBlYXQ9XCJmaWVsZCBpbiBub3JtYWxGaWVsZHNcIiBzdHlsZT1cImRpc3BsYXk6IGJsb2NrXCIgPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cIm1vZGVsc1tmaWVsZC52YWx1ZV1cIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMSVcIiA+PHNwYW4+e3tmaWVsZC52YWx1ZX19PC9zcGFuPjwvbGFiZWw+JyArXG5cdFx0JyAgIDwvZGl2PicgK1xuXHRcdCc8L2Rpdj4nO1xuXHRcdHJldHVybiB7XG5cdFx0XHRyZXN0cmljdDogJ0UnLFxuXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuXHRcdFx0bGluazogZnVuY3Rpb24oc2NvcGUsZWxtLGF0dHJzKXtcblx0XHRcdFx0aWYoIXNjb3BlLiRwYXJlbnQubm9ybWFsRmllbGRzLmxlbmd0aCA+IDAgfHwgIXNjb3BlLiRwYXJlbnQuZW50aXR5VG9UcmFuc2xhdGUpe1xuXHRcdFx0XHRcdHRocm93ICdNaXNzaW5nIHNvbWUgcGFyYW1ldGVycyBpbiBHdW1nYVNlYXJjaCc7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2NvcGUubW9kZWxzID0ge307XG5cdFx0XHRcdHNjb3BlLnNlYXJjaEZpZWxkID0gJyc7XG5cdFx0XHRcdHNjb3BlLnRyYW5zbGF0ZSA9IHNjb3BlLiRwYXJlbnQuZW50aXR5VG9UcmFuc2xhdGU7XG5cdFx0XHRcdHNjb3BlLm5vcm1hbEZpZWxkcyA9IHNjb3BlLiRwYXJlbnQubm9ybWFsRmllbGRzLm1hcChmdW5jdGlvbihlbG0sJGluZGV4KXtcblx0XHRcdFx0XHRzY29wZS5tb2RlbHNbZWxtXSA9IGZhbHNlO1xuXHRcdFx0XHRcdCRpbmRleCA9PSAwICYmIChzY29wZS5tb2RlbHNbZWxtXSA9IHRydWUpO1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRuYW1lOiBlbG0uc2xpY2UoMCwxKS50b1VwcGVyQ2FzZSgpICsgZWxtLnNsaWNlKDEsZWxtLmxlbmd0aCkudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHZhbHVlOiBlbG1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRzY29wZS5tb2RlbHMucmV0dXJuU3RyaW5nID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHR2YXIgdHh0ID0gJyc7XG5cdFx0XHRcdFx0Zm9yKHZhciBrZXkgaW4gdGhpcykgaWYodGhpcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGtleSAhPSAncmV0dXJuU3RyaW5nJyAmJiB0aGlzW2tleV0pe1xuXHRcdFx0XHRcdFx0dHh0ICs9IGtleSArICcsJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYodHh0Lmxlbmd0aCA9PSAwKXtcblx0XHRcdFx0XHRcdHJldHVybiBzY29wZS5ub3JtYWxGaWVsZHNbMF0udmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0eHQuc2xpY2UoMCwtMSk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0ZWxtLmZpbmQoJ2lucHV0Jylcblx0XHRcdFx0LmJpbmQoJ2tleXByZXNzJyxmdW5jdGlvbihldil7XG5cdFx0XHRcdFx0aWYoZXYua2V5Q29kZSA9PSAxMyAmJiBzY29wZS5zZWFyY2hGaWVsZC5sZW5ndGggPiAwKXtcblx0XHRcdFx0XHRcdHNjb3BlLiRlbWl0KCdub3JtYWwnLHtmaWVsZDogc2NvcGUubW9kZWxzLnJldHVyblN0cmluZygpLHBhcmFtOnNjb3BlLnNlYXJjaEZpZWxkfSk7XG5cdFx0XHRcdFx0XHRpZihzY29wZS5zaG93TGl0dGxlUGFuZWwpe1xuXHRcdFx0XHRcdFx0XHRzY29wZS5zaG93TGl0dGxlUGFuZWwgPSAhc2NvcGUuc2hvd0xpdHRsZVBhbmVsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0c2NvcGUuZG9TZWFyY2ggPSBmdW5jdGlvbih0eHQpe1xuXHRcdFx0XHRcdHNjb3BlLiRlbWl0KCdub3JtYWwnLHtmaWVsZDogc2NvcGUubW9kZWxzLnJldHVyblN0cmluZygpLHBhcmFtOnR4dCB8fCAnJ30pO1xuXHRcdFx0XHRcdHNjb3BlLnNob3dMaXR0bGVQYW5lbCA9ICFzY29wZS5zaG93TGl0dGxlUGFuZWw7XG5cdFx0XHRcdFx0c2NvcGUuc2VhcmNoRmllbGQgPSAnJztcblx0XHRcdFx0fTtcblxuXHRcdFx0fVxuXHRcdH07XG5cdH1cblx0YW5ndWxhci5tb2R1bGUoJ2d1bWdhLmRpcmVjdGl2ZXMuc2VhcmNoLm5vcm1hbHNlYXJjaCcsW10pXG5cdC5kaXJlY3RpdmUoJ2d1bWdhTm9ybWFsU2VhcmNoJyxOb3JtYWxTZWFyY2gpXG59KSgpOyIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cblx0U2VhcmNoLiRpbmplY3QgPSBbXTtcblx0ZnVuY3Rpb24gU2VhcmNoKCl7XG5cdFx0dmFyIHRlbXBsYXRlID1cblx0XHQnPGRpdiBjbGFzcz1cImZ1bGwtd2lkdGgtd2l0aG91dC1wYWRkaW5nXCI+JyArXG5cdFx0JyAgICAgPGRpdiBuZy1pZj1cIiFhZHZcIj4nICtcblx0XHQnICAgICAgICAgPGd1bWdhLW5vcm1hbC1zZWFyY2g+PC9ndW1nYS1ub3JtYWwtc2VhcmNoPicgK1xuXHRcdCcgICAgIDwvZGl2PicgK1xuXHRcdCcgICAgIDxkaXYgbmctaWY9XCJhZHZcIj4nICtcblx0XHQnICAgICAgICAgPGd1bWdhLWFkdmFuY2VkLXNlYXJjaD48L2d1bWdhLWFkdmFuY2VkLXNlYXJjaD4nICtcblx0XHQnICAgICA8L2Rpdj4nICtcblx0XHQnPC9kaXY+Jztcblx0XHRyZXR1cm4ge1xuXHRcdFx0cmVzdHJpY3Q6ICdFJyxcblx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcblx0XHRcdHRyYW5zY2x1ZGU6IHRydWUsXG5cdFx0XHRzY29wZSA6IHtcblx0XHRcdFx0YWR2YW5jZWQ6ICcmYWR2YW5jZWRNZXRob2QnLFxuXHRcdFx0XHRub3JtYWw6ICcmc2VhcmNoTWV0aG9kJyxcblx0XHRcdFx0b25TZWFyY2g6ICcmJyxcblx0XHRcdFx0b25BZHZhbmNlZFNlYXJjaDogJyYnLFxuXHRcdFx0XHRnZXRRdWVyaWVzOiAnJj8nXG5cdFx0XHR9LFxuXHRcdFx0bGluazogZnVuY3Rpb24oc2NvcGUsZWxtLGF0dHJzLGNvbnRyb2xsZXIsdHJhbnNjbHVkZUZuKXtcblx0XHRcdFx0c2NvcGUuYWR2ID0gZmFsc2U7XG5cdFx0XHRcdHNjb3BlLmF0dHJpYnV0ZXMgPSBbXTtcblx0XHRcdFx0c2NvcGUubm9ybWFsRmllbGRzID0gYXR0cnMuZmllbGRzLnNwbGl0KCcsJyk7XG5cdFx0XHRcdHNjb3BlLmVudGl0eVRvVHJhbnNsYXRlID0gYXR0cnMudHJhbnNsYXRlRW50aXR5O1xuXHRcdFx0XHRzY29wZS4kcGFyZW50LnNlYXJjaFF1ZXJpZXMgPSBbXTtcblx0XHRcdFx0c2NvcGUuYXZhaWxhYmxlUXVlcmllcyA9IFtdO1xuXHRcdFx0XHRzY29wZS5zYXZlUXVlcnkgPSBmYWxzZTtcblx0XHRcdFx0aWYoYXR0cnMuZ2V0UXVlcmllcyl7XG5cdFx0XHRcdFx0c2NvcGUuc2F2ZVF1ZXJ5ID0gdHJ1ZTtcblx0XHRcdFx0XHRzY29wZS5nZXRRdWVyaWVzKHtwYWdlOiBsb2NhdGlvbi5oYXNofSlcblx0XHRcdFx0XHQudGhlbihmdW5jdGlvbihkYXRhKXtcblx0XHRcdFx0XHRcdHNjb3BlLmF2YWlsYWJsZVF1ZXJpZXMgPSBkYXRhO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZXZlbnRIYW5kbGVyID0ge1xuXHRcdFx0XHRcdHNlYXJjaDogYXR0cnMub25TZWFyY2ggPyBzY29wZS5vblNlYXJjaCA6IGFuZ3VsYXIubm9vcCxcblx0XHRcdFx0XHRhZHZhbmNlZDogYXR0cnMub25BZHZhbmNlZFNlYXJjaCA/IHNjb3BlLm9uQWR2YW5jZWRTZWFyY2ggOiBhbmd1bGFyLm5vb3Bcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihhdHRycy5hZHZhbmNlZCA9PT0gXCJ0cnVlXCIpe1xuXHRcdFx0XHRcdHNjb3BlLmFkdiA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5nZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCl7XG5cdFx0XHRcdFx0dHJhbnNjbHVkZUZuKGZ1bmN0aW9uKGNsb25lKXtcblx0XHRcdFx0XHRcdGFuZ3VsYXIuZm9yRWFjaChjbG9uZSxmdW5jdGlvbihjbG9uZUVsKXtcblx0XHRcdFx0XHRcdFx0aWYoY2xvbmVFbC5ub2RlTmFtZSA9PSAnQURWQU5DRUQtRklFTEQnKXtcblx0XHRcdFx0XHRcdFx0XHRzY29wZS5hdHRyaWJ1dGVzLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRcdFx0bmFtZTogY2xvbmVFbC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IGNsb25lRWwuZ2V0QXR0cmlidXRlKCd0eXBlJylcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0c2NvcGUuJG9uKCdhZHZhbmNlZCcsZnVuY3Rpb24oZXYsZGF0YSl7XG5cdFx0XHRcdFx0c2NvcGUuJHBhcmVudC5zZWFyY2hRdWVyaWVzID0gW107XG5cdFx0XHRcdFx0c2NvcGUuJHBhcmVudC5zZWFyY2hRdWVyaWVzID0gZGF0YS5zb3VyY2U7XG5cdFx0XHRcdFx0c2NvcGUuYWR2YW5jZWQoe3BhcmFtOiBkYXRhfSk7XG5cdFx0XHRcdFx0ZXZlbnRIYW5kbGVyLmFkdmFuY2VkKCk7XG4gICAgICAgIH0pO1xuXG5cdFx0XHRcdHNjb3BlLiRvbignbm9ybWFsJyxmdW5jdGlvbihldixkYXRhKXtcblx0XHRcdFx0XHRzY29wZS5ub3JtYWwoe2ZpZWxkOiBkYXRhLmZpZWxkLHBhcmFtOiBkYXRhLnBhcmFtfSk7XG5cdFx0XHRcdFx0ZXZlbnRIYW5kbGVyLnNlYXJjaCgpXG4gICAgICAgIH0pO1xuXG5cdFx0XHRcdHNjb3BlLmdldEF0dHJpYnV0ZXMoKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cdGFuZ3VsYXIubW9kdWxlKCdndW1nYS5kaXJlY3RpdmVzLnNlYXJjaC5zZWFyY2gnLFtdKVxuXHQuZGlyZWN0aXZlKCdndW1nYVNlYXJjaCcsU2VhcmNoKVxufSkoKTtcbiIsIihmdW5jdGlvbigpe1xuXHQndXNlIHN0cmljdCc7XG5cblx0U2VhcmNoSGVscGVyLiRpbmplY3QgPSBbXTtcblx0ZnVuY3Rpb24gU2VhcmNoSGVscGVyKCl7XG5cdFx0dmFyIHR5cGVzID17XG5cdFx0XHRcInN0cmluZ1wiOiB7XG5cdFx0XHRcdFwiSFFMUG9zc2liaWxpdGllc1wiOiBbXG5cdFx0XHRcdHtocWw6XCJlcVwiLGxhYmVsOiBcImlndWFsXCIgLCBiZWZvcmU6IFwiPSdcIixhZnRlcjpcIidcIn0sXG5cdFx0XHRcdHtocWw6XCJuZVwiLGxhYmVsOiBcImRpZmVyZW50ZSBkZVwiICwgYmVmb3JlOiBcIiE9J1wiLGFmdGVyOlwiJ1wifSxcblx0XHRcdFx0e2hxbDogXCJjb250YWluc1wiLGxhYmVsOiBcImNvbnTDqW1cIiAsIGJlZm9yZTogXCIgbGlrZSAnXFwlXCIsYWZ0ZXI6XCJcXCUnXCJ9LFxuXHRcdFx0XHR7aHFsOiBcIm5vdF9jb250YWluc1wiLGxhYmVsOlwibsOjbyBjb250w6ltXCIgLCBiZWZvcmU6IFwiIG5vdCBsaWtlICdcXCVcIixhZnRlcjpcIlxcJSdcIn0sXG5cdFx0XHRcdHtocWw6IFwic3RhcnRzX3dpdGhcIixsYWJlbDpcImNvbWXDp2EgY29tXCIgLCBiZWZvcmU6IFwibGlrZSAnXCIsYWZ0ZXI6XCJcXCUnXCJ9LFxuXHRcdFx0XHR7aHFsOiBcImVuZHNfd2l0aFwiLGxhYmVsOiBcInRlcm1pbmEgY29tXCIgLCBiZWZvcmU6IFwibGlrZSAnXFwlXCIsYWZ0ZXI6XCInXCJ9LFxuXHRcdFx0XHR7aHFsOiBcImdlXCIsbGFiZWw6XCJtYWlvciBpZ3VhbFwiICwgYmVmb3JlOiBcIj49J1wiLGFmdGVyOlwiJ1wifSxcblx0XHRcdFx0e2hxbDogXCJsZVwiLGxhYmVsOiBcIm1lbm9yIGlndWFsXCIgLCBiZWZvcmU6IFwiPD0nXCIsYWZ0ZXI6XCInXCJ9XVxuXHRcdFx0fSxcblx0XHRcdFwibnVtYmVyXCI6IHtcblx0XHRcdFx0XCJIUUxQb3NzaWJpbGl0aWVzXCI6IFtcblx0XHRcdFx0e2hxbDpcImVxXCIsbGFiZWw6IFwiaWd1YWxcIiwgYmVmb3JlOiBcIj1cIixhZnRlcjpcIlwifSxcblx0XHRcdFx0e2hxbDpcIm5lXCIsbGFiZWw6IFwiZGlmZXJlbnRlIGRlXCIsIGJlZm9yZTogXCIhPVwiLGFmdGVyOlwiXCJ9LFxuXHRcdFx0XHR7aHFsOiBcImd0XCIsbGFiZWw6XCJtYWlvciBxdWVcIiwgYmVmb3JlOiBcIj5cIixhZnRlcjpcIlwifSxcblx0XHRcdFx0e2hxbDogXCJnZVwiLGxhYmVsOlwibWFpb3IgaWd1YWxcIiwgYmVmb3JlOiBcIj49XCIsYWZ0ZXI6XCJcIn0sXG5cdFx0XHRcdHtocWw6IFwibHRcIixsYWJlbDpcIm1lbm9yIHF1ZVwiLCBiZWZvcmU6IFwiPFwiLGFmdGVyOlwiXCJ9LFxuXHRcdFx0XHR7aHFsOiBcImxlXCIsbGFiZWw6XCJtZW5vciBpZ3VhbFwiLCBiZWZvcmU6IFwiPD1cIixhZnRlcjpcIlwifV1cblx0XHRcdH0sXG5cdFx0XHRcIm1vbmV5XCI6IHtcblx0XHRcdFx0XCJIUUxQb3NzaWJpbGl0aWVzXCI6IFtcblx0XHRcdFx0e2hxbDpcImVxXCIsbGFiZWw6IFwiaWd1YWxcIiwgYmVmb3JlOiBcIj1cIixhZnRlcjpcIlwifSxcblx0XHRcdFx0e2hxbDpcIm5lXCIsbGFiZWw6IFwiZGlmZXJlbnRlIGRlXCIsIGJlZm9yZTogXCIhPVwiLGFmdGVyOlwiXCJ9LFxuXHRcdFx0XHR7aHFsOiBcImd0XCIsbGFiZWw6XCJtYWlvciBxdWVcIiwgYmVmb3JlOiBcIj5cIixhZnRlcjpcIlwifSxcblx0XHRcdFx0e2hxbDogXCJnZVwiLGxhYmVsOlwibWFpb3IgaWd1YWxcIiwgYmVmb3JlOiBcIj49XCIsYWZ0ZXI6XCJcIn0sXG5cdFx0XHRcdHtocWw6IFwibHRcIixsYWJlbDpcIm1lbm9yIHF1ZVwiLCBiZWZvcmU6IFwiPFwiLGFmdGVyOlwiXCJ9LFxuXHRcdFx0XHR7aHFsOiBcImxlXCIsbGFiZWw6XCJtYWlvciBpZ3VhbFwiLCBiZWZvcmU6IFwiPD1cIixhZnRlcjpcIlwifV1cblxuXHRcdFx0fSxcblx0XHRcdFwiYm9vbGVhblwiOiB7XG5cdFx0XHRcdFwiSFFMUG9zc2liaWxpdGllc1wiOiBbe2hxbDpcImVxXCIsbGFiZWw6IFwiaWd1YWxcIiAsIGJlZm9yZTogXCI9J1wiLGFmdGVyOlwiJ1wifV1cblx0XHRcdH0sXG5cdFx0XHRcImRhdGVcIjoge1xuXHRcdFx0XHRcIkhRTFBvc3NpYmlsaXRpZXNcIjogW1xuXHRcdFx0XHR7aHFsOiBcImVxXCIsIGxhYmVsOiBcImlndWFsXCIsIGJlZm9yZTogXCI9J1wiLCBhZnRlcjogXCInXCJ9LFxuXHRcdFx0XHR7aHFsOiBcImdlXCIsIGxhYmVsOiBcIm1haW9yIGlndWFsXCIsIGJlZm9yZTogXCI+PSdcIiwgYWZ0ZXI6IFwiJ1wifSxcblx0XHRcdFx0e2hxbDogXCJsZVwiLCBsYWJlbDogXCJtZW5vciBpZ3VhbFwiLCBiZWZvcmU6IFwiPD0nXCIsIGFmdGVyOiBcIidcIn1dXG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Z2V0VHlwZUxpc3RPZkhRTFBvc3NpYmlsaXRpZXM6IGZ1bmN0aW9uKHR5cGUpe1xuXHRcdFx0XHRpZihhbmd1bGFyLmlzRGVmaW5lZCh0eXBlc1t0eXBlXSkpXG5cdFx0XHRcdFx0cmV0dXJuIHR5cGVzW3R5cGVdLkhRTFBvc3NpYmlsaXRpZXM7XG5cdFx0XHRcdHRocm93ICdUeXBlIGRvZXNuXFwndCBleGlzdCc7XG5cdFx0XHR9LFxuXHRcdFx0dHJhbnNsYXRlQXJyYXlUb0hRTDogZnVuY3Rpb24oYXJyYXkpe1xuXHRcdFx0XHRyZXR1cm4gYXJyYXlcblx0XHRcdFx0Lm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdChhbmd1bGFyLmlzRGVmaW5lZChlbGVtZW50LmF0dHJpYnV0ZSkgPyAnb2JqLicgKyBlbGVtZW50LmF0dHJpYnV0ZS5uYW1lIDogJyEnKVxuXHRcdFx0XHRcdFx0KyAnJyArXG5cdFx0XHRcdFx0XHQoYW5ndWxhci5pc0RlZmluZWQoZWxlbWVudC5ocWwpID8gZWxlbWVudC5ocWwuYmVmb3JlIDogJyAhJylcblx0XHRcdFx0XHRcdCsgJycgK1xuXHRcdFx0XHRcdFx0ZWxlbWVudC52YWx1ZVxuXHRcdFx0XHRcdFx0KyAoYW5ndWxhci5pc0RlZmluZWQoZWxlbWVudC5ocWwpID8gZWxlbWVudC5ocWwuYWZ0ZXIgOiAnICEnKSApO1xuXHRcdFx0XHR9KS5tYXAoZnVuY3Rpb24oZWxlbWVudCl7XG5cdFx0XHRcdFx0aWYoZWxlbWVudC5pbmRleE9mKCchJykgIT0gLTEpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1lbnQucmVwbGFjZSgvIS9nLCcnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdFx0XHRcdH0pLmpvaW4oXCJcIik7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXHRhbmd1bGFyLm1vZHVsZSgnZ3VtZ2EuZGlyZWN0aXZlcy5zZWFyY2guc2VhcmNoaGVscGVyJyxbXSlcblx0LmZhY3RvcnkoJ0d1bWdhU2VhcmNoSGVscGVyJyxTZWFyY2hIZWxwZXIpXG59KSgpO1xuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9